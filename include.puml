@startuml
class Class1 {
}
class ActivateAdmin {
    + OnPointerDown(eventData:PointerEventData) : void
    + OnPointerUp(eventData:PointerEventData) : void
    Update() : void
}
MonoBehaviour <|-- ActivateAdmin
IPointerDownHandler <|-- ActivateAdmin
IPointerUpHandler <|-- ActivateAdmin
class AppSettings {
}
MonoBehaviour <|-- AppSettings
class ConsoleToGUI {
    myLog : string = "*begin log"
    filename : string = ""
    doShow : bool = true
    kChars : int = 700
    OnEnable() : void
    OnDisable() : void
    Update() : void
    + Log(logString:string, stackTrace:string, type:LogType) : void
    OnGUI() : void
}
MonoBehaviour <|-- ConsoleToGUI
class Note {
    + Note(id:int, username:string, content:string, pinID:int, fontID:int)
    + id : int <<get>> <<set>>
    + Username : string <<get>> <<set>>
    + Content : string <<get>> <<set>>
    + PinID : int <<get>> <<set>>
    + FontID : int <<get>> <<set>>
}
class NoteDetails {
    + ShowNoteDetailsOnClick() : void
    + HideNoteDetailsOnClick() : void
}
MonoBehaviour <|-- NoteDetails
class NoteItem {
    + SetupNote(noteID:int, noteUsername:string, noteContent:string, pinIndicator:int, randomSpawn:bool) : void
    + DeleteNoteOnAdminClick() : void
}
MonoBehaviour <|-- NoteItem
class SQLManipulator {
    + InsertNote(username:string, content:string, pinID:int, fontID:int) : void
    + DeleteNote(id:int) : void
    + SaveNotesToList() : void
    + GetNotes() : List<Note>
}
class "List`1"<T> {
}
MonoBehaviour <|-- SQLManipulator
SQLManipulator --> "Instance" SQLManipulator
SQLManipulator --> "dbconn" IDbConnection
SQLManipulator --> "dbcmd" IDbCommand
SQLManipulator --> "ListOfNotes<Note>" "List`1"
class AddNewNoteController {
    + SelectedPinID : int <<get>> <<set>>
    + CloseAddNewNodeCanvas() : void
    + AddNewNodeToDb() : void
}
MonoBehaviour <|-- AddNewNoteController
class MainController {
    + Setup() : void
    + SetUpNotes() : void
    SpawnNoteWithDelay(seconds:float, ID:int, username:string, content:string, pinIndicator:int) : IEnumerator
    + ShowNewNoteCanvas() : void
    + SetAdminAuthorization(AuthorizationFlag:bool) : void
}
MonoBehaviour <|-- MainController
MainController --> "Instance" MainController
class CharacterButton {
    + OnPointerUp(eventData:PointerEventData) : void
}
MonoBehaviour <|-- CharacterButton
IPointerUpHandler <|-- CharacterButton
class InputField {
    + Focus() : void
    + UnFocus() : void
    + Append(value:string) : void
    <<internal>> Execute(code:KeyCode) : void
}
MonoBehaviour <|-- InputField
class OSK_AdminCanvas {
    + Setup() : void
    <<internal>> SpecialKeyPress(code:KeyCode) : void
    + KeyPress(value:string) : void
    + TextInputChanged() : void
    + CloseAdmin() : void
    + ShowLowercase() : void
    + ShowUppercase() : void
    + ShowNumbers() : void
}
MonoBehaviour <|-- OSK_AdminCanvas
class OSK_NewNodeController {
    + Setup() : void
    <<internal>> SpecialKeyPress(code:KeyCode) : void
    + KeyPress(value:string) : void
    + SetInputFieldToSelected(_inputField:TMP_InputField) : void
    + ShowLowercase() : void
    + ShowUppercase() : void
    + ShowNumbers() : void
}
MonoBehaviour <|-- OSK_NewNodeController
enum KeyCode {
    Delete,
    Space,
    Enter,
}
class SpecialButton {
    + OnPointerUp(eventData:PointerEventData) : void
}
MonoBehaviour <|-- SpecialButton
IPointerUpHandler <|-- SpecialButton
class ChangePin {
    _pinID : int
    + ChangePinOnClick() : void
}
MonoBehaviour <|-- ChangePin
class PinAnimation {
}
MonoBehaviour <|-- PinAnimation
class KeyboardDragHandler {
    + OnDrag(eventData:PointerEventData) : void
}
MonoBehaviour <|-- KeyboardDragHandler
IDragHandler <|-- KeyboardDragHandler
class KeyboardScript {
    + alphabetFunction(alphabet:string) : void
    + BackSpace() : void
    + CloseAllLayouts() : void
    + ShowLayout(SetLayout:GameObject) : void
}
MonoBehaviour <|-- KeyboardScript
KeyboardScript --> "TextField" InputField
KeyboardScript --> "RusLayoutSml" GameObject
KeyboardScript --> "RusLayoutBig" GameObject
KeyboardScript --> "EngLayoutSml" GameObject
KeyboardScript --> "EngLayoutBig" GameObject
KeyboardScript --> "SymbLayout" GameObject
enum AnimationToolType {
    UnknownTool= 0,
    Visibilility= 6,
    PreviewPose= 7,
    EditPose= 8,
    CreateBone= 9,
    SplitBone= 10,
    ReparentBone= 11,
    EditGeometry= 12,
    CreateVertex= 13,
    CreateEdge= 14,
    SplitEdge= 15,
    GenerateGeometry= 16,
    WeightSlider= 17,
    WeightBrush= 18,
    BoneInfluence= 19,
    GenerateWeights= 20,
}
enum AnimationEventType {
    Truncated= -1,
    SelectedSpriteChanged= 0,
    SkeletonPreviewPoseChanged= 1,
    SkeletonBindPoseChanged= 2,
    SkeletonTopologyChanged= 3,
    MeshChanged= 4,
    MeshPreviewChanged= 5,
    SkinningModuleModeChanged= 6,
    BoneSelectionChanged= 7,
    BoneNameChanged= 8,
    CharacterPartChanged= 9,
    ToolChanged= 10,
    RestoreBindPose= 11,
    Copy= 12,
    Paste= 13,
    BoneDepthChanged= 14,
    Shortcut= 15,
    Visibility= 16,
}
class AnimationEvent <<struct>> {
    + repeated_event : int
    + data : string
}
class AnimationToolUsageEvent <<struct>> {
    + instance_id : int
    + character_mode : bool
    + time_start_s : int
    + time_end_s : int
}
class AnimationToolApplyEvent <<struct>> {
    + character_mode : bool
    + instance_id : int
    + sprite_count : int
    + bone_root_count : int
}
interface IAnimationAnalyticsModel {
    hasCharacter : bool <<get>>
    GetTool(tool:Tools) : ITool
    selectedBoneCount : int <<get>>
    applicationElapseTime : int <<get>>
}
class SkinningModuleAnalyticsModel {
    + hasCharacter : bool <<get>>
    + SkinningModuleAnalyticsModel(s:SkinningCache)
    + GetTool(tool:Tools) : ITool
    + selectedBoneCount : int <<get>>
    + applicationElapseTime : int <<get>>
}
class AnimationAnalytics {
    <<const>> k_AnimationEventElementCount : int = 3
    <<const>> k_AnimationToolUsageEventElementCount : int = 6
    m_CurrentEvent : AnimationToolUsageEvent?
    m_InstanceId : int
    + AnimationAnalytics(analyticsStorage:IAnalyticsStorage, eventBus:SkinningEvents, model:IAnimationAnalyticsModel, instanceId:int)
    + Dispose() : void
    OnBoneVisibility(s:string) : void
    OnShortcut(s:string) : void
    OnCopy() : void
    OnPaste(bone:bool, mesh:bool, flipX:bool, flipY:bool) : void
    OnSelectedSpriteChanged(sprite:SpriteCache) : void
    OnSkeletonPreviewPoseChanged(skeleton:SkeletonCache) : void
    OnSkeletonBindPoseChanged(skeleton:SkeletonCache) : void
    OnSkeletonTopologyChanged(skeleton:SkeletonCache) : void
    OnMeshChanged(mesh:MeshCache) : void
    OnMeshPreviewChanged(mesh:MeshPreviewCache) : void
    OnSkinningModuleModeChanged(mode:SkinningMode) : void
    OnBoneSelectionChanged() : void
    OnBoneNameChanged(bone:BoneCache) : void
    OnBoneDepthChanged(bone:BoneCache) : void
    OnCharacterPartChanged(part:CharacterPartCache) : void
    OnToolChanged(tool:ITool) : void
    OnRestoreBindPose() : void
    SetAnimationEvent(evt:AnimationEvent) : void
    StartNewEvent(animationType:AnimationToolType, tick:int) : void
    SendLastEvent(evt:AnimationToolUsageEvent, tick:int) : void
    SendLastEvent(tick:int) : void
    + FlushEvent() : void
    + SendApplyEvent(spriteCount:int, spriteBoneCount:int[], bones:BoneCache[]) : void
    {static} GetChainBoneStatistic(bones:BoneCache[], chainBoneCount:int[], maxDepth:int[], boneRootCount:int, boneCount:int[]) : void
}
interface IAnalyticsStorage {
    SendUsageEvent(evt:AnimationToolUsageEvent) : AnalyticsResult
    SendApplyEvent(evt:AnimationToolApplyEvent) : AnalyticsResult
    Dispose() : void
}
class AnalyticConstant <<static>> {
    + <<const>> k_MaxEventsPerHour : int = 1000
    + <<const>> k_MaxNumberOfElements : int = 1000
}
class AnalyticsJsonStorage {
    + SendUsageEvent(evt:AnimationToolUsageEvent) : AnalyticsResult
    + SendApplyEvent(evt:AnimationToolApplyEvent) : AnalyticsResult
    + Dispose() : void
}
class UnityAnalyticsStorage {
    <<const>> k_VendorKey : string = "unity.2d.animation"
    <<const>> k_Version : int = 1
    {static} UnityAnalyticsStorage()
    + SendUsageEvent(evt:AnimationToolUsageEvent) : AnalyticsResult
    + SendApplyEvent(evt:AnimationToolApplyEvent) : AnalyticsResult
    + Dispose() : void
}
class "List`1"<T> {
}
class AnimationToolEvents <<struct>> {
}
AnimationEvent --> "sub_type" AnimationEventType
AnimationToolUsageEvent --> "animation_tool" AnimationToolType
AnimationToolUsageEvent --> "animation_events<AnimationEvent>" "List`1"
IAnimationAnalyticsModel --> "mode" SkinningMode
IAnimationAnalyticsModel --> "selectedTool" ITool
IAnimationAnalyticsModel <|-- SkinningModuleAnalyticsModel
SkinningModuleAnalyticsModel --> "skinningCache" SkinningCache
SkinningModuleAnalyticsModel --> "mode" SkinningMode
SkinningModuleAnalyticsModel --> "selectedTool" ITool
AnimationAnalytics --> "m_AnalyticsStorage" IAnalyticsStorage
AnimationAnalytics --> "m_EventBus" SkinningEvents
AnimationAnalytics --> "m_Model" IAnimationAnalyticsModel
IAnalyticsStorage <|-- AnalyticsJsonStorage
AnalyticsJsonStorage o-> "m_TotalEvents" AnimationToolEvents
IAnalyticsStorage <|-- UnityAnalyticsStorage
AnalyticsJsonStorage +-- AnimationToolEvents
AnimationToolEvents --> "events<AnimationToolUsageEvent>" "List`1"
AnimationToolEvents --> "applyEvent" AnimationToolApplyEvent
interface ICharacterDataProvider {
    GetCharacterData() : CharacterData
    SetCharacterData(characterData:CharacterData) : void
}
class CharacterData <<struct>> {
}
interface ICharacterOrder {
    order : int <<get>> <<set>>
}
class CharacterGroup <<struct>> {
    + name : string
    + parentGroup : int
    m_Order : int
    + order : int <<get>> <<set>>
}
class CharacterPart <<struct>> {
    + spriteId : string
    + parentGroup : int
    m_Order : int
    + order : int <<get>> <<set>>
}
CharacterData --> "dimension" Vector2Int
ICharacterOrder <|-- CharacterGroup
ICharacterOrder <|-- CharacterPart
CharacterPart --> "spritePosition" RectInt
class ResourceLoader <<static>> {
    <<const>> k_ResourcePath : string = "Packages/com.unity.2d.animation/Editor/Assets"
    <<internal>> {static} Load(path:string) : T
}
class SpritePostProcess {
    OnPostprocessSprites(texture:Texture2D, sprites:Sprite[]) : void
    {static} RefreshSpriteSkinCache() : void
    {static} CalculateLocaltoWorldMatrix(i:int, spriteRect:SpriteRect, definitionScale:float, pixelsPerUnit:float, spriteBone:List<UnityEngine.U2D.SpriteBone>, outpriteBone:UnityEngine.U2D.SpriteBone?[], bindPose:NativeArray<Matrix4x4>) : void
    {static} PostProcessBoneData(spriteDataProvider:ISpriteEditorDataProvider, definitionScale:float, sprites:Sprite[]) : bool
    {static} PostProcessSpriteMeshData(spriteDataProvider:ISpriteEditorDataProvider, definitionScale:float, sprites:Sprite[]) : bool
    {static} CalculateDefinitionScale(texture:Texture2D, dataProvider:ITextureDataProvider) : float
}
AssetPostprocessor <|-- SpritePostProcess
class NativeArrayHelpers <<static>> {
    + {static} <<unsafe>> ResizeIfNeeded(nativeArray:NativeArray<T>, size:int, allocator:Allocator) : void
    + {static} ResizeAndCopyIfNeeded(nativeArray:NativeArray<T>, size:int, allocator:Allocator) : void
    + {static} <<unsafe>> DisposeIfCreated(nativeArray:NativeArray<T>) : void
    + {static} <<unsafe>> CopyFromNativeSlice(nativeArray:NativeArray<T>, dstStartIndex:int, dstEndIndex:int, slice:NativeSlice<S>, srcStartIndex:int, srcEndIndex:int) : void
}
class "NativeCustomSlice`1"<T> <<struct>> {
    + length : int
    + stride : int
    + {static} Default() : NativeCustomSlice<T>
    + <<unsafe>> NativeCustomSlice(nativeSlice:NativeSlice<T>)
    + <<unsafe>> NativeCustomSlice(slice:NativeSlice<byte>, length:int, stride:int)
    + Length : int <<get>>
}
class "NativeCustomSliceEnumerator`1"<T> <<struct>> {
    <<internal>> NativeCustomSliceEnumerator(slice:NativeSlice<byte>, length:int, stride:int)
    + GetEnumerator() : IEnumerator<T>
    GetEnumerator() : IEnumerator
    + MoveNext() : bool
    + Reset() : void
    + Current : T <<get>>
    Current : object <<get>>
    Dispose() : void
}
class "ReadArrayElementWithStride`1"<T> {
}
class "IEnumerable`1"<T> {
}
class "IEnumerator`1"<T> {
}
"NativeCustomSlice`1" --> "data" IntPtr
"IEnumerable`1" "<T>" <|-- "NativeCustomSliceEnumerator`1"
"IEnumerator`1" "<T>" <|-- "NativeCustomSliceEnumerator`1"
class PositionVertex <<struct>> {
}
class PositionTangentVertex <<struct>> {
}
class DeformVerticesBuffer <<struct>> {
    + <<const>> k_DefaultBufferSize : int = 2
    m_BufferCount : int
    m_CurrentBuffer : int
    + DeformVerticesBuffer(bufferCount:int)
    + Dispose() : void
    + GetBuffer(expectedSize:int) : ref NativeArray<byte>
    <<internal>> GetCurrentBuffer() : ref NativeArray<byte>
}
class SpriteSkin <<sealed>> <<partial>> {
    m_IsValid : bool = false
    m_TransformsHash : int = 0
    <<internal>> batchSkinning : bool <<get>> <<set>>
    <<internal>> Awake() : void
    OnEnable() : void
    <<internal>> OnEditorEnable() : void
    CacheValidFlag() : void
    Reset() : void
    <<internal>> UseBatching(value:bool) : void
    <<internal>> GetDeformedVertices(spriteVertexCount:int) : ref NativeArray<byte>
    + HasCurrentDeformedVertices() : bool
    <<internal>> GetCurrentDeformedVertices() : NativeArray<byte>
    <<internal>> GetCurrentDeformedVertexPositions() : NativeSlice<PositionVertex>
    <<internal>> GetCurrentDeformedVertexPositionsAndTangents() : NativeSlice<PositionTangentVertex>
    + GetDeformedVertexPositionData() : IEnumerable<Vector3>
    + GetDeformedVertexTangentData() : IEnumerable<Vector4>
    OnDisable() : void
    LateUpdate() : void
    CacheCurrentSprite() : void
    + alwaysUpdate : bool <<get>> <<set>>
    <<internal>> isValid : bool <<get>>
    OnDestroy() : void
    <<internal>> DeactivateSkinning() : void
    <<internal>> ResetSprite() : void
    + OnBeforeSerialize() : void
    + OnAfterDeserialize() : void
}
PositionVertex --> "position" Vector3
PositionTangentVertex --> "position" Vector3
PositionTangentVertex --> "tangent" Vector4
MonoBehaviour <|-- SpriteSkin
ISerializationCallbackReceiver <|-- SpriteSkin
SpriteSkin --> "sprite" Sprite
SpriteSkin --> "spriteRenderer" SpriteRenderer
SpriteSkin --> "rootBone" Transform
SpriteSkin --> "bounds" Bounds
class SpriteSkin <<sealed>> <<partial>> {
    OnEnableBatch() : void
    <<internal>> UpdateSpriteDeform() : void
    OnResetBatch() : void
    UseBatchingBatch() : void
    OnDisableBatch() : void
    OnBoneTransformChanged() : void
    OnRootBoneTransformChanged() : void
    OnBeforeSerializeBatch() : void
    OnAfterSerializeBatch() : void
}
MonoBehaviour <|-- SpriteSkin
class SpriteSkinEntity {
}
MonoBehaviour <|-- SpriteSkinEntity
class SpriteSkinManager {
}
class SpriteSkinManagerInternal {
}
SpriteSkinManager +-- SpriteSkinManagerInternal
MonoBehaviour <|-- SpriteSkinManagerInternal
enum SpriteSkinValidationResult {
    SpriteNotFound,
    SpriteHasNoSkinningInformation,
    SpriteHasNoWeights,
    RootTransformNotFound,
    InvalidTransformArray,
    InvalidTransformArrayLength,
    TransformArrayContainsNull,
    RootNotFoundInTransformArray,
    Ready,
}
class SpriteSkinUtility <<static>> {
    <<internal>> {static} Validate(spriteSkin:SpriteSkin) : SpriteSkinValidationResult
    <<internal>> {static} CreateBoneHierarchy(spriteSkin:SpriteSkin) : void
    <<internal>> {static} GetVertexStreamSize(sprite:Sprite) : int
    <<internal>> {static} GetVertexStreamOffset(sprite:Sprite, channel:Rendering.VertexAttribute) : int
    <<internal>> {static} ResetBindPose(spriteSkin:SpriteSkin) : void
    <<internal>> {static} Rebind(spriteSkin:SpriteSkin) : void
    <<internal>> {static} CalculateTransformHash(spriteSkin:SpriteSkin) : int
    <<internal>> <<unsafe>> {static} Deform(sprite:Sprite, rootInv:Matrix4x4, vertices:NativeSlice<Vector3>, tangents:NativeSlice<Vector4>, boneWeights:NativeSlice<BoneWeight>, boneTransforms:NativeArray<Matrix4x4>, bindPoses:NativeSlice<Matrix4x4>, deformableVertices:NativeArray<byte>) : void
    <<internal>> {static} Deform(rootInv:float4x4, vertices:NativeSlice<float3>, boneWeights:NativeSlice<BoneWeight>, boneTransforms:NativeArray<float4x4>, bindPoses:NativeSlice<float4x4>, deformed:NativeSlice<float3>) : void
    <<internal>> {static} Deform(rootInv:float4x4, vertices:NativeSlice<float3>, tangents:NativeSlice<float4>, boneWeights:NativeSlice<BoneWeight>, boneTransforms:NativeArray<float4x4>, bindPoses:NativeSlice<float4x4>, deformed:NativeSlice<float3>, deformedTangents:NativeSlice<float4>) : void
    <<internal>> <<unsafe>> {static} Deform(sprite:Sprite, invRoot:Matrix4x4, boneTransformsArray:Transform[], deformVertexData:NativeArray<byte>) : void
    <<internal>> {static} Bake(spriteSkin:SpriteSkin, deformVertexData:NativeArray<byte>) : void
    <<internal>> <<unsafe>> {static} CalculateBounds(spriteSkin:SpriteSkin) : void
    <<internal>> {static} CalculateSpriteSkinBounds(deformablePositions:NativeSlice<float3>) : Bounds
    <<internal>> {static} <<unsafe>> UpdateBounds(spriteSkin:SpriteSkin, deformedVertices:NativeArray<byte>) : void
}
class PathPlaceholder {
    + PlaceHolderTest() : void
}
class CinemachinePixelPerfectEditor {
    + <<override>> OnInspectorGUI() : void
}
Editor <|-- CinemachinePixelPerfectEditor
class PixelPerfectCameraEditor {
    + OnEnable() : void
    + <<override>> RequiresConstantRepaint() : bool
    + <<override>> OnInspectorGUI() : void
    OnSceneGUI() : void
}
class Style {
    + srpWarning : string = "Pixel Perfect Camera in the 2D Pixel Perfect package isn't compatible with Scriptable Render Pipeline. If you are using the Lightweight Render Pipeline, you can swap this for the Pixel Perfect Camera component that ships with LWRP."
    + Style()
}
Editor <|-- PixelPerfectCameraEditor
PixelPerfectCameraEditor +-- Style
Style o-> "x" GUIContent
Style o-> "y" GUIContent
Style o-> "assetsPPU" GUIContent
Style o-> "refRes" GUIContent
Style o-> "upscaleRT" GUIContent
Style o-> "pixelSnapping" GUIContent
Style o-> "cropFrame" GUIContent
Style o-> "stretchFill" GUIContent
Style o-> "currentPixelRatio" GUIContent
Style o-> "runInEditMode" GUIContent
Style --> "centeredLabel" GUIStyle
class CinemachinePixelPerfect {
    OnEnable() : void
}
MonoBehaviour <|-- CinemachinePixelPerfect
class PixelPerfectCamera {
    + assetsPPU : int <<get>> <<set>>
    + refResolutionX : int <<get>> <<set>>
    + refResolutionY : int <<get>> <<set>>
    + upscaleRT : bool <<get>> <<set>>
    + pixelSnapping : bool <<get>> <<set>>
    + cropFrameX : bool <<get>> <<set>>
    + cropFrameY : bool <<get>> <<set>>
    + stretchFill : bool <<get>> <<set>>
    + pixelRatio : int <<get>>
    + RoundToPixel(position:Vector3) : Vector3
    + CorrectCinemachineOrthoSize(targetOrthoSize:float) : float
    m_AssetsPPU : int = 100
    m_RefResolutionX : int = 320
    m_RefResolutionY : int = 180
    m_UpscaleRT : bool = false
    m_PixelSnapping : bool = false
    m_CropFrameX : bool = false
    m_CropFrameY : bool = false
    m_StretchFill : bool = false
    m_CinemachineCompatibilityMode : bool
    PixelSnap() : void
    Awake() : void
    LateUpdate() : void
    OnPreCull() : void
    OnPreRender() : void
    OnPostRender() : void
    <<internal>> OnDisable() : void
}
MonoBehaviour <|-- PixelPerfectCamera
IPixelPerfectCamera <|-- PixelPerfectCamera
PixelPerfectCamera --> "m_Camera" Camera
PixelPerfectCamera --> "m_Internal" PixelPerfectCameraInternal
interface IPixelPerfectCamera {
    assetsPPU : int <<get>> <<set>>
    refResolutionX : int <<get>> <<set>>
    refResolutionY : int <<get>> <<set>>
    upscaleRT : bool <<get>> <<set>>
    pixelSnapping : bool <<get>> <<set>>
    cropFrameX : bool <<get>> <<set>>
    cropFrameY : bool <<get>> <<set>>
    stretchFill : bool <<get>> <<set>>
}
class PixelPerfectCameraInternal {
    <<internal>> originalOrthoSize : float
    <<internal>> hasPostProcessLayer : bool
    <<internal>> cropFrameXAndY : bool = false
    <<internal>> cropFrameXOrY : bool = false
    <<internal>> useStretchFill : bool = false
    <<internal>> zoom : int = 1
    <<internal>> useOffscreenRT : bool = false
    <<internal>> offscreenRTWidth : int = 0
    <<internal>> offscreenRTHeight : int = 0
    <<internal>> orthoSize : float = 1.0f
    <<internal>> unitsPerPixel : float = 0.0f
    <<internal>> cinemachineVCamZoom : int = 1
    <<internal>> PixelPerfectCameraInternal(component:IPixelPerfectCamera)
    + OnBeforeSerialize() : void
    + OnAfterDeserialize() : void
    <<internal>> CalculateCameraProperties(screenWidth:int, screenHeight:int) : void
    <<internal>> CalculatePostRenderPixelRect(cameraAspect:float, screenWidth:int, screenHeight:int) : Rect
    <<internal>> CorrectCinemachineOrthoSize(targetOrthoSize:float) : float
}
ISerializationCallbackReceiver <|-- PixelPerfectCameraInternal
PixelPerfectCameraInternal --> "m_Component" IPixelPerfectCamera
PixelPerfectCameraInternal --> "m_SerializableComponent" PixelPerfectCamera
PixelPerfectCameraInternal o-> "pixelRect" Rect
class PSDApplyEvent <<struct>> {
    + instance_id : int
    + texture_type : int
    + sprite_mode : int
    + mosaic_layer : bool
    + import_hidden_layer : bool
    + character_mode : bool
    + generate_go_hierarchy : bool
    + reslice_from_layer : bool
    + is_character_rigged : bool
    + is_psd : bool
}
interface IAnalytics {
    SendApplyEvent(evt:PSDApplyEvent) : AnalyticsResult
}
class AnalyticFactory <<static>> {
}
class Analytics {
    <<const>> k_MaxEventsPerHour : int = 100
    <<const>> k_MaxNumberOfElements : int = 1000
    <<const>> k_VendorKey : string = "unity.2d.psdimporter"
    <<const>> k_Version : int = 1
    {static} Analytics()
    + SendApplyEvent(evt:PSDApplyEvent) : AnalyticsResult
}
PSDApplyEvent --> "character_alignment" SpriteAlignment
PSDApplyEvent --> "color_mode" PsdColorMode
AnalyticFactory --> "s_Analytics" IAnalytics
AnalyticFactory --> "analytics" IAnalytics
IAnalytics <|-- Analytics
class PSDImporter {
    m_MosaicLayers : bool = true
    m_ImportHiddenLayers : bool = false
    m_ImportedTextureWidth : int
    m_ImportedTextureHeight : int
    m_PaperDollMode : bool = false
    m_KeepDupilcateSpriteName : bool = false
    m_TextureActualWidth : int
    <<internal>> textureActualWidth : int <<get>>
    m_TextureActualHeight : int
    <<internal>> textureActualHeight : int <<get>>
    m_SpritePackingTag : string = ""
    m_ResliceFromLayer : bool = false
    m_CharacterMode : bool = true
    m_GenerateGOHierarchy : bool = false
    m_TextureAssetName : string = null
    m_PrefabAssetName : string = null
    m_SpriteLibAssetName : string = null
    + <<override>> OnImportAsset(ctx:AssetImportContext) : void
    {static} ValidatePSDLayerId(layers:List<BitmapLayer>, uniqueNameGenerator:UniqueNameGenerator) : void
    ValidatePSDLayerId(doc:Document) : void
    ImportTexture(ctx:AssetImportContext, imageData:NativeArray<Color32>, textureWidth:int, textureHeight:int, spriteStart:int, spriteCount:int) : TextureGenerationOutput
    AutoGenerateSpriteSkinData(metaData:SpriteMetaData) : void
    GetUniqueSpriteName(name:string, namehash:List<int>) : string
    ImportFromLayers(ctx:AssetImportContext, doc:Document) : void
    MemorySnapshotFinish(path:string, done:bool) : void
    EnsureSingleSpriteExist() : void
    <<internal>> GetPlatformTextureSettings(buildTarget:BuildTarget) : TextureImporterPlatformSettings
    RegisterAssets(ctx:AssetImportContext, output:TextureGenerationOutput) : void
    SpriteIsMainFromSpriteLib(spriteId:string, categoryName:string) : bool
    BuildGroupGameObject(psdGroup:List<PSDLayer>, index:int, root:Transform) : void
    shouldProduceGameObject : bool <<get>>
    shouldResliceFromLayer : bool <<get>>
    characterMode : bool <<get>>
    definitionScale : float <<get>>
    CreateBoneGO(index:int, bones:SpriteBone[], bonesGO:BoneGO[], defaultRoot:Transform) : void
    CreateBonesGO(root:Transform) : BoneGO[]
    GetSpriteLiblabel(spriteId:string, category:string, label:string) : void
    OnProducePaperDollPrefab(assetname:string, sprites:Sprite[], spriteLib:SpriteLibraryAsset) : GameObject
    OnProducePrefab(assetname:string, sprites:Sprite[], spriteLib:SpriteLibraryAsset) : GameObject
    GetBoundingBox(root:GameObject) : Bounds?
    CleanUpGameobjectsWithOutRig(root:GameObject) : bool
    {static} SanitizeName(name:string) : string
    {static} GetUniqueName(name:string, stringHash:List<int>, logNewNameGenerated:bool, context:UnityEngine.Object) : string
    <<internal>> spriteDataCount : int <<get>>
    <<internal>> pixelsPerUnit : float <<get>>
    pixelsPerUnit : float <<get>>
    <<internal>> GetDataProvider() : T
    GetDataProvider() : T
    <<internal>> HasDataProvider(type:Type) : bool
    HasDataProvider(type:Type) : bool
    <<internal>> AddSpriteData(spriteRect:SpriteRect) : void
    <<internal>> DeleteSpriteData(spriteRect:SpriteRect) : void
    <<internal>> GetSpriteDataIndex(guid:GUID) : int
    <<internal>> Apply() : void
    Apply() : void
    <<internal>> InitSpriteEditorDataProvider() : void
    InitSpriteEditorDataProvider() : void
    <<internal>> GetSpriteRects() : SpriteRect[]
    GetSpriteRects() : SpriteRect[]
    GetSpriteImportData() : List<SpriteMetaData>
    <<internal>> GetPSDLayers() : List<PSDLayer>
    <<internal>> GetSpriteMetaData() : SpriteMetaData[]
    <<internal>> GetSpriteData(guid:GUID) : SpriteRect
    <<internal>> SetSpriteRects(spriteRects:SpriteRect[]) : void
    SetSpriteRects(spriteRects:SpriteRect[]) : void
    mosaicMode : bool <<get>>
    ProduceSpriteLibAsset(sprites:Sprite[]) : SpriteLibraryAsset
}
class UniqueNameGenerator {
    + ContainHash(i:int) : bool
    + AddHash(i:int) : void
    + GetUniqueName(name:string) : string
}
class GameObjectCreationFactory {
    + CreateGameObject(name:string, components:System.Type[]) : GameObject
}
class BoneGO <<struct>> {
    + index : int
}
class "List`1"<T> {
}
ScriptedImporter <|-- PSDImporter
ISpriteEditorDataProvider <|-- PSDImporter
PSDImporter o-> "m_TextureImporterSettings" TextureImporterSettings
PSDImporter o-> "m_SpriteImportData<SpriteMetaData>" "List`1"
PSDImporter o-> "m_MosaicSpriteImportData<SpriteMetaData>" "List`1"
PSDImporter o-> "m_RigSpriteImportData<SpriteMetaData>" "List`1"
PSDImporter o-> "m_PlatformSettings<TextureImporterPlatformSettings>" "List`1"
PSDImporter o-> "m_DocumentPivot" Vector2
PSDImporter o-> "m_DocumentAlignment" SpriteAlignment
PSDImporter --> "m_DocumentSize" Vector2Int
PSDImporter o-> "m_SpriteCategoryList" SpriteCategoryList
PSDImporter o-> "m_GameObjectFactory" GameObjectCreationFactory
PSDImporter --> "spriteCategoryList" SpriteCategoryList
PSDImporter o-> "m_MosaicPSDLayers<PSDLayer>" "List`1"
PSDImporter o-> "m_RigPSDLayers<PSDLayer>" "List`1"
PSDImporter o-> "m_CharacterData" CharacterData
PSDImporter --> "spriteImportMode" SpriteImportMode
PSDImporter --> "spriteImportMode" SpriteImportMode
PSDImporter --> "characterData" CharacterData
PSDImporter --> "documentSize" Vector2Int
PSDImporter +-- UniqueNameGenerator
UniqueNameGenerator o-> "m_NameHash<int>" "List`1"
PSDImporter +-- GameObjectCreationFactory
UniqueNameGenerator <|-- GameObjectCreationFactory
PSDImporter +-- BoneGO
BoneGO --> "go" GameObject
abstract class PSDDataProvider {
}
class SpriteBoneDataProvider {
    + GetBones(guid:GUID) : List<SpriteBone>
    + SetBones(guid:GUID, bones:List<SpriteBone>) : void
}
class TextureDataProvider {
    + GetReadableTexture2D() : Texture2D
    + GetTextureActualWidthAndHeight(width:int, height:int) : void
}
class SecondaryTextureDataProvider {
}
class SpriteOutlineDataProvider {
    + GetOutlines(guid:GUID) : List<Vector2[]>
    + SetOutlines(guid:GUID, data:List<Vector2[]>) : void
    + GetTessellationDetail(guid:GUID) : float
    + SetTessellationDetail(guid:GUID, value:float) : void
}
class SpritePhysicsOutlineProvider {
    + GetOutlines(guid:GUID) : List<Vector2[]>
    + SetOutlines(guid:GUID, data:List<Vector2[]>) : void
    + GetTessellationDetail(guid:GUID) : float
    + SetTessellationDetail(guid:GUID, value:float) : void
}
class SpriteMeshDataProvider {
    + GetVertices(guid:GUID) : Vertex2DMetaData[]
    + SetVertices(guid:GUID, vertices:Vertex2DMetaData[]) : void
    + GetIndices(guid:GUID) : int[]
    + SetIndices(guid:GUID, indices:int[]) : void
    + GetEdges(guid:GUID) : Vector2Int[]
    + SetEdges(guid:GUID, edges:Vector2Int[]) : void
}
class CharacterDataProvider {
    ParentGroupInFlatten(parentIndex:int, psdLayers:List<PSDLayer>) : int
    + GetCharacterData() : CharacterData
    + SetCharacterData(characterData:CharacterData) : void
}
class SpriteLibraryDataProvider {
    + GetSpriteCategoryList() : SpriteCategoryList
    + SetSpriteCategoryList(spriteCategoryList:SpriteCategoryList) : void
}
PSDDataProvider --> "dataProvider" PSDImporter
PSDDataProvider <|-- SpriteBoneDataProvider
ISpriteBoneDataProvider <|-- SpriteBoneDataProvider
PSDDataProvider <|-- TextureDataProvider
ITextureDataProvider <|-- TextureDataProvider
TextureDataProvider --> "m_ReadableTexture" Texture2D
TextureDataProvider --> "m_OriginalTexture" Texture2D
TextureDataProvider --> "textureImporter" PSDImporter
TextureDataProvider --> "texture" Texture2D
TextureDataProvider --> "previewTexture" Texture2D
PSDDataProvider <|-- SecondaryTextureDataProvider
ISecondaryTextureDataProvider <|-- SecondaryTextureDataProvider
PSDDataProvider <|-- SpriteOutlineDataProvider
ISpriteOutlineDataProvider <|-- SpriteOutlineDataProvider
PSDDataProvider <|-- SpritePhysicsOutlineProvider
ISpritePhysicsOutlineDataProvider <|-- SpritePhysicsOutlineProvider
PSDDataProvider <|-- SpriteMeshDataProvider
ISpriteMeshDataProvider <|-- SpriteMeshDataProvider
PSDDataProvider <|-- CharacterDataProvider
ICharacterDataProvider <|-- CharacterDataProvider
PSDDataProvider <|-- SpriteLibraryDataProvider
ISpriteLibDataProvider <|-- SpriteLibraryDataProvider
class PSDImporterEditor {
    m_IsPOT : bool = false
    m_ShowAdvanced : bool = false
    m_ShowExperimental : bool = false
    m_PlatformSettingsIndex : int
    m_ShowPerAxisWrapModes : bool = false
    + <<override>> OnEnable() : void
    + <<override>> OnInspectorGUI() : void
    {static} IsPSD(doc:PsdFile) : bool
    {static} FileColorMode(doc:PsdFile) : PsdColorMode
    IsCharacterRigged() : bool
    LoadPlatformSettings() : void
    StorePlatformSettings() : void
    DoPlatformSettings() : void
    DoAdvanceInspector() : void
    CommonTextureSettingsGUI() : void
    <<internal>> {static} WrapModePopup(wrapU:SerializedProperty, wrapV:SerializedProperty, wrapW:SerializedProperty, isVolumeTexture:bool, showPerAxisWrapModes:bool) : void
    {static} WrapModeAxisPopup(label:GUIContent, wrapProperty:SerializedProperty) : void
    DoWrapModePopup() : void
    IsVolume() : bool
    DoSpriteInspector() : void
    DoTextureDefaultInspector() : void
    ColorSpaceGUI() : void
    POTScaleGUI() : void
    ReadableGUI() : void
    AlphaHandlingGUI() : void
    MipMapGUI() : void
    ToggleFromInt(property:SerializedProperty, label:GUIContent) : void
    EnumPopup(property:SerializedProperty, type:System.Type, label:GUIContent) : void
    ExportMosaicTexture() : void
    + <<override>> showImportedObject : bool <<get>>
}
class "Dictionary`2"<T1,T2> {
}
class Styles {
    + Styles()
}
ScriptedImporterEditor <|-- PSDImporterEditor
PSDImporterEditor --> "m_TextureType" SerializedProperty
PSDImporterEditor --> "m_TextureShape" SerializedProperty
PSDImporterEditor --> "m_SpriteMode" SerializedProperty
PSDImporterEditor --> "m_SpritePixelsToUnits" SerializedProperty
PSDImporterEditor --> "m_SpriteMeshType" SerializedProperty
PSDImporterEditor --> "m_SpriteExtrude" SerializedProperty
PSDImporterEditor --> "m_Alignment" SerializedProperty
PSDImporterEditor --> "m_SpritePivot" SerializedProperty
PSDImporterEditor --> "m_NPOTScale" SerializedProperty
PSDImporterEditor --> "m_IsReadable" SerializedProperty
PSDImporterEditor --> "m_sRGBTexture" SerializedProperty
PSDImporterEditor --> "m_AlphaSource" SerializedProperty
PSDImporterEditor --> "m_MipMapMode" SerializedProperty
PSDImporterEditor --> "m_EnableMipMap" SerializedProperty
PSDImporterEditor --> "m_FadeOut" SerializedProperty
PSDImporterEditor --> "m_BorderMipMap" SerializedProperty
PSDImporterEditor --> "m_MipMapsPreserveCoverage" SerializedProperty
PSDImporterEditor --> "m_AlphaTestReferenceValue" SerializedProperty
PSDImporterEditor --> "m_MipMapFadeDistanceStart" SerializedProperty
PSDImporterEditor --> "m_MipMapFadeDistanceEnd" SerializedProperty
PSDImporterEditor --> "m_AlphaIsTransparency" SerializedProperty
PSDImporterEditor --> "m_FilterMode" SerializedProperty
PSDImporterEditor --> "m_Aniso" SerializedProperty
PSDImporterEditor --> "m_WrapU" SerializedProperty
PSDImporterEditor --> "m_WrapV" SerializedProperty
PSDImporterEditor --> "m_WrapW" SerializedProperty
PSDImporterEditor --> "m_ConvertToNormalMap" SerializedProperty
PSDImporterEditor --> "m_MosaicLayers" SerializedProperty
PSDImporterEditor --> "m_ImportHiddenLayers" SerializedProperty
PSDImporterEditor --> "m_ResliceFromLayer" SerializedProperty
PSDImporterEditor --> "m_CharacterMode" SerializedProperty
PSDImporterEditor --> "m_DocumentPivot" SerializedProperty
PSDImporterEditor --> "m_DocumentAlignment" SerializedProperty
PSDImporterEditor --> "m_GenerateGOHierarchy" SerializedProperty
PSDImporterEditor --> "m_PaperDollMode" SerializedProperty
PSDImporterEditor --> "m_KeepDupilcateSpriteName" SerializedProperty
PSDImporterEditor o-> "m_AdvanceInspectorGUI<TextureImporterType,Action[]>" "Dictionary`2"
PSDImporterEditor o-> "m_TexturePlatformSettingsView" TexturePlatformSettingsView
PSDImporterEditor o-> "m_TexturePlatformSettingsController" TexturePlatformSettingsController
PSDImporterEditor o-> "m_PlatfromSettings<string,List<TextureImporterPlatformSettings>>" "Dictionary`2"
PSDImporterEditor --> "s_Styles" Styles
PSDImporterEditor +-- Styles
Styles o-> "textureTypeTitle" GUIContent
Styles o-> "textureShape" GUIContent
Styles o-> "textureShapeOptionsDictionnary<TextureImporterShape,GUIContent[]>" "Dictionary`2"
Styles o-> "textureShapeValuesDictionnary<TextureImporterShape,int[]>" "Dictionary`2"
Styles o-> "filterMode" GUIContent
Styles o-> "textureFormat" GUIContent
Styles o-> "defaultPlatform" GUIContent
Styles o-> "mipmapFadeOutToggle" GUIContent
Styles o-> "mipmapFadeOut" GUIContent
Styles o-> "readWrite" GUIContent
Styles o-> "alphaSource" GUIContent
Styles o-> "generateMipMaps" GUIContent
Styles o-> "sRGBTexture" GUIContent
Styles o-> "borderMipMaps" GUIContent
Styles o-> "mipMapsPreserveCoverage" GUIContent
Styles o-> "alphaTestReferenceValue" GUIContent
Styles o-> "mipMapFilter" GUIContent
Styles o-> "npot" GUIContent
Styles o-> "compressionQuality" GUIContent
Styles o-> "compressionQualitySlider" GUIContent
Styles o-> "spriteMode" GUIContent
Styles o-> "spritePackingTag" GUIContent
Styles o-> "spritePixelsPerUnit" GUIContent
Styles o-> "spriteExtrude" GUIContent
Styles o-> "spriteMeshType" GUIContent
Styles o-> "spriteAlignment" GUIContent
Styles o-> "characterAlignment" GUIContent
Styles o-> "warpNotSupportWarning" GUIContent
Styles o-> "anisoLevelLabel" GUIContent
Styles o-> "anisotropicDisableInfo" GUIContent
Styles o-> "anisotropicForceEnableInfo" GUIContent
Styles o-> "unappliedSettingsDialogTitle" GUIContent
Styles o-> "unappliedSettingsDialogContent" GUIContent
Styles o-> "applyButtonLabel" GUIContent
Styles o-> "revertButtonLabel" GUIContent
Styles o-> "spriteEditorButtonLabel" GUIContent
Styles o-> "resliceFromLayerWarning" GUIContent
Styles o-> "alphaIsTransparency" GUIContent
Styles o-> "etc1Compression" GUIContent
Styles o-> "crunchedCompression" GUIContent
Styles o-> "showAdvanced" GUIContent
Styles o-> "platformSettingsLabel" GUIContent
Styles o-> "wrapModeLabel" GUIContent
Styles o-> "wrapU" GUIContent
Styles o-> "wrapV" GUIContent
Styles o-> "wrapW" GUIContent
Styles o-> "importHiddenLayer" GUIContent
Styles o-> "mosaicLayers" GUIContent
Styles o-> "characterMode" GUIContent
Styles o-> "generateGOHierarchy" GUIContent
Styles o-> "resliceFromLayer" GUIContent
Styles o-> "paperDollMode" GUIContent
Styles o-> "experimental" GUIContent
Styles o-> "keepDuplicateSpriteName" GUIContent
class PSDImportPostProcessor {
    OnPostprocessSprites(texture:Texture2D, sprites:Sprite[]) : void
}
AssetPostprocessor <|-- PSDImportPostProcessor
class PSDLayer {
    m_Name : string
    m_SpriteName : string
    m_IsGroup : bool
    m_ParentIndex : int
    m_SpriteID : string
    m_LayerID : int
    + PSDLayer(tex:NativeArray<Color32>, parent:int, group:bool, layerName:string, width:int, height:int, id:int)
    + layerID : int <<get>>
    + name : string <<get>>
    + spriteName : string <<get>> <<set>>
    + isGroup : bool <<get>>
    + parentIndex : int <<get>>
    + width : int <<get>>
    + height : int <<get>>
    + Dispose() : void
}
class "NativeArray`1"<T> {
}
PSDLayer --> "m_MosaicPosition" Vector2Int
PSDLayer --> "m_GameObject" GameObject
PSDLayer --> "mosaicPosition" Vector2Int
PSDLayer --> "spriteID" GUID
PSDLayer --> "gameObject" GameObject
PSDLayer --> "texture<Color32>" "NativeArray`1"
class SpriteMetaData {
    + tessellationDetail : float
    + parentGroupIndex : int
    + SpriteMetaData()
    + SpriteMetaData(sr:SpriteRect)
    + {static} GetGUIDFromSerializedProperty(sp:SerializedProperty) : GUID
    + {static} GetPivotValue(alignment:SpriteAlignment, customOffset:Vector2) : Vector2
}
class SpriteOutline {
}
class "List`1"<T> {
}
SpriteRect <|-- SpriteMetaData
SpriteMetaData --> "spriteBone<SpriteBone>" "List`1"
SpriteMetaData --> "spriteOutline<SpriteOutline>" "List`1"
SpriteMetaData --> "vertices<Vertex2DMetaData>" "List`1"
SpriteMetaData --> "spritePhysicsOutline<SpriteOutline>" "List`1"
SpriteMetaData o-> "uvTransform" Vector2Int
class TexturePlatformSettingsController {
    + HandleDefaultSettings(platformSettings:List<TextureImporterPlatformSettings>, view:TexturePlatformSettingsView) : bool
    + HandlePlatformSettings(buildTarget:BuildTarget, platformSettings:List<TextureImporterPlatformSettings>, view:TexturePlatformSettingsView) : bool
    + AcquireTextureFormatValuesAndStrings(buildTarget:BuildTarget, formatValues:int[], formatStrings:string[]) : void
    <<internal>> {static} IsFormatRequireCompressionSetting(format:TextureImporterFormat) : bool
    <<internal>> {static} IsGLESMobileTargetPlatform(target:BuildTarget) : bool
}
class TexturePlatformSettingsModal <<static>> {
    {static} TexturePlatformSettingsModal()
    <<internal>> {static} BuildTextureStrings(texFormatValues:int[]) : string[]
    {static} GetTextureFormatString(format:TextureImporterFormat) : string
}
class BuildPlatformData <<struct>> {
    + buildTargetName : string
}
TexturePlatformSettingsModal +-- BuildPlatformData
BuildPlatformData --> "defaultTextureFormat" TextureImporterFormat
class TexturePlatformSettingsView {
    + buildPlatformTitle : string <<get>> <<set>>
    <<internal>> TexturePlatformSettingsView()
    + <<virtual>> DrawResizeAlgorithm(defaultValue:TextureResizeAlgorithm, isMixedValue:bool, isDisabled:bool, changed:bool) : TextureResizeAlgorithm
    + <<virtual>> DrawCompression(defaultValue:TextureImporterCompression, isMixedValue:bool, changed:bool) : TextureImporterCompression
    + <<virtual>> DrawUseCrunchedCompression(defaultValue:bool, isMixedValue:bool, changed:bool) : bool
    + <<virtual>> DrawOverride(defaultValue:bool, isMixedValue:bool, changed:bool) : bool
    + <<virtual>> DrawMaxSize(defaultValue:int, isMixedValue:bool, isDisabled:bool, changed:bool) : int
    + <<virtual>> DrawFormat(defaultValue:TextureImporterFormat, displayValues:int[], displayStrings:string[], isMixedValue:bool, isDisabled:bool, changed:bool) : TextureImporterFormat
    + <<virtual>> DrawCompressionQualityPopup(defaultValue:int, isMixedValue:bool, changed:bool) : int
    + <<virtual>> DrawCompressionQualitySlider(defaultValue:int, isMixedValue:bool, changed:bool) : int
}
class Styles {
    + Styles()
}
TexturePlatformSettingsView +-- Styles
Styles o-> "textureFormatLabel" GUIContent
Styles o-> "maxTextureSizeLabel" GUIContent
Styles o-> "compressionLabel" GUIContent
Styles o-> "resizeAlgorithmLabel" GUIContent
Styles o-> "useCrunchedCompressionLabel" GUIContent
Styles o-> "compressionQualityLabel" GUIContent
Styles o-> "compressionQualitySliderLabel" GUIContent
interface IAngleRangeCache {
    selectedIndex : int <<get>> <<set>>
    previewAngle : float <<get>> <<set>>
    RegisterUndo(name:string) : void
}
class AngleRangeController {
    +  <<event>> selectionChanged : Action 
    + angleOffset : float <<get>> <<set>>
    + radius : float <<get>> <<set>>
    + snap : bool <<get>> <<set>>
    + OnGUI() : void
    + RemoveInvalidRanges() : void
    + CreateRange() : void
    + SetRange(angleRange:AngleRange, start:float, end:float) : void
}
class "List`1"<T> {
}
IAngleRangeCache --> "angleRanges<AngleRange>" "List`1"
AngleRangeController --> "cache" IAngleRangeCache
AngleRangeController --> "view" IAngleRangeView
AngleRangeController --> "rect" Rect
AngleRangeController --> "gradientMin" Color
AngleRangeController --> "gradientMid" Color
AngleRangeController --> "gradientMax" Color
AngleRangeController --> "selectedAngleRange" AngleRange
class AngleRangeGUI {
    + {static} <<readonly>> kLeftHandleHashCode : int
    + {static} <<readonly>> kRightHandleHashCode : int
    + <<const>> kRangeWidth : float = 10f
    + {static} AngleRangeField(rect:Rect, start:float, end:float, angleOffset:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, rangeColor:Color) : void
    + {static} AngleRangeField(rect:Rect, leftHandleID:int, rightHandleID:int, start:float, end:float, angleOffset:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, rangeColor:Color) : void
    + {static} AngleRangeField(rect:Rect, startProperty:SerializedProperty, endProperty:SerializedProperty, angleOffset:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, rangeColor:Color) : void
    + {static} AngleField(id:int, property:SerializedProperty, angleOffset:float, handleOffset:Vector2, handleAngle:float, handleSize:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, drawCapFunction:Handles.CapFunction) : void
    + {static} AngleField(r:Rect, id:int, property:SerializedProperty, angleOffset:float, handleOffset:Vector2, handleAngle:float, handleSize:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, drawCapFunction:Handles.CapFunction) : void
    + {static} AngleField(id:int, angle:float, angleOffset:float, handleOffset:Vector2, handleAngle:float, radius:float, handleSize:float, snap:bool, drawLine:bool, drawCircle:bool, drawCapFunction:Handles.CapFunction) : float
    + {static} AngleField(rect:Rect, id:int, angle:float, angleOffset:float, handleOffset:Vector2, handleAngle:float, handleSize:float, radius:float, snap:bool, drawLine:bool, drawCircle:bool, drawCapFunction:Handles.CapFunction) : float
}
enum AngleRangeAction {
    SelectRange,
    ModifyRange,
    CreateRange,
    ModifySelector,
    RemoveRange,
}
interface IAngleRangeView {
    hoveredRangeIndex : int <<get>>
    RequestFocusIndex(index:int) : void
    GetAngleFromPosition(rect:Rect, angleOffset:float) : float
    Repaint() : void
    SetupLayout(rect:Rect, angleOffset:float, radius:float) : void
    DoAngleRange(index:int, rect:Rect, radius:float, angleOffset:float, start:float, end:float, snap:bool, disabled:bool, gradientMin:Color, gradientMid:Color, gradientMax:Color) : bool
    DoSelectAngleRange(currentSelected:int, newSelected:int) : bool
    DoCreateRange(rect:Rect, radius:float, angleOffset:float, start:float, end:float) : bool
    DoCreateRangeTooltip() : void
    DoSelector(rect:Rect, angleOffset:float, radius:float, angle:float, newAngle:float) : bool
    DoRemoveRange() : bool
    IsActionActive(action:AngleRangeAction) : bool
    IsActionTriggering(action:AngleRangeAction) : bool
    IsActionFinishing(action:AngleRangeAction) : bool
    DrawAngleRangeOutline(rect:Rect, start:float, end:float, angleOffset:float, radius:float) : void
}
class AngleRangeView {
    <<const>> kDeleteCommandName : string = "Delete"
    <<const>> kSoftDeleteCommandName : string = "SoftDelete"
    {static} <<readonly>> kAngleRangeHashCode : int
    {static} <<readonly>> kCreateRangeHashCode : int
    {static} <<readonly>> kSelectorHashCode : int
    + hoveredRangeIndex : int <<get>>
    + RequestFocusIndex(index:int) : void
    + GetAngleFromPosition(rect:Rect, angleOffset:float) : float
    + Repaint() : void
    + SetupLayout(rect:Rect, angleOffset:float, radius:float) : void
    + DoAngleRange(index:int, rect:Rect, radius:float, angleOffset:float, start:float, end:float, snap:bool, disabled:bool, gradientMin:Color, gradientMid:Color, gradientMax:Color) : bool
    + DoSelectAngleRange(currentSelected:int, newSelected:int) : bool
    + DoCreateRange(rect:Rect, radius:float, angleOffset:float, start:float, end:float) : bool
    + DoCreateRangeTooltip() : void
    + DoSelector(rect:Rect, angleOffset:float, radius:float, angle:float, newAngle:float) : bool
    + DoRemoveRange() : bool
    + IsActionActive(action:AngleRangeAction) : bool
    + IsActionHot(action:AngleRangeAction) : bool
    + IsActionTriggering(action:AngleRangeAction) : bool
    + IsActionFinishing(action:AngleRangeAction) : bool
    + DrawAngleRangeOutline(rect:Rect, start:float, end:float, angleOffset:float, radius:float) : void
}
class Contents <<static>> {
}
IAngleRangeView <|-- AngleRangeView
AngleRangeView +-- Contents
Contents o-> "addRangeTooltip" GUIContent
class ContextMenu {
    + {static} CreateNewSpriteStrip() : void
    + {static} CreateNewSpriteShape() : void
    <<internal>> {static} CreateSpriteShapeEmpty() : void
}
class EditorSpriteGUIUtility <<static>> {
    + {static} GetOriginalSpriteTexture(sprite:Sprite) : Texture
    + {static} GetOriginalSpriteUvs(sprite:Sprite) : Vector2[]
    + {static} DrawSpriteInRectPrepare(rect:Rect, sprite:Sprite, fitMode:FitMode, excludeBorders:bool, forceQuad:bool, mesh:Mesh) : void
    + {static} DrawMesh(mesh:Mesh, material:Material, position:Vector3, rotation:Quaternion, scale:Vector3) : void
}
enum FitMode {
    BestFit,
    FitHorizontal,
    FitVertical,
    Fill,
    Tiled,
}
EditorSpriteGUIUtility --> "spriteMaterial" Material
EditorSpriteGUIUtility +-- FitMode
class SceneDragAndDrop <<static>> {
    {static} SceneDragAndDrop()
    {static} OnSceneGUI(sceneView:SceneView) : void
    + {static} Create(shape:UnityEngine.U2D.SpriteShape, position:Vector3, sceneView:SceneView) : GameObject
    {static} OnHierarchyGUI(instanceID:int, rect:Rect) : void
    {static} GetSpriteShapeFromPathsOrObjects(objects:Object[], paths:string[], currentEventType:EventType) : List<UnityEngine.U2D.SpriteShape>
    {static} HandleSceneDrag(sceneView:SceneView, evt:Event, objectReferences:Object[], paths:string[]) : void
    {static} PositionSceneDragObjects(objects:List<Object>, sceneView:SceneView, mousePosition:Vector2) : void
    {static} CreateSceneDragObjects(shapes:List<UnityEngine.U2D.SpriteShape>) : void
    {static} CleanUp(deleteTempSceneObject:bool) : void
    {static} ExistingAssets(objects:Object[]) : bool
    {static} CreateDragGO(spriteShape:UnityEngine.U2D.SpriteShape, position:Vector3) : GameObject
}
class Contents <<static>> {
    + {static} <<readonly>> createString : string = "Create Sprite Shape"
}
class "List`1"<T> {
}
enum DragType {
    NotInitialized,
    CreateMultiple,
}
SceneDragAndDrop --> "s_SceneDragObjects<Object>" "List`1"
SceneDragAndDrop --> "s_DragType" DragType
SceneDragAndDrop +-- Contents
SceneDragAndDrop +-- DragType
class SpriteSelector {
    m_SelectedSprite : int = 0
    + selectedIndex : int <<get>> <<set>>
    + SpriteSelector()
    + UpdateSprites(sprites:Sprite[]) : void
    + UpdateSelection(newSelectedBrush:int) : void
    {static} DrawRectangleOutline(rect:Rect, color:Color) : void
    + GetActiveSprite() : Sprite
    + ShowGUI(selectedIndex:int) : bool
    SpriteSelectionGrid(selected:int, sprites:Sprite[], approxSize:int, style:GUIStyle, emptyString:GUIContent, columns:int, rows:int) : int
    <<internal>> {static} PreviewTexturesFromSprites(sprites:Sprite[]) : Texture[]
}
class Styles <<static>> {
}
SpriteSelector --> "m_ScrollPos" Vector2
SpriteSelector +-- Styles
Styles o-> "gridList" GUIStyle
Styles o-> "spriteList" GUIContent
Styles o-> "missingSprites" GUIContent
Styles o-> "localGrid" GUIStyle
class SpriteShapeAnalyticsEvents {
}
enum SpriteShapeAnalyticsEventType {
    SpriteShapeProfileCreated= 0,
    SpriteShapeRendererCreated= 1,
}
class SpriteShapeAnalyticsEvent <<struct>> {
    + data : string
}
interface ISpriteShapeAnalyticsStorage {
    SendUsageEvent(evt:SpriteShapeAnalyticsEvent) : AnalyticsResult
    Dispose() : void
}
class SpriteShapeAnalyticConstant <<static>> {
    + <<const>> k_MaxEventsPerHour : int = 1000
    + <<const>> k_MaxNumberOfElements : int = 1000
}
class SpriteShapeAnalytics {
    <<const>> k_SpriteShapeEventElementCount : int = 2
    + SpriteShapeAnalytics(analyticsStorage:ISpriteShapeAnalyticsStorage)
    + Dispose() : void
    OnSpriteShapeCreated(shape:UnityEngine.U2D.SpriteShape) : void
    OnSpriteShapeRendererCreated(renderer:SpriteShapeRenderer) : void
    + SendUsageEvent(evt:SpriteShapeAnalyticsEvent) : void
}
class SpriteShapeJsonAnalyticsStorage {
    + SendUsageEvent(evt:SpriteShapeAnalyticsEvent) : AnalyticsResult
    + Dispose() : void
}
class SpriteShapeUnityAnalyticsStorage {
    <<const>> k_VendorKey : string = "unity.2d.spriteshape"
    <<const>> k_Version : int = 1
    + SpriteShapeUnityAnalyticsStorage()
    + SendUsageEvent(evt:SpriteShapeAnalyticsEvent) : AnalyticsResult
    + Dispose() : void
}
class SpriteShapeEvent {
}
class SpriteShapeRendererEvent {
}
class SpriteShapeToolEvents <<struct>> {
}
class "UnityEvent`1"<T> {
}
class "List`1"<T> {
}
SpriteShapeAnalyticsEvents --> "spriteShapeEvent" SpriteShapeEvent
SpriteShapeAnalyticsEvents --> "spriteShapeRendererEvent" SpriteShapeRendererEvent
SpriteShapeAnalyticsEvent --> "sub_type" SpriteShapeAnalyticsEventType
SpriteShapeAnalytics --> "m_AnalyticsStorage" ISpriteShapeAnalyticsStorage
SpriteShapeAnalytics o-> "m_EventBus" SpriteShapeAnalyticsEvents
SpriteShapeAnalytics --> "eventBus" SpriteShapeAnalyticsEvents
ISpriteShapeAnalyticsStorage <|-- SpriteShapeJsonAnalyticsStorage
SpriteShapeJsonAnalyticsStorage o-> "m_TotalEvents" SpriteShapeToolEvents
ISpriteShapeAnalyticsStorage <|-- SpriteShapeUnityAnalyticsStorage
SpriteShapeAnalyticsEvents +-- SpriteShapeEvent
"UnityEvent`1" "<UnityEngine.U2D.SpriteShape>" <|-- SpriteShapeEvent
SpriteShapeAnalyticsEvents +-- SpriteShapeRendererEvent
"UnityEvent`1" "<SpriteShapeRenderer>" <|-- SpriteShapeRendererEvent
SpriteShapeJsonAnalyticsStorage +-- SpriteShapeToolEvents
SpriteShapeToolEvents --> "events<SpriteShapeAnalyticsEvent>" "List`1"
class SpriteShapeAssetPostProcessor {
    {static} OnPostprocessAllAssets(importedAssets:string[], deletedAssets:string[], movedAssets:string[], movedFromAssetPaths:string[]) : void
}
AssetPostprocessor <|-- SpriteShapeAssetPostProcessor
class SpriteShapeControllerEditor {
    m_SelectedPoint : int
    m_SelectedAngleRange : int
    m_SpriteShapeHashCode : int = 0
    m_SplineHashCode : int = 0
    + DrawHeader(content:GUIContent) : void
    {static} WithinRange(angleRange:ShapeAngleRange, inputAngle:float) : bool
    {static} RangeFromAngle(angleRanges:List<ShapeAngleRange>, angle:float) : int
    + GetAngleRange(index:int) : int
    + <<override>> OnInspectorGUI() : void
    BakeCollider() : void
    ShowMaterials(show:bool) : void
    {static} RenderSpline(m_SpriteShapeController:SpriteShapeController, gizmoType:GizmoType) : void
}
class SpriteShapeUpdateCache <<static>> {
    <<internal>> {static} s_cacheGeometrySet : bool = false
    {static} SpriteShapeUpdateCache()
    {static} UpdateSpriteShapeCacheInOpenScenes() : void
    <<internal>> {static} UpdateCache(targets:UnityEngine.Object[]) : void
}
class "PathComponentEditor`1"<T> {
}
class Contents <<static>> {
    + {static} <<readonly>> editSplineLabel : string = "Edit Spline"
}
class ShapeSegment <<struct>> {
    + start : int
    + end : int
    + angleRange : int
}
class ShapeAngleRange <<struct>> {
    + start : float
    + end : float
    + order : int
    + index : int
}
class "List`1"<T> {
}
"PathComponentEditor`1" "<CustomPath>" <|-- SpriteShapeControllerEditor
SpriteShapeControllerEditor o-> "m_ShowStretchOption" AnimBool
SpriteShapeControllerEditor o-> "m_ShowNonStretchOption" AnimBool
SpriteShapeControllerEditor o-> "m_ShapeSegments<ShapeSegment>" "List`1"
SpriteShapeControllerEditor o-> "spriteSelector" SpriteSelector
SpriteShapeControllerEditor +-- Contents
Contents o-> "splineLabel" GUIContent
Contents o-> "fillLabel" GUIContent
Contents o-> "colliderLabel" GUIContent
Contents o-> "fillPixelPerUnitLabel" GUIContent
Contents o-> "spriteShapeProfile" GUIContent
Contents o-> "materialLabel" GUIContent
Contents o-> "colorLabel" GUIContent
Contents o-> "metaDataLabel" GUIContent
Contents o-> "showComponentsLabel" GUIContent
Contents o-> "splineDetail" GUIContent
Contents o-> "openEndedLabel" GUIContent
Contents o-> "adaptiveUVLabel" GUIContent
Contents o-> "enableTangentsLabel" GUIContent
Contents o-> "worldUVLabel" GUIContent
Contents o-> "stretchUVLabel" GUIContent
Contents o-> "stretchTilingLabel" GUIContent
Contents o-> "colliderDetail" GUIContent
Contents o-> "cornerThresholdDetail" GUIContent
Contents o-> "colliderOffset" GUIContent
Contents o-> "updateColliderLabel" GUIContent
Contents o-> "optimizeColliderLabel" GUIContent
Contents o-> "optimizeGeometryLabel" GUIContent
Contents o-> "cacheGeometryLabel" GUIContent
SpriteShapeControllerEditor +-- ShapeSegment
SpriteShapeControllerEditor +-- ShapeAngleRange
class SpriteShapeEditor {
    + selectedIndex : int <<get>> <<set>>
    isSelectedIndexValid : bool <<get>>
    + previewAngle : float <<get>> <<set>>
    + RegisterUndo(name:string) : void
    + OnEnable() : void
    + <<override>> RequiresConstantRepaint() : bool
    + DrawHeader(content:GUIContent) : void
    + <<override>> OnInspectorGUI() : void
}
class Contents <<static>> {
}
class "List`1"<T> {
}
Editor <|-- SpriteShapeEditor
IAngleRangeCache <|-- SpriteShapeEditor
SpriteShapeEditor --> "angleRanges<AngleRange>" "List`1"
SpriteShapeEditor +-- Contents
Contents o-> "fillTextureLabel" GUIContent
Contents o-> "fillScaleLabel" GUIContent
Contents o-> "useSpriteBorderLabel" GUIContent
Contents o-> "cornerTypeLabel" GUIContent
Contents o-> "controlPointsLabel" GUIContent
Contents o-> "fillLabel" GUIContent
Contents o-> "cornerLabel" GUIContent
Contents o-> "cornerListLabel" GUIContent
Contents o-> "cornerSpriteTypeLabel" GUIContent
Contents o-> "angleRangesLabel" GUIContent
Contents o-> "spritesLabel" GUIContent
Contents o-> "angleRangeLabel" GUIContent
Contents o-> "wrapModeErrorLabel" GUIContent
Contents o-> "proBackgroundColor" Color
Contents o-> "proBackgroundRangeColor" Color
Contents o-> "proColor1" Color
Contents o-> "proColor2" Color
Contents o-> "defaultColor1" Color
Contents o-> "defaultColor2" Color
Contents o-> "defaultBackgroundColor" Color
class SpriteShapeEditorAnalytics {
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<SpriteShapeEditorAnalytics>" <|-- SpriteShapeEditorAnalytics
SpriteShapeEditorAnalytics o-> "m_Analytics" SpriteShapeAnalytics
SpriteShapeEditorAnalytics --> "eventBus" SpriteShapeAnalyticsEvents
class SpriteShapeEditorGUI {
    + {static} s_FoldoutHash : int
    + {static} MultiDelayedIntField(position:Rect, subLabels:GUIContent[], values:int[], labelWidth:float) : void
}
class CustomDrawer {
    + CustomDrawer(spriteShapeController:SpriteShapeController)
    DrawBezier(p1:Vector3, p2:Vector3, p3:Vector3, p4:Vector3, width:float, color:Color) : void
    DrawCreatePointPreview(position:Vector3) : void
    DrawLine(p1:Vector3, p2:Vector3, width:float, color:Color) : void
    DrawPoint(position:Vector3) : void
    DrawPointHovered(position:Vector3) : void
    DrawPointSelected(position:Vector3) : void
    DrawTangent(position:Vector3, tangent:Vector3) : void
}
class SpriteShapeData {
    + height : float = 1f
    + spriteIndex : int
    + corner : bool = true
}
class ScriptableSpriteShapeData {
}
class SpriteShapeDataInspector {
    + <<override>> OnInspectorGUI() : void
}
class CustomPath {
}
class CustomPathInspector {
}
class SpriteShapeEditorTool {
}
class "ScriptableData`1"<T> {
}
class Contents <<static>> {
}
class "GenericScriptablePath`1"<T> {
}
class "GenericScriptablePathInspector`2"<T1,T2> {
}
class "PathEditorTool`1"<T> {
}
IDrawer <|-- CustomDrawer
"ScriptableData`1" "<SpriteShapeData>" <|-- ScriptableSpriteShapeData
Editor <|-- SpriteShapeDataInspector
"GenericScriptablePath`1" "<SpriteShapeData>" <|-- CustomPath
"GenericScriptablePathInspector`2" "<ScriptableSpriteShapeData,SpriteShapeData>" <|-- CustomPathInspector
"PathEditorTool`1" "<CustomPath>" <|-- SpriteShapeEditorTool
SpriteShapeEditorTool --> "activeSpriteShapeEditorTool" SpriteShapeEditorTool
SpriteShapeDataInspector +-- Contents
Contents o-> "heightLabel" GUIContent
Contents o-> "spriteIndexLabel" GUIContent
Contents o-> "invalidSpriteLabel" GUIContent
Contents o-> "cornerLabel" GUIContent
class SpriteShapeEditorUtility {
    + <<const>> kMaxSideSize : float = 2.0f
    + {static} CreateSpriteShapeAsset() : UnityEngine.U2D.SpriteShape
    + {static} CreateSpriteShapeController(shape:UnityEngine.U2D.SpriteShape) : SpriteShapeController
    + {static} CreateSpriteShapeControllerFromSelection() : SpriteShapeController
    + {static} SetShapeFromAsset(spriteShapeController:SpriteShapeController) : void
    {static} SetToSquare(spriteShapeController:SpriteShapeController) : void
    {static} SetToLine(spriteShapeController:SpriteShapeController) : void
    {static} SetToOctogon(spriteShapeController:SpriteShapeController) : void
    + {static} GetRangeIndexFromAngle(spriteShape:UnityEngine.U2D.SpriteShape, angle:float) : int
    + {static} GetRangeIndexFromAngle(angleRanges:List<AngleRange>, angle:float) : int
}
class Contents <<static>> {
    + {static} <<readonly>> createSpriteShapeString : string = "Create Sprite Shape"
    + {static} <<readonly>> newSpriteShapeString : string = "SpriteShape"
}
SpriteShapeEditorUtility +-- Contents
class SpriteShapeHandleUtility {
    + {static} PosToAngle(position:Vector2, center:Vector2, angleOffset:float) : float
    + {static} Slider2D(id:int, position:Vector2, capOffset:Vector3, rotation:Quaternion, size:float, drawCapFunction:Handles.CapFunction) : Vector2
    + {static} DrawRangeOutline(start:float, end:float, angleOffset:float, center:Vector2, radius:float, width:float) : void
    {static} SetDiscSectionPoints(dest:Vector3[], center:Vector3, normal:Vector3, from:Vector3, angle:float, radius:float) : void
    + {static} DrawSolidArc(center:Vector3, normal:Vector3, from:Vector3, angle:float, radius:float, width:float) : void
    + {static} DrawTextureArc(texture:Texture, pixelsPerRadius:float, center:Vector3, normal:Vector3, from:Vector3, angle:float, radius:float) : void
    + {static} PlayHeadCap(controlID:int, position:Vector3, rotation:Quaternion, size:float, eventType:EventType) : void
    + {static} RangeLeftCap(controlID:int, position:Vector3, rotation:Quaternion, size:float, eventType:EventType) : void
    + {static} RangeRightCap(controlID:int, position:Vector3, rotation:Quaternion, size:float, eventType:EventType) : void
    + {static} GUITextureCap(controlID:int, texture:Texture, position:Vector3, rotation:Quaternion, size:float, eventType:EventType) : void
    + {static} DistanceToArcWidth(position:Vector2, center:Vector2, start:float, end:float, radius:float, width:float, angleOffet:float) : float
    + {static} DistanceToRectangle(position:Vector3, rotation:Quaternion, size:Vector2) : float
}
class Styles {
}
SpriteShapeHandleUtility +-- Styles
Styles --> "playheadTex" Texture
Styles --> "handRightTex" Texture
Styles --> "handLeftTex" Texture
class BezierUtility <<static>> {
    + {static} BezierPoint(startPosition:Vector3, startTangent:Vector3, endTangent:Vector3, endPosition:Vector3, t:float) : Vector3
    <<internal>> {static} GetSpritePixelWidth(sprite:Sprite) : float
    <<internal>> {static} BezierLength(shapePoints:NativeArray<ShapeControlPoint>, splineDetail:int) : float
    + {static} ClosestPointOnCurve(point:Vector3, startPosition:Vector3, endPosition:Vector3, startTangent:Vector3, endTangent:Vector3, t:float) : Vector3
    + {static} ClosestPointOnCurveFast(point:Vector3, startPosition:Vector3, endPosition:Vector3, startTangent:Vector3, endTangent:Vector3, t:float) : Vector3
    + {static} SplitBezier(t:float, startPosition:Vector3, endPosition:Vector3, startRightTangent:Vector3, endLeftTangent:Vector3, leftStartPosition:Vector3, leftEndPosition:Vector3, leftStartTangent:Vector3, leftEndTangent:Vector3, rightStartPosition:Vector3, rightEndPosition:Vector3, rightStartTangent:Vector3, rightEndTangent:Vector3) : void
}
class Spline {
    + isOpenEnded : bool <<get>> <<set>>
    + Clear() : void
    + GetPointCount() : int
    + InsertPointAt(index:int, point:Vector3) : void
    + RemovePointAt(index:int) : void
    + GetPosition(index:int) : Vector3
    + SetPosition(index:int, point:Vector3) : void
    + GetLeftTangent(index:int) : Vector3
    + SetLeftTangent(index:int, tangent:Vector3) : void
    + GetRightTangent(index:int) : Vector3
    + SetRightTangent(index:int, tangent:Vector3) : void
    + GetTangentMode(index:int) : ShapeTangentMode
    + SetTangentMode(index:int, mode:ShapeTangentMode) : void
    + GetHeight(index:int) : float
    + SetHeight(index:int, value:float) : void
    + GetSpriteIndex(index:int) : int
    + SetSpriteIndex(index:int, value:int) : void
    + GetCorner(index:int) : bool
    + SetCorner(index:int, value:bool) : void
    + <<override>> GetHashCode() : int
}
class SplineUtility {
    + {static} SlopeAngle(start:Vector2, end:Vector2) : float
    + {static} CalculateTangents(point:Vector3, prevPoint:Vector3, nextPoint:Vector3, forward:Vector3, scale:float, rightTangent:Vector3, leftTangent:Vector3) : void
    + {static} NextIndex(index:int, pointCount:int) : int
    + {static} PreviousIndex(index:int, pointCount:int) : int
}
class "SpriteShapeCopyUtility`1"<T> {
    <<internal>> {static} Copy(dst:NativeSlice<T>, src:T[], length:int) : void
    <<internal>> {static} Copy(dst:T[], src:NativeSlice<T>, length:int) : void
}
enum ShapeTangentMode {
    Linear= 0,
    Continuous= 1,
    Broken= 2,
}
enum CornerType {
    OuterTopLeft,
    OuterTopRight,
    OuterBottomLeft,
    OuterBottomRight,
    InnerTopLeft,
    InnerTopRight,
    InnerBottomLeft,
    InnerBottomRight,
}
enum QualityDetail {
    High= 16,
    Mid= 8,
    Low= 4,
}
class SplineControlPoint {
    + height : float = 1f
    + bevelCutoff : float
    + bevelSize : float
    + spriteIndex : int
    + corner : bool
    + <<override>> GetHashCode() : int
}
class AngleRange {
    + start : float <<get>> <<set>>
    + end : float <<get>> <<set>>
    + order : int <<get>> <<set>>
    m_Start : float
    m_End : float
    m_Order : int
    + Clone() : object
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class CornerSprite {
    + Clone() : object
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class SpriteShape {
    + fillOffset : float <<get>> <<set>>
    + useSpriteBorders : bool <<get>> <<set>>
    m_FillOffset : float
    m_UseSpriteBorders : bool = true
    ResetCornerList() : void
    OnValidate() : void
    Reset() : void
    <<internal>> {static} GetSpriteShapeHashCode(spriteShape:SpriteShape) : int
}
class "List`1"<T> {
}
SplineControlPoint --> "position" Vector3
SplineControlPoint --> "leftTangent" Vector3
SplineControlPoint --> "rightTangent" Vector3
SplineControlPoint --> "mode" ShapeTangentMode
ICloneable <|-- AngleRange
AngleRange --> "sprites<Sprite>" "List`1"
AngleRange o-> "m_Sprites<Sprite>" "List`1"
ICloneable <|-- CornerSprite
CornerSprite --> "cornerType" CornerType
CornerSprite --> "sprites<Sprite>" "List`1"
CornerSprite --> "m_CornerType" CornerType
CornerSprite --> "m_Sprites<Sprite>" "List`1"
ScriptableObject <|-- SpriteShape
SpriteShape --> "angleRanges<AngleRange>" "List`1"
SpriteShape --> "fillTexture" Texture2D
SpriteShape --> "cornerSprites<CornerSprite>" "List`1"
SpriteShape o-> "m_Angles<AngleRange>" "List`1"
SpriteShape --> "m_FillTexture" Texture2D
SpriteShape o-> "m_CornerSprites<CornerSprite>" "List`1"
class SpriteShapeController {
    <<const>> s_DistanceTolerance : float = 0.001f
    m_DynamicOcclusionLocal : bool
    m_DynamicOcclusionOverriden : bool
    m_ActiveSplineHash : int = 0
    m_ActiveSpriteShapeHash : int = 0
    m_FillPixelPerUnit : float = 100.0f
    m_StretchTiling : float = 1.0f
    m_SplineDetail : int
    m_AdaptiveUV : bool
    m_StretchUV : bool
    m_WorldSpaceUV : bool
    m_CornerAngleThreshold : float = 30.0f
    m_ColliderDetail : int
    m_ColliderOffset : float
    m_UpdateCollider : bool = true
    m_OptimizeCollider : bool = true
    m_OptimizeGeometry : bool = true
    m_EnableTangents : bool = false
    m_GeometryCached : bool = false
    <<internal>> geometryCached : bool <<get>>
    <<internal>> splineHashCode : int <<get>>
    + spriteShapeHashCode : int <<get>>
    + worldSpaceUVs : bool <<get>> <<set>>
    + fillPixelsPerUnit : float <<get>> <<set>>
    + enableTangents : bool <<get>> <<set>>
    + stretchTiling : float <<get>> <<set>>
    + splineDetail : int <<get>> <<set>>
    + colliderDetail : int <<get>> <<set>>
    + colliderOffset : float <<get>> <<set>>
    + cornerAngleThreshold : float <<get>> <<set>>
    + autoUpdateCollider : bool <<get>> <<set>>
    + optimizeCollider : bool <<get>>
    + optimizeGeometry : bool <<get>>
    + hasCollider : bool <<get>>
    DisposeInternal() : void
    OnApplicationQuit() : void
    OnEnable() : void
    OnDisable() : void
    OnDestroy() : void
    Reset() : void
    {static} SmartDestroy(o:UnityEngine.Object) : void
    + RefreshSpriteShape() : void
    ValidateSpline() : bool
    ValidateSpriteShapeTexture() : bool
    HasSpriteShapeChanged() : bool
    HasSpriteShapeDataChanged() : bool
    HasSplineDataChanged() : bool
    OnWillRenderObject() : void
    + BakeMesh() : JobHandle
    + UpdateSpriteShapeParameters() : bool
    UpdateSpriteData() : void
    GetShapeControlPoints() : NativeArray<ShapeControlPoint>
    GetSpriteShapeMetaData() : NativeArray<SpriteShapeMetaData>
    CalculateMaxArrayCount(shapePoints:NativeArray<ShapeControlPoint>) : int
    <<unsafe>> ScheduleBake() : JobHandle
    + BakeCollider() : void
    <<internal>> BakeMeshForced() : void
    GetTextureFromIndex(index:int) : Texture2D
    GetSpriteTexture(sprite:Sprite) : Texture2D
}
class "NativeArray`1"<T> {
}
MonoBehaviour <|-- SpriteShapeController
SpriteShapeController --> "m_ActiveSpriteShape" SpriteShape
SpriteShapeController --> "m_EdgeCollider2D" EdgeCollider2D
SpriteShapeController --> "m_PolygonCollider2D" PolygonCollider2D
SpriteShapeController --> "m_SpriteShapeRenderer" SpriteShapeRenderer
SpriteShapeController --> "m_SpriteShapeGeometryCache" SpriteShapeGeometryCache
SpriteShapeController --> "m_ColliderData<float2>" "NativeArray`1"
SpriteShapeController --> "m_TangentData<Vector4>" "NativeArray`1"
SpriteShapeController --> "m_ActiveShapeParameters" SpriteShapeParameters
SpriteShapeController o-> "m_Spline" Spline
SpriteShapeController --> "m_SpriteShape" SpriteShape
SpriteShapeController --> "spriteShapeParameters" SpriteShapeParameters
SpriteShapeController --> "spriteShapeGeometryCache" SpriteShapeGeometryCache
SpriteShapeController --> "spline" Spline
SpriteShapeController --> "spriteShape" SpriteShape
SpriteShapeController --> "edgeCollider" EdgeCollider2D
SpriteShapeController --> "polygonCollider" PolygonCollider2D
SpriteShapeController --> "spriteShapeRenderer" SpriteShapeRenderer
class SpriteShapeGenerator <<struct>> {
    m_IndexDataCount : int
    m_VertexDataCount : int
    m_ColliderDataCount : int
    m_ActiveIndexCount : int
    m_ActiveVertexCount : int
    kModeLinear : int
    kModeContinous : int
    kModeBroken : int
    kCornerTypeOuterTopLeft : int
    kCornerTypeOuterTopRight : int
    kCornerTypeOuterBottomLeft : int
    kCornerTypeOuterBottomRight : int
    kCornerTypeInnerTopLeft : int
    kCornerTypeInnerTopRight : int
    kCornerTypeInnerBottomLeft : int
    kCornerTypeInnerBottomRight : int
    kControlPointCount : int
    kEpsilon : float
    kEpsilonOrder : float
    kEpsilonRelaxed : float
    kExtendSegment : float
    kRenderQuality : float
    kOptimizeRender : float
    kColliderQuality : float
    kOptimizeCollider : float
    kLowestQualityTolerance : float
    kHighestQualityTolerance : float
    GetSpriteInfo(index:int) : JobSpriteInfo
    GetCornerSpriteInfo(index:int) : JobSpriteInfo
    GetAngleRange(index:int) : JobAngleRange
    GetControlPoint(index:int) : JobControlPoint
    GetContourPoint(index:int) : JobContourPoint
    GetSegmentInfo(index:int) : JobSegmentInfo
    GetContourIndex(index:int) : int
    GetEndContourIndexOfSegment(isi:JobSegmentInfo) : int
    {static} CopyToNativeArray(from:NativeArray<T>, length:int, to:NativeArray<T>) : void
    {static} SafeDispose(na:NativeArray<T>) : void
    {static} IsPointOnLine(epsilon:float, a:float2, b:float2, c:float2) : bool
    {static} IsPointOnLines(epsilon:float, p1:float2, p2:float2, p3:float2, p4:float2, r:float2) : bool
    {static} LineIntersection(epsilon:float, p1:float2, p2:float2, p3:float2, p4:float2, result:float2) : bool
    {static} AngleBetweenVector(a:float2, b:float2) : float
    {static} GenerateColumnsBi(a:float2, b:float2, whsize:float2, flip:bool, rt:float2, rb:float2, cph:float) : bool
    {static} GenerateColumnsTri(a:float2, b:float2, c:float2, whsize:float2, flip:bool, rt:float2, rb:float2, cph:float) : bool
    AppendCornerCoordinates(corners:NativeArray<float2>, cornerCount:int, a:float2, b:float2, c:float2, d:float2) : void
    <<unsafe>> PrepareInput(shapeParams:SpriteShapeParameters, maxArrayCount:int, shapePoints:NativeArray<ShapeControlPoint>, optimizeGeometry:bool, updateCollider:bool, optimizeCollider:bool, colliderPivot:float, colliderDetail:float) : void
    TransferSprites(spriteInfos:NativeArray<JobSpriteInfo>, sprites:Sprite[], maxCount:int) : void
    PrepareSprites(edgeSprites:Sprite[], cornerSprites:Sprite[]) : void
    PrepareAngleRanges(angleRanges:AngleRangeInfo[]) : void
    PrepareControlPoints(shapePoints:NativeArray<ShapeControlPoint>, metaData:NativeArray<SpriteShapeMetaData>) : void
    WithinRange(angleRange:JobAngleRange, inputAngle:float) : bool
    AngleWithinRange(t:float, a:float, b:float) : bool
    {static} BezierPoint(st:float2, sp:float2, ep:float2, et:float2, t:float) : float2
    {static} SlopeAngle(dirNormalized:float2) : float
    {static} SlopeAngle(start:float2, end:float2) : float
    ResolveAngle(angle:float, activeIndex:int, renderOrder:float, spriteIndex:int, firstSpriteIndex:int) : bool
    GetSpriteIndex(index:int, previousIndex:int, resolved:int) : int
    GenerateSegments() : void
    GenerateControlPoints() : bool
    SegmentDistance(isi:JobSegmentInfo) : float
    GenerateContour() : void
    TessellateContour() : void
    CalculateBoundingBox() : void
    CalculateTexCoords() : void
    CopyVertexData(outPos:NativeSlice<Vector3>, outUV0:NativeSlice<Vector2>, outTan:NativeSlice<Vector4>, outIndex:int, inVertices:NativeArray<JobShapeVertex>, inIndex:int, pivot:float, sOrder:float) : void
    CopySegmentRenderData(ispr:JobSpriteInfo, outPos:NativeSlice<Vector3>, outUV0:NativeSlice<Vector2>, outTan:NativeSlice<Vector4>, outCount:int, indexData:NativeArray<ushort>, indexCount:int, inVertices:NativeArray<JobShapeVertex>, inCount:int, sOrder:float) : int
    TessellateSegment(sprInfo:JobSpriteInfo, segment:JobSegmentInfo, whsize:float2, border:float4, pxlWidth:float, useClosure:bool, validHead:bool, validTail:bool, vertices:NativeArray<JobShapeVertex>, vertexCount:int, outputVertices:NativeArray<JobShapeVertex>, outputCount:int) : void
    SkipSegment(isi:JobSegmentInfo) : bool
    TessellateSegments() : void
    AttachCorner(cp:int, ct:int, ispr:JobSpriteInfo, newPoints:NativeArray<JobControlPoint>, activePoint:int) : bool
    CornerTextureCoordinate(cornerType:int, index:int) : float2
    CalculateCorner(index:int, angle:float, lt:float2, rt:float2) : int
    InsertCorner(index:int, cpSpriteIndices:NativeArray<int2>, newPoints:NativeArray<JobControlPoint>, activePoint:int) : bool
    TessellateCorners() : void
    AreCollinear(a:float2, b:float2, c:float2, t:float) : bool
    OptimizePoints(tolerance:float, pointSet:NativeArray<float2>, pointCount:int) : void
    AttachCornerToCollider(isi:JobSegmentInfo, pivot:float, colliderPoints:NativeArray<float2>, colliderPointCount:int) : void
    UpdateCollider(isi:JobSegmentInfo, ispr:JobSpriteInfo, vertices:NativeArray<JobShapeVertex>, count:int, colliderPoints:NativeArray<float2>, colliderPointCount:int) : float2
    TrimOverlaps() : void
    OptimizeCollider() : void
    + Prepare(controller:UnityEngine.U2D.SpriteShapeController, shapeParams:SpriteShapeParameters, maxArrayCount:int, shapePoints:NativeArray<ShapeControlPoint>, metaData:NativeArray<SpriteShapeMetaData>, angleRanges:AngleRangeInfo[], segmentSprites:Sprite[], cornerSprites:Sprite[]) : void
    + Execute() : void
    + Cleanup() : void
}
class JobParameters <<struct>> {
}
class JobSpriteInfo <<struct>> {
}
class JobAngleRange <<struct>> {
}
class JobControlPoint <<struct>> {
}
class JobContourPoint <<struct>> {
}
class JobSegmentInfo <<struct>> {
}
class JobCornerInfo <<struct>> {
}
class JobShapeVertex <<struct>> {
}
class "NativeArray`1"<T> {
}
class "NativeSlice`1"<T> {
}
IJob <|-- SpriteShapeGenerator
SpriteShapeGenerator --> "m_VertexData<JobShapeVertex>" "NativeArray`1"
SpriteShapeGenerator --> "m_OutputVertexData<JobShapeVertex>" "NativeArray`1"
SpriteShapeGenerator --> "m_IndexArray<ushort>" "NativeArray`1"
SpriteShapeGenerator --> "m_PosArray<Vector3>" "NativeSlice`1"
SpriteShapeGenerator --> "m_Uv0Array<Vector2>" "NativeSlice`1"
SpriteShapeGenerator --> "m_TanArray<Vector4>" "NativeSlice`1"
SpriteShapeGenerator --> "m_GeomArray<SpriteShapeSegment>" "NativeArray`1"
SpriteShapeGenerator --> "m_ColliderPoints<float2>" "NativeArray`1"
SpriteShapeGenerator --> "m_Bounds<Bounds>" "NativeArray`1"
SpriteShapeGenerator --> "m_FirstLT" float2
SpriteShapeGenerator --> "m_FirstLB" float2
SpriteShapeGenerator --> "m_Transform" float4x4
SpriteShapeGenerator +-- JobParameters
JobParameters --> "shapeData" int4
JobParameters --> "splineData" int4
JobParameters --> "curveData" float4
JobParameters --> "fillData" float4
SpriteShapeGenerator +-- JobSpriteInfo
JobSpriteInfo --> "texRect" float4
JobSpriteInfo --> "texData" float4
JobSpriteInfo --> "uvInfo" float4
JobSpriteInfo --> "metaInfo" float4
JobSpriteInfo --> "border" float4
SpriteShapeGenerator +-- JobAngleRange
JobAngleRange --> "spriteAngles" float4
JobAngleRange --> "spriteVariant1" int4
JobAngleRange --> "spriteVariant2" int4
JobAngleRange --> "spriteData" int4
SpriteShapeGenerator +-- JobControlPoint
JobControlPoint --> "cpData" int4
JobControlPoint --> "exData" int4
JobControlPoint --> "cpInfo" float4
JobControlPoint --> "position" float2
JobControlPoint --> "tangentLt" float2
JobControlPoint --> "tangentRt" float2
SpriteShapeGenerator +-- JobContourPoint
JobContourPoint --> "position" float2
JobContourPoint --> "ptData" float2
SpriteShapeGenerator +-- JobSegmentInfo
JobSegmentInfo --> "spInfo" int4
JobSegmentInfo --> "spriteInfo" float4
SpriteShapeGenerator +-- JobCornerInfo
JobCornerInfo --> "bottom" float2
JobCornerInfo --> "top" float2
JobCornerInfo --> "left" float2
JobCornerInfo --> "right" float2
JobCornerInfo --> "cornerData" int2
SpriteShapeGenerator +-- JobShapeVertex
JobShapeVertex --> "pos" float2
JobShapeVertex --> "uv" float2
JobShapeVertex --> "tan" float4
JobShapeVertex --> "meta" float2
JobShapeVertex --> "sprite" int2
class SpriteShapeGeometryInfo <<struct>> {
    <<internal>> geomIndex : int
    <<internal>> indexCount : int
    <<internal>> vertexCount : int
    <<internal>> spriteIndex : int
}
class SpriteShapeGeometryCache {
    m_MaxArrayCount : int
    m_RequiresUpdate : bool = false
    m_RequiresUpload : bool = false
    <<internal>> maxArrayCount : int <<get>>
    OnEnable() : void
    <<internal>> SetGeometryCache(_maxArrayCount:int, _posArray:NativeSlice<Vector3>, _uv0Array:NativeSlice<Vector2>, _tanArray:NativeSlice<Vector4>, _indexArray:NativeArray<ushort>, _geomArray:NativeArray<UnityEngine.U2D.SpriteShapeSegment>) : void
    <<internal>> UpdateGeometryCache() : void
    <<internal>> Upload(sr:SpriteShapeRenderer, sc:SpriteShapeController) : JobHandle
}
class "NativeSlice`1"<T> {
}
class "NativeArray`1"<T> {
}
MonoBehaviour <|-- SpriteShapeGeometryCache
SpriteShapeGeometryCache --> "m_PosArrayCache<Vector3>" "NativeSlice`1"
SpriteShapeGeometryCache --> "m_Uv0ArrayCache<Vector2>" "NativeSlice`1"
SpriteShapeGeometryCache --> "m_TanArrayCache<Vector4>" "NativeSlice`1"
SpriteShapeGeometryCache --> "m_IndexArrayCache<ushort>" "NativeArray`1"
SpriteShapeGeometryCache --> "m_GeomArrayCache<UnityEngine.U2D.SpriteShapeSegment>" "NativeArray`1"
class SpriteShapePlaceholder {
    + PlaceHolderTest() : void
}
interface IDiscovery {
    PathCallback() : CodeEditor.Installation[]
}
class VSCodeDiscovery {
    + PathCallback() : CodeEditor.Installation[]
    FindInstallationPaths() : void
    {static} GetLongestCommonPrefix(paths:List<string>) : string
    {static} VSCodeExists(path:string) : bool
}
class "List`1"<T> {
}
IDiscovery <|-- VSCodeDiscovery
VSCodeDiscovery --> "m_Installations<CodeEditor.Installation>" "List`1"
class VSCodeScriptEditor {
    <<const>> vscode_argument : string = "vscode_arguments"
    <<const>> vscode_extension : string = "vscode_userExtensions"
    m_Arguments : string
    {static} IsOSX : bool <<get>>
    {static} DefaultApp : string <<get>>
    {static} DefaultArgument : string <<get>> = "\"$(ProjectPath)\" -g \"$(File)\":$(Line):$(Column)"
    Arguments : string <<get>> <<set>>
    {static} HandledExtensionsString : string <<get>> <<set>>
    + TryGetInstallationForPath(editorPath:string, installation:CodeEditor.Installation) : bool
    + OnGUI() : void
    RegenerateProjectFiles() : void
    SettingsButton(preference:ProjectGenerationFlag, guiMessage:string, toolTip:string) : void
    + CreateIfDoesntExist() : void
    + SyncIfNeeded(addedFiles:string[], deletedFiles:string[], movedFiles:string[], movedFromFiles:string[], importedFiles:string[]) : void
    + SyncAll() : void
    + OpenProject(path:string, line:int, column:int) : bool
    {static} OpenOSX(arguments:string) : bool
    {static} SupportsExtension(path:string) : bool
    + VSCodeScriptEditor(discovery:IDiscovery, projectGeneration:IGenerator)
    {static} VSCodeScriptEditor()
    {static} IsVSCodeInstallation(path:string) : bool
    + Initialize(editorInstallationPath:string) : void
}
IExternalCodeEditor <|-- VSCodeScriptEditor
VSCodeScriptEditor o-> "k_ResetArguments" GUIContent
VSCodeScriptEditor --> "m_Discoverability" IDiscovery
VSCodeScriptEditor --> "m_ProjectGeneration" IGenerator
class WindowsOnlyAttribute {
    + WindowsOnlyAttribute(reason:string)
}
class TestCompilerAttribute <<sealed>> {
}
Attribute <|-- WindowsOnlyAttribute
TestCaseAttribute <|-- TestCompilerAttribute
ITestBuilder <|-- TestCompilerAttribute
class bool2 <<struct>> {
    + x : bool
    + y : bool
    + bool2(x:bool, y:bool)
    + bool2(xy:bool2)
    + bool2(v:bool)
    + Equals(rhs:bool2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool2(x:bool, y:bool) : bool2
    + {static} bool2(xy:bool2) : bool2
    + {static} bool2(v:bool) : bool2
    + {static} hash(v:bool2) : uint
    + {static} hashwide(v:bool2) : uint2
    + {static} shuffle(a:bool2, b:bool2, x:ShuffleComponent) : bool
    + {static} shuffle(a:bool2, b:bool2, x:ShuffleComponent, y:ShuffleComponent) : bool2
    + {static} shuffle(a:bool2, b:bool2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : bool3
    + {static} shuffle(a:bool2, b:bool2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : bool4
    <<internal>> {static} select_shuffle_component(a:bool2, b:bool2, component:ShuffleComponent) : bool
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : bool
    + y : bool
    + DebuggerProxy(v:bool2)
}
bool2 --> "xxxx" bool4
bool2 --> "xxxy" bool4
bool2 --> "xxyx" bool4
bool2 --> "xxyy" bool4
bool2 --> "xyxx" bool4
bool2 --> "xyxy" bool4
bool2 --> "xyyx" bool4
bool2 --> "xyyy" bool4
bool2 --> "yxxx" bool4
bool2 --> "yxxy" bool4
bool2 --> "yxyx" bool4
bool2 --> "yxyy" bool4
bool2 --> "yyxx" bool4
bool2 --> "yyxy" bool4
bool2 --> "yyyx" bool4
bool2 --> "yyyy" bool4
bool2 --> "xxx" bool3
bool2 --> "xxy" bool3
bool2 --> "xyx" bool3
bool2 --> "xyy" bool3
bool2 --> "yxx" bool3
bool2 --> "yxy" bool3
bool2 --> "yyx" bool3
bool2 --> "yyy" bool3
bool2 --> "xx" bool2
bool2 --> "xy" bool2
bool2 --> "yx" bool2
bool2 --> "yy" bool2
bool2 +-- DebuggerProxy
class bool2x2 <<struct>> {
    + bool2x2(c0:bool2, c1:bool2)
    + bool2x2(m00:bool, m01:bool, m10:bool, m11:bool)
    + bool2x2(v:bool)
    + Equals(rhs:bool2x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool2x2(c0:bool2, c1:bool2) : bool2x2
    + {static} bool2x2(m00:bool, m01:bool, m10:bool, m11:bool) : bool2x2
    + {static} bool2x2(v:bool) : bool2x2
    + {static} transpose(v:bool2x2) : bool2x2
    + {static} hash(v:bool2x2) : uint
    + {static} hashwide(v:bool2x2) : uint2
}
class "IEquatable`1"<T> {
}
bool2x2 --> "c0" bool2
bool2x2 --> "c1" bool2
class bool2x3 <<struct>> {
    + bool2x3(c0:bool2, c1:bool2, c2:bool2)
    + bool2x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool)
    + bool2x3(v:bool)
    + Equals(rhs:bool2x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool2x3(c0:bool2, c1:bool2, c2:bool2) : bool2x3
    + {static} bool2x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool) : bool2x3
    + {static} bool2x3(v:bool) : bool2x3
    + {static} transpose(v:bool2x3) : bool3x2
    + {static} hash(v:bool2x3) : uint
    + {static} hashwide(v:bool2x3) : uint2
}
class "IEquatable`1"<T> {
}
bool2x3 --> "c0" bool2
bool2x3 --> "c1" bool2
bool2x3 --> "c2" bool2
class bool2x4 <<struct>> {
    + bool2x4(c0:bool2, c1:bool2, c2:bool2, c3:bool2)
    + bool2x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool)
    + bool2x4(v:bool)
    + Equals(rhs:bool2x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool2x4(c0:bool2, c1:bool2, c2:bool2, c3:bool2) : bool2x4
    + {static} bool2x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool) : bool2x4
    + {static} bool2x4(v:bool) : bool2x4
    + {static} transpose(v:bool2x4) : bool4x2
    + {static} hash(v:bool2x4) : uint
    + {static} hashwide(v:bool2x4) : uint2
}
class "IEquatable`1"<T> {
}
bool2x4 --> "c0" bool2
bool2x4 --> "c1" bool2
bool2x4 --> "c2" bool2
bool2x4 --> "c3" bool2
class bool3 <<struct>> {
    + x : bool
    + y : bool
    + z : bool
    + bool3(x:bool, y:bool, z:bool)
    + bool3(x:bool, yz:bool2)
    + bool3(xy:bool2, z:bool)
    + bool3(xyz:bool3)
    + bool3(v:bool)
    + Equals(rhs:bool3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool3(x:bool, y:bool, z:bool) : bool3
    + {static} bool3(x:bool, yz:bool2) : bool3
    + {static} bool3(xy:bool2, z:bool) : bool3
    + {static} bool3(xyz:bool3) : bool3
    + {static} bool3(v:bool) : bool3
    + {static} hash(v:bool3) : uint
    + {static} hashwide(v:bool3) : uint3
    + {static} shuffle(a:bool3, b:bool3, x:ShuffleComponent) : bool
    + {static} shuffle(a:bool3, b:bool3, x:ShuffleComponent, y:ShuffleComponent) : bool2
    + {static} shuffle(a:bool3, b:bool3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : bool3
    + {static} shuffle(a:bool3, b:bool3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : bool4
    <<internal>> {static} select_shuffle_component(a:bool3, b:bool3, component:ShuffleComponent) : bool
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : bool
    + y : bool
    + z : bool
    + DebuggerProxy(v:bool3)
}
bool3 --> "xxxx" bool4
bool3 --> "xxxy" bool4
bool3 --> "xxxz" bool4
bool3 --> "xxyx" bool4
bool3 --> "xxyy" bool4
bool3 --> "xxyz" bool4
bool3 --> "xxzx" bool4
bool3 --> "xxzy" bool4
bool3 --> "xxzz" bool4
bool3 --> "xyxx" bool4
bool3 --> "xyxy" bool4
bool3 --> "xyxz" bool4
bool3 --> "xyyx" bool4
bool3 --> "xyyy" bool4
bool3 --> "xyyz" bool4
bool3 --> "xyzx" bool4
bool3 --> "xyzy" bool4
bool3 --> "xyzz" bool4
bool3 --> "xzxx" bool4
bool3 --> "xzxy" bool4
bool3 --> "xzxz" bool4
bool3 --> "xzyx" bool4
bool3 --> "xzyy" bool4
bool3 --> "xzyz" bool4
bool3 --> "xzzx" bool4
bool3 --> "xzzy" bool4
bool3 --> "xzzz" bool4
bool3 --> "yxxx" bool4
bool3 --> "yxxy" bool4
bool3 --> "yxxz" bool4
bool3 --> "yxyx" bool4
bool3 --> "yxyy" bool4
bool3 --> "yxyz" bool4
bool3 --> "yxzx" bool4
bool3 --> "yxzy" bool4
bool3 --> "yxzz" bool4
bool3 --> "yyxx" bool4
bool3 --> "yyxy" bool4
bool3 --> "yyxz" bool4
bool3 --> "yyyx" bool4
bool3 --> "yyyy" bool4
bool3 --> "yyyz" bool4
bool3 --> "yyzx" bool4
bool3 --> "yyzy" bool4
bool3 --> "yyzz" bool4
bool3 --> "yzxx" bool4
bool3 --> "yzxy" bool4
bool3 --> "yzxz" bool4
bool3 --> "yzyx" bool4
bool3 --> "yzyy" bool4
bool3 --> "yzyz" bool4
bool3 --> "yzzx" bool4
bool3 --> "yzzy" bool4
bool3 --> "yzzz" bool4
bool3 --> "zxxx" bool4
bool3 --> "zxxy" bool4
bool3 --> "zxxz" bool4
bool3 --> "zxyx" bool4
bool3 --> "zxyy" bool4
bool3 --> "zxyz" bool4
bool3 --> "zxzx" bool4
bool3 --> "zxzy" bool4
bool3 --> "zxzz" bool4
bool3 --> "zyxx" bool4
bool3 --> "zyxy" bool4
bool3 --> "zyxz" bool4
bool3 --> "zyyx" bool4
bool3 --> "zyyy" bool4
bool3 --> "zyyz" bool4
bool3 --> "zyzx" bool4
bool3 --> "zyzy" bool4
bool3 --> "zyzz" bool4
bool3 --> "zzxx" bool4
bool3 --> "zzxy" bool4
bool3 --> "zzxz" bool4
bool3 --> "zzyx" bool4
bool3 --> "zzyy" bool4
bool3 --> "zzyz" bool4
bool3 --> "zzzx" bool4
bool3 --> "zzzy" bool4
bool3 --> "zzzz" bool4
bool3 --> "xxx" bool3
bool3 --> "xxy" bool3
bool3 --> "xxz" bool3
bool3 --> "xyx" bool3
bool3 --> "xyy" bool3
bool3 --> "xyz" bool3
bool3 --> "xzx" bool3
bool3 --> "xzy" bool3
bool3 --> "xzz" bool3
bool3 --> "yxx" bool3
bool3 --> "yxy" bool3
bool3 --> "yxz" bool3
bool3 --> "yyx" bool3
bool3 --> "yyy" bool3
bool3 --> "yyz" bool3
bool3 --> "yzx" bool3
bool3 --> "yzy" bool3
bool3 --> "yzz" bool3
bool3 --> "zxx" bool3
bool3 --> "zxy" bool3
bool3 --> "zxz" bool3
bool3 --> "zyx" bool3
bool3 --> "zyy" bool3
bool3 --> "zyz" bool3
bool3 --> "zzx" bool3
bool3 --> "zzy" bool3
bool3 --> "zzz" bool3
bool3 --> "xx" bool2
bool3 --> "xy" bool2
bool3 --> "xz" bool2
bool3 --> "yx" bool2
bool3 --> "yy" bool2
bool3 --> "yz" bool2
bool3 --> "zx" bool2
bool3 --> "zy" bool2
bool3 --> "zz" bool2
bool3 +-- DebuggerProxy
class bool3x2 <<struct>> {
    + bool3x2(c0:bool3, c1:bool3)
    + bool3x2(m00:bool, m01:bool, m10:bool, m11:bool, m20:bool, m21:bool)
    + bool3x2(v:bool)
    + Equals(rhs:bool3x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool3x2(c0:bool3, c1:bool3) : bool3x2
    + {static} bool3x2(m00:bool, m01:bool, m10:bool, m11:bool, m20:bool, m21:bool) : bool3x2
    + {static} bool3x2(v:bool) : bool3x2
    + {static} transpose(v:bool3x2) : bool2x3
    + {static} hash(v:bool3x2) : uint
    + {static} hashwide(v:bool3x2) : uint3
}
class "IEquatable`1"<T> {
}
bool3x2 --> "c0" bool3
bool3x2 --> "c1" bool3
class bool3x3 <<struct>> {
    + bool3x3(c0:bool3, c1:bool3, c2:bool3)
    + bool3x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool, m20:bool, m21:bool, m22:bool)
    + bool3x3(v:bool)
    + Equals(rhs:bool3x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool3x3(c0:bool3, c1:bool3, c2:bool3) : bool3x3
    + {static} bool3x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool, m20:bool, m21:bool, m22:bool) : bool3x3
    + {static} bool3x3(v:bool) : bool3x3
    + {static} transpose(v:bool3x3) : bool3x3
    + {static} hash(v:bool3x3) : uint
    + {static} hashwide(v:bool3x3) : uint3
}
class "IEquatable`1"<T> {
}
bool3x3 --> "c0" bool3
bool3x3 --> "c1" bool3
bool3x3 --> "c2" bool3
class bool3x4 <<struct>> {
    + bool3x4(c0:bool3, c1:bool3, c2:bool3, c3:bool3)
    + bool3x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool, m20:bool, m21:bool, m22:bool, m23:bool)
    + bool3x4(v:bool)
    + Equals(rhs:bool3x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool3x4(c0:bool3, c1:bool3, c2:bool3, c3:bool3) : bool3x4
    + {static} bool3x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool, m20:bool, m21:bool, m22:bool, m23:bool) : bool3x4
    + {static} bool3x4(v:bool) : bool3x4
    + {static} transpose(v:bool3x4) : bool4x3
    + {static} hash(v:bool3x4) : uint
    + {static} hashwide(v:bool3x4) : uint3
}
class "IEquatable`1"<T> {
}
bool3x4 --> "c0" bool3
bool3x4 --> "c1" bool3
bool3x4 --> "c2" bool3
bool3x4 --> "c3" bool3
class bool4 <<struct>> {
    + x : bool
    + y : bool
    + z : bool
    + w : bool
    + bool4(x:bool, y:bool, z:bool, w:bool)
    + bool4(x:bool, y:bool, zw:bool2)
    + bool4(x:bool, yz:bool2, w:bool)
    + bool4(x:bool, yzw:bool3)
    + bool4(xy:bool2, z:bool, w:bool)
    + bool4(xy:bool2, zw:bool2)
    + bool4(xyz:bool3, w:bool)
    + bool4(xyzw:bool4)
    + bool4(v:bool)
    + Equals(rhs:bool4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool4(x:bool, y:bool, z:bool, w:bool) : bool4
    + {static} bool4(x:bool, y:bool, zw:bool2) : bool4
    + {static} bool4(x:bool, yz:bool2, w:bool) : bool4
    + {static} bool4(x:bool, yzw:bool3) : bool4
    + {static} bool4(xy:bool2, z:bool, w:bool) : bool4
    + {static} bool4(xy:bool2, zw:bool2) : bool4
    + {static} bool4(xyz:bool3, w:bool) : bool4
    + {static} bool4(xyzw:bool4) : bool4
    + {static} bool4(v:bool) : bool4
    + {static} hash(v:bool4) : uint
    + {static} hashwide(v:bool4) : uint4
    + {static} shuffle(a:bool4, b:bool4, x:ShuffleComponent) : bool
    + {static} shuffle(a:bool4, b:bool4, x:ShuffleComponent, y:ShuffleComponent) : bool2
    + {static} shuffle(a:bool4, b:bool4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : bool3
    + {static} shuffle(a:bool4, b:bool4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : bool4
    <<internal>> {static} select_shuffle_component(a:bool4, b:bool4, component:ShuffleComponent) : bool
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : bool
    + y : bool
    + z : bool
    + w : bool
    + DebuggerProxy(v:bool4)
}
bool4 --> "xxxx" bool4
bool4 --> "xxxy" bool4
bool4 --> "xxxz" bool4
bool4 --> "xxxw" bool4
bool4 --> "xxyx" bool4
bool4 --> "xxyy" bool4
bool4 --> "xxyz" bool4
bool4 --> "xxyw" bool4
bool4 --> "xxzx" bool4
bool4 --> "xxzy" bool4
bool4 --> "xxzz" bool4
bool4 --> "xxzw" bool4
bool4 --> "xxwx" bool4
bool4 --> "xxwy" bool4
bool4 --> "xxwz" bool4
bool4 --> "xxww" bool4
bool4 --> "xyxx" bool4
bool4 --> "xyxy" bool4
bool4 --> "xyxz" bool4
bool4 --> "xyxw" bool4
bool4 --> "xyyx" bool4
bool4 --> "xyyy" bool4
bool4 --> "xyyz" bool4
bool4 --> "xyyw" bool4
bool4 --> "xyzx" bool4
bool4 --> "xyzy" bool4
bool4 --> "xyzz" bool4
bool4 --> "xyzw" bool4
bool4 --> "xywx" bool4
bool4 --> "xywy" bool4
bool4 --> "xywz" bool4
bool4 --> "xyww" bool4
bool4 --> "xzxx" bool4
bool4 --> "xzxy" bool4
bool4 --> "xzxz" bool4
bool4 --> "xzxw" bool4
bool4 --> "xzyx" bool4
bool4 --> "xzyy" bool4
bool4 --> "xzyz" bool4
bool4 --> "xzyw" bool4
bool4 --> "xzzx" bool4
bool4 --> "xzzy" bool4
bool4 --> "xzzz" bool4
bool4 --> "xzzw" bool4
bool4 --> "xzwx" bool4
bool4 --> "xzwy" bool4
bool4 --> "xzwz" bool4
bool4 --> "xzww" bool4
bool4 --> "xwxx" bool4
bool4 --> "xwxy" bool4
bool4 --> "xwxz" bool4
bool4 --> "xwxw" bool4
bool4 --> "xwyx" bool4
bool4 --> "xwyy" bool4
bool4 --> "xwyz" bool4
bool4 --> "xwyw" bool4
bool4 --> "xwzx" bool4
bool4 --> "xwzy" bool4
bool4 --> "xwzz" bool4
bool4 --> "xwzw" bool4
bool4 --> "xwwx" bool4
bool4 --> "xwwy" bool4
bool4 --> "xwwz" bool4
bool4 --> "xwww" bool4
bool4 --> "yxxx" bool4
bool4 --> "yxxy" bool4
bool4 --> "yxxz" bool4
bool4 --> "yxxw" bool4
bool4 --> "yxyx" bool4
bool4 --> "yxyy" bool4
bool4 --> "yxyz" bool4
bool4 --> "yxyw" bool4
bool4 --> "yxzx" bool4
bool4 --> "yxzy" bool4
bool4 --> "yxzz" bool4
bool4 --> "yxzw" bool4
bool4 --> "yxwx" bool4
bool4 --> "yxwy" bool4
bool4 --> "yxwz" bool4
bool4 --> "yxww" bool4
bool4 --> "yyxx" bool4
bool4 --> "yyxy" bool4
bool4 --> "yyxz" bool4
bool4 --> "yyxw" bool4
bool4 --> "yyyx" bool4
bool4 --> "yyyy" bool4
bool4 --> "yyyz" bool4
bool4 --> "yyyw" bool4
bool4 --> "yyzx" bool4
bool4 --> "yyzy" bool4
bool4 --> "yyzz" bool4
bool4 --> "yyzw" bool4
bool4 --> "yywx" bool4
bool4 --> "yywy" bool4
bool4 --> "yywz" bool4
bool4 --> "yyww" bool4
bool4 --> "yzxx" bool4
bool4 --> "yzxy" bool4
bool4 --> "yzxz" bool4
bool4 --> "yzxw" bool4
bool4 --> "yzyx" bool4
bool4 --> "yzyy" bool4
bool4 --> "yzyz" bool4
bool4 --> "yzyw" bool4
bool4 --> "yzzx" bool4
bool4 --> "yzzy" bool4
bool4 --> "yzzz" bool4
bool4 --> "yzzw" bool4
bool4 --> "yzwx" bool4
bool4 --> "yzwy" bool4
bool4 --> "yzwz" bool4
bool4 --> "yzww" bool4
bool4 --> "ywxx" bool4
bool4 --> "ywxy" bool4
bool4 --> "ywxz" bool4
bool4 --> "ywxw" bool4
bool4 --> "ywyx" bool4
bool4 --> "ywyy" bool4
bool4 --> "ywyz" bool4
bool4 --> "ywyw" bool4
bool4 --> "ywzx" bool4
bool4 --> "ywzy" bool4
bool4 --> "ywzz" bool4
bool4 --> "ywzw" bool4
bool4 --> "ywwx" bool4
bool4 --> "ywwy" bool4
bool4 --> "ywwz" bool4
bool4 --> "ywww" bool4
bool4 --> "zxxx" bool4
bool4 --> "zxxy" bool4
bool4 --> "zxxz" bool4
bool4 --> "zxxw" bool4
bool4 --> "zxyx" bool4
bool4 --> "zxyy" bool4
bool4 --> "zxyz" bool4
bool4 --> "zxyw" bool4
bool4 --> "zxzx" bool4
bool4 --> "zxzy" bool4
bool4 --> "zxzz" bool4
bool4 --> "zxzw" bool4
bool4 --> "zxwx" bool4
bool4 --> "zxwy" bool4
bool4 --> "zxwz" bool4
bool4 --> "zxww" bool4
bool4 --> "zyxx" bool4
bool4 --> "zyxy" bool4
bool4 --> "zyxz" bool4
bool4 --> "zyxw" bool4
bool4 --> "zyyx" bool4
bool4 --> "zyyy" bool4
bool4 --> "zyyz" bool4
bool4 --> "zyyw" bool4
bool4 --> "zyzx" bool4
bool4 --> "zyzy" bool4
bool4 --> "zyzz" bool4
bool4 --> "zyzw" bool4
bool4 --> "zywx" bool4
bool4 --> "zywy" bool4
bool4 --> "zywz" bool4
bool4 --> "zyww" bool4
bool4 --> "zzxx" bool4
bool4 --> "zzxy" bool4
bool4 --> "zzxz" bool4
bool4 --> "zzxw" bool4
bool4 --> "zzyx" bool4
bool4 --> "zzyy" bool4
bool4 --> "zzyz" bool4
bool4 --> "zzyw" bool4
bool4 --> "zzzx" bool4
bool4 --> "zzzy" bool4
bool4 --> "zzzz" bool4
bool4 --> "zzzw" bool4
bool4 --> "zzwx" bool4
bool4 --> "zzwy" bool4
bool4 --> "zzwz" bool4
bool4 --> "zzww" bool4
bool4 --> "zwxx" bool4
bool4 --> "zwxy" bool4
bool4 --> "zwxz" bool4
bool4 --> "zwxw" bool4
bool4 --> "zwyx" bool4
bool4 --> "zwyy" bool4
bool4 --> "zwyz" bool4
bool4 --> "zwyw" bool4
bool4 --> "zwzx" bool4
bool4 --> "zwzy" bool4
bool4 --> "zwzz" bool4
bool4 --> "zwzw" bool4
bool4 --> "zwwx" bool4
bool4 --> "zwwy" bool4
bool4 --> "zwwz" bool4
bool4 --> "zwww" bool4
bool4 --> "wxxx" bool4
bool4 --> "wxxy" bool4
bool4 --> "wxxz" bool4
bool4 --> "wxxw" bool4
bool4 --> "wxyx" bool4
bool4 --> "wxyy" bool4
bool4 --> "wxyz" bool4
bool4 --> "wxyw" bool4
bool4 --> "wxzx" bool4
bool4 --> "wxzy" bool4
bool4 --> "wxzz" bool4
bool4 --> "wxzw" bool4
bool4 --> "wxwx" bool4
bool4 --> "wxwy" bool4
bool4 --> "wxwz" bool4
bool4 --> "wxww" bool4
bool4 --> "wyxx" bool4
bool4 --> "wyxy" bool4
bool4 --> "wyxz" bool4
bool4 --> "wyxw" bool4
bool4 --> "wyyx" bool4
bool4 --> "wyyy" bool4
bool4 --> "wyyz" bool4
bool4 --> "wyyw" bool4
bool4 --> "wyzx" bool4
bool4 --> "wyzy" bool4
bool4 --> "wyzz" bool4
bool4 --> "wyzw" bool4
bool4 --> "wywx" bool4
bool4 --> "wywy" bool4
bool4 --> "wywz" bool4
bool4 --> "wyww" bool4
bool4 --> "wzxx" bool4
bool4 --> "wzxy" bool4
bool4 --> "wzxz" bool4
bool4 --> "wzxw" bool4
bool4 --> "wzyx" bool4
bool4 --> "wzyy" bool4
bool4 --> "wzyz" bool4
bool4 --> "wzyw" bool4
bool4 --> "wzzx" bool4
bool4 --> "wzzy" bool4
bool4 --> "wzzz" bool4
bool4 --> "wzzw" bool4
bool4 --> "wzwx" bool4
bool4 --> "wzwy" bool4
bool4 --> "wzwz" bool4
bool4 --> "wzww" bool4
bool4 --> "wwxx" bool4
bool4 --> "wwxy" bool4
bool4 --> "wwxz" bool4
bool4 --> "wwxw" bool4
bool4 --> "wwyx" bool4
bool4 --> "wwyy" bool4
bool4 --> "wwyz" bool4
bool4 --> "wwyw" bool4
bool4 --> "wwzx" bool4
bool4 --> "wwzy" bool4
bool4 --> "wwzz" bool4
bool4 --> "wwzw" bool4
bool4 --> "wwwx" bool4
bool4 --> "wwwy" bool4
bool4 --> "wwwz" bool4
bool4 --> "wwww" bool4
bool4 --> "xxx" bool3
bool4 --> "xxy" bool3
bool4 --> "xxz" bool3
bool4 --> "xxw" bool3
bool4 --> "xyx" bool3
bool4 --> "xyy" bool3
bool4 --> "xyz" bool3
bool4 --> "xyw" bool3
bool4 --> "xzx" bool3
bool4 --> "xzy" bool3
bool4 --> "xzz" bool3
bool4 --> "xzw" bool3
bool4 --> "xwx" bool3
bool4 --> "xwy" bool3
bool4 --> "xwz" bool3
bool4 --> "xww" bool3
bool4 --> "yxx" bool3
bool4 --> "yxy" bool3
bool4 --> "yxz" bool3
bool4 --> "yxw" bool3
bool4 --> "yyx" bool3
bool4 --> "yyy" bool3
bool4 --> "yyz" bool3
bool4 --> "yyw" bool3
bool4 --> "yzx" bool3
bool4 --> "yzy" bool3
bool4 --> "yzz" bool3
bool4 --> "yzw" bool3
bool4 --> "ywx" bool3
bool4 --> "ywy" bool3
bool4 --> "ywz" bool3
bool4 --> "yww" bool3
bool4 --> "zxx" bool3
bool4 --> "zxy" bool3
bool4 --> "zxz" bool3
bool4 --> "zxw" bool3
bool4 --> "zyx" bool3
bool4 --> "zyy" bool3
bool4 --> "zyz" bool3
bool4 --> "zyw" bool3
bool4 --> "zzx" bool3
bool4 --> "zzy" bool3
bool4 --> "zzz" bool3
bool4 --> "zzw" bool3
bool4 --> "zwx" bool3
bool4 --> "zwy" bool3
bool4 --> "zwz" bool3
bool4 --> "zww" bool3
bool4 --> "wxx" bool3
bool4 --> "wxy" bool3
bool4 --> "wxz" bool3
bool4 --> "wxw" bool3
bool4 --> "wyx" bool3
bool4 --> "wyy" bool3
bool4 --> "wyz" bool3
bool4 --> "wyw" bool3
bool4 --> "wzx" bool3
bool4 --> "wzy" bool3
bool4 --> "wzz" bool3
bool4 --> "wzw" bool3
bool4 --> "wwx" bool3
bool4 --> "wwy" bool3
bool4 --> "wwz" bool3
bool4 --> "www" bool3
bool4 --> "xx" bool2
bool4 --> "xy" bool2
bool4 --> "xz" bool2
bool4 --> "xw" bool2
bool4 --> "yx" bool2
bool4 --> "yy" bool2
bool4 --> "yz" bool2
bool4 --> "yw" bool2
bool4 --> "zx" bool2
bool4 --> "zy" bool2
bool4 --> "zz" bool2
bool4 --> "zw" bool2
bool4 --> "wx" bool2
bool4 --> "wy" bool2
bool4 --> "wz" bool2
bool4 --> "ww" bool2
bool4 +-- DebuggerProxy
class bool4x2 <<struct>> {
    + bool4x2(c0:bool4, c1:bool4)
    + bool4x2(m00:bool, m01:bool, m10:bool, m11:bool, m20:bool, m21:bool, m30:bool, m31:bool)
    + bool4x2(v:bool)
    + Equals(rhs:bool4x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool4x2(c0:bool4, c1:bool4) : bool4x2
    + {static} bool4x2(m00:bool, m01:bool, m10:bool, m11:bool, m20:bool, m21:bool, m30:bool, m31:bool) : bool4x2
    + {static} bool4x2(v:bool) : bool4x2
    + {static} transpose(v:bool4x2) : bool2x4
    + {static} hash(v:bool4x2) : uint
    + {static} hashwide(v:bool4x2) : uint4
}
class "IEquatable`1"<T> {
}
bool4x2 --> "c0" bool4
bool4x2 --> "c1" bool4
class bool4x3 <<struct>> {
    + bool4x3(c0:bool4, c1:bool4, c2:bool4)
    + bool4x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool, m20:bool, m21:bool, m22:bool, m30:bool, m31:bool, m32:bool)
    + bool4x3(v:bool)
    + Equals(rhs:bool4x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool4x3(c0:bool4, c1:bool4, c2:bool4) : bool4x3
    + {static} bool4x3(m00:bool, m01:bool, m02:bool, m10:bool, m11:bool, m12:bool, m20:bool, m21:bool, m22:bool, m30:bool, m31:bool, m32:bool) : bool4x3
    + {static} bool4x3(v:bool) : bool4x3
    + {static} transpose(v:bool4x3) : bool3x4
    + {static} hash(v:bool4x3) : uint
    + {static} hashwide(v:bool4x3) : uint4
}
class "IEquatable`1"<T> {
}
bool4x3 --> "c0" bool4
bool4x3 --> "c1" bool4
bool4x3 --> "c2" bool4
class bool4x4 <<struct>> {
    + bool4x4(c0:bool4, c1:bool4, c2:bool4, c3:bool4)
    + bool4x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool, m20:bool, m21:bool, m22:bool, m23:bool, m30:bool, m31:bool, m32:bool, m33:bool)
    + bool4x4(v:bool)
    + Equals(rhs:bool4x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
class math <<static>> <<partial>> {
    + {static} bool4x4(c0:bool4, c1:bool4, c2:bool4, c3:bool4) : bool4x4
    + {static} bool4x4(m00:bool, m01:bool, m02:bool, m03:bool, m10:bool, m11:bool, m12:bool, m13:bool, m20:bool, m21:bool, m22:bool, m23:bool, m30:bool, m31:bool, m32:bool, m33:bool) : bool4x4
    + {static} bool4x4(v:bool) : bool4x4
    + {static} transpose(v:bool4x4) : bool4x4
    + {static} hash(v:bool4x4) : uint
    + {static} hashwide(v:bool4x4) : uint4
}
class "IEquatable`1"<T> {
}
bool4x4 --> "c0" bool4
bool4x4 --> "c1" bool4
bool4x4 --> "c2" bool4
bool4x4 --> "c3" bool4
class double2 <<struct>> {
    + x : double
    + y : double
    + double2(x:double, y:double)
    + double2(xy:double2)
    + double2(v:double)
    + double2(v:bool)
    + double2(v:bool2)
    + double2(v:int)
    + double2(v:int2)
    + double2(v:uint)
    + double2(v:uint2)
    + double2(v:half)
    + double2(v:half2)
    + double2(v:float)
    + double2(v:float2)
    + Equals(rhs:double2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double2(x:double, y:double) : double2
    + {static} double2(xy:double2) : double2
    + {static} double2(v:double) : double2
    + {static} double2(v:bool) : double2
    + {static} double2(v:bool2) : double2
    + {static} double2(v:int) : double2
    + {static} double2(v:int2) : double2
    + {static} double2(v:uint) : double2
    + {static} double2(v:uint2) : double2
    + {static} double2(v:half) : double2
    + {static} double2(v:half2) : double2
    + {static} double2(v:float) : double2
    + {static} double2(v:float2) : double2
    + {static} hash(v:double2) : uint
    + {static} hashwide(v:double2) : uint2
    + {static} shuffle(a:double2, b:double2, x:ShuffleComponent) : double
    + {static} shuffle(a:double2, b:double2, x:ShuffleComponent, y:ShuffleComponent) : double2
    + {static} shuffle(a:double2, b:double2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : double3
    + {static} shuffle(a:double2, b:double2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : double4
    <<internal>> {static} select_shuffle_component(a:double2, b:double2, component:ShuffleComponent) : double
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : double
    + y : double
    + DebuggerProxy(v:double2)
}
IFormattable <|-- double2
double2 --> "zero" double2
double2 --> "xxxx" double4
double2 --> "xxxy" double4
double2 --> "xxyx" double4
double2 --> "xxyy" double4
double2 --> "xyxx" double4
double2 --> "xyxy" double4
double2 --> "xyyx" double4
double2 --> "xyyy" double4
double2 --> "yxxx" double4
double2 --> "yxxy" double4
double2 --> "yxyx" double4
double2 --> "yxyy" double4
double2 --> "yyxx" double4
double2 --> "yyxy" double4
double2 --> "yyyx" double4
double2 --> "yyyy" double4
double2 --> "xxx" double3
double2 --> "xxy" double3
double2 --> "xyx" double3
double2 --> "xyy" double3
double2 --> "yxx" double3
double2 --> "yxy" double3
double2 --> "yyx" double3
double2 --> "yyy" double3
double2 --> "xx" double2
double2 --> "xy" double2
double2 --> "yx" double2
double2 --> "yy" double2
double2 +-- DebuggerProxy
class double2x2 <<struct>> {
    + double2x2(c0:double2, c1:double2)
    + double2x2(m00:double, m01:double, m10:double, m11:double)
    + double2x2(v:double)
    + double2x2(v:bool)
    + double2x2(v:bool2x2)
    + double2x2(v:int)
    + double2x2(v:int2x2)
    + double2x2(v:uint)
    + double2x2(v:uint2x2)
    + double2x2(v:float)
    + double2x2(v:float2x2)
    + Equals(rhs:double2x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double2x2(c0:double2, c1:double2) : double2x2
    + {static} double2x2(m00:double, m01:double, m10:double, m11:double) : double2x2
    + {static} double2x2(v:double) : double2x2
    + {static} double2x2(v:bool) : double2x2
    + {static} double2x2(v:bool2x2) : double2x2
    + {static} double2x2(v:int) : double2x2
    + {static} double2x2(v:int2x2) : double2x2
    + {static} double2x2(v:uint) : double2x2
    + {static} double2x2(v:uint2x2) : double2x2
    + {static} double2x2(v:float) : double2x2
    + {static} double2x2(v:float2x2) : double2x2
    + {static} transpose(v:double2x2) : double2x2
    + {static} inverse(m:double2x2) : double2x2
    + {static} determinant(m:double2x2) : double
    + {static} hash(v:double2x2) : uint
    + {static} hashwide(v:double2x2) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double2x2
double2x2 --> "c0" double2
double2x2 --> "c1" double2
double2x2 o-> "identity" double2x2
double2x2 --> "zero" double2x2
class double2x3 <<struct>> {
    + double2x3(c0:double2, c1:double2, c2:double2)
    + double2x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double)
    + double2x3(v:double)
    + double2x3(v:bool)
    + double2x3(v:bool2x3)
    + double2x3(v:int)
    + double2x3(v:int2x3)
    + double2x3(v:uint)
    + double2x3(v:uint2x3)
    + double2x3(v:float)
    + double2x3(v:float2x3)
    + Equals(rhs:double2x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double2x3(c0:double2, c1:double2, c2:double2) : double2x3
    + {static} double2x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double) : double2x3
    + {static} double2x3(v:double) : double2x3
    + {static} double2x3(v:bool) : double2x3
    + {static} double2x3(v:bool2x3) : double2x3
    + {static} double2x3(v:int) : double2x3
    + {static} double2x3(v:int2x3) : double2x3
    + {static} double2x3(v:uint) : double2x3
    + {static} double2x3(v:uint2x3) : double2x3
    + {static} double2x3(v:float) : double2x3
    + {static} double2x3(v:float2x3) : double2x3
    + {static} transpose(v:double2x3) : double3x2
    + {static} hash(v:double2x3) : uint
    + {static} hashwide(v:double2x3) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double2x3
double2x3 --> "c0" double2
double2x3 --> "c1" double2
double2x3 --> "c2" double2
double2x3 --> "zero" double2x3
class double2x4 <<struct>> {
    + double2x4(c0:double2, c1:double2, c2:double2, c3:double2)
    + double2x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double)
    + double2x4(v:double)
    + double2x4(v:bool)
    + double2x4(v:bool2x4)
    + double2x4(v:int)
    + double2x4(v:int2x4)
    + double2x4(v:uint)
    + double2x4(v:uint2x4)
    + double2x4(v:float)
    + double2x4(v:float2x4)
    + Equals(rhs:double2x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double2x4(c0:double2, c1:double2, c2:double2, c3:double2) : double2x4
    + {static} double2x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double) : double2x4
    + {static} double2x4(v:double) : double2x4
    + {static} double2x4(v:bool) : double2x4
    + {static} double2x4(v:bool2x4) : double2x4
    + {static} double2x4(v:int) : double2x4
    + {static} double2x4(v:int2x4) : double2x4
    + {static} double2x4(v:uint) : double2x4
    + {static} double2x4(v:uint2x4) : double2x4
    + {static} double2x4(v:float) : double2x4
    + {static} double2x4(v:float2x4) : double2x4
    + {static} transpose(v:double2x4) : double4x2
    + {static} hash(v:double2x4) : uint
    + {static} hashwide(v:double2x4) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double2x4
double2x4 --> "c0" double2
double2x4 --> "c1" double2
double2x4 --> "c2" double2
double2x4 --> "c3" double2
double2x4 --> "zero" double2x4
class double3 <<struct>> {
    + x : double
    + y : double
    + z : double
    + double3(x:double, y:double, z:double)
    + double3(x:double, yz:double2)
    + double3(xy:double2, z:double)
    + double3(xyz:double3)
    + double3(v:double)
    + double3(v:bool)
    + double3(v:bool3)
    + double3(v:int)
    + double3(v:int3)
    + double3(v:uint)
    + double3(v:uint3)
    + double3(v:half)
    + double3(v:half3)
    + double3(v:float)
    + double3(v:float3)
    + Equals(rhs:double3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double3(x:double, y:double, z:double) : double3
    + {static} double3(x:double, yz:double2) : double3
    + {static} double3(xy:double2, z:double) : double3
    + {static} double3(xyz:double3) : double3
    + {static} double3(v:double) : double3
    + {static} double3(v:bool) : double3
    + {static} double3(v:bool3) : double3
    + {static} double3(v:int) : double3
    + {static} double3(v:int3) : double3
    + {static} double3(v:uint) : double3
    + {static} double3(v:uint3) : double3
    + {static} double3(v:half) : double3
    + {static} double3(v:half3) : double3
    + {static} double3(v:float) : double3
    + {static} double3(v:float3) : double3
    + {static} hash(v:double3) : uint
    + {static} hashwide(v:double3) : uint3
    + {static} shuffle(a:double3, b:double3, x:ShuffleComponent) : double
    + {static} shuffle(a:double3, b:double3, x:ShuffleComponent, y:ShuffleComponent) : double2
    + {static} shuffle(a:double3, b:double3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : double3
    + {static} shuffle(a:double3, b:double3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : double4
    <<internal>> {static} select_shuffle_component(a:double3, b:double3, component:ShuffleComponent) : double
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : double
    + y : double
    + z : double
    + DebuggerProxy(v:double3)
}
IFormattable <|-- double3
double3 --> "zero" double3
double3 --> "xxxx" double4
double3 --> "xxxy" double4
double3 --> "xxxz" double4
double3 --> "xxyx" double4
double3 --> "xxyy" double4
double3 --> "xxyz" double4
double3 --> "xxzx" double4
double3 --> "xxzy" double4
double3 --> "xxzz" double4
double3 --> "xyxx" double4
double3 --> "xyxy" double4
double3 --> "xyxz" double4
double3 --> "xyyx" double4
double3 --> "xyyy" double4
double3 --> "xyyz" double4
double3 --> "xyzx" double4
double3 --> "xyzy" double4
double3 --> "xyzz" double4
double3 --> "xzxx" double4
double3 --> "xzxy" double4
double3 --> "xzxz" double4
double3 --> "xzyx" double4
double3 --> "xzyy" double4
double3 --> "xzyz" double4
double3 --> "xzzx" double4
double3 --> "xzzy" double4
double3 --> "xzzz" double4
double3 --> "yxxx" double4
double3 --> "yxxy" double4
double3 --> "yxxz" double4
double3 --> "yxyx" double4
double3 --> "yxyy" double4
double3 --> "yxyz" double4
double3 --> "yxzx" double4
double3 --> "yxzy" double4
double3 --> "yxzz" double4
double3 --> "yyxx" double4
double3 --> "yyxy" double4
double3 --> "yyxz" double4
double3 --> "yyyx" double4
double3 --> "yyyy" double4
double3 --> "yyyz" double4
double3 --> "yyzx" double4
double3 --> "yyzy" double4
double3 --> "yyzz" double4
double3 --> "yzxx" double4
double3 --> "yzxy" double4
double3 --> "yzxz" double4
double3 --> "yzyx" double4
double3 --> "yzyy" double4
double3 --> "yzyz" double4
double3 --> "yzzx" double4
double3 --> "yzzy" double4
double3 --> "yzzz" double4
double3 --> "zxxx" double4
double3 --> "zxxy" double4
double3 --> "zxxz" double4
double3 --> "zxyx" double4
double3 --> "zxyy" double4
double3 --> "zxyz" double4
double3 --> "zxzx" double4
double3 --> "zxzy" double4
double3 --> "zxzz" double4
double3 --> "zyxx" double4
double3 --> "zyxy" double4
double3 --> "zyxz" double4
double3 --> "zyyx" double4
double3 --> "zyyy" double4
double3 --> "zyyz" double4
double3 --> "zyzx" double4
double3 --> "zyzy" double4
double3 --> "zyzz" double4
double3 --> "zzxx" double4
double3 --> "zzxy" double4
double3 --> "zzxz" double4
double3 --> "zzyx" double4
double3 --> "zzyy" double4
double3 --> "zzyz" double4
double3 --> "zzzx" double4
double3 --> "zzzy" double4
double3 --> "zzzz" double4
double3 --> "xxx" double3
double3 --> "xxy" double3
double3 --> "xxz" double3
double3 --> "xyx" double3
double3 --> "xyy" double3
double3 --> "xyz" double3
double3 --> "xzx" double3
double3 --> "xzy" double3
double3 --> "xzz" double3
double3 --> "yxx" double3
double3 --> "yxy" double3
double3 --> "yxz" double3
double3 --> "yyx" double3
double3 --> "yyy" double3
double3 --> "yyz" double3
double3 --> "yzx" double3
double3 --> "yzy" double3
double3 --> "yzz" double3
double3 --> "zxx" double3
double3 --> "zxy" double3
double3 --> "zxz" double3
double3 --> "zyx" double3
double3 --> "zyy" double3
double3 --> "zyz" double3
double3 --> "zzx" double3
double3 --> "zzy" double3
double3 --> "zzz" double3
double3 --> "xx" double2
double3 --> "xy" double2
double3 --> "xz" double2
double3 --> "yx" double2
double3 --> "yy" double2
double3 --> "yz" double2
double3 --> "zx" double2
double3 --> "zy" double2
double3 --> "zz" double2
double3 +-- DebuggerProxy
class double3x2 <<struct>> {
    + double3x2(c0:double3, c1:double3)
    + double3x2(m00:double, m01:double, m10:double, m11:double, m20:double, m21:double)
    + double3x2(v:double)
    + double3x2(v:bool)
    + double3x2(v:bool3x2)
    + double3x2(v:int)
    + double3x2(v:int3x2)
    + double3x2(v:uint)
    + double3x2(v:uint3x2)
    + double3x2(v:float)
    + double3x2(v:float3x2)
    + Equals(rhs:double3x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double3x2(c0:double3, c1:double3) : double3x2
    + {static} double3x2(m00:double, m01:double, m10:double, m11:double, m20:double, m21:double) : double3x2
    + {static} double3x2(v:double) : double3x2
    + {static} double3x2(v:bool) : double3x2
    + {static} double3x2(v:bool3x2) : double3x2
    + {static} double3x2(v:int) : double3x2
    + {static} double3x2(v:int3x2) : double3x2
    + {static} double3x2(v:uint) : double3x2
    + {static} double3x2(v:uint3x2) : double3x2
    + {static} double3x2(v:float) : double3x2
    + {static} double3x2(v:float3x2) : double3x2
    + {static} transpose(v:double3x2) : double2x3
    + {static} hash(v:double3x2) : uint
    + {static} hashwide(v:double3x2) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double3x2
double3x2 --> "c0" double3
double3x2 --> "c1" double3
double3x2 --> "zero" double3x2
class double3x3 <<struct>> {
    + double3x3(c0:double3, c1:double3, c2:double3)
    + double3x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double, m20:double, m21:double, m22:double)
    + double3x3(v:double)
    + double3x3(v:bool)
    + double3x3(v:bool3x3)
    + double3x3(v:int)
    + double3x3(v:int3x3)
    + double3x3(v:uint)
    + double3x3(v:uint3x3)
    + double3x3(v:float)
    + double3x3(v:float3x3)
    + Equals(rhs:double3x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double3x3(c0:double3, c1:double3, c2:double3) : double3x3
    + {static} double3x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double, m20:double, m21:double, m22:double) : double3x3
    + {static} double3x3(v:double) : double3x3
    + {static} double3x3(v:bool) : double3x3
    + {static} double3x3(v:bool3x3) : double3x3
    + {static} double3x3(v:int) : double3x3
    + {static} double3x3(v:int3x3) : double3x3
    + {static} double3x3(v:uint) : double3x3
    + {static} double3x3(v:uint3x3) : double3x3
    + {static} double3x3(v:float) : double3x3
    + {static} double3x3(v:float3x3) : double3x3
    + {static} transpose(v:double3x3) : double3x3
    + {static} inverse(m:double3x3) : double3x3
    + {static} determinant(m:double3x3) : double
    + {static} hash(v:double3x3) : uint
    + {static} hashwide(v:double3x3) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double3x3
double3x3 --> "c0" double3
double3x3 --> "c1" double3
double3x3 --> "c2" double3
double3x3 o-> "identity" double3x3
double3x3 --> "zero" double3x3
class double3x4 <<struct>> {
    + double3x4(c0:double3, c1:double3, c2:double3, c3:double3)
    + double3x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double, m20:double, m21:double, m22:double, m23:double)
    + double3x4(v:double)
    + double3x4(v:bool)
    + double3x4(v:bool3x4)
    + double3x4(v:int)
    + double3x4(v:int3x4)
    + double3x4(v:uint)
    + double3x4(v:uint3x4)
    + double3x4(v:float)
    + double3x4(v:float3x4)
    + Equals(rhs:double3x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double3x4(c0:double3, c1:double3, c2:double3, c3:double3) : double3x4
    + {static} double3x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double, m20:double, m21:double, m22:double, m23:double) : double3x4
    + {static} double3x4(v:double) : double3x4
    + {static} double3x4(v:bool) : double3x4
    + {static} double3x4(v:bool3x4) : double3x4
    + {static} double3x4(v:int) : double3x4
    + {static} double3x4(v:int3x4) : double3x4
    + {static} double3x4(v:uint) : double3x4
    + {static} double3x4(v:uint3x4) : double3x4
    + {static} double3x4(v:float) : double3x4
    + {static} double3x4(v:float3x4) : double3x4
    + {static} transpose(v:double3x4) : double4x3
    + {static} fastinverse(m:double3x4) : double3x4
    + {static} hash(v:double3x4) : uint
    + {static} hashwide(v:double3x4) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double3x4
double3x4 --> "c0" double3
double3x4 --> "c1" double3
double3x4 --> "c2" double3
double3x4 --> "c3" double3
double3x4 --> "zero" double3x4
class double4 <<struct>> {
    + x : double
    + y : double
    + z : double
    + w : double
    + double4(x:double, y:double, z:double, w:double)
    + double4(x:double, y:double, zw:double2)
    + double4(x:double, yz:double2, w:double)
    + double4(x:double, yzw:double3)
    + double4(xy:double2, z:double, w:double)
    + double4(xy:double2, zw:double2)
    + double4(xyz:double3, w:double)
    + double4(xyzw:double4)
    + double4(v:double)
    + double4(v:bool)
    + double4(v:bool4)
    + double4(v:int)
    + double4(v:int4)
    + double4(v:uint)
    + double4(v:uint4)
    + double4(v:half)
    + double4(v:half4)
    + double4(v:float)
    + double4(v:float4)
    + Equals(rhs:double4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double4(x:double, y:double, z:double, w:double) : double4
    + {static} double4(x:double, y:double, zw:double2) : double4
    + {static} double4(x:double, yz:double2, w:double) : double4
    + {static} double4(x:double, yzw:double3) : double4
    + {static} double4(xy:double2, z:double, w:double) : double4
    + {static} double4(xy:double2, zw:double2) : double4
    + {static} double4(xyz:double3, w:double) : double4
    + {static} double4(xyzw:double4) : double4
    + {static} double4(v:double) : double4
    + {static} double4(v:bool) : double4
    + {static} double4(v:bool4) : double4
    + {static} double4(v:int) : double4
    + {static} double4(v:int4) : double4
    + {static} double4(v:uint) : double4
    + {static} double4(v:uint4) : double4
    + {static} double4(v:half) : double4
    + {static} double4(v:half4) : double4
    + {static} double4(v:float) : double4
    + {static} double4(v:float4) : double4
    + {static} hash(v:double4) : uint
    + {static} hashwide(v:double4) : uint4
    + {static} shuffle(a:double4, b:double4, x:ShuffleComponent) : double
    + {static} shuffle(a:double4, b:double4, x:ShuffleComponent, y:ShuffleComponent) : double2
    + {static} shuffle(a:double4, b:double4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : double3
    + {static} shuffle(a:double4, b:double4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : double4
    <<internal>> {static} select_shuffle_component(a:double4, b:double4, component:ShuffleComponent) : double
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : double
    + y : double
    + z : double
    + w : double
    + DebuggerProxy(v:double4)
}
IFormattable <|-- double4
double4 --> "zero" double4
double4 --> "xxxx" double4
double4 --> "xxxy" double4
double4 --> "xxxz" double4
double4 --> "xxxw" double4
double4 --> "xxyx" double4
double4 --> "xxyy" double4
double4 --> "xxyz" double4
double4 --> "xxyw" double4
double4 --> "xxzx" double4
double4 --> "xxzy" double4
double4 --> "xxzz" double4
double4 --> "xxzw" double4
double4 --> "xxwx" double4
double4 --> "xxwy" double4
double4 --> "xxwz" double4
double4 --> "xxww" double4
double4 --> "xyxx" double4
double4 --> "xyxy" double4
double4 --> "xyxz" double4
double4 --> "xyxw" double4
double4 --> "xyyx" double4
double4 --> "xyyy" double4
double4 --> "xyyz" double4
double4 --> "xyyw" double4
double4 --> "xyzx" double4
double4 --> "xyzy" double4
double4 --> "xyzz" double4
double4 --> "xyzw" double4
double4 --> "xywx" double4
double4 --> "xywy" double4
double4 --> "xywz" double4
double4 --> "xyww" double4
double4 --> "xzxx" double4
double4 --> "xzxy" double4
double4 --> "xzxz" double4
double4 --> "xzxw" double4
double4 --> "xzyx" double4
double4 --> "xzyy" double4
double4 --> "xzyz" double4
double4 --> "xzyw" double4
double4 --> "xzzx" double4
double4 --> "xzzy" double4
double4 --> "xzzz" double4
double4 --> "xzzw" double4
double4 --> "xzwx" double4
double4 --> "xzwy" double4
double4 --> "xzwz" double4
double4 --> "xzww" double4
double4 --> "xwxx" double4
double4 --> "xwxy" double4
double4 --> "xwxz" double4
double4 --> "xwxw" double4
double4 --> "xwyx" double4
double4 --> "xwyy" double4
double4 --> "xwyz" double4
double4 --> "xwyw" double4
double4 --> "xwzx" double4
double4 --> "xwzy" double4
double4 --> "xwzz" double4
double4 --> "xwzw" double4
double4 --> "xwwx" double4
double4 --> "xwwy" double4
double4 --> "xwwz" double4
double4 --> "xwww" double4
double4 --> "yxxx" double4
double4 --> "yxxy" double4
double4 --> "yxxz" double4
double4 --> "yxxw" double4
double4 --> "yxyx" double4
double4 --> "yxyy" double4
double4 --> "yxyz" double4
double4 --> "yxyw" double4
double4 --> "yxzx" double4
double4 --> "yxzy" double4
double4 --> "yxzz" double4
double4 --> "yxzw" double4
double4 --> "yxwx" double4
double4 --> "yxwy" double4
double4 --> "yxwz" double4
double4 --> "yxww" double4
double4 --> "yyxx" double4
double4 --> "yyxy" double4
double4 --> "yyxz" double4
double4 --> "yyxw" double4
double4 --> "yyyx" double4
double4 --> "yyyy" double4
double4 --> "yyyz" double4
double4 --> "yyyw" double4
double4 --> "yyzx" double4
double4 --> "yyzy" double4
double4 --> "yyzz" double4
double4 --> "yyzw" double4
double4 --> "yywx" double4
double4 --> "yywy" double4
double4 --> "yywz" double4
double4 --> "yyww" double4
double4 --> "yzxx" double4
double4 --> "yzxy" double4
double4 --> "yzxz" double4
double4 --> "yzxw" double4
double4 --> "yzyx" double4
double4 --> "yzyy" double4
double4 --> "yzyz" double4
double4 --> "yzyw" double4
double4 --> "yzzx" double4
double4 --> "yzzy" double4
double4 --> "yzzz" double4
double4 --> "yzzw" double4
double4 --> "yzwx" double4
double4 --> "yzwy" double4
double4 --> "yzwz" double4
double4 --> "yzww" double4
double4 --> "ywxx" double4
double4 --> "ywxy" double4
double4 --> "ywxz" double4
double4 --> "ywxw" double4
double4 --> "ywyx" double4
double4 --> "ywyy" double4
double4 --> "ywyz" double4
double4 --> "ywyw" double4
double4 --> "ywzx" double4
double4 --> "ywzy" double4
double4 --> "ywzz" double4
double4 --> "ywzw" double4
double4 --> "ywwx" double4
double4 --> "ywwy" double4
double4 --> "ywwz" double4
double4 --> "ywww" double4
double4 --> "zxxx" double4
double4 --> "zxxy" double4
double4 --> "zxxz" double4
double4 --> "zxxw" double4
double4 --> "zxyx" double4
double4 --> "zxyy" double4
double4 --> "zxyz" double4
double4 --> "zxyw" double4
double4 --> "zxzx" double4
double4 --> "zxzy" double4
double4 --> "zxzz" double4
double4 --> "zxzw" double4
double4 --> "zxwx" double4
double4 --> "zxwy" double4
double4 --> "zxwz" double4
double4 --> "zxww" double4
double4 --> "zyxx" double4
double4 --> "zyxy" double4
double4 --> "zyxz" double4
double4 --> "zyxw" double4
double4 --> "zyyx" double4
double4 --> "zyyy" double4
double4 --> "zyyz" double4
double4 --> "zyyw" double4
double4 --> "zyzx" double4
double4 --> "zyzy" double4
double4 --> "zyzz" double4
double4 --> "zyzw" double4
double4 --> "zywx" double4
double4 --> "zywy" double4
double4 --> "zywz" double4
double4 --> "zyww" double4
double4 --> "zzxx" double4
double4 --> "zzxy" double4
double4 --> "zzxz" double4
double4 --> "zzxw" double4
double4 --> "zzyx" double4
double4 --> "zzyy" double4
double4 --> "zzyz" double4
double4 --> "zzyw" double4
double4 --> "zzzx" double4
double4 --> "zzzy" double4
double4 --> "zzzz" double4
double4 --> "zzzw" double4
double4 --> "zzwx" double4
double4 --> "zzwy" double4
double4 --> "zzwz" double4
double4 --> "zzww" double4
double4 --> "zwxx" double4
double4 --> "zwxy" double4
double4 --> "zwxz" double4
double4 --> "zwxw" double4
double4 --> "zwyx" double4
double4 --> "zwyy" double4
double4 --> "zwyz" double4
double4 --> "zwyw" double4
double4 --> "zwzx" double4
double4 --> "zwzy" double4
double4 --> "zwzz" double4
double4 --> "zwzw" double4
double4 --> "zwwx" double4
double4 --> "zwwy" double4
double4 --> "zwwz" double4
double4 --> "zwww" double4
double4 --> "wxxx" double4
double4 --> "wxxy" double4
double4 --> "wxxz" double4
double4 --> "wxxw" double4
double4 --> "wxyx" double4
double4 --> "wxyy" double4
double4 --> "wxyz" double4
double4 --> "wxyw" double4
double4 --> "wxzx" double4
double4 --> "wxzy" double4
double4 --> "wxzz" double4
double4 --> "wxzw" double4
double4 --> "wxwx" double4
double4 --> "wxwy" double4
double4 --> "wxwz" double4
double4 --> "wxww" double4
double4 --> "wyxx" double4
double4 --> "wyxy" double4
double4 --> "wyxz" double4
double4 --> "wyxw" double4
double4 --> "wyyx" double4
double4 --> "wyyy" double4
double4 --> "wyyz" double4
double4 --> "wyyw" double4
double4 --> "wyzx" double4
double4 --> "wyzy" double4
double4 --> "wyzz" double4
double4 --> "wyzw" double4
double4 --> "wywx" double4
double4 --> "wywy" double4
double4 --> "wywz" double4
double4 --> "wyww" double4
double4 --> "wzxx" double4
double4 --> "wzxy" double4
double4 --> "wzxz" double4
double4 --> "wzxw" double4
double4 --> "wzyx" double4
double4 --> "wzyy" double4
double4 --> "wzyz" double4
double4 --> "wzyw" double4
double4 --> "wzzx" double4
double4 --> "wzzy" double4
double4 --> "wzzz" double4
double4 --> "wzzw" double4
double4 --> "wzwx" double4
double4 --> "wzwy" double4
double4 --> "wzwz" double4
double4 --> "wzww" double4
double4 --> "wwxx" double4
double4 --> "wwxy" double4
double4 --> "wwxz" double4
double4 --> "wwxw" double4
double4 --> "wwyx" double4
double4 --> "wwyy" double4
double4 --> "wwyz" double4
double4 --> "wwyw" double4
double4 --> "wwzx" double4
double4 --> "wwzy" double4
double4 --> "wwzz" double4
double4 --> "wwzw" double4
double4 --> "wwwx" double4
double4 --> "wwwy" double4
double4 --> "wwwz" double4
double4 --> "wwww" double4
double4 --> "xxx" double3
double4 --> "xxy" double3
double4 --> "xxz" double3
double4 --> "xxw" double3
double4 --> "xyx" double3
double4 --> "xyy" double3
double4 --> "xyz" double3
double4 --> "xyw" double3
double4 --> "xzx" double3
double4 --> "xzy" double3
double4 --> "xzz" double3
double4 --> "xzw" double3
double4 --> "xwx" double3
double4 --> "xwy" double3
double4 --> "xwz" double3
double4 --> "xww" double3
double4 --> "yxx" double3
double4 --> "yxy" double3
double4 --> "yxz" double3
double4 --> "yxw" double3
double4 --> "yyx" double3
double4 --> "yyy" double3
double4 --> "yyz" double3
double4 --> "yyw" double3
double4 --> "yzx" double3
double4 --> "yzy" double3
double4 --> "yzz" double3
double4 --> "yzw" double3
double4 --> "ywx" double3
double4 --> "ywy" double3
double4 --> "ywz" double3
double4 --> "yww" double3
double4 --> "zxx" double3
double4 --> "zxy" double3
double4 --> "zxz" double3
double4 --> "zxw" double3
double4 --> "zyx" double3
double4 --> "zyy" double3
double4 --> "zyz" double3
double4 --> "zyw" double3
double4 --> "zzx" double3
double4 --> "zzy" double3
double4 --> "zzz" double3
double4 --> "zzw" double3
double4 --> "zwx" double3
double4 --> "zwy" double3
double4 --> "zwz" double3
double4 --> "zww" double3
double4 --> "wxx" double3
double4 --> "wxy" double3
double4 --> "wxz" double3
double4 --> "wxw" double3
double4 --> "wyx" double3
double4 --> "wyy" double3
double4 --> "wyz" double3
double4 --> "wyw" double3
double4 --> "wzx" double3
double4 --> "wzy" double3
double4 --> "wzz" double3
double4 --> "wzw" double3
double4 --> "wwx" double3
double4 --> "wwy" double3
double4 --> "wwz" double3
double4 --> "www" double3
double4 --> "xx" double2
double4 --> "xy" double2
double4 --> "xz" double2
double4 --> "xw" double2
double4 --> "yx" double2
double4 --> "yy" double2
double4 --> "yz" double2
double4 --> "yw" double2
double4 --> "zx" double2
double4 --> "zy" double2
double4 --> "zz" double2
double4 --> "zw" double2
double4 --> "wx" double2
double4 --> "wy" double2
double4 --> "wz" double2
double4 --> "ww" double2
double4 +-- DebuggerProxy
class double4x2 <<struct>> {
    + double4x2(c0:double4, c1:double4)
    + double4x2(m00:double, m01:double, m10:double, m11:double, m20:double, m21:double, m30:double, m31:double)
    + double4x2(v:double)
    + double4x2(v:bool)
    + double4x2(v:bool4x2)
    + double4x2(v:int)
    + double4x2(v:int4x2)
    + double4x2(v:uint)
    + double4x2(v:uint4x2)
    + double4x2(v:float)
    + double4x2(v:float4x2)
    + Equals(rhs:double4x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double4x2(c0:double4, c1:double4) : double4x2
    + {static} double4x2(m00:double, m01:double, m10:double, m11:double, m20:double, m21:double, m30:double, m31:double) : double4x2
    + {static} double4x2(v:double) : double4x2
    + {static} double4x2(v:bool) : double4x2
    + {static} double4x2(v:bool4x2) : double4x2
    + {static} double4x2(v:int) : double4x2
    + {static} double4x2(v:int4x2) : double4x2
    + {static} double4x2(v:uint) : double4x2
    + {static} double4x2(v:uint4x2) : double4x2
    + {static} double4x2(v:float) : double4x2
    + {static} double4x2(v:float4x2) : double4x2
    + {static} transpose(v:double4x2) : double2x4
    + {static} hash(v:double4x2) : uint
    + {static} hashwide(v:double4x2) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double4x2
double4x2 --> "c0" double4
double4x2 --> "c1" double4
double4x2 --> "zero" double4x2
class double4x3 <<struct>> {
    + double4x3(c0:double4, c1:double4, c2:double4)
    + double4x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double, m20:double, m21:double, m22:double, m30:double, m31:double, m32:double)
    + double4x3(v:double)
    + double4x3(v:bool)
    + double4x3(v:bool4x3)
    + double4x3(v:int)
    + double4x3(v:int4x3)
    + double4x3(v:uint)
    + double4x3(v:uint4x3)
    + double4x3(v:float)
    + double4x3(v:float4x3)
    + Equals(rhs:double4x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double4x3(c0:double4, c1:double4, c2:double4) : double4x3
    + {static} double4x3(m00:double, m01:double, m02:double, m10:double, m11:double, m12:double, m20:double, m21:double, m22:double, m30:double, m31:double, m32:double) : double4x3
    + {static} double4x3(v:double) : double4x3
    + {static} double4x3(v:bool) : double4x3
    + {static} double4x3(v:bool4x3) : double4x3
    + {static} double4x3(v:int) : double4x3
    + {static} double4x3(v:int4x3) : double4x3
    + {static} double4x3(v:uint) : double4x3
    + {static} double4x3(v:uint4x3) : double4x3
    + {static} double4x3(v:float) : double4x3
    + {static} double4x3(v:float4x3) : double4x3
    + {static} transpose(v:double4x3) : double3x4
    + {static} hash(v:double4x3) : uint
    + {static} hashwide(v:double4x3) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double4x3
double4x3 --> "c0" double4
double4x3 --> "c1" double4
double4x3 --> "c2" double4
double4x3 --> "zero" double4x3
class double4x4 <<struct>> {
    + double4x4(c0:double4, c1:double4, c2:double4, c3:double4)
    + double4x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double, m20:double, m21:double, m22:double, m23:double, m30:double, m31:double, m32:double, m33:double)
    + double4x4(v:double)
    + double4x4(v:bool)
    + double4x4(v:bool4x4)
    + double4x4(v:int)
    + double4x4(v:int4x4)
    + double4x4(v:uint)
    + double4x4(v:uint4x4)
    + double4x4(v:float)
    + double4x4(v:float4x4)
    + Equals(rhs:double4x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} double4x4(c0:double4, c1:double4, c2:double4, c3:double4) : double4x4
    + {static} double4x4(m00:double, m01:double, m02:double, m03:double, m10:double, m11:double, m12:double, m13:double, m20:double, m21:double, m22:double, m23:double, m30:double, m31:double, m32:double, m33:double) : double4x4
    + {static} double4x4(v:double) : double4x4
    + {static} double4x4(v:bool) : double4x4
    + {static} double4x4(v:bool4x4) : double4x4
    + {static} double4x4(v:int) : double4x4
    + {static} double4x4(v:int4x4) : double4x4
    + {static} double4x4(v:uint) : double4x4
    + {static} double4x4(v:uint4x4) : double4x4
    + {static} double4x4(v:float) : double4x4
    + {static} double4x4(v:float4x4) : double4x4
    + {static} rotate(a:double4x4, b:double3) : double3
    + {static} transform(a:double4x4, b:double3) : double3
    + {static} transpose(v:double4x4) : double4x4
    + {static} inverse(m:double4x4) : double4x4
    + {static} fastinverse(m:double4x4) : double4x4
    + {static} determinant(m:double4x4) : double
    + {static} hash(v:double4x4) : uint
    + {static} hashwide(v:double4x4) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- double4x4
double4x4 --> "c0" double4
double4x4 --> "c1" double4
double4x4 --> "c2" double4
double4x4 --> "c3" double4
double4x4 o-> "identity" double4x4
double4x4 --> "zero" double4x4
class float2 <<struct>> {
    + x : float
    + y : float
    + float2(x:float, y:float)
    + float2(xy:float2)
    + float2(v:float)
    + float2(v:bool)
    + float2(v:bool2)
    + float2(v:int)
    + float2(v:int2)
    + float2(v:uint)
    + float2(v:uint2)
    + float2(v:half)
    + float2(v:half2)
    + float2(v:double)
    + float2(v:double2)
    + Equals(rhs:float2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float2(x:float, y:float) : float2
    + {static} float2(xy:float2) : float2
    + {static} float2(v:float) : float2
    + {static} float2(v:bool) : float2
    + {static} float2(v:bool2) : float2
    + {static} float2(v:int) : float2
    + {static} float2(v:int2) : float2
    + {static} float2(v:uint) : float2
    + {static} float2(v:uint2) : float2
    + {static} float2(v:half) : float2
    + {static} float2(v:half2) : float2
    + {static} float2(v:double) : float2
    + {static} float2(v:double2) : float2
    + {static} hash(v:float2) : uint
    + {static} hashwide(v:float2) : uint2
    + {static} shuffle(a:float2, b:float2, x:ShuffleComponent) : float
    + {static} shuffle(a:float2, b:float2, x:ShuffleComponent, y:ShuffleComponent) : float2
    + {static} shuffle(a:float2, b:float2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : float3
    + {static} shuffle(a:float2, b:float2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : float4
    <<internal>> {static} select_shuffle_component(a:float2, b:float2, component:ShuffleComponent) : float
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : float
    + y : float
    + DebuggerProxy(v:float2)
}
IFormattable <|-- float2
float2 --> "zero" float2
float2 --> "xxxx" float4
float2 --> "xxxy" float4
float2 --> "xxyx" float4
float2 --> "xxyy" float4
float2 --> "xyxx" float4
float2 --> "xyxy" float4
float2 --> "xyyx" float4
float2 --> "xyyy" float4
float2 --> "yxxx" float4
float2 --> "yxxy" float4
float2 --> "yxyx" float4
float2 --> "yxyy" float4
float2 --> "yyxx" float4
float2 --> "yyxy" float4
float2 --> "yyyx" float4
float2 --> "yyyy" float4
float2 --> "xxx" float3
float2 --> "xxy" float3
float2 --> "xyx" float3
float2 --> "xyy" float3
float2 --> "yxx" float3
float2 --> "yxy" float3
float2 --> "yyx" float3
float2 --> "yyy" float3
float2 --> "xx" float2
float2 --> "xy" float2
float2 --> "yx" float2
float2 --> "yy" float2
float2 +-- DebuggerProxy
class float2x2 <<struct>> {
    + float2x2(c0:float2, c1:float2)
    + float2x2(m00:float, m01:float, m10:float, m11:float)
    + float2x2(v:float)
    + float2x2(v:bool)
    + float2x2(v:bool2x2)
    + float2x2(v:int)
    + float2x2(v:int2x2)
    + float2x2(v:uint)
    + float2x2(v:uint2x2)
    + float2x2(v:double)
    + float2x2(v:double2x2)
    + Equals(rhs:float2x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float2x2(c0:float2, c1:float2) : float2x2
    + {static} float2x2(m00:float, m01:float, m10:float, m11:float) : float2x2
    + {static} float2x2(v:float) : float2x2
    + {static} float2x2(v:bool) : float2x2
    + {static} float2x2(v:bool2x2) : float2x2
    + {static} float2x2(v:int) : float2x2
    + {static} float2x2(v:int2x2) : float2x2
    + {static} float2x2(v:uint) : float2x2
    + {static} float2x2(v:uint2x2) : float2x2
    + {static} float2x2(v:double) : float2x2
    + {static} float2x2(v:double2x2) : float2x2
    + {static} transpose(v:float2x2) : float2x2
    + {static} inverse(m:float2x2) : float2x2
    + {static} determinant(m:float2x2) : float
    + {static} hash(v:float2x2) : uint
    + {static} hashwide(v:float2x2) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float2x2
float2x2 --> "c0" float2
float2x2 --> "c1" float2
float2x2 o-> "identity" float2x2
float2x2 --> "zero" float2x2
class float2x3 <<struct>> {
    + float2x3(c0:float2, c1:float2, c2:float2)
    + float2x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float)
    + float2x3(v:float)
    + float2x3(v:bool)
    + float2x3(v:bool2x3)
    + float2x3(v:int)
    + float2x3(v:int2x3)
    + float2x3(v:uint)
    + float2x3(v:uint2x3)
    + float2x3(v:double)
    + float2x3(v:double2x3)
    + Equals(rhs:float2x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float2x3(c0:float2, c1:float2, c2:float2) : float2x3
    + {static} float2x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float) : float2x3
    + {static} float2x3(v:float) : float2x3
    + {static} float2x3(v:bool) : float2x3
    + {static} float2x3(v:bool2x3) : float2x3
    + {static} float2x3(v:int) : float2x3
    + {static} float2x3(v:int2x3) : float2x3
    + {static} float2x3(v:uint) : float2x3
    + {static} float2x3(v:uint2x3) : float2x3
    + {static} float2x3(v:double) : float2x3
    + {static} float2x3(v:double2x3) : float2x3
    + {static} transpose(v:float2x3) : float3x2
    + {static} hash(v:float2x3) : uint
    + {static} hashwide(v:float2x3) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float2x3
float2x3 --> "c0" float2
float2x3 --> "c1" float2
float2x3 --> "c2" float2
float2x3 --> "zero" float2x3
class float2x4 <<struct>> {
    + float2x4(c0:float2, c1:float2, c2:float2, c3:float2)
    + float2x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float)
    + float2x4(v:float)
    + float2x4(v:bool)
    + float2x4(v:bool2x4)
    + float2x4(v:int)
    + float2x4(v:int2x4)
    + float2x4(v:uint)
    + float2x4(v:uint2x4)
    + float2x4(v:double)
    + float2x4(v:double2x4)
    + Equals(rhs:float2x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float2x4(c0:float2, c1:float2, c2:float2, c3:float2) : float2x4
    + {static} float2x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float) : float2x4
    + {static} float2x4(v:float) : float2x4
    + {static} float2x4(v:bool) : float2x4
    + {static} float2x4(v:bool2x4) : float2x4
    + {static} float2x4(v:int) : float2x4
    + {static} float2x4(v:int2x4) : float2x4
    + {static} float2x4(v:uint) : float2x4
    + {static} float2x4(v:uint2x4) : float2x4
    + {static} float2x4(v:double) : float2x4
    + {static} float2x4(v:double2x4) : float2x4
    + {static} transpose(v:float2x4) : float4x2
    + {static} hash(v:float2x4) : uint
    + {static} hashwide(v:float2x4) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float2x4
float2x4 --> "c0" float2
float2x4 --> "c1" float2
float2x4 --> "c2" float2
float2x4 --> "c3" float2
float2x4 --> "zero" float2x4
class float3 <<struct>> {
    + x : float
    + y : float
    + z : float
    + float3(x:float, y:float, z:float)
    + float3(x:float, yz:float2)
    + float3(xy:float2, z:float)
    + float3(xyz:float3)
    + float3(v:float)
    + float3(v:bool)
    + float3(v:bool3)
    + float3(v:int)
    + float3(v:int3)
    + float3(v:uint)
    + float3(v:uint3)
    + float3(v:half)
    + float3(v:half3)
    + float3(v:double)
    + float3(v:double3)
    + Equals(rhs:float3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float3(x:float, y:float, z:float) : float3
    + {static} float3(x:float, yz:float2) : float3
    + {static} float3(xy:float2, z:float) : float3
    + {static} float3(xyz:float3) : float3
    + {static} float3(v:float) : float3
    + {static} float3(v:bool) : float3
    + {static} float3(v:bool3) : float3
    + {static} float3(v:int) : float3
    + {static} float3(v:int3) : float3
    + {static} float3(v:uint) : float3
    + {static} float3(v:uint3) : float3
    + {static} float3(v:half) : float3
    + {static} float3(v:half3) : float3
    + {static} float3(v:double) : float3
    + {static} float3(v:double3) : float3
    + {static} hash(v:float3) : uint
    + {static} hashwide(v:float3) : uint3
    + {static} shuffle(a:float3, b:float3, x:ShuffleComponent) : float
    + {static} shuffle(a:float3, b:float3, x:ShuffleComponent, y:ShuffleComponent) : float2
    + {static} shuffle(a:float3, b:float3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : float3
    + {static} shuffle(a:float3, b:float3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : float4
    <<internal>> {static} select_shuffle_component(a:float3, b:float3, component:ShuffleComponent) : float
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : float
    + y : float
    + z : float
    + DebuggerProxy(v:float3)
}
IFormattable <|-- float3
float3 --> "zero" float3
float3 --> "xxxx" float4
float3 --> "xxxy" float4
float3 --> "xxxz" float4
float3 --> "xxyx" float4
float3 --> "xxyy" float4
float3 --> "xxyz" float4
float3 --> "xxzx" float4
float3 --> "xxzy" float4
float3 --> "xxzz" float4
float3 --> "xyxx" float4
float3 --> "xyxy" float4
float3 --> "xyxz" float4
float3 --> "xyyx" float4
float3 --> "xyyy" float4
float3 --> "xyyz" float4
float3 --> "xyzx" float4
float3 --> "xyzy" float4
float3 --> "xyzz" float4
float3 --> "xzxx" float4
float3 --> "xzxy" float4
float3 --> "xzxz" float4
float3 --> "xzyx" float4
float3 --> "xzyy" float4
float3 --> "xzyz" float4
float3 --> "xzzx" float4
float3 --> "xzzy" float4
float3 --> "xzzz" float4
float3 --> "yxxx" float4
float3 --> "yxxy" float4
float3 --> "yxxz" float4
float3 --> "yxyx" float4
float3 --> "yxyy" float4
float3 --> "yxyz" float4
float3 --> "yxzx" float4
float3 --> "yxzy" float4
float3 --> "yxzz" float4
float3 --> "yyxx" float4
float3 --> "yyxy" float4
float3 --> "yyxz" float4
float3 --> "yyyx" float4
float3 --> "yyyy" float4
float3 --> "yyyz" float4
float3 --> "yyzx" float4
float3 --> "yyzy" float4
float3 --> "yyzz" float4
float3 --> "yzxx" float4
float3 --> "yzxy" float4
float3 --> "yzxz" float4
float3 --> "yzyx" float4
float3 --> "yzyy" float4
float3 --> "yzyz" float4
float3 --> "yzzx" float4
float3 --> "yzzy" float4
float3 --> "yzzz" float4
float3 --> "zxxx" float4
float3 --> "zxxy" float4
float3 --> "zxxz" float4
float3 --> "zxyx" float4
float3 --> "zxyy" float4
float3 --> "zxyz" float4
float3 --> "zxzx" float4
float3 --> "zxzy" float4
float3 --> "zxzz" float4
float3 --> "zyxx" float4
float3 --> "zyxy" float4
float3 --> "zyxz" float4
float3 --> "zyyx" float4
float3 --> "zyyy" float4
float3 --> "zyyz" float4
float3 --> "zyzx" float4
float3 --> "zyzy" float4
float3 --> "zyzz" float4
float3 --> "zzxx" float4
float3 --> "zzxy" float4
float3 --> "zzxz" float4
float3 --> "zzyx" float4
float3 --> "zzyy" float4
float3 --> "zzyz" float4
float3 --> "zzzx" float4
float3 --> "zzzy" float4
float3 --> "zzzz" float4
float3 --> "xxx" float3
float3 --> "xxy" float3
float3 --> "xxz" float3
float3 --> "xyx" float3
float3 --> "xyy" float3
float3 --> "xyz" float3
float3 --> "xzx" float3
float3 --> "xzy" float3
float3 --> "xzz" float3
float3 --> "yxx" float3
float3 --> "yxy" float3
float3 --> "yxz" float3
float3 --> "yyx" float3
float3 --> "yyy" float3
float3 --> "yyz" float3
float3 --> "yzx" float3
float3 --> "yzy" float3
float3 --> "yzz" float3
float3 --> "zxx" float3
float3 --> "zxy" float3
float3 --> "zxz" float3
float3 --> "zyx" float3
float3 --> "zyy" float3
float3 --> "zyz" float3
float3 --> "zzx" float3
float3 --> "zzy" float3
float3 --> "zzz" float3
float3 --> "xx" float2
float3 --> "xy" float2
float3 --> "xz" float2
float3 --> "yx" float2
float3 --> "yy" float2
float3 --> "yz" float2
float3 --> "zx" float2
float3 --> "zy" float2
float3 --> "zz" float2
float3 +-- DebuggerProxy
class float3x2 <<struct>> {
    + float3x2(c0:float3, c1:float3)
    + float3x2(m00:float, m01:float, m10:float, m11:float, m20:float, m21:float)
    + float3x2(v:float)
    + float3x2(v:bool)
    + float3x2(v:bool3x2)
    + float3x2(v:int)
    + float3x2(v:int3x2)
    + float3x2(v:uint)
    + float3x2(v:uint3x2)
    + float3x2(v:double)
    + float3x2(v:double3x2)
    + Equals(rhs:float3x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float3x2(c0:float3, c1:float3) : float3x2
    + {static} float3x2(m00:float, m01:float, m10:float, m11:float, m20:float, m21:float) : float3x2
    + {static} float3x2(v:float) : float3x2
    + {static} float3x2(v:bool) : float3x2
    + {static} float3x2(v:bool3x2) : float3x2
    + {static} float3x2(v:int) : float3x2
    + {static} float3x2(v:int3x2) : float3x2
    + {static} float3x2(v:uint) : float3x2
    + {static} float3x2(v:uint3x2) : float3x2
    + {static} float3x2(v:double) : float3x2
    + {static} float3x2(v:double3x2) : float3x2
    + {static} transpose(v:float3x2) : float2x3
    + {static} hash(v:float3x2) : uint
    + {static} hashwide(v:float3x2) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float3x2
float3x2 --> "c0" float3
float3x2 --> "c1" float3
float3x2 --> "zero" float3x2
class float3x3 <<struct>> {
    + float3x3(c0:float3, c1:float3, c2:float3)
    + float3x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float, m20:float, m21:float, m22:float)
    + float3x3(v:float)
    + float3x3(v:bool)
    + float3x3(v:bool3x3)
    + float3x3(v:int)
    + float3x3(v:int3x3)
    + float3x3(v:uint)
    + float3x3(v:uint3x3)
    + float3x3(v:double)
    + float3x3(v:double3x3)
    + Equals(rhs:float3x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float3x3(c0:float3, c1:float3, c2:float3) : float3x3
    + {static} float3x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float, m20:float, m21:float, m22:float) : float3x3
    + {static} float3x3(v:float) : float3x3
    + {static} float3x3(v:bool) : float3x3
    + {static} float3x3(v:bool3x3) : float3x3
    + {static} float3x3(v:int) : float3x3
    + {static} float3x3(v:int3x3) : float3x3
    + {static} float3x3(v:uint) : float3x3
    + {static} float3x3(v:uint3x3) : float3x3
    + {static} float3x3(v:double) : float3x3
    + {static} float3x3(v:double3x3) : float3x3
    + {static} transpose(v:float3x3) : float3x3
    + {static} inverse(m:float3x3) : float3x3
    + {static} determinant(m:float3x3) : float
    + {static} hash(v:float3x3) : uint
    + {static} hashwide(v:float3x3) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float3x3
float3x3 --> "c0" float3
float3x3 --> "c1" float3
float3x3 --> "c2" float3
float3x3 o-> "identity" float3x3
float3x3 --> "zero" float3x3
class float3x4 <<struct>> {
    + float3x4(c0:float3, c1:float3, c2:float3, c3:float3)
    + float3x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float, m20:float, m21:float, m22:float, m23:float)
    + float3x4(v:float)
    + float3x4(v:bool)
    + float3x4(v:bool3x4)
    + float3x4(v:int)
    + float3x4(v:int3x4)
    + float3x4(v:uint)
    + float3x4(v:uint3x4)
    + float3x4(v:double)
    + float3x4(v:double3x4)
    + Equals(rhs:float3x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float3x4(c0:float3, c1:float3, c2:float3, c3:float3) : float3x4
    + {static} float3x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float, m20:float, m21:float, m22:float, m23:float) : float3x4
    + {static} float3x4(v:float) : float3x4
    + {static} float3x4(v:bool) : float3x4
    + {static} float3x4(v:bool3x4) : float3x4
    + {static} float3x4(v:int) : float3x4
    + {static} float3x4(v:int3x4) : float3x4
    + {static} float3x4(v:uint) : float3x4
    + {static} float3x4(v:uint3x4) : float3x4
    + {static} float3x4(v:double) : float3x4
    + {static} float3x4(v:double3x4) : float3x4
    + {static} transpose(v:float3x4) : float4x3
    + {static} fastinverse(m:float3x4) : float3x4
    + {static} hash(v:float3x4) : uint
    + {static} hashwide(v:float3x4) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float3x4
float3x4 --> "c0" float3
float3x4 --> "c1" float3
float3x4 --> "c2" float3
float3x4 --> "c3" float3
float3x4 --> "zero" float3x4
class float4 <<struct>> {
    + x : float
    + y : float
    + z : float
    + w : float
    + float4(x:float, y:float, z:float, w:float)
    + float4(x:float, y:float, zw:float2)
    + float4(x:float, yz:float2, w:float)
    + float4(x:float, yzw:float3)
    + float4(xy:float2, z:float, w:float)
    + float4(xy:float2, zw:float2)
    + float4(xyz:float3, w:float)
    + float4(xyzw:float4)
    + float4(v:float)
    + float4(v:bool)
    + float4(v:bool4)
    + float4(v:int)
    + float4(v:int4)
    + float4(v:uint)
    + float4(v:uint4)
    + float4(v:half)
    + float4(v:half4)
    + float4(v:double)
    + float4(v:double4)
    + Equals(rhs:float4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float4(x:float, y:float, z:float, w:float) : float4
    + {static} float4(x:float, y:float, zw:float2) : float4
    + {static} float4(x:float, yz:float2, w:float) : float4
    + {static} float4(x:float, yzw:float3) : float4
    + {static} float4(xy:float2, z:float, w:float) : float4
    + {static} float4(xy:float2, zw:float2) : float4
    + {static} float4(xyz:float3, w:float) : float4
    + {static} float4(xyzw:float4) : float4
    + {static} float4(v:float) : float4
    + {static} float4(v:bool) : float4
    + {static} float4(v:bool4) : float4
    + {static} float4(v:int) : float4
    + {static} float4(v:int4) : float4
    + {static} float4(v:uint) : float4
    + {static} float4(v:uint4) : float4
    + {static} float4(v:half) : float4
    + {static} float4(v:half4) : float4
    + {static} float4(v:double) : float4
    + {static} float4(v:double4) : float4
    + {static} hash(v:float4) : uint
    + {static} hashwide(v:float4) : uint4
    + {static} shuffle(a:float4, b:float4, x:ShuffleComponent) : float
    + {static} shuffle(a:float4, b:float4, x:ShuffleComponent, y:ShuffleComponent) : float2
    + {static} shuffle(a:float4, b:float4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : float3
    + {static} shuffle(a:float4, b:float4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : float4
    <<internal>> {static} select_shuffle_component(a:float4, b:float4, component:ShuffleComponent) : float
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : float
    + y : float
    + z : float
    + w : float
    + DebuggerProxy(v:float4)
}
IFormattable <|-- float4
float4 --> "zero" float4
float4 --> "xxxx" float4
float4 --> "xxxy" float4
float4 --> "xxxz" float4
float4 --> "xxxw" float4
float4 --> "xxyx" float4
float4 --> "xxyy" float4
float4 --> "xxyz" float4
float4 --> "xxyw" float4
float4 --> "xxzx" float4
float4 --> "xxzy" float4
float4 --> "xxzz" float4
float4 --> "xxzw" float4
float4 --> "xxwx" float4
float4 --> "xxwy" float4
float4 --> "xxwz" float4
float4 --> "xxww" float4
float4 --> "xyxx" float4
float4 --> "xyxy" float4
float4 --> "xyxz" float4
float4 --> "xyxw" float4
float4 --> "xyyx" float4
float4 --> "xyyy" float4
float4 --> "xyyz" float4
float4 --> "xyyw" float4
float4 --> "xyzx" float4
float4 --> "xyzy" float4
float4 --> "xyzz" float4
float4 --> "xyzw" float4
float4 --> "xywx" float4
float4 --> "xywy" float4
float4 --> "xywz" float4
float4 --> "xyww" float4
float4 --> "xzxx" float4
float4 --> "xzxy" float4
float4 --> "xzxz" float4
float4 --> "xzxw" float4
float4 --> "xzyx" float4
float4 --> "xzyy" float4
float4 --> "xzyz" float4
float4 --> "xzyw" float4
float4 --> "xzzx" float4
float4 --> "xzzy" float4
float4 --> "xzzz" float4
float4 --> "xzzw" float4
float4 --> "xzwx" float4
float4 --> "xzwy" float4
float4 --> "xzwz" float4
float4 --> "xzww" float4
float4 --> "xwxx" float4
float4 --> "xwxy" float4
float4 --> "xwxz" float4
float4 --> "xwxw" float4
float4 --> "xwyx" float4
float4 --> "xwyy" float4
float4 --> "xwyz" float4
float4 --> "xwyw" float4
float4 --> "xwzx" float4
float4 --> "xwzy" float4
float4 --> "xwzz" float4
float4 --> "xwzw" float4
float4 --> "xwwx" float4
float4 --> "xwwy" float4
float4 --> "xwwz" float4
float4 --> "xwww" float4
float4 --> "yxxx" float4
float4 --> "yxxy" float4
float4 --> "yxxz" float4
float4 --> "yxxw" float4
float4 --> "yxyx" float4
float4 --> "yxyy" float4
float4 --> "yxyz" float4
float4 --> "yxyw" float4
float4 --> "yxzx" float4
float4 --> "yxzy" float4
float4 --> "yxzz" float4
float4 --> "yxzw" float4
float4 --> "yxwx" float4
float4 --> "yxwy" float4
float4 --> "yxwz" float4
float4 --> "yxww" float4
float4 --> "yyxx" float4
float4 --> "yyxy" float4
float4 --> "yyxz" float4
float4 --> "yyxw" float4
float4 --> "yyyx" float4
float4 --> "yyyy" float4
float4 --> "yyyz" float4
float4 --> "yyyw" float4
float4 --> "yyzx" float4
float4 --> "yyzy" float4
float4 --> "yyzz" float4
float4 --> "yyzw" float4
float4 --> "yywx" float4
float4 --> "yywy" float4
float4 --> "yywz" float4
float4 --> "yyww" float4
float4 --> "yzxx" float4
float4 --> "yzxy" float4
float4 --> "yzxz" float4
float4 --> "yzxw" float4
float4 --> "yzyx" float4
float4 --> "yzyy" float4
float4 --> "yzyz" float4
float4 --> "yzyw" float4
float4 --> "yzzx" float4
float4 --> "yzzy" float4
float4 --> "yzzz" float4
float4 --> "yzzw" float4
float4 --> "yzwx" float4
float4 --> "yzwy" float4
float4 --> "yzwz" float4
float4 --> "yzww" float4
float4 --> "ywxx" float4
float4 --> "ywxy" float4
float4 --> "ywxz" float4
float4 --> "ywxw" float4
float4 --> "ywyx" float4
float4 --> "ywyy" float4
float4 --> "ywyz" float4
float4 --> "ywyw" float4
float4 --> "ywzx" float4
float4 --> "ywzy" float4
float4 --> "ywzz" float4
float4 --> "ywzw" float4
float4 --> "ywwx" float4
float4 --> "ywwy" float4
float4 --> "ywwz" float4
float4 --> "ywww" float4
float4 --> "zxxx" float4
float4 --> "zxxy" float4
float4 --> "zxxz" float4
float4 --> "zxxw" float4
float4 --> "zxyx" float4
float4 --> "zxyy" float4
float4 --> "zxyz" float4
float4 --> "zxyw" float4
float4 --> "zxzx" float4
float4 --> "zxzy" float4
float4 --> "zxzz" float4
float4 --> "zxzw" float4
float4 --> "zxwx" float4
float4 --> "zxwy" float4
float4 --> "zxwz" float4
float4 --> "zxww" float4
float4 --> "zyxx" float4
float4 --> "zyxy" float4
float4 --> "zyxz" float4
float4 --> "zyxw" float4
float4 --> "zyyx" float4
float4 --> "zyyy" float4
float4 --> "zyyz" float4
float4 --> "zyyw" float4
float4 --> "zyzx" float4
float4 --> "zyzy" float4
float4 --> "zyzz" float4
float4 --> "zyzw" float4
float4 --> "zywx" float4
float4 --> "zywy" float4
float4 --> "zywz" float4
float4 --> "zyww" float4
float4 --> "zzxx" float4
float4 --> "zzxy" float4
float4 --> "zzxz" float4
float4 --> "zzxw" float4
float4 --> "zzyx" float4
float4 --> "zzyy" float4
float4 --> "zzyz" float4
float4 --> "zzyw" float4
float4 --> "zzzx" float4
float4 --> "zzzy" float4
float4 --> "zzzz" float4
float4 --> "zzzw" float4
float4 --> "zzwx" float4
float4 --> "zzwy" float4
float4 --> "zzwz" float4
float4 --> "zzww" float4
float4 --> "zwxx" float4
float4 --> "zwxy" float4
float4 --> "zwxz" float4
float4 --> "zwxw" float4
float4 --> "zwyx" float4
float4 --> "zwyy" float4
float4 --> "zwyz" float4
float4 --> "zwyw" float4
float4 --> "zwzx" float4
float4 --> "zwzy" float4
float4 --> "zwzz" float4
float4 --> "zwzw" float4
float4 --> "zwwx" float4
float4 --> "zwwy" float4
float4 --> "zwwz" float4
float4 --> "zwww" float4
float4 --> "wxxx" float4
float4 --> "wxxy" float4
float4 --> "wxxz" float4
float4 --> "wxxw" float4
float4 --> "wxyx" float4
float4 --> "wxyy" float4
float4 --> "wxyz" float4
float4 --> "wxyw" float4
float4 --> "wxzx" float4
float4 --> "wxzy" float4
float4 --> "wxzz" float4
float4 --> "wxzw" float4
float4 --> "wxwx" float4
float4 --> "wxwy" float4
float4 --> "wxwz" float4
float4 --> "wxww" float4
float4 --> "wyxx" float4
float4 --> "wyxy" float4
float4 --> "wyxz" float4
float4 --> "wyxw" float4
float4 --> "wyyx" float4
float4 --> "wyyy" float4
float4 --> "wyyz" float4
float4 --> "wyyw" float4
float4 --> "wyzx" float4
float4 --> "wyzy" float4
float4 --> "wyzz" float4
float4 --> "wyzw" float4
float4 --> "wywx" float4
float4 --> "wywy" float4
float4 --> "wywz" float4
float4 --> "wyww" float4
float4 --> "wzxx" float4
float4 --> "wzxy" float4
float4 --> "wzxz" float4
float4 --> "wzxw" float4
float4 --> "wzyx" float4
float4 --> "wzyy" float4
float4 --> "wzyz" float4
float4 --> "wzyw" float4
float4 --> "wzzx" float4
float4 --> "wzzy" float4
float4 --> "wzzz" float4
float4 --> "wzzw" float4
float4 --> "wzwx" float4
float4 --> "wzwy" float4
float4 --> "wzwz" float4
float4 --> "wzww" float4
float4 --> "wwxx" float4
float4 --> "wwxy" float4
float4 --> "wwxz" float4
float4 --> "wwxw" float4
float4 --> "wwyx" float4
float4 --> "wwyy" float4
float4 --> "wwyz" float4
float4 --> "wwyw" float4
float4 --> "wwzx" float4
float4 --> "wwzy" float4
float4 --> "wwzz" float4
float4 --> "wwzw" float4
float4 --> "wwwx" float4
float4 --> "wwwy" float4
float4 --> "wwwz" float4
float4 --> "wwww" float4
float4 --> "xxx" float3
float4 --> "xxy" float3
float4 --> "xxz" float3
float4 --> "xxw" float3
float4 --> "xyx" float3
float4 --> "xyy" float3
float4 --> "xyz" float3
float4 --> "xyw" float3
float4 --> "xzx" float3
float4 --> "xzy" float3
float4 --> "xzz" float3
float4 --> "xzw" float3
float4 --> "xwx" float3
float4 --> "xwy" float3
float4 --> "xwz" float3
float4 --> "xww" float3
float4 --> "yxx" float3
float4 --> "yxy" float3
float4 --> "yxz" float3
float4 --> "yxw" float3
float4 --> "yyx" float3
float4 --> "yyy" float3
float4 --> "yyz" float3
float4 --> "yyw" float3
float4 --> "yzx" float3
float4 --> "yzy" float3
float4 --> "yzz" float3
float4 --> "yzw" float3
float4 --> "ywx" float3
float4 --> "ywy" float3
float4 --> "ywz" float3
float4 --> "yww" float3
float4 --> "zxx" float3
float4 --> "zxy" float3
float4 --> "zxz" float3
float4 --> "zxw" float3
float4 --> "zyx" float3
float4 --> "zyy" float3
float4 --> "zyz" float3
float4 --> "zyw" float3
float4 --> "zzx" float3
float4 --> "zzy" float3
float4 --> "zzz" float3
float4 --> "zzw" float3
float4 --> "zwx" float3
float4 --> "zwy" float3
float4 --> "zwz" float3
float4 --> "zww" float3
float4 --> "wxx" float3
float4 --> "wxy" float3
float4 --> "wxz" float3
float4 --> "wxw" float3
float4 --> "wyx" float3
float4 --> "wyy" float3
float4 --> "wyz" float3
float4 --> "wyw" float3
float4 --> "wzx" float3
float4 --> "wzy" float3
float4 --> "wzz" float3
float4 --> "wzw" float3
float4 --> "wwx" float3
float4 --> "wwy" float3
float4 --> "wwz" float3
float4 --> "www" float3
float4 --> "xx" float2
float4 --> "xy" float2
float4 --> "xz" float2
float4 --> "xw" float2
float4 --> "yx" float2
float4 --> "yy" float2
float4 --> "yz" float2
float4 --> "yw" float2
float4 --> "zx" float2
float4 --> "zy" float2
float4 --> "zz" float2
float4 --> "zw" float2
float4 --> "wx" float2
float4 --> "wy" float2
float4 --> "wz" float2
float4 --> "ww" float2
float4 +-- DebuggerProxy
class float4x2 <<struct>> {
    + float4x2(c0:float4, c1:float4)
    + float4x2(m00:float, m01:float, m10:float, m11:float, m20:float, m21:float, m30:float, m31:float)
    + float4x2(v:float)
    + float4x2(v:bool)
    + float4x2(v:bool4x2)
    + float4x2(v:int)
    + float4x2(v:int4x2)
    + float4x2(v:uint)
    + float4x2(v:uint4x2)
    + float4x2(v:double)
    + float4x2(v:double4x2)
    + Equals(rhs:float4x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float4x2(c0:float4, c1:float4) : float4x2
    + {static} float4x2(m00:float, m01:float, m10:float, m11:float, m20:float, m21:float, m30:float, m31:float) : float4x2
    + {static} float4x2(v:float) : float4x2
    + {static} float4x2(v:bool) : float4x2
    + {static} float4x2(v:bool4x2) : float4x2
    + {static} float4x2(v:int) : float4x2
    + {static} float4x2(v:int4x2) : float4x2
    + {static} float4x2(v:uint) : float4x2
    + {static} float4x2(v:uint4x2) : float4x2
    + {static} float4x2(v:double) : float4x2
    + {static} float4x2(v:double4x2) : float4x2
    + {static} transpose(v:float4x2) : float2x4
    + {static} hash(v:float4x2) : uint
    + {static} hashwide(v:float4x2) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float4x2
float4x2 --> "c0" float4
float4x2 --> "c1" float4
float4x2 --> "zero" float4x2
class float4x3 <<struct>> {
    + float4x3(c0:float4, c1:float4, c2:float4)
    + float4x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float, m20:float, m21:float, m22:float, m30:float, m31:float, m32:float)
    + float4x3(v:float)
    + float4x3(v:bool)
    + float4x3(v:bool4x3)
    + float4x3(v:int)
    + float4x3(v:int4x3)
    + float4x3(v:uint)
    + float4x3(v:uint4x3)
    + float4x3(v:double)
    + float4x3(v:double4x3)
    + Equals(rhs:float4x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float4x3(c0:float4, c1:float4, c2:float4) : float4x3
    + {static} float4x3(m00:float, m01:float, m02:float, m10:float, m11:float, m12:float, m20:float, m21:float, m22:float, m30:float, m31:float, m32:float) : float4x3
    + {static} float4x3(v:float) : float4x3
    + {static} float4x3(v:bool) : float4x3
    + {static} float4x3(v:bool4x3) : float4x3
    + {static} float4x3(v:int) : float4x3
    + {static} float4x3(v:int4x3) : float4x3
    + {static} float4x3(v:uint) : float4x3
    + {static} float4x3(v:uint4x3) : float4x3
    + {static} float4x3(v:double) : float4x3
    + {static} float4x3(v:double4x3) : float4x3
    + {static} transpose(v:float4x3) : float3x4
    + {static} hash(v:float4x3) : uint
    + {static} hashwide(v:float4x3) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float4x3
float4x3 --> "c0" float4
float4x3 --> "c1" float4
float4x3 --> "c2" float4
float4x3 --> "zero" float4x3
class float4x4 <<struct>> {
    + float4x4(c0:float4, c1:float4, c2:float4, c3:float4)
    + float4x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float, m20:float, m21:float, m22:float, m23:float, m30:float, m31:float, m32:float, m33:float)
    + float4x4(v:float)
    + float4x4(v:bool)
    + float4x4(v:bool4x4)
    + float4x4(v:int)
    + float4x4(v:int4x4)
    + float4x4(v:uint)
    + float4x4(v:uint4x4)
    + float4x4(v:double)
    + float4x4(v:double4x4)
    + Equals(rhs:float4x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} float4x4(c0:float4, c1:float4, c2:float4, c3:float4) : float4x4
    + {static} float4x4(m00:float, m01:float, m02:float, m03:float, m10:float, m11:float, m12:float, m13:float, m20:float, m21:float, m22:float, m23:float, m30:float, m31:float, m32:float, m33:float) : float4x4
    + {static} float4x4(v:float) : float4x4
    + {static} float4x4(v:bool) : float4x4
    + {static} float4x4(v:bool4x4) : float4x4
    + {static} float4x4(v:int) : float4x4
    + {static} float4x4(v:int4x4) : float4x4
    + {static} float4x4(v:uint) : float4x4
    + {static} float4x4(v:uint4x4) : float4x4
    + {static} float4x4(v:double) : float4x4
    + {static} float4x4(v:double4x4) : float4x4
    + {static} rotate(a:float4x4, b:float3) : float3
    + {static} transform(a:float4x4, b:float3) : float3
    + {static} transpose(v:float4x4) : float4x4
    + {static} inverse(m:float4x4) : float4x4
    + {static} fastinverse(m:float4x4) : float4x4
    + {static} determinant(m:float4x4) : float
    + {static} hash(v:float4x4) : uint
    + {static} hashwide(v:float4x4) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- float4x4
float4x4 --> "c0" float4
float4x4 --> "c1" float4
float4x4 --> "c2" float4
float4x4 --> "c3" float4
float4x4 o-> "identity" float4x4
float4x4 --> "zero" float4x4
class half <<struct>> {
    + value : ushort
    + {static} MaxValue : float <<get>>
    + {static} MinValue : float <<get>>
    + half(x:half)
    + half(v:float)
    + half(v:double)
    + Equals(rhs:half) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} half(x:half) : half
    + {static} half(v:float) : half
    + {static} half(v:double) : half
    + {static} hash(v:half) : uint
}
class "IEquatable`1"<T> {
}
IFormattable <|-- half
half o-> "zero" half
class half2 <<struct>> {
    + half2(x:half, y:half)
    + half2(xy:half2)
    + half2(v:half)
    + half2(v:float)
    + half2(v:float2)
    + half2(v:double)
    + half2(v:double2)
    + Equals(rhs:half2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} half2(x:half, y:half) : half2
    + {static} half2(xy:half2) : half2
    + {static} half2(v:half) : half2
    + {static} half2(v:float) : half2
    + {static} half2(v:float2) : half2
    + {static} half2(v:double) : half2
    + {static} half2(v:double2) : half2
    + {static} hash(v:half2) : uint
    + {static} hashwide(v:half2) : uint2
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + DebuggerProxy(v:half2)
}
IFormattable <|-- half2
half2 --> "x" half
half2 --> "y" half
half2 --> "zero" half2
half2 --> "xxxx" half4
half2 --> "xxxy" half4
half2 --> "xxyx" half4
half2 --> "xxyy" half4
half2 --> "xyxx" half4
half2 --> "xyxy" half4
half2 --> "xyyx" half4
half2 --> "xyyy" half4
half2 --> "yxxx" half4
half2 --> "yxxy" half4
half2 --> "yxyx" half4
half2 --> "yxyy" half4
half2 --> "yyxx" half4
half2 --> "yyxy" half4
half2 --> "yyyx" half4
half2 --> "yyyy" half4
half2 --> "xxx" half3
half2 --> "xxy" half3
half2 --> "xyx" half3
half2 --> "xyy" half3
half2 --> "yxx" half3
half2 --> "yxy" half3
half2 --> "yyx" half3
half2 --> "yyy" half3
half2 --> "xx" half2
half2 --> "xy" half2
half2 --> "yx" half2
half2 --> "yy" half2
half2 +-- DebuggerProxy
DebuggerProxy --> "x" half
DebuggerProxy --> "y" half
class half3 <<struct>> {
    + half3(x:half, y:half, z:half)
    + half3(x:half, yz:half2)
    + half3(xy:half2, z:half)
    + half3(xyz:half3)
    + half3(v:half)
    + half3(v:float)
    + half3(v:float3)
    + half3(v:double)
    + half3(v:double3)
    + Equals(rhs:half3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} half3(x:half, y:half, z:half) : half3
    + {static} half3(x:half, yz:half2) : half3
    + {static} half3(xy:half2, z:half) : half3
    + {static} half3(xyz:half3) : half3
    + {static} half3(v:half) : half3
    + {static} half3(v:float) : half3
    + {static} half3(v:float3) : half3
    + {static} half3(v:double) : half3
    + {static} half3(v:double3) : half3
    + {static} hash(v:half3) : uint
    + {static} hashwide(v:half3) : uint3
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + DebuggerProxy(v:half3)
}
IFormattable <|-- half3
half3 --> "x" half
half3 --> "y" half
half3 --> "z" half
half3 --> "zero" half3
half3 --> "xxxx" half4
half3 --> "xxxy" half4
half3 --> "xxxz" half4
half3 --> "xxyx" half4
half3 --> "xxyy" half4
half3 --> "xxyz" half4
half3 --> "xxzx" half4
half3 --> "xxzy" half4
half3 --> "xxzz" half4
half3 --> "xyxx" half4
half3 --> "xyxy" half4
half3 --> "xyxz" half4
half3 --> "xyyx" half4
half3 --> "xyyy" half4
half3 --> "xyyz" half4
half3 --> "xyzx" half4
half3 --> "xyzy" half4
half3 --> "xyzz" half4
half3 --> "xzxx" half4
half3 --> "xzxy" half4
half3 --> "xzxz" half4
half3 --> "xzyx" half4
half3 --> "xzyy" half4
half3 --> "xzyz" half4
half3 --> "xzzx" half4
half3 --> "xzzy" half4
half3 --> "xzzz" half4
half3 --> "yxxx" half4
half3 --> "yxxy" half4
half3 --> "yxxz" half4
half3 --> "yxyx" half4
half3 --> "yxyy" half4
half3 --> "yxyz" half4
half3 --> "yxzx" half4
half3 --> "yxzy" half4
half3 --> "yxzz" half4
half3 --> "yyxx" half4
half3 --> "yyxy" half4
half3 --> "yyxz" half4
half3 --> "yyyx" half4
half3 --> "yyyy" half4
half3 --> "yyyz" half4
half3 --> "yyzx" half4
half3 --> "yyzy" half4
half3 --> "yyzz" half4
half3 --> "yzxx" half4
half3 --> "yzxy" half4
half3 --> "yzxz" half4
half3 --> "yzyx" half4
half3 --> "yzyy" half4
half3 --> "yzyz" half4
half3 --> "yzzx" half4
half3 --> "yzzy" half4
half3 --> "yzzz" half4
half3 --> "zxxx" half4
half3 --> "zxxy" half4
half3 --> "zxxz" half4
half3 --> "zxyx" half4
half3 --> "zxyy" half4
half3 --> "zxyz" half4
half3 --> "zxzx" half4
half3 --> "zxzy" half4
half3 --> "zxzz" half4
half3 --> "zyxx" half4
half3 --> "zyxy" half4
half3 --> "zyxz" half4
half3 --> "zyyx" half4
half3 --> "zyyy" half4
half3 --> "zyyz" half4
half3 --> "zyzx" half4
half3 --> "zyzy" half4
half3 --> "zyzz" half4
half3 --> "zzxx" half4
half3 --> "zzxy" half4
half3 --> "zzxz" half4
half3 --> "zzyx" half4
half3 --> "zzyy" half4
half3 --> "zzyz" half4
half3 --> "zzzx" half4
half3 --> "zzzy" half4
half3 --> "zzzz" half4
half3 --> "xxx" half3
half3 --> "xxy" half3
half3 --> "xxz" half3
half3 --> "xyx" half3
half3 --> "xyy" half3
half3 --> "xyz" half3
half3 --> "xzx" half3
half3 --> "xzy" half3
half3 --> "xzz" half3
half3 --> "yxx" half3
half3 --> "yxy" half3
half3 --> "yxz" half3
half3 --> "yyx" half3
half3 --> "yyy" half3
half3 --> "yyz" half3
half3 --> "yzx" half3
half3 --> "yzy" half3
half3 --> "yzz" half3
half3 --> "zxx" half3
half3 --> "zxy" half3
half3 --> "zxz" half3
half3 --> "zyx" half3
half3 --> "zyy" half3
half3 --> "zyz" half3
half3 --> "zzx" half3
half3 --> "zzy" half3
half3 --> "zzz" half3
half3 --> "xx" half2
half3 --> "xy" half2
half3 --> "xz" half2
half3 --> "yx" half2
half3 --> "yy" half2
half3 --> "yz" half2
half3 --> "zx" half2
half3 --> "zy" half2
half3 --> "zz" half2
half3 +-- DebuggerProxy
DebuggerProxy --> "x" half
DebuggerProxy --> "y" half
DebuggerProxy --> "z" half
class half4 <<struct>> {
    + half4(x:half, y:half, z:half, w:half)
    + half4(x:half, y:half, zw:half2)
    + half4(x:half, yz:half2, w:half)
    + half4(x:half, yzw:half3)
    + half4(xy:half2, z:half, w:half)
    + half4(xy:half2, zw:half2)
    + half4(xyz:half3, w:half)
    + half4(xyzw:half4)
    + half4(v:half)
    + half4(v:float)
    + half4(v:float4)
    + half4(v:double)
    + half4(v:double4)
    + Equals(rhs:half4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} half4(x:half, y:half, z:half, w:half) : half4
    + {static} half4(x:half, y:half, zw:half2) : half4
    + {static} half4(x:half, yz:half2, w:half) : half4
    + {static} half4(x:half, yzw:half3) : half4
    + {static} half4(xy:half2, z:half, w:half) : half4
    + {static} half4(xy:half2, zw:half2) : half4
    + {static} half4(xyz:half3, w:half) : half4
    + {static} half4(xyzw:half4) : half4
    + {static} half4(v:half) : half4
    + {static} half4(v:float) : half4
    + {static} half4(v:float4) : half4
    + {static} half4(v:double) : half4
    + {static} half4(v:double4) : half4
    + {static} hash(v:half4) : uint
    + {static} hashwide(v:half4) : uint4
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + DebuggerProxy(v:half4)
}
IFormattable <|-- half4
half4 --> "x" half
half4 --> "y" half
half4 --> "z" half
half4 --> "w" half
half4 --> "zero" half4
half4 --> "xxxx" half4
half4 --> "xxxy" half4
half4 --> "xxxz" half4
half4 --> "xxxw" half4
half4 --> "xxyx" half4
half4 --> "xxyy" half4
half4 --> "xxyz" half4
half4 --> "xxyw" half4
half4 --> "xxzx" half4
half4 --> "xxzy" half4
half4 --> "xxzz" half4
half4 --> "xxzw" half4
half4 --> "xxwx" half4
half4 --> "xxwy" half4
half4 --> "xxwz" half4
half4 --> "xxww" half4
half4 --> "xyxx" half4
half4 --> "xyxy" half4
half4 --> "xyxz" half4
half4 --> "xyxw" half4
half4 --> "xyyx" half4
half4 --> "xyyy" half4
half4 --> "xyyz" half4
half4 --> "xyyw" half4
half4 --> "xyzx" half4
half4 --> "xyzy" half4
half4 --> "xyzz" half4
half4 --> "xyzw" half4
half4 --> "xywx" half4
half4 --> "xywy" half4
half4 --> "xywz" half4
half4 --> "xyww" half4
half4 --> "xzxx" half4
half4 --> "xzxy" half4
half4 --> "xzxz" half4
half4 --> "xzxw" half4
half4 --> "xzyx" half4
half4 --> "xzyy" half4
half4 --> "xzyz" half4
half4 --> "xzyw" half4
half4 --> "xzzx" half4
half4 --> "xzzy" half4
half4 --> "xzzz" half4
half4 --> "xzzw" half4
half4 --> "xzwx" half4
half4 --> "xzwy" half4
half4 --> "xzwz" half4
half4 --> "xzww" half4
half4 --> "xwxx" half4
half4 --> "xwxy" half4
half4 --> "xwxz" half4
half4 --> "xwxw" half4
half4 --> "xwyx" half4
half4 --> "xwyy" half4
half4 --> "xwyz" half4
half4 --> "xwyw" half4
half4 --> "xwzx" half4
half4 --> "xwzy" half4
half4 --> "xwzz" half4
half4 --> "xwzw" half4
half4 --> "xwwx" half4
half4 --> "xwwy" half4
half4 --> "xwwz" half4
half4 --> "xwww" half4
half4 --> "yxxx" half4
half4 --> "yxxy" half4
half4 --> "yxxz" half4
half4 --> "yxxw" half4
half4 --> "yxyx" half4
half4 --> "yxyy" half4
half4 --> "yxyz" half4
half4 --> "yxyw" half4
half4 --> "yxzx" half4
half4 --> "yxzy" half4
half4 --> "yxzz" half4
half4 --> "yxzw" half4
half4 --> "yxwx" half4
half4 --> "yxwy" half4
half4 --> "yxwz" half4
half4 --> "yxww" half4
half4 --> "yyxx" half4
half4 --> "yyxy" half4
half4 --> "yyxz" half4
half4 --> "yyxw" half4
half4 --> "yyyx" half4
half4 --> "yyyy" half4
half4 --> "yyyz" half4
half4 --> "yyyw" half4
half4 --> "yyzx" half4
half4 --> "yyzy" half4
half4 --> "yyzz" half4
half4 --> "yyzw" half4
half4 --> "yywx" half4
half4 --> "yywy" half4
half4 --> "yywz" half4
half4 --> "yyww" half4
half4 --> "yzxx" half4
half4 --> "yzxy" half4
half4 --> "yzxz" half4
half4 --> "yzxw" half4
half4 --> "yzyx" half4
half4 --> "yzyy" half4
half4 --> "yzyz" half4
half4 --> "yzyw" half4
half4 --> "yzzx" half4
half4 --> "yzzy" half4
half4 --> "yzzz" half4
half4 --> "yzzw" half4
half4 --> "yzwx" half4
half4 --> "yzwy" half4
half4 --> "yzwz" half4
half4 --> "yzww" half4
half4 --> "ywxx" half4
half4 --> "ywxy" half4
half4 --> "ywxz" half4
half4 --> "ywxw" half4
half4 --> "ywyx" half4
half4 --> "ywyy" half4
half4 --> "ywyz" half4
half4 --> "ywyw" half4
half4 --> "ywzx" half4
half4 --> "ywzy" half4
half4 --> "ywzz" half4
half4 --> "ywzw" half4
half4 --> "ywwx" half4
half4 --> "ywwy" half4
half4 --> "ywwz" half4
half4 --> "ywww" half4
half4 --> "zxxx" half4
half4 --> "zxxy" half4
half4 --> "zxxz" half4
half4 --> "zxxw" half4
half4 --> "zxyx" half4
half4 --> "zxyy" half4
half4 --> "zxyz" half4
half4 --> "zxyw" half4
half4 --> "zxzx" half4
half4 --> "zxzy" half4
half4 --> "zxzz" half4
half4 --> "zxzw" half4
half4 --> "zxwx" half4
half4 --> "zxwy" half4
half4 --> "zxwz" half4
half4 --> "zxww" half4
half4 --> "zyxx" half4
half4 --> "zyxy" half4
half4 --> "zyxz" half4
half4 --> "zyxw" half4
half4 --> "zyyx" half4
half4 --> "zyyy" half4
half4 --> "zyyz" half4
half4 --> "zyyw" half4
half4 --> "zyzx" half4
half4 --> "zyzy" half4
half4 --> "zyzz" half4
half4 --> "zyzw" half4
half4 --> "zywx" half4
half4 --> "zywy" half4
half4 --> "zywz" half4
half4 --> "zyww" half4
half4 --> "zzxx" half4
half4 --> "zzxy" half4
half4 --> "zzxz" half4
half4 --> "zzxw" half4
half4 --> "zzyx" half4
half4 --> "zzyy" half4
half4 --> "zzyz" half4
half4 --> "zzyw" half4
half4 --> "zzzx" half4
half4 --> "zzzy" half4
half4 --> "zzzz" half4
half4 --> "zzzw" half4
half4 --> "zzwx" half4
half4 --> "zzwy" half4
half4 --> "zzwz" half4
half4 --> "zzww" half4
half4 --> "zwxx" half4
half4 --> "zwxy" half4
half4 --> "zwxz" half4
half4 --> "zwxw" half4
half4 --> "zwyx" half4
half4 --> "zwyy" half4
half4 --> "zwyz" half4
half4 --> "zwyw" half4
half4 --> "zwzx" half4
half4 --> "zwzy" half4
half4 --> "zwzz" half4
half4 --> "zwzw" half4
half4 --> "zwwx" half4
half4 --> "zwwy" half4
half4 --> "zwwz" half4
half4 --> "zwww" half4
half4 --> "wxxx" half4
half4 --> "wxxy" half4
half4 --> "wxxz" half4
half4 --> "wxxw" half4
half4 --> "wxyx" half4
half4 --> "wxyy" half4
half4 --> "wxyz" half4
half4 --> "wxyw" half4
half4 --> "wxzx" half4
half4 --> "wxzy" half4
half4 --> "wxzz" half4
half4 --> "wxzw" half4
half4 --> "wxwx" half4
half4 --> "wxwy" half4
half4 --> "wxwz" half4
half4 --> "wxww" half4
half4 --> "wyxx" half4
half4 --> "wyxy" half4
half4 --> "wyxz" half4
half4 --> "wyxw" half4
half4 --> "wyyx" half4
half4 --> "wyyy" half4
half4 --> "wyyz" half4
half4 --> "wyyw" half4
half4 --> "wyzx" half4
half4 --> "wyzy" half4
half4 --> "wyzz" half4
half4 --> "wyzw" half4
half4 --> "wywx" half4
half4 --> "wywy" half4
half4 --> "wywz" half4
half4 --> "wyww" half4
half4 --> "wzxx" half4
half4 --> "wzxy" half4
half4 --> "wzxz" half4
half4 --> "wzxw" half4
half4 --> "wzyx" half4
half4 --> "wzyy" half4
half4 --> "wzyz" half4
half4 --> "wzyw" half4
half4 --> "wzzx" half4
half4 --> "wzzy" half4
half4 --> "wzzz" half4
half4 --> "wzzw" half4
half4 --> "wzwx" half4
half4 --> "wzwy" half4
half4 --> "wzwz" half4
half4 --> "wzww" half4
half4 --> "wwxx" half4
half4 --> "wwxy" half4
half4 --> "wwxz" half4
half4 --> "wwxw" half4
half4 --> "wwyx" half4
half4 --> "wwyy" half4
half4 --> "wwyz" half4
half4 --> "wwyw" half4
half4 --> "wwzx" half4
half4 --> "wwzy" half4
half4 --> "wwzz" half4
half4 --> "wwzw" half4
half4 --> "wwwx" half4
half4 --> "wwwy" half4
half4 --> "wwwz" half4
half4 --> "wwww" half4
half4 --> "xxx" half3
half4 --> "xxy" half3
half4 --> "xxz" half3
half4 --> "xxw" half3
half4 --> "xyx" half3
half4 --> "xyy" half3
half4 --> "xyz" half3
half4 --> "xyw" half3
half4 --> "xzx" half3
half4 --> "xzy" half3
half4 --> "xzz" half3
half4 --> "xzw" half3
half4 --> "xwx" half3
half4 --> "xwy" half3
half4 --> "xwz" half3
half4 --> "xww" half3
half4 --> "yxx" half3
half4 --> "yxy" half3
half4 --> "yxz" half3
half4 --> "yxw" half3
half4 --> "yyx" half3
half4 --> "yyy" half3
half4 --> "yyz" half3
half4 --> "yyw" half3
half4 --> "yzx" half3
half4 --> "yzy" half3
half4 --> "yzz" half3
half4 --> "yzw" half3
half4 --> "ywx" half3
half4 --> "ywy" half3
half4 --> "ywz" half3
half4 --> "yww" half3
half4 --> "zxx" half3
half4 --> "zxy" half3
half4 --> "zxz" half3
half4 --> "zxw" half3
half4 --> "zyx" half3
half4 --> "zyy" half3
half4 --> "zyz" half3
half4 --> "zyw" half3
half4 --> "zzx" half3
half4 --> "zzy" half3
half4 --> "zzz" half3
half4 --> "zzw" half3
half4 --> "zwx" half3
half4 --> "zwy" half3
half4 --> "zwz" half3
half4 --> "zww" half3
half4 --> "wxx" half3
half4 --> "wxy" half3
half4 --> "wxz" half3
half4 --> "wxw" half3
half4 --> "wyx" half3
half4 --> "wyy" half3
half4 --> "wyz" half3
half4 --> "wyw" half3
half4 --> "wzx" half3
half4 --> "wzy" half3
half4 --> "wzz" half3
half4 --> "wzw" half3
half4 --> "wwx" half3
half4 --> "wwy" half3
half4 --> "wwz" half3
half4 --> "www" half3
half4 --> "xx" half2
half4 --> "xy" half2
half4 --> "xz" half2
half4 --> "xw" half2
half4 --> "yx" half2
half4 --> "yy" half2
half4 --> "yz" half2
half4 --> "yw" half2
half4 --> "zx" half2
half4 --> "zy" half2
half4 --> "zz" half2
half4 --> "zw" half2
half4 --> "wx" half2
half4 --> "wy" half2
half4 --> "wz" half2
half4 --> "ww" half2
half4 +-- DebuggerProxy
DebuggerProxy --> "x" half
DebuggerProxy --> "y" half
DebuggerProxy --> "z" half
DebuggerProxy --> "w" half
class int2 <<struct>> {
    + x : int
    + y : int
    + int2(x:int, y:int)
    + int2(xy:int2)
    + int2(v:int)
    + int2(v:bool)
    + int2(v:bool2)
    + int2(v:uint)
    + int2(v:uint2)
    + int2(v:float)
    + int2(v:float2)
    + int2(v:double)
    + int2(v:double2)
    + Equals(rhs:int2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int2(x:int, y:int) : int2
    + {static} int2(xy:int2) : int2
    + {static} int2(v:int) : int2
    + {static} int2(v:bool) : int2
    + {static} int2(v:bool2) : int2
    + {static} int2(v:uint) : int2
    + {static} int2(v:uint2) : int2
    + {static} int2(v:float) : int2
    + {static} int2(v:float2) : int2
    + {static} int2(v:double) : int2
    + {static} int2(v:double2) : int2
    + {static} hash(v:int2) : uint
    + {static} hashwide(v:int2) : uint2
    + {static} shuffle(a:int2, b:int2, x:ShuffleComponent) : int
    + {static} shuffle(a:int2, b:int2, x:ShuffleComponent, y:ShuffleComponent) : int2
    + {static} shuffle(a:int2, b:int2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : int3
    + {static} shuffle(a:int2, b:int2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : int4
    <<internal>> {static} select_shuffle_component(a:int2, b:int2, component:ShuffleComponent) : int
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : int
    + y : int
    + DebuggerProxy(v:int2)
}
IFormattable <|-- int2
int2 --> "zero" int2
int2 --> "xxxx" int4
int2 --> "xxxy" int4
int2 --> "xxyx" int4
int2 --> "xxyy" int4
int2 --> "xyxx" int4
int2 --> "xyxy" int4
int2 --> "xyyx" int4
int2 --> "xyyy" int4
int2 --> "yxxx" int4
int2 --> "yxxy" int4
int2 --> "yxyx" int4
int2 --> "yxyy" int4
int2 --> "yyxx" int4
int2 --> "yyxy" int4
int2 --> "yyyx" int4
int2 --> "yyyy" int4
int2 --> "xxx" int3
int2 --> "xxy" int3
int2 --> "xyx" int3
int2 --> "xyy" int3
int2 --> "yxx" int3
int2 --> "yxy" int3
int2 --> "yyx" int3
int2 --> "yyy" int3
int2 --> "xx" int2
int2 --> "xy" int2
int2 --> "yx" int2
int2 --> "yy" int2
int2 +-- DebuggerProxy
class int2x2 <<struct>> {
    + int2x2(c0:int2, c1:int2)
    + int2x2(m00:int, m01:int, m10:int, m11:int)
    + int2x2(v:int)
    + int2x2(v:bool)
    + int2x2(v:bool2x2)
    + int2x2(v:uint)
    + int2x2(v:uint2x2)
    + int2x2(v:float)
    + int2x2(v:float2x2)
    + int2x2(v:double)
    + int2x2(v:double2x2)
    + Equals(rhs:int2x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int2x2(c0:int2, c1:int2) : int2x2
    + {static} int2x2(m00:int, m01:int, m10:int, m11:int) : int2x2
    + {static} int2x2(v:int) : int2x2
    + {static} int2x2(v:bool) : int2x2
    + {static} int2x2(v:bool2x2) : int2x2
    + {static} int2x2(v:uint) : int2x2
    + {static} int2x2(v:uint2x2) : int2x2
    + {static} int2x2(v:float) : int2x2
    + {static} int2x2(v:float2x2) : int2x2
    + {static} int2x2(v:double) : int2x2
    + {static} int2x2(v:double2x2) : int2x2
    + {static} transpose(v:int2x2) : int2x2
    + {static} determinant(m:int2x2) : int
    + {static} hash(v:int2x2) : uint
    + {static} hashwide(v:int2x2) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int2x2
int2x2 --> "c0" int2
int2x2 --> "c1" int2
int2x2 o-> "identity" int2x2
int2x2 --> "zero" int2x2
class int2x3 <<struct>> {
    + int2x3(c0:int2, c1:int2, c2:int2)
    + int2x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int)
    + int2x3(v:int)
    + int2x3(v:bool)
    + int2x3(v:bool2x3)
    + int2x3(v:uint)
    + int2x3(v:uint2x3)
    + int2x3(v:float)
    + int2x3(v:float2x3)
    + int2x3(v:double)
    + int2x3(v:double2x3)
    + Equals(rhs:int2x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int2x3(c0:int2, c1:int2, c2:int2) : int2x3
    + {static} int2x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int) : int2x3
    + {static} int2x3(v:int) : int2x3
    + {static} int2x3(v:bool) : int2x3
    + {static} int2x3(v:bool2x3) : int2x3
    + {static} int2x3(v:uint) : int2x3
    + {static} int2x3(v:uint2x3) : int2x3
    + {static} int2x3(v:float) : int2x3
    + {static} int2x3(v:float2x3) : int2x3
    + {static} int2x3(v:double) : int2x3
    + {static} int2x3(v:double2x3) : int2x3
    + {static} transpose(v:int2x3) : int3x2
    + {static} hash(v:int2x3) : uint
    + {static} hashwide(v:int2x3) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int2x3
int2x3 --> "c0" int2
int2x3 --> "c1" int2
int2x3 --> "c2" int2
int2x3 --> "zero" int2x3
class int2x4 <<struct>> {
    + int2x4(c0:int2, c1:int2, c2:int2, c3:int2)
    + int2x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int)
    + int2x4(v:int)
    + int2x4(v:bool)
    + int2x4(v:bool2x4)
    + int2x4(v:uint)
    + int2x4(v:uint2x4)
    + int2x4(v:float)
    + int2x4(v:float2x4)
    + int2x4(v:double)
    + int2x4(v:double2x4)
    + Equals(rhs:int2x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int2x4(c0:int2, c1:int2, c2:int2, c3:int2) : int2x4
    + {static} int2x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int) : int2x4
    + {static} int2x4(v:int) : int2x4
    + {static} int2x4(v:bool) : int2x4
    + {static} int2x4(v:bool2x4) : int2x4
    + {static} int2x4(v:uint) : int2x4
    + {static} int2x4(v:uint2x4) : int2x4
    + {static} int2x4(v:float) : int2x4
    + {static} int2x4(v:float2x4) : int2x4
    + {static} int2x4(v:double) : int2x4
    + {static} int2x4(v:double2x4) : int2x4
    + {static} transpose(v:int2x4) : int4x2
    + {static} hash(v:int2x4) : uint
    + {static} hashwide(v:int2x4) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int2x4
int2x4 --> "c0" int2
int2x4 --> "c1" int2
int2x4 --> "c2" int2
int2x4 --> "c3" int2
int2x4 --> "zero" int2x4
class int3 <<struct>> {
    + x : int
    + y : int
    + z : int
    + int3(x:int, y:int, z:int)
    + int3(x:int, yz:int2)
    + int3(xy:int2, z:int)
    + int3(xyz:int3)
    + int3(v:int)
    + int3(v:bool)
    + int3(v:bool3)
    + int3(v:uint)
    + int3(v:uint3)
    + int3(v:float)
    + int3(v:float3)
    + int3(v:double)
    + int3(v:double3)
    + Equals(rhs:int3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int3(x:int, y:int, z:int) : int3
    + {static} int3(x:int, yz:int2) : int3
    + {static} int3(xy:int2, z:int) : int3
    + {static} int3(xyz:int3) : int3
    + {static} int3(v:int) : int3
    + {static} int3(v:bool) : int3
    + {static} int3(v:bool3) : int3
    + {static} int3(v:uint) : int3
    + {static} int3(v:uint3) : int3
    + {static} int3(v:float) : int3
    + {static} int3(v:float3) : int3
    + {static} int3(v:double) : int3
    + {static} int3(v:double3) : int3
    + {static} hash(v:int3) : uint
    + {static} hashwide(v:int3) : uint3
    + {static} shuffle(a:int3, b:int3, x:ShuffleComponent) : int
    + {static} shuffle(a:int3, b:int3, x:ShuffleComponent, y:ShuffleComponent) : int2
    + {static} shuffle(a:int3, b:int3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : int3
    + {static} shuffle(a:int3, b:int3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : int4
    <<internal>> {static} select_shuffle_component(a:int3, b:int3, component:ShuffleComponent) : int
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : int
    + y : int
    + z : int
    + DebuggerProxy(v:int3)
}
IFormattable <|-- int3
int3 --> "zero" int3
int3 --> "xxxx" int4
int3 --> "xxxy" int4
int3 --> "xxxz" int4
int3 --> "xxyx" int4
int3 --> "xxyy" int4
int3 --> "xxyz" int4
int3 --> "xxzx" int4
int3 --> "xxzy" int4
int3 --> "xxzz" int4
int3 --> "xyxx" int4
int3 --> "xyxy" int4
int3 --> "xyxz" int4
int3 --> "xyyx" int4
int3 --> "xyyy" int4
int3 --> "xyyz" int4
int3 --> "xyzx" int4
int3 --> "xyzy" int4
int3 --> "xyzz" int4
int3 --> "xzxx" int4
int3 --> "xzxy" int4
int3 --> "xzxz" int4
int3 --> "xzyx" int4
int3 --> "xzyy" int4
int3 --> "xzyz" int4
int3 --> "xzzx" int4
int3 --> "xzzy" int4
int3 --> "xzzz" int4
int3 --> "yxxx" int4
int3 --> "yxxy" int4
int3 --> "yxxz" int4
int3 --> "yxyx" int4
int3 --> "yxyy" int4
int3 --> "yxyz" int4
int3 --> "yxzx" int4
int3 --> "yxzy" int4
int3 --> "yxzz" int4
int3 --> "yyxx" int4
int3 --> "yyxy" int4
int3 --> "yyxz" int4
int3 --> "yyyx" int4
int3 --> "yyyy" int4
int3 --> "yyyz" int4
int3 --> "yyzx" int4
int3 --> "yyzy" int4
int3 --> "yyzz" int4
int3 --> "yzxx" int4
int3 --> "yzxy" int4
int3 --> "yzxz" int4
int3 --> "yzyx" int4
int3 --> "yzyy" int4
int3 --> "yzyz" int4
int3 --> "yzzx" int4
int3 --> "yzzy" int4
int3 --> "yzzz" int4
int3 --> "zxxx" int4
int3 --> "zxxy" int4
int3 --> "zxxz" int4
int3 --> "zxyx" int4
int3 --> "zxyy" int4
int3 --> "zxyz" int4
int3 --> "zxzx" int4
int3 --> "zxzy" int4
int3 --> "zxzz" int4
int3 --> "zyxx" int4
int3 --> "zyxy" int4
int3 --> "zyxz" int4
int3 --> "zyyx" int4
int3 --> "zyyy" int4
int3 --> "zyyz" int4
int3 --> "zyzx" int4
int3 --> "zyzy" int4
int3 --> "zyzz" int4
int3 --> "zzxx" int4
int3 --> "zzxy" int4
int3 --> "zzxz" int4
int3 --> "zzyx" int4
int3 --> "zzyy" int4
int3 --> "zzyz" int4
int3 --> "zzzx" int4
int3 --> "zzzy" int4
int3 --> "zzzz" int4
int3 --> "xxx" int3
int3 --> "xxy" int3
int3 --> "xxz" int3
int3 --> "xyx" int3
int3 --> "xyy" int3
int3 --> "xyz" int3
int3 --> "xzx" int3
int3 --> "xzy" int3
int3 --> "xzz" int3
int3 --> "yxx" int3
int3 --> "yxy" int3
int3 --> "yxz" int3
int3 --> "yyx" int3
int3 --> "yyy" int3
int3 --> "yyz" int3
int3 --> "yzx" int3
int3 --> "yzy" int3
int3 --> "yzz" int3
int3 --> "zxx" int3
int3 --> "zxy" int3
int3 --> "zxz" int3
int3 --> "zyx" int3
int3 --> "zyy" int3
int3 --> "zyz" int3
int3 --> "zzx" int3
int3 --> "zzy" int3
int3 --> "zzz" int3
int3 --> "xx" int2
int3 --> "xy" int2
int3 --> "xz" int2
int3 --> "yx" int2
int3 --> "yy" int2
int3 --> "yz" int2
int3 --> "zx" int2
int3 --> "zy" int2
int3 --> "zz" int2
int3 +-- DebuggerProxy
class int3x2 <<struct>> {
    + int3x2(c0:int3, c1:int3)
    + int3x2(m00:int, m01:int, m10:int, m11:int, m20:int, m21:int)
    + int3x2(v:int)
    + int3x2(v:bool)
    + int3x2(v:bool3x2)
    + int3x2(v:uint)
    + int3x2(v:uint3x2)
    + int3x2(v:float)
    + int3x2(v:float3x2)
    + int3x2(v:double)
    + int3x2(v:double3x2)
    + Equals(rhs:int3x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int3x2(c0:int3, c1:int3) : int3x2
    + {static} int3x2(m00:int, m01:int, m10:int, m11:int, m20:int, m21:int) : int3x2
    + {static} int3x2(v:int) : int3x2
    + {static} int3x2(v:bool) : int3x2
    + {static} int3x2(v:bool3x2) : int3x2
    + {static} int3x2(v:uint) : int3x2
    + {static} int3x2(v:uint3x2) : int3x2
    + {static} int3x2(v:float) : int3x2
    + {static} int3x2(v:float3x2) : int3x2
    + {static} int3x2(v:double) : int3x2
    + {static} int3x2(v:double3x2) : int3x2
    + {static} transpose(v:int3x2) : int2x3
    + {static} hash(v:int3x2) : uint
    + {static} hashwide(v:int3x2) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int3x2
int3x2 --> "c0" int3
int3x2 --> "c1" int3
int3x2 --> "zero" int3x2
class int3x3 <<struct>> {
    + int3x3(c0:int3, c1:int3, c2:int3)
    + int3x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int, m20:int, m21:int, m22:int)
    + int3x3(v:int)
    + int3x3(v:bool)
    + int3x3(v:bool3x3)
    + int3x3(v:uint)
    + int3x3(v:uint3x3)
    + int3x3(v:float)
    + int3x3(v:float3x3)
    + int3x3(v:double)
    + int3x3(v:double3x3)
    + Equals(rhs:int3x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int3x3(c0:int3, c1:int3, c2:int3) : int3x3
    + {static} int3x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int, m20:int, m21:int, m22:int) : int3x3
    + {static} int3x3(v:int) : int3x3
    + {static} int3x3(v:bool) : int3x3
    + {static} int3x3(v:bool3x3) : int3x3
    + {static} int3x3(v:uint) : int3x3
    + {static} int3x3(v:uint3x3) : int3x3
    + {static} int3x3(v:float) : int3x3
    + {static} int3x3(v:float3x3) : int3x3
    + {static} int3x3(v:double) : int3x3
    + {static} int3x3(v:double3x3) : int3x3
    + {static} transpose(v:int3x3) : int3x3
    + {static} determinant(m:int3x3) : int
    + {static} hash(v:int3x3) : uint
    + {static} hashwide(v:int3x3) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int3x3
int3x3 --> "c0" int3
int3x3 --> "c1" int3
int3x3 --> "c2" int3
int3x3 o-> "identity" int3x3
int3x3 --> "zero" int3x3
class int3x4 <<struct>> {
    + int3x4(c0:int3, c1:int3, c2:int3, c3:int3)
    + int3x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int, m20:int, m21:int, m22:int, m23:int)
    + int3x4(v:int)
    + int3x4(v:bool)
    + int3x4(v:bool3x4)
    + int3x4(v:uint)
    + int3x4(v:uint3x4)
    + int3x4(v:float)
    + int3x4(v:float3x4)
    + int3x4(v:double)
    + int3x4(v:double3x4)
    + Equals(rhs:int3x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int3x4(c0:int3, c1:int3, c2:int3, c3:int3) : int3x4
    + {static} int3x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int, m20:int, m21:int, m22:int, m23:int) : int3x4
    + {static} int3x4(v:int) : int3x4
    + {static} int3x4(v:bool) : int3x4
    + {static} int3x4(v:bool3x4) : int3x4
    + {static} int3x4(v:uint) : int3x4
    + {static} int3x4(v:uint3x4) : int3x4
    + {static} int3x4(v:float) : int3x4
    + {static} int3x4(v:float3x4) : int3x4
    + {static} int3x4(v:double) : int3x4
    + {static} int3x4(v:double3x4) : int3x4
    + {static} transpose(v:int3x4) : int4x3
    + {static} hash(v:int3x4) : uint
    + {static} hashwide(v:int3x4) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int3x4
int3x4 --> "c0" int3
int3x4 --> "c1" int3
int3x4 --> "c2" int3
int3x4 --> "c3" int3
int3x4 --> "zero" int3x4
class int4 <<struct>> {
    + x : int
    + y : int
    + z : int
    + w : int
    + int4(x:int, y:int, z:int, w:int)
    + int4(x:int, y:int, zw:int2)
    + int4(x:int, yz:int2, w:int)
    + int4(x:int, yzw:int3)
    + int4(xy:int2, z:int, w:int)
    + int4(xy:int2, zw:int2)
    + int4(xyz:int3, w:int)
    + int4(xyzw:int4)
    + int4(v:int)
    + int4(v:bool)
    + int4(v:bool4)
    + int4(v:uint)
    + int4(v:uint4)
    + int4(v:float)
    + int4(v:float4)
    + int4(v:double)
    + int4(v:double4)
    + Equals(rhs:int4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int4(x:int, y:int, z:int, w:int) : int4
    + {static} int4(x:int, y:int, zw:int2) : int4
    + {static} int4(x:int, yz:int2, w:int) : int4
    + {static} int4(x:int, yzw:int3) : int4
    + {static} int4(xy:int2, z:int, w:int) : int4
    + {static} int4(xy:int2, zw:int2) : int4
    + {static} int4(xyz:int3, w:int) : int4
    + {static} int4(xyzw:int4) : int4
    + {static} int4(v:int) : int4
    + {static} int4(v:bool) : int4
    + {static} int4(v:bool4) : int4
    + {static} int4(v:uint) : int4
    + {static} int4(v:uint4) : int4
    + {static} int4(v:float) : int4
    + {static} int4(v:float4) : int4
    + {static} int4(v:double) : int4
    + {static} int4(v:double4) : int4
    + {static} hash(v:int4) : uint
    + {static} hashwide(v:int4) : uint4
    + {static} shuffle(a:int4, b:int4, x:ShuffleComponent) : int
    + {static} shuffle(a:int4, b:int4, x:ShuffleComponent, y:ShuffleComponent) : int2
    + {static} shuffle(a:int4, b:int4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : int3
    + {static} shuffle(a:int4, b:int4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : int4
    <<internal>> {static} select_shuffle_component(a:int4, b:int4, component:ShuffleComponent) : int
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : int
    + y : int
    + z : int
    + w : int
    + DebuggerProxy(v:int4)
}
IFormattable <|-- int4
int4 --> "zero" int4
int4 --> "xxxx" int4
int4 --> "xxxy" int4
int4 --> "xxxz" int4
int4 --> "xxxw" int4
int4 --> "xxyx" int4
int4 --> "xxyy" int4
int4 --> "xxyz" int4
int4 --> "xxyw" int4
int4 --> "xxzx" int4
int4 --> "xxzy" int4
int4 --> "xxzz" int4
int4 --> "xxzw" int4
int4 --> "xxwx" int4
int4 --> "xxwy" int4
int4 --> "xxwz" int4
int4 --> "xxww" int4
int4 --> "xyxx" int4
int4 --> "xyxy" int4
int4 --> "xyxz" int4
int4 --> "xyxw" int4
int4 --> "xyyx" int4
int4 --> "xyyy" int4
int4 --> "xyyz" int4
int4 --> "xyyw" int4
int4 --> "xyzx" int4
int4 --> "xyzy" int4
int4 --> "xyzz" int4
int4 --> "xyzw" int4
int4 --> "xywx" int4
int4 --> "xywy" int4
int4 --> "xywz" int4
int4 --> "xyww" int4
int4 --> "xzxx" int4
int4 --> "xzxy" int4
int4 --> "xzxz" int4
int4 --> "xzxw" int4
int4 --> "xzyx" int4
int4 --> "xzyy" int4
int4 --> "xzyz" int4
int4 --> "xzyw" int4
int4 --> "xzzx" int4
int4 --> "xzzy" int4
int4 --> "xzzz" int4
int4 --> "xzzw" int4
int4 --> "xzwx" int4
int4 --> "xzwy" int4
int4 --> "xzwz" int4
int4 --> "xzww" int4
int4 --> "xwxx" int4
int4 --> "xwxy" int4
int4 --> "xwxz" int4
int4 --> "xwxw" int4
int4 --> "xwyx" int4
int4 --> "xwyy" int4
int4 --> "xwyz" int4
int4 --> "xwyw" int4
int4 --> "xwzx" int4
int4 --> "xwzy" int4
int4 --> "xwzz" int4
int4 --> "xwzw" int4
int4 --> "xwwx" int4
int4 --> "xwwy" int4
int4 --> "xwwz" int4
int4 --> "xwww" int4
int4 --> "yxxx" int4
int4 --> "yxxy" int4
int4 --> "yxxz" int4
int4 --> "yxxw" int4
int4 --> "yxyx" int4
int4 --> "yxyy" int4
int4 --> "yxyz" int4
int4 --> "yxyw" int4
int4 --> "yxzx" int4
int4 --> "yxzy" int4
int4 --> "yxzz" int4
int4 --> "yxzw" int4
int4 --> "yxwx" int4
int4 --> "yxwy" int4
int4 --> "yxwz" int4
int4 --> "yxww" int4
int4 --> "yyxx" int4
int4 --> "yyxy" int4
int4 --> "yyxz" int4
int4 --> "yyxw" int4
int4 --> "yyyx" int4
int4 --> "yyyy" int4
int4 --> "yyyz" int4
int4 --> "yyyw" int4
int4 --> "yyzx" int4
int4 --> "yyzy" int4
int4 --> "yyzz" int4
int4 --> "yyzw" int4
int4 --> "yywx" int4
int4 --> "yywy" int4
int4 --> "yywz" int4
int4 --> "yyww" int4
int4 --> "yzxx" int4
int4 --> "yzxy" int4
int4 --> "yzxz" int4
int4 --> "yzxw" int4
int4 --> "yzyx" int4
int4 --> "yzyy" int4
int4 --> "yzyz" int4
int4 --> "yzyw" int4
int4 --> "yzzx" int4
int4 --> "yzzy" int4
int4 --> "yzzz" int4
int4 --> "yzzw" int4
int4 --> "yzwx" int4
int4 --> "yzwy" int4
int4 --> "yzwz" int4
int4 --> "yzww" int4
int4 --> "ywxx" int4
int4 --> "ywxy" int4
int4 --> "ywxz" int4
int4 --> "ywxw" int4
int4 --> "ywyx" int4
int4 --> "ywyy" int4
int4 --> "ywyz" int4
int4 --> "ywyw" int4
int4 --> "ywzx" int4
int4 --> "ywzy" int4
int4 --> "ywzz" int4
int4 --> "ywzw" int4
int4 --> "ywwx" int4
int4 --> "ywwy" int4
int4 --> "ywwz" int4
int4 --> "ywww" int4
int4 --> "zxxx" int4
int4 --> "zxxy" int4
int4 --> "zxxz" int4
int4 --> "zxxw" int4
int4 --> "zxyx" int4
int4 --> "zxyy" int4
int4 --> "zxyz" int4
int4 --> "zxyw" int4
int4 --> "zxzx" int4
int4 --> "zxzy" int4
int4 --> "zxzz" int4
int4 --> "zxzw" int4
int4 --> "zxwx" int4
int4 --> "zxwy" int4
int4 --> "zxwz" int4
int4 --> "zxww" int4
int4 --> "zyxx" int4
int4 --> "zyxy" int4
int4 --> "zyxz" int4
int4 --> "zyxw" int4
int4 --> "zyyx" int4
int4 --> "zyyy" int4
int4 --> "zyyz" int4
int4 --> "zyyw" int4
int4 --> "zyzx" int4
int4 --> "zyzy" int4
int4 --> "zyzz" int4
int4 --> "zyzw" int4
int4 --> "zywx" int4
int4 --> "zywy" int4
int4 --> "zywz" int4
int4 --> "zyww" int4
int4 --> "zzxx" int4
int4 --> "zzxy" int4
int4 --> "zzxz" int4
int4 --> "zzxw" int4
int4 --> "zzyx" int4
int4 --> "zzyy" int4
int4 --> "zzyz" int4
int4 --> "zzyw" int4
int4 --> "zzzx" int4
int4 --> "zzzy" int4
int4 --> "zzzz" int4
int4 --> "zzzw" int4
int4 --> "zzwx" int4
int4 --> "zzwy" int4
int4 --> "zzwz" int4
int4 --> "zzww" int4
int4 --> "zwxx" int4
int4 --> "zwxy" int4
int4 --> "zwxz" int4
int4 --> "zwxw" int4
int4 --> "zwyx" int4
int4 --> "zwyy" int4
int4 --> "zwyz" int4
int4 --> "zwyw" int4
int4 --> "zwzx" int4
int4 --> "zwzy" int4
int4 --> "zwzz" int4
int4 --> "zwzw" int4
int4 --> "zwwx" int4
int4 --> "zwwy" int4
int4 --> "zwwz" int4
int4 --> "zwww" int4
int4 --> "wxxx" int4
int4 --> "wxxy" int4
int4 --> "wxxz" int4
int4 --> "wxxw" int4
int4 --> "wxyx" int4
int4 --> "wxyy" int4
int4 --> "wxyz" int4
int4 --> "wxyw" int4
int4 --> "wxzx" int4
int4 --> "wxzy" int4
int4 --> "wxzz" int4
int4 --> "wxzw" int4
int4 --> "wxwx" int4
int4 --> "wxwy" int4
int4 --> "wxwz" int4
int4 --> "wxww" int4
int4 --> "wyxx" int4
int4 --> "wyxy" int4
int4 --> "wyxz" int4
int4 --> "wyxw" int4
int4 --> "wyyx" int4
int4 --> "wyyy" int4
int4 --> "wyyz" int4
int4 --> "wyyw" int4
int4 --> "wyzx" int4
int4 --> "wyzy" int4
int4 --> "wyzz" int4
int4 --> "wyzw" int4
int4 --> "wywx" int4
int4 --> "wywy" int4
int4 --> "wywz" int4
int4 --> "wyww" int4
int4 --> "wzxx" int4
int4 --> "wzxy" int4
int4 --> "wzxz" int4
int4 --> "wzxw" int4
int4 --> "wzyx" int4
int4 --> "wzyy" int4
int4 --> "wzyz" int4
int4 --> "wzyw" int4
int4 --> "wzzx" int4
int4 --> "wzzy" int4
int4 --> "wzzz" int4
int4 --> "wzzw" int4
int4 --> "wzwx" int4
int4 --> "wzwy" int4
int4 --> "wzwz" int4
int4 --> "wzww" int4
int4 --> "wwxx" int4
int4 --> "wwxy" int4
int4 --> "wwxz" int4
int4 --> "wwxw" int4
int4 --> "wwyx" int4
int4 --> "wwyy" int4
int4 --> "wwyz" int4
int4 --> "wwyw" int4
int4 --> "wwzx" int4
int4 --> "wwzy" int4
int4 --> "wwzz" int4
int4 --> "wwzw" int4
int4 --> "wwwx" int4
int4 --> "wwwy" int4
int4 --> "wwwz" int4
int4 --> "wwww" int4
int4 --> "xxx" int3
int4 --> "xxy" int3
int4 --> "xxz" int3
int4 --> "xxw" int3
int4 --> "xyx" int3
int4 --> "xyy" int3
int4 --> "xyz" int3
int4 --> "xyw" int3
int4 --> "xzx" int3
int4 --> "xzy" int3
int4 --> "xzz" int3
int4 --> "xzw" int3
int4 --> "xwx" int3
int4 --> "xwy" int3
int4 --> "xwz" int3
int4 --> "xww" int3
int4 --> "yxx" int3
int4 --> "yxy" int3
int4 --> "yxz" int3
int4 --> "yxw" int3
int4 --> "yyx" int3
int4 --> "yyy" int3
int4 --> "yyz" int3
int4 --> "yyw" int3
int4 --> "yzx" int3
int4 --> "yzy" int3
int4 --> "yzz" int3
int4 --> "yzw" int3
int4 --> "ywx" int3
int4 --> "ywy" int3
int4 --> "ywz" int3
int4 --> "yww" int3
int4 --> "zxx" int3
int4 --> "zxy" int3
int4 --> "zxz" int3
int4 --> "zxw" int3
int4 --> "zyx" int3
int4 --> "zyy" int3
int4 --> "zyz" int3
int4 --> "zyw" int3
int4 --> "zzx" int3
int4 --> "zzy" int3
int4 --> "zzz" int3
int4 --> "zzw" int3
int4 --> "zwx" int3
int4 --> "zwy" int3
int4 --> "zwz" int3
int4 --> "zww" int3
int4 --> "wxx" int3
int4 --> "wxy" int3
int4 --> "wxz" int3
int4 --> "wxw" int3
int4 --> "wyx" int3
int4 --> "wyy" int3
int4 --> "wyz" int3
int4 --> "wyw" int3
int4 --> "wzx" int3
int4 --> "wzy" int3
int4 --> "wzz" int3
int4 --> "wzw" int3
int4 --> "wwx" int3
int4 --> "wwy" int3
int4 --> "wwz" int3
int4 --> "www" int3
int4 --> "xx" int2
int4 --> "xy" int2
int4 --> "xz" int2
int4 --> "xw" int2
int4 --> "yx" int2
int4 --> "yy" int2
int4 --> "yz" int2
int4 --> "yw" int2
int4 --> "zx" int2
int4 --> "zy" int2
int4 --> "zz" int2
int4 --> "zw" int2
int4 --> "wx" int2
int4 --> "wy" int2
int4 --> "wz" int2
int4 --> "ww" int2
int4 +-- DebuggerProxy
class int4x2 <<struct>> {
    + int4x2(c0:int4, c1:int4)
    + int4x2(m00:int, m01:int, m10:int, m11:int, m20:int, m21:int, m30:int, m31:int)
    + int4x2(v:int)
    + int4x2(v:bool)
    + int4x2(v:bool4x2)
    + int4x2(v:uint)
    + int4x2(v:uint4x2)
    + int4x2(v:float)
    + int4x2(v:float4x2)
    + int4x2(v:double)
    + int4x2(v:double4x2)
    + Equals(rhs:int4x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int4x2(c0:int4, c1:int4) : int4x2
    + {static} int4x2(m00:int, m01:int, m10:int, m11:int, m20:int, m21:int, m30:int, m31:int) : int4x2
    + {static} int4x2(v:int) : int4x2
    + {static} int4x2(v:bool) : int4x2
    + {static} int4x2(v:bool4x2) : int4x2
    + {static} int4x2(v:uint) : int4x2
    + {static} int4x2(v:uint4x2) : int4x2
    + {static} int4x2(v:float) : int4x2
    + {static} int4x2(v:float4x2) : int4x2
    + {static} int4x2(v:double) : int4x2
    + {static} int4x2(v:double4x2) : int4x2
    + {static} transpose(v:int4x2) : int2x4
    + {static} hash(v:int4x2) : uint
    + {static} hashwide(v:int4x2) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int4x2
int4x2 --> "c0" int4
int4x2 --> "c1" int4
int4x2 --> "zero" int4x2
class int4x3 <<struct>> {
    + int4x3(c0:int4, c1:int4, c2:int4)
    + int4x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int, m20:int, m21:int, m22:int, m30:int, m31:int, m32:int)
    + int4x3(v:int)
    + int4x3(v:bool)
    + int4x3(v:bool4x3)
    + int4x3(v:uint)
    + int4x3(v:uint4x3)
    + int4x3(v:float)
    + int4x3(v:float4x3)
    + int4x3(v:double)
    + int4x3(v:double4x3)
    + Equals(rhs:int4x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int4x3(c0:int4, c1:int4, c2:int4) : int4x3
    + {static} int4x3(m00:int, m01:int, m02:int, m10:int, m11:int, m12:int, m20:int, m21:int, m22:int, m30:int, m31:int, m32:int) : int4x3
    + {static} int4x3(v:int) : int4x3
    + {static} int4x3(v:bool) : int4x3
    + {static} int4x3(v:bool4x3) : int4x3
    + {static} int4x3(v:uint) : int4x3
    + {static} int4x3(v:uint4x3) : int4x3
    + {static} int4x3(v:float) : int4x3
    + {static} int4x3(v:float4x3) : int4x3
    + {static} int4x3(v:double) : int4x3
    + {static} int4x3(v:double4x3) : int4x3
    + {static} transpose(v:int4x3) : int3x4
    + {static} hash(v:int4x3) : uint
    + {static} hashwide(v:int4x3) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int4x3
int4x3 --> "c0" int4
int4x3 --> "c1" int4
int4x3 --> "c2" int4
int4x3 --> "zero" int4x3
class int4x4 <<struct>> {
    + int4x4(c0:int4, c1:int4, c2:int4, c3:int4)
    + int4x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int, m20:int, m21:int, m22:int, m23:int, m30:int, m31:int, m32:int, m33:int)
    + int4x4(v:int)
    + int4x4(v:bool)
    + int4x4(v:bool4x4)
    + int4x4(v:uint)
    + int4x4(v:uint4x4)
    + int4x4(v:float)
    + int4x4(v:float4x4)
    + int4x4(v:double)
    + int4x4(v:double4x4)
    + Equals(rhs:int4x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} int4x4(c0:int4, c1:int4, c2:int4, c3:int4) : int4x4
    + {static} int4x4(m00:int, m01:int, m02:int, m03:int, m10:int, m11:int, m12:int, m13:int, m20:int, m21:int, m22:int, m23:int, m30:int, m31:int, m32:int, m33:int) : int4x4
    + {static} int4x4(v:int) : int4x4
    + {static} int4x4(v:bool) : int4x4
    + {static} int4x4(v:bool4x4) : int4x4
    + {static} int4x4(v:uint) : int4x4
    + {static} int4x4(v:uint4x4) : int4x4
    + {static} int4x4(v:float) : int4x4
    + {static} int4x4(v:float4x4) : int4x4
    + {static} int4x4(v:double) : int4x4
    + {static} int4x4(v:double4x4) : int4x4
    + {static} transpose(v:int4x4) : int4x4
    + {static} determinant(m:int4x4) : int
    + {static} hash(v:int4x4) : uint
    + {static} hashwide(v:int4x4) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- int4x4
int4x4 --> "c0" int4
int4x4 --> "c1" int4
int4x4 --> "c2" int4
int4x4 --> "c3" int4
int4x4 o-> "identity" int4x4
int4x4 --> "zero" int4x4
class math <<static>> <<partial>> {
    + <<const>> E_DBL : double = 2.71828182845904523536
    + <<const>> LOG2E_DBL : double = 1.44269504088896340736
    + <<const>> LOG10E_DBL : double = 0.434294481903251827651
    + <<const>> LN2_DBL : double = 0.693147180559945309417
    + <<const>> LN10_DBL : double = 2.30258509299404568402
    + <<const>> PI_DBL : double = 3.14159265358979323846
    + <<const>> SQRT2_DBL : double = 1.41421356237309504880
    + <<const>> FLT_MIN_NORMAL : float = 1.175494351e-38F
    + <<const>> DBL_MIN_NORMAL : double = 2.2250738585072014e-308
    + <<const>> E : float
    + <<const>> LOG2E : float
    + <<const>> LOG10E : float
    + <<const>> LN2 : float
    + <<const>> LN10 : float
    + <<const>> PI : float
    + <<const>> SQRT2 : float
    + {static} asint(x:uint) : int
    + {static} asint(x:uint2) : int2
    + {static} asint(x:uint3) : int3
    + {static} asint(x:uint4) : int4
    + {static} asint(x:float) : int
    + {static} asint(x:float2) : int2
    + {static} asint(x:float3) : int3
    + {static} asint(x:float4) : int4
    + {static} asuint(x:int) : uint
    + {static} asuint(x:int2) : uint2
    + {static} asuint(x:int3) : uint3
    + {static} asuint(x:int4) : uint4
    + {static} asuint(x:float) : uint
    + {static} asuint(x:float2) : uint2
    + {static} asuint(x:float3) : uint3
    + {static} asuint(x:float4) : uint4
    + {static} aslong(x:ulong) : long
    + {static} aslong(x:double) : long
    + {static} asulong(x:long) : ulong
    + {static} asulong(x:double) : ulong
    + {static} asfloat(x:int) : float
    + {static} asfloat(x:int2) : float2
    + {static} asfloat(x:int3) : float3
    + {static} asfloat(x:int4) : float4
    + {static} asfloat(x:uint) : float
    + {static} asfloat(x:uint2) : float2
    + {static} asfloat(x:uint3) : float3
    + {static} asfloat(x:uint4) : float4
    + {static} bitmask(value:bool4) : int
    + {static} asdouble(x:long) : double
    + {static} asdouble(x:ulong) : double
    + {static} isfinite(x:float) : bool
    + {static} isfinite(x:float2) : bool2
    + {static} isfinite(x:float3) : bool3
    + {static} isfinite(x:float4) : bool4
    + {static} isfinite(x:double) : bool
    + {static} isfinite(x:double2) : bool2
    + {static} isfinite(x:double3) : bool3
    + {static} isfinite(x:double4) : bool4
    + {static} isinf(x:float) : bool
    + {static} isinf(x:float2) : bool2
    + {static} isinf(x:float3) : bool3
    + {static} isinf(x:float4) : bool4
    + {static} isinf(x:double) : bool
    + {static} isinf(x:double2) : bool2
    + {static} isinf(x:double3) : bool3
    + {static} isinf(x:double4) : bool4
    + {static} isnan(x:float) : bool
    + {static} isnan(x:float2) : bool2
    + {static} isnan(x:float3) : bool3
    + {static} isnan(x:float4) : bool4
    + {static} isnan(x:double) : bool
    + {static} isnan(x:double2) : bool2
    + {static} isnan(x:double3) : bool3
    + {static} isnan(x:double4) : bool4
    + {static} min(x:int, y:int) : int
    + {static} min(x:int2, y:int2) : int2
    + {static} min(x:int3, y:int3) : int3
    + {static} min(x:int4, y:int4) : int4
    + {static} min(x:uint, y:uint) : uint
    + {static} min(x:uint2, y:uint2) : uint2
    + {static} min(x:uint3, y:uint3) : uint3
    + {static} min(x:uint4, y:uint4) : uint4
    + {static} min(x:long, y:long) : long
    + {static} min(x:ulong, y:ulong) : ulong
    + {static} min(x:float, y:float) : float
    + {static} min(x:float2, y:float2) : float2
    + {static} min(x:float3, y:float3) : float3
    + {static} min(x:float4, y:float4) : float4
    + {static} min(x:double, y:double) : double
    + {static} min(x:double2, y:double2) : double2
    + {static} min(x:double3, y:double3) : double3
    + {static} min(x:double4, y:double4) : double4
    + {static} max(x:int, y:int) : int
    + {static} max(x:int2, y:int2) : int2
    + {static} max(x:int3, y:int3) : int3
    + {static} max(x:int4, y:int4) : int4
    + {static} max(x:uint, y:uint) : uint
    + {static} max(x:uint2, y:uint2) : uint2
    + {static} max(x:uint3, y:uint3) : uint3
    + {static} max(x:uint4, y:uint4) : uint4
    + {static} max(x:long, y:long) : long
    + {static} max(x:ulong, y:ulong) : ulong
    + {static} max(x:float, y:float) : float
    + {static} max(x:float2, y:float2) : float2
    + {static} max(x:float3, y:float3) : float3
    + {static} max(x:float4, y:float4) : float4
    + {static} max(x:double, y:double) : double
    + {static} max(x:double2, y:double2) : double2
    + {static} max(x:double3, y:double3) : double3
    + {static} max(x:double4, y:double4) : double4
    + {static} lerp(x:float, y:float, s:float) : float
    + {static} lerp(x:float2, y:float2, s:float) : float2
    + {static} lerp(x:float3, y:float3, s:float) : float3
    + {static} lerp(x:float4, y:float4, s:float) : float4
    + {static} lerp(x:float2, y:float2, s:float2) : float2
    + {static} lerp(x:float3, y:float3, s:float3) : float3
    + {static} lerp(x:float4, y:float4, s:float4) : float4
    + {static} lerp(x:double, y:double, s:double) : double
    + {static} lerp(x:double2, y:double2, s:double) : double2
    + {static} lerp(x:double3, y:double3, s:double) : double3
    + {static} lerp(x:double4, y:double4, s:double) : double4
    + {static} lerp(x:double2, y:double2, s:double2) : double2
    + {static} lerp(x:double3, y:double3, s:double3) : double3
    + {static} lerp(x:double4, y:double4, s:double4) : double4
    + {static} unlerp(a:float, b:float, x:float) : float
    + {static} unlerp(a:float2, b:float2, x:float2) : float2
    + {static} unlerp(a:float3, b:float3, x:float3) : float3
    + {static} unlerp(a:float4, b:float4, x:float4) : float4
    + {static} unlerp(a:double, b:double, x:double) : double
    + {static} unlerp(a:double2, b:double2, x:double2) : double2
    + {static} unlerp(a:double3, b:double3, x:double3) : double3
    + {static} unlerp(a:double4, b:double4, x:double4) : double4
    + {static} remap(a:float, b:float, c:float, d:float, x:float) : float
    + {static} remap(a:float2, b:float2, c:float2, d:float2, x:float2) : float2
    + {static} remap(a:float3, b:float3, c:float3, d:float3, x:float3) : float3
    + {static} remap(a:float4, b:float4, c:float4, d:float4, x:float4) : float4
    + {static} remap(a:double, b:double, c:double, d:double, x:double) : double
    + {static} remap(a:double2, b:double2, c:double2, d:double2, x:double2) : double2
    + {static} remap(a:double3, b:double3, c:double3, d:double3, x:double3) : double3
    + {static} remap(a:double4, b:double4, c:double4, d:double4, x:double4) : double4
    + {static} mad(a:int, b:int, c:int) : int
    + {static} mad(a:int2, b:int2, c:int2) : int2
    + {static} mad(a:int3, b:int3, c:int3) : int3
    + {static} mad(a:int4, b:int4, c:int4) : int4
    + {static} mad(a:uint, b:uint, c:uint) : uint
    + {static} mad(a:uint2, b:uint2, c:uint2) : uint2
    + {static} mad(a:uint3, b:uint3, c:uint3) : uint3
    + {static} mad(a:uint4, b:uint4, c:uint4) : uint4
    + {static} mad(a:long, b:long, c:long) : long
    + {static} mad(a:ulong, b:ulong, c:ulong) : ulong
    + {static} mad(a:float, b:float, c:float) : float
    + {static} mad(a:float2, b:float2, c:float2) : float2
    + {static} mad(a:float3, b:float3, c:float3) : float3
    + {static} mad(a:float4, b:float4, c:float4) : float4
    + {static} mad(a:double, b:double, c:double) : double
    + {static} mad(a:double2, b:double2, c:double2) : double2
    + {static} mad(a:double3, b:double3, c:double3) : double3
    + {static} mad(a:double4, b:double4, c:double4) : double4
    + {static} clamp(x:int, a:int, b:int) : int
    + {static} clamp(x:int2, a:int2, b:int2) : int2
    + {static} clamp(x:int3, a:int3, b:int3) : int3
    + {static} clamp(x:int4, a:int4, b:int4) : int4
    + {static} clamp(x:uint, a:uint, b:uint) : uint
    + {static} clamp(x:uint2, a:uint2, b:uint2) : uint2
    + {static} clamp(x:uint3, a:uint3, b:uint3) : uint3
    + {static} clamp(x:uint4, a:uint4, b:uint4) : uint4
    + {static} clamp(x:long, a:long, b:long) : long
    + {static} clamp(x:ulong, a:ulong, b:ulong) : ulong
    + {static} clamp(x:float, a:float, b:float) : float
    + {static} clamp(x:float2, a:float2, b:float2) : float2
    + {static} clamp(x:float3, a:float3, b:float3) : float3
    + {static} clamp(x:float4, a:float4, b:float4) : float4
    + {static} clamp(x:double, a:double, b:double) : double
    + {static} clamp(x:double2, a:double2, b:double2) : double2
    + {static} clamp(x:double3, a:double3, b:double3) : double3
    + {static} clamp(x:double4, a:double4, b:double4) : double4
    + {static} saturate(x:float) : float
    + {static} saturate(x:float2) : float2
    + {static} saturate(x:float3) : float3
    + {static} saturate(x:float4) : float4
    + {static} saturate(x:double) : double
    + {static} saturate(x:double2) : double2
    + {static} saturate(x:double3) : double3
    + {static} saturate(x:double4) : double4
    + {static} abs(x:int) : int
    + {static} abs(x:int2) : int2
    + {static} abs(x:int3) : int3
    + {static} abs(x:int4) : int4
    + {static} abs(x:long) : long
    + {static} abs(x:float) : float
    + {static} abs(x:float2) : float2
    + {static} abs(x:float3) : float3
    + {static} abs(x:float4) : float4
    + {static} abs(x:double) : double
    + {static} abs(x:double2) : double2
    + {static} abs(x:double3) : double3
    + {static} abs(x:double4) : double4
    + {static} dot(x:int, y:int) : int
    + {static} dot(x:int2, y:int2) : int
    + {static} dot(x:int3, y:int3) : int
    + {static} dot(x:int4, y:int4) : int
    + {static} dot(x:uint, y:uint) : uint
    + {static} dot(x:uint2, y:uint2) : uint
    + {static} dot(x:uint3, y:uint3) : uint
    + {static} dot(x:uint4, y:uint4) : uint
    + {static} dot(x:float, y:float) : float
    + {static} dot(x:float2, y:float2) : float
    + {static} dot(x:float3, y:float3) : float
    + {static} dot(x:float4, y:float4) : float
    + {static} dot(x:double, y:double) : double
    + {static} dot(x:double2, y:double2) : double
    + {static} dot(x:double3, y:double3) : double
    + {static} dot(x:double4, y:double4) : double
    + {static} tan(x:float) : float
    + {static} tan(x:float2) : float2
    + {static} tan(x:float3) : float3
    + {static} tan(x:float4) : float4
    + {static} tan(x:double) : double
    + {static} tan(x:double2) : double2
    + {static} tan(x:double3) : double3
    + {static} tan(x:double4) : double4
    + {static} tanh(x:float) : float
    + {static} tanh(x:float2) : float2
    + {static} tanh(x:float3) : float3
    + {static} tanh(x:float4) : float4
    + {static} tanh(x:double) : double
    + {static} tanh(x:double2) : double2
    + {static} tanh(x:double3) : double3
    + {static} tanh(x:double4) : double4
    + {static} atan(x:float) : float
    + {static} atan(x:float2) : float2
    + {static} atan(x:float3) : float3
    + {static} atan(x:float4) : float4
    + {static} atan(x:double) : double
    + {static} atan(x:double2) : double2
    + {static} atan(x:double3) : double3
    + {static} atan(x:double4) : double4
    + {static} atan2(y:float, x:float) : float
    + {static} atan2(y:float2, x:float2) : float2
    + {static} atan2(y:float3, x:float3) : float3
    + {static} atan2(y:float4, x:float4) : float4
    + {static} atan2(y:double, x:double) : double
    + {static} atan2(y:double2, x:double2) : double2
    + {static} atan2(y:double3, x:double3) : double3
    + {static} atan2(y:double4, x:double4) : double4
    + {static} cos(x:float) : float
    + {static} cos(x:float2) : float2
    + {static} cos(x:float3) : float3
    + {static} cos(x:float4) : float4
    + {static} cos(x:double) : double
    + {static} cos(x:double2) : double2
    + {static} cos(x:double3) : double3
    + {static} cos(x:double4) : double4
    + {static} cosh(x:float) : float
    + {static} cosh(x:float2) : float2
    + {static} cosh(x:float3) : float3
    + {static} cosh(x:float4) : float4
    + {static} cosh(x:double) : double
    + {static} cosh(x:double2) : double2
    + {static} cosh(x:double3) : double3
    + {static} cosh(x:double4) : double4
    + {static} acos(x:float) : float
    + {static} acos(x:float2) : float2
    + {static} acos(x:float3) : float3
    + {static} acos(x:float4) : float4
    + {static} acos(x:double) : double
    + {static} acos(x:double2) : double2
    + {static} acos(x:double3) : double3
    + {static} acos(x:double4) : double4
    + {static} sin(x:float) : float
    + {static} sin(x:float2) : float2
    + {static} sin(x:float3) : float3
    + {static} sin(x:float4) : float4
    + {static} sin(x:double) : double
    + {static} sin(x:double2) : double2
    + {static} sin(x:double3) : double3
    + {static} sin(x:double4) : double4
    + {static} sinh(x:float) : float
    + {static} sinh(x:float2) : float2
    + {static} sinh(x:float3) : float3
    + {static} sinh(x:float4) : float4
    + {static} sinh(x:double) : double
    + {static} sinh(x:double2) : double2
    + {static} sinh(x:double3) : double3
    + {static} sinh(x:double4) : double4
    + {static} asin(x:float) : float
    + {static} asin(x:float2) : float2
    + {static} asin(x:float3) : float3
    + {static} asin(x:float4) : float4
    + {static} asin(x:double) : double
    + {static} asin(x:double2) : double2
    + {static} asin(x:double3) : double3
    + {static} asin(x:double4) : double4
    + {static} floor(x:float) : float
    + {static} floor(x:float2) : float2
    + {static} floor(x:float3) : float3
    + {static} floor(x:float4) : float4
    + {static} floor(x:double) : double
    + {static} floor(x:double2) : double2
    + {static} floor(x:double3) : double3
    + {static} floor(x:double4) : double4
    + {static} ceil(x:float) : float
    + {static} ceil(x:float2) : float2
    + {static} ceil(x:float3) : float3
    + {static} ceil(x:float4) : float4
    + {static} ceil(x:double) : double
    + {static} ceil(x:double2) : double2
    + {static} ceil(x:double3) : double3
    + {static} ceil(x:double4) : double4
    + {static} round(x:float) : float
    + {static} round(x:float2) : float2
    + {static} round(x:float3) : float3
    + {static} round(x:float4) : float4
    + {static} round(x:double) : double
    + {static} round(x:double2) : double2
    + {static} round(x:double3) : double3
    + {static} round(x:double4) : double4
    + {static} trunc(x:float) : float
    + {static} trunc(x:float2) : float2
    + {static} trunc(x:float3) : float3
    + {static} trunc(x:float4) : float4
    + {static} trunc(x:double) : double
    + {static} trunc(x:double2) : double2
    + {static} trunc(x:double3) : double3
    + {static} trunc(x:double4) : double4
    + {static} frac(x:float) : float
    + {static} frac(x:float2) : float2
    + {static} frac(x:float3) : float3
    + {static} frac(x:float4) : float4
    + {static} frac(x:double) : double
    + {static} frac(x:double2) : double2
    + {static} frac(x:double3) : double3
    + {static} frac(x:double4) : double4
    + {static} rcp(x:float) : float
    + {static} rcp(x:float2) : float2
    + {static} rcp(x:float3) : float3
    + {static} rcp(x:float4) : float4
    + {static} rcp(x:double) : double
    + {static} rcp(x:double2) : double2
    + {static} rcp(x:double3) : double3
    + {static} rcp(x:double4) : double4
    + {static} sign(x:float) : float
    + {static} sign(x:float2) : float2
    + {static} sign(x:float3) : float3
    + {static} sign(x:float4) : float4
    + {static} sign(x:double) : double
    + {static} sign(x:double2) : double2
    + {static} sign(x:double3) : double3
    + {static} sign(x:double4) : double4
    + {static} pow(x:float, y:float) : float
    + {static} pow(x:float2, y:float2) : float2
    + {static} pow(x:float3, y:float3) : float3
    + {static} pow(x:float4, y:float4) : float4
    + {static} pow(x:double, y:double) : double
    + {static} pow(x:double2, y:double2) : double2
    + {static} pow(x:double3, y:double3) : double3
    + {static} pow(x:double4, y:double4) : double4
    + {static} exp(x:float) : float
    + {static} exp(x:float2) : float2
    + {static} exp(x:float3) : float3
    + {static} exp(x:float4) : float4
    + {static} exp(x:double) : double
    + {static} exp(x:double2) : double2
    + {static} exp(x:double3) : double3
    + {static} exp(x:double4) : double4
    + {static} exp2(x:float) : float
    + {static} exp2(x:float2) : float2
    + {static} exp2(x:float3) : float3
    + {static} exp2(x:float4) : float4
    + {static} exp2(x:double) : double
    + {static} exp2(x:double2) : double2
    + {static} exp2(x:double3) : double3
    + {static} exp2(x:double4) : double4
    + {static} exp10(x:float) : float
    + {static} exp10(x:float2) : float2
    + {static} exp10(x:float3) : float3
    + {static} exp10(x:float4) : float4
    + {static} exp10(x:double) : double
    + {static} exp10(x:double2) : double2
    + {static} exp10(x:double3) : double3
    + {static} exp10(x:double4) : double4
    + {static} log(x:float) : float
    + {static} log(x:float2) : float2
    + {static} log(x:float3) : float3
    + {static} log(x:float4) : float4
    + {static} log(x:double) : double
    + {static} log(x:double2) : double2
    + {static} log(x:double3) : double3
    + {static} log(x:double4) : double4
    + {static} log2(x:float) : float
    + {static} log2(x:float2) : float2
    + {static} log2(x:float3) : float3
    + {static} log2(x:float4) : float4
    + {static} log2(x:double) : double
    + {static} log2(x:double2) : double2
    + {static} log2(x:double3) : double3
    + {static} log2(x:double4) : double4
    + {static} log10(x:float) : float
    + {static} log10(x:float2) : float2
    + {static} log10(x:float3) : float3
    + {static} log10(x:float4) : float4
    + {static} log10(x:double) : double
    + {static} log10(x:double2) : double2
    + {static} log10(x:double3) : double3
    + {static} log10(x:double4) : double4
    + {static} fmod(x:float, y:float) : float
    + {static} fmod(x:float2, y:float2) : float2
    + {static} fmod(x:float3, y:float3) : float3
    + {static} fmod(x:float4, y:float4) : float4
    + {static} fmod(x:double, y:double) : double
    + {static} fmod(x:double2, y:double2) : double2
    + {static} fmod(x:double3, y:double3) : double3
    + {static} fmod(x:double4, y:double4) : double4
    + {static} modf(x:float, i:float) : float
    + {static} modf(x:float2, i:float2) : float2
    + {static} modf(x:float3, i:float3) : float3
    + {static} modf(x:float4, i:float4) : float4
    + {static} modf(x:double, i:double) : double
    + {static} modf(x:double2, i:double2) : double2
    + {static} modf(x:double3, i:double3) : double3
    + {static} modf(x:double4, i:double4) : double4
    + {static} sqrt(x:float) : float
    + {static} sqrt(x:float2) : float2
    + {static} sqrt(x:float3) : float3
    + {static} sqrt(x:float4) : float4
    + {static} sqrt(x:double) : double
    + {static} sqrt(x:double2) : double2
    + {static} sqrt(x:double3) : double3
    + {static} sqrt(x:double4) : double4
    + {static} rsqrt(x:float) : float
    + {static} rsqrt(x:float2) : float2
    + {static} rsqrt(x:float3) : float3
    + {static} rsqrt(x:float4) : float4
    + {static} rsqrt(x:double) : double
    + {static} rsqrt(x:double2) : double2
    + {static} rsqrt(x:double3) : double3
    + {static} rsqrt(x:double4) : double4
    + {static} normalize(x:float2) : float2
    + {static} normalize(x:float3) : float3
    + {static} normalize(x:float4) : float4
    + {static} normalize(x:double2) : double2
    + {static} normalize(x:double3) : double3
    + {static} normalize(x:double4) : double4
    {static} + normalizesafe(x:float2, defaultvalue:float2) : float2
    {static} + normalizesafe(x:float3, defaultvalue:float3) : float3
    {static} + normalizesafe(x:float4, defaultvalue:float4) : float4
    {static} + normalizesafe(x:double2, defaultvalue:double2) : double2
    {static} + normalizesafe(x:double3, defaultvalue:double3) : double3
    {static} + normalizesafe(x:double4, defaultvalue:double4) : double4
    + {static} length(x:float) : float
    + {static} length(x:float2) : float
    + {static} length(x:float3) : float
    + {static} length(x:float4) : float
    + {static} length(x:double) : double
    + {static} length(x:double2) : double
    + {static} length(x:double3) : double
    + {static} length(x:double4) : double
    + {static} lengthsq(x:float) : float
    + {static} lengthsq(x:float2) : float
    + {static} lengthsq(x:float3) : float
    + {static} lengthsq(x:float4) : float
    + {static} lengthsq(x:double) : double
    + {static} lengthsq(x:double2) : double
    + {static} lengthsq(x:double3) : double
    + {static} lengthsq(x:double4) : double
    + {static} distance(x:float, y:float) : float
    + {static} distance(x:float2, y:float2) : float
    + {static} distance(x:float3, y:float3) : float
    + {static} distance(x:float4, y:float4) : float
    + {static} distance(x:double, y:double) : double
    + {static} distance(x:double2, y:double2) : double
    + {static} distance(x:double3, y:double3) : double
    + {static} distance(x:double4, y:double4) : double
    + {static} distancesq(x:float, y:float) : float
    + {static} distancesq(x:float2, y:float2) : float
    + {static} distancesq(x:float3, y:float3) : float
    + {static} distancesq(x:float4, y:float4) : float
    + {static} distancesq(x:double, y:double) : double
    + {static} distancesq(x:double2, y:double2) : double
    + {static} distancesq(x:double3, y:double3) : double
    + {static} distancesq(x:double4, y:double4) : double
    + {static} cross(x:float3, y:float3) : float3
    + {static} cross(x:double3, y:double3) : double3
    + {static} smoothstep(a:float, b:float, x:float) : float
    + {static} smoothstep(a:float2, b:float2, x:float2) : float2
    + {static} smoothstep(a:float3, b:float3, x:float3) : float3
    + {static} smoothstep(a:float4, b:float4, x:float4) : float4
    + {static} smoothstep(a:double, b:double, x:double) : double
    + {static} smoothstep(a:double2, b:double2, x:double2) : double2
    + {static} smoothstep(a:double3, b:double3, x:double3) : double3
    + {static} smoothstep(a:double4, b:double4, x:double4) : double4
    + {static} any(x:bool2) : bool
    + {static} any(x:bool3) : bool
    + {static} any(x:bool4) : bool
    + {static} any(x:int2) : bool
    + {static} any(x:int3) : bool
    + {static} any(x:int4) : bool
    + {static} any(x:uint2) : bool
    + {static} any(x:uint3) : bool
    + {static} any(x:uint4) : bool
    + {static} any(x:float2) : bool
    + {static} any(x:float3) : bool
    + {static} any(x:float4) : bool
    + {static} any(x:double2) : bool
    + {static} any(x:double3) : bool
    + {static} any(x:double4) : bool
    + {static} all(x:bool2) : bool
    + {static} all(x:bool3) : bool
    + {static} all(x:bool4) : bool
    + {static} all(x:int2) : bool
    + {static} all(x:int3) : bool
    + {static} all(x:int4) : bool
    + {static} all(x:uint2) : bool
    + {static} all(x:uint3) : bool
    + {static} all(x:uint4) : bool
    + {static} all(x:float2) : bool
    + {static} all(x:float3) : bool
    + {static} all(x:float4) : bool
    + {static} all(x:double2) : bool
    + {static} all(x:double3) : bool
    + {static} all(x:double4) : bool
    + {static} select(a:int, b:int, c:bool) : int
    + {static} select(a:int2, b:int2, c:bool) : int2
    + {static} select(a:int3, b:int3, c:bool) : int3
    + {static} select(a:int4, b:int4, c:bool) : int4
    + {static} select(a:int2, b:int2, c:bool2) : int2
    + {static} select(a:int3, b:int3, c:bool3) : int3
    + {static} select(a:int4, b:int4, c:bool4) : int4
    + {static} select(a:uint, b:uint, c:bool) : uint
    + {static} select(a:uint2, b:uint2, c:bool) : uint2
    + {static} select(a:uint3, b:uint3, c:bool) : uint3
    + {static} select(a:uint4, b:uint4, c:bool) : uint4
    + {static} select(a:uint2, b:uint2, c:bool2) : uint2
    + {static} select(a:uint3, b:uint3, c:bool3) : uint3
    + {static} select(a:uint4, b:uint4, c:bool4) : uint4
    + {static} select(a:long, b:long, c:bool) : long
    + {static} select(a:ulong, b:ulong, c:bool) : ulong
    + {static} select(a:float, b:float, c:bool) : float
    + {static} select(a:float2, b:float2, c:bool) : float2
    + {static} select(a:float3, b:float3, c:bool) : float3
    + {static} select(a:float4, b:float4, c:bool) : float4
    + {static} select(a:float2, b:float2, c:bool2) : float2
    + {static} select(a:float3, b:float3, c:bool3) : float3
    + {static} select(a:float4, b:float4, c:bool4) : float4
    + {static} select(a:double, b:double, c:bool) : double
    + {static} select(a:double2, b:double2, c:bool) : double2
    + {static} select(a:double3, b:double3, c:bool) : double3
    + {static} select(a:double4, b:double4, c:bool) : double4
    + {static} select(a:double2, b:double2, c:bool2) : double2
    + {static} select(a:double3, b:double3, c:bool3) : double3
    + {static} select(a:double4, b:double4, c:bool4) : double4
    + {static} step(y:float, x:float) : float
    + {static} step(y:float2, x:float2) : float2
    + {static} step(y:float3, x:float3) : float3
    + {static} step(y:float4, x:float4) : float4
    + {static} step(y:double, x:double) : double
    + {static} step(y:double2, x:double2) : double2
    + {static} step(y:double3, x:double3) : double3
    + {static} step(y:double4, x:double4) : double4
    + {static} reflect(i:float2, n:float2) : float2
    + {static} reflect(i:float3, n:float3) : float3
    + {static} reflect(i:float4, n:float4) : float4
    + {static} reflect(i:double2, n:double2) : double2
    + {static} reflect(i:double3, n:double3) : double3
    + {static} reflect(i:double4, n:double4) : double4
    + {static} refract(i:float2, n:float2, eta:float) : float2
    + {static} refract(i:float3, n:float3, eta:float) : float3
    + {static} refract(i:float4, n:float4, eta:float) : float4
    + {static} refract(i:double2, n:double2, eta:double) : double2
    + {static} refract(i:double3, n:double3, eta:double) : double3
    + {static} refract(i:double4, n:double4, eta:double) : double4
    + {static} faceforward(n:float2, i:float2, ng:float2) : float2
    + {static} faceforward(n:float3, i:float3, ng:float3) : float3
    + {static} faceforward(n:float4, i:float4, ng:float4) : float4
    + {static} faceforward(n:double2, i:double2, ng:double2) : double2
    + {static} faceforward(n:double3, i:double3, ng:double3) : double3
    + {static} faceforward(n:double4, i:double4, ng:double4) : double4
    + {static} sincos(x:float, s:float, c:float) : void
    + {static} sincos(x:float2, s:float2, c:float2) : void
    + {static} sincos(x:float3, s:float3, c:float3) : void
    + {static} sincos(x:float4, s:float4, c:float4) : void
    + {static} sincos(x:double, s:double, c:double) : void
    + {static} sincos(x:double2, s:double2, c:double2) : void
    + {static} sincos(x:double3, s:double3, c:double3) : void
    + {static} sincos(x:double4, s:double4, c:double4) : void
    + {static} countbits(x:int) : int
    + {static} countbits(x:int2) : int2
    + {static} countbits(x:int3) : int3
    + {static} countbits(x:int4) : int4
    + {static} countbits(x:uint) : int
    + {static} countbits(x:uint2) : int2
    + {static} countbits(x:uint3) : int3
    + {static} countbits(x:uint4) : int4
    + {static} countbits(x:ulong) : int
    + {static} countbits(x:long) : int
    + {static} lzcnt(x:int) : int
    + {static} lzcnt(x:int2) : int2
    + {static} lzcnt(x:int3) : int3
    + {static} lzcnt(x:int4) : int4
    + {static} lzcnt(x:uint) : int
    + {static} lzcnt(x:uint2) : int2
    + {static} lzcnt(x:uint3) : int3
    + {static} lzcnt(x:uint4) : int4
    + {static} lzcnt(x:long) : int
    + {static} lzcnt(x:ulong) : int
    + {static} tzcnt(x:int) : int
    + {static} tzcnt(x:int2) : int2
    + {static} tzcnt(v:int3) : int3
    + {static} tzcnt(v:int4) : int4
    + {static} tzcnt(x:uint) : int
    + {static} tzcnt(x:uint2) : int2
    + {static} tzcnt(x:uint3) : int3
    + {static} tzcnt(x:uint4) : int4
    + {static} tzcnt(x:long) : int
    + {static} tzcnt(x:ulong) : int
    + {static} reversebits(x:int) : int
    + {static} reversebits(x:int2) : int2
    + {static} reversebits(x:int3) : int3
    + {static} reversebits(x:int4) : int4
    + {static} reversebits(x:uint) : uint
    + {static} reversebits(x:uint2) : uint2
    + {static} reversebits(x:uint3) : uint3
    + {static} reversebits(x:uint4) : uint4
    + {static} reversebits(x:long) : long
    + {static} reversebits(x:ulong) : ulong
    + {static} rol(x:int, n:int) : int
    + {static} rol(x:int2, n:int) : int2
    + {static} rol(x:int3, n:int) : int3
    + {static} rol(x:int4, n:int) : int4
    + {static} rol(x:uint, n:int) : uint
    + {static} rol(x:uint2, n:int) : uint2
    + {static} rol(x:uint3, n:int) : uint3
    + {static} rol(x:uint4, n:int) : uint4
    + {static} rol(x:long, n:int) : long
    + {static} rol(x:ulong, n:int) : ulong
    + {static} ror(x:int, n:int) : int
    + {static} ror(x:int2, n:int) : int2
    + {static} ror(x:int3, n:int) : int3
    + {static} ror(x:int4, n:int) : int4
    + {static} ror(x:uint, n:int) : uint
    + {static} ror(x:uint2, n:int) : uint2
    + {static} ror(x:uint3, n:int) : uint3
    + {static} ror(x:uint4, n:int) : uint4
    + {static} ror(x:long, n:int) : long
    + {static} ror(x:ulong, n:int) : ulong
    + {static} ceilpow2(x:int) : int
    + {static} ceilpow2(x:int2) : int2
    + {static} ceilpow2(x:int3) : int3
    + {static} ceilpow2(x:int4) : int4
    + {static} ceilpow2(x:uint) : uint
    + {static} ceilpow2(x:uint2) : uint2
    + {static} ceilpow2(x:uint3) : uint3
    + {static} ceilpow2(x:uint4) : uint4
    + {static} ceilpow2(x:long) : long
    + {static} ceilpow2(x:ulong) : ulong
    + {static} radians(x:float) : float
    + {static} radians(x:float2) : float2
    + {static} radians(x:float3) : float3
    + {static} radians(x:float4) : float4
    + {static} radians(x:double) : double
    + {static} radians(x:double2) : double2
    + {static} radians(x:double3) : double3
    + {static} radians(x:double4) : double4
    + {static} degrees(x:float) : float
    + {static} degrees(x:float2) : float2
    + {static} degrees(x:float3) : float3
    + {static} degrees(x:float4) : float4
    + {static} degrees(x:double) : double
    + {static} degrees(x:double2) : double2
    + {static} degrees(x:double3) : double3
    + {static} degrees(x:double4) : double4
    + {static} cmin(x:int2) : int
    + {static} cmin(x:int3) : int
    + {static} cmin(x:int4) : int
    + {static} cmin(x:uint2) : uint
    + {static} cmin(x:uint3) : uint
    + {static} cmin(x:uint4) : uint
    + {static} cmin(x:float2) : float
    + {static} cmin(x:float3) : float
    + {static} cmin(x:float4) : float
    + {static} cmin(x:double2) : double
    + {static} cmin(x:double3) : double
    + {static} cmin(x:double4) : double
    + {static} cmax(x:int2) : int
    + {static} cmax(x:int3) : int
    + {static} cmax(x:int4) : int
    + {static} cmax(x:uint2) : uint
    + {static} cmax(x:uint3) : uint
    + {static} cmax(x:uint4) : uint
    + {static} cmax(x:float2) : float
    + {static} cmax(x:float3) : float
    + {static} cmax(x:float4) : float
    + {static} cmax(x:double2) : double
    + {static} cmax(x:double3) : double
    + {static} cmax(x:double4) : double
    + {static} csum(x:int2) : int
    + {static} csum(x:int3) : int
    + {static} csum(x:int4) : int
    + {static} csum(x:uint2) : uint
    + {static} csum(x:uint3) : uint
    + {static} csum(x:uint4) : uint
    + {static} csum(x:float2) : float
    + {static} csum(x:float3) : float
    + {static} csum(x:float4) : float
    + {static} csum(x:double2) : double
    + {static} csum(x:double3) : double
    + {static} csum(x:double4) : double
    + {static} <<unsafe>> compress(output:int*, index:int, val:int4, mask:bool4) : int
    + {static} f16tof32(x:uint) : float
    + {static} f16tof32(x:uint2) : float2
    + {static} f16tof32(x:uint3) : float3
    + {static} f16tof32(x:uint4) : float4
    + {static} f32tof16(x:float) : uint
    + {static} f32tof16(x:float2) : uint2
    + {static} f32tof16(x:float3) : uint3
    + {static} f32tof16(x:float4) : uint4
    + {static} <<unsafe>> hash(pBuffer:void*, numBytes:int, seed:uint) : uint
    + {static} up() : float3
    <<internal>> {static} unpacklo(a:float4, b:float4) : float4
    <<internal>> {static} unpacklo(a:double4, b:double4) : double4
    <<internal>> {static} unpackhi(a:float4, b:float4) : float4
    <<internal>> {static} unpackhi(a:double4, b:double4) : double4
    <<internal>> {static} movelh(a:float4, b:float4) : float4
    <<internal>> {static} movelh(a:double4, b:double4) : double4
    <<internal>> {static} movehl(a:float4, b:float4) : float4
    <<internal>> {static} movehl(a:double4, b:double4) : double4
    <<internal>> {static} fold_to_uint(x:double) : uint
    <<internal>> {static} fold_to_uint(x:double2) : uint2
    <<internal>> {static} fold_to_uint(x:double3) : uint3
    <<internal>> {static} fold_to_uint(x:double4) : uint4
}
enum RotationOrder {
    XYZ,
    XZY,
    YXZ,
    YZX,
    ZXY,
    ZYX,
    Default= ZXY,
}
enum ShuffleComponent {
    LeftX,
    LeftY,
    LeftZ,
    LeftW,
    RightX,
    RightY,
    RightZ,
    RightW,
}
class IntFloatUnion <<struct>> {
    + intValue : int
    + floatValue : float
}
class LongDoubleUnion <<struct>> {
    + longValue : long
    + doubleValue : double
}
math +-- RotationOrder
math +-- ShuffleComponent
math +-- IntFloatUnion
math +-- LongDoubleUnion
class float2 <<struct>> {
}
class float3 <<struct>> {
}
class float4 <<struct>> {
}
class quaternion <<struct>> {
}
class float4x4 <<struct>> {
}
class float2x2 <<struct>> {
    + {static} Rotate(angle:float) : float2x2
    + {static} Scale(s:float) : float2x2
    + {static} Scale(x:float, y:float) : float2x2
    + {static} Scale(v:float2) : float2x2
}
class float3x3 <<struct>> {
    + float3x3(q:quaternion)
    + {static} AxisAngle(axis:float3, angle:float) : float3x3
    + {static} EulerXYZ(xyz:float3) : float3x3
    + {static} EulerXZY(xyz:float3) : float3x3
    + {static} EulerYXZ(xyz:float3) : float3x3
    + {static} EulerYZX(xyz:float3) : float3x3
    + {static} EulerZXY(xyz:float3) : float3x3
    + {static} EulerZYX(xyz:float3) : float3x3
    + {static} EulerXYZ(x:float, y:float, z:float) : float3x3
    + {static} EulerXZY(x:float, y:float, z:float) : float3x3
    + {static} EulerYXZ(x:float, y:float, z:float) : float3x3
    + {static} EulerYZX(x:float, y:float, z:float) : float3x3
    + {static} EulerZXY(x:float, y:float, z:float) : float3x3
    + {static} EulerZYX(x:float, y:float, z:float) : float3x3
    + {static} Euler(xyz:float3, order:RotationOrder) : float3x3
    + {static} Euler(x:float, y:float, z:float, order:RotationOrder) : float3x3
    + {static} RotateX(angle:float) : float3x3
    + {static} RotateY(angle:float) : float3x3
    + {static} RotateZ(angle:float) : float3x3
    + {static} Scale(s:float) : float3x3
    + {static} Scale(x:float, y:float, z:float) : float3x3
    + {static} Scale(v:float3) : float3x3
    + {static} LookRotation(forward:float3, up:float3) : float3x3
    + {static} LookRotationSafe(forward:float3, up:float3) : float3x3
}
class float4x4 <<struct>> {
    + float4x4(rotation:float3x3, translation:float3)
    + float4x4(rotation:quaternion, translation:float3)
    + float4x4(transform:RigidTransform)
    + {static} AxisAngle(axis:float3, angle:float) : float4x4
    + {static} EulerXYZ(xyz:float3) : float4x4
    + {static} EulerXZY(xyz:float3) : float4x4
    + {static} EulerYXZ(xyz:float3) : float4x4
    + {static} EulerYZX(xyz:float3) : float4x4
    + {static} EulerZXY(xyz:float3) : float4x4
    + {static} EulerZYX(xyz:float3) : float4x4
    + {static} EulerXYZ(x:float, y:float, z:float) : float4x4
    + {static} EulerXZY(x:float, y:float, z:float) : float4x4
    + {static} EulerYXZ(x:float, y:float, z:float) : float4x4
    + {static} EulerYZX(x:float, y:float, z:float) : float4x4
    + {static} EulerZXY(x:float, y:float, z:float) : float4x4
    + {static} EulerZYX(x:float, y:float, z:float) : float4x4
    + {static} Euler(xyz:float3, order:RotationOrder) : float4x4
    + {static} Euler(x:float, y:float, z:float, order:RotationOrder) : float4x4
    + {static} RotateX(angle:float) : float4x4
    + {static} RotateY(angle:float) : float4x4
    + {static} RotateZ(angle:float) : float4x4
    + {static} Scale(s:float) : float4x4
    + {static} Scale(x:float, y:float, z:float) : float4x4
    + {static} Scale(scales:float3) : float4x4
    + {static} Translate(vector:float3) : float4x4
    + {static} LookAt(eye:float3, target:float3, up:float3) : float4x4
    + {static} Ortho(width:float, height:float, near:float, far:float) : float4x4
    + {static} OrthoOffCenter(left:float, right:float, bottom:float, top:float, near:float, far:float) : float4x4
    + {static} PerspectiveFov(verticalFov:float, aspect:float, near:float, far:float) : float4x4
    + {static} PerspectiveOffCenter(left:float, right:float, bottom:float, top:float, near:float, far:float) : float4x4
    + {static} TRS(translation:float3, rotation:quaternion, scale:float3) : float4x4
}
class math <<partial>> {
    + {static} float3x3(rotation:quaternion) : float3x3
    + {static} float4x4(rotation:float3x3, translation:float3) : float4x4
    + {static} float4x4(rotation:quaternion, translation:float3) : float4x4
    + {static} float4x4(transform:RigidTransform) : float4x4
    + {static} orthonormalize(i:float3x3) : float3x3
}
class math <<partial>> {
    + {static} mul(a:float, b:float) : float
    + {static} mul(a:float2, b:float2) : float
    + {static} mul(a:float2, b:float2x2) : float2
    + {static} mul(a:float2, b:float2x3) : float3
    + {static} mul(a:float2, b:float2x4) : float4
    + {static} mul(a:float3, b:float3) : float
    + {static} mul(a:float3, b:float3x2) : float2
    + {static} mul(a:float3, b:float3x3) : float3
    + {static} mul(a:float3, b:float3x4) : float4
    + {static} mul(a:float4, b:float4) : float
    + {static} mul(a:float4, b:float4x2) : float2
    + {static} mul(a:float4, b:float4x3) : float3
    + {static} mul(a:float4, b:float4x4) : float4
    + {static} mul(a:float2x2, b:float2) : float2
    + {static} mul(a:float2x2, b:float2x2) : float2x2
    + {static} mul(a:float2x2, b:float2x3) : float2x3
    + {static} mul(a:float2x2, b:float2x4) : float2x4
    + {static} mul(a:float2x3, b:float3) : float2
    + {static} mul(a:float2x3, b:float3x2) : float2x2
    + {static} mul(a:float2x3, b:float3x3) : float2x3
    + {static} mul(a:float2x3, b:float3x4) : float2x4
    + {static} mul(a:float2x4, b:float4) : float2
    + {static} mul(a:float2x4, b:float4x2) : float2x2
    + {static} mul(a:float2x4, b:float4x3) : float2x3
    + {static} mul(a:float2x4, b:float4x4) : float2x4
    + {static} mul(a:float3x2, b:float2) : float3
    + {static} mul(a:float3x2, b:float2x2) : float3x2
    + {static} mul(a:float3x2, b:float2x3) : float3x3
    + {static} mul(a:float3x2, b:float2x4) : float3x4
    + {static} mul(a:float3x3, b:float3) : float3
    + {static} mul(a:float3x3, b:float3x2) : float3x2
    + {static} mul(a:float3x3, b:float3x3) : float3x3
    + {static} mul(a:float3x3, b:float3x4) : float3x4
    + {static} mul(a:float3x4, b:float4) : float3
    + {static} mul(a:float3x4, b:float4x2) : float3x2
    + {static} mul(a:float3x4, b:float4x3) : float3x3
    + {static} mul(a:float3x4, b:float4x4) : float3x4
    + {static} mul(a:float4x2, b:float2) : float4
    + {static} mul(a:float4x2, b:float2x2) : float4x2
    + {static} mul(a:float4x2, b:float2x3) : float4x3
    + {static} mul(a:float4x2, b:float2x4) : float4x4
    + {static} mul(a:float4x3, b:float3) : float4
    + {static} mul(a:float4x3, b:float3x2) : float4x2
    + {static} mul(a:float4x3, b:float3x3) : float4x3
    + {static} mul(a:float4x3, b:float3x4) : float4x4
    + {static} mul(a:float4x4, b:float4) : float4
    + {static} mul(a:float4x4, b:float4x2) : float4x2
    + {static} mul(a:float4x4, b:float4x3) : float4x3
    + {static} mul(a:float4x4, b:float4x4) : float4x4
    + {static} mul(a:double, b:double) : double
    + {static} mul(a:double2, b:double2) : double
    + {static} mul(a:double2, b:double2x2) : double2
    + {static} mul(a:double2, b:double2x3) : double3
    + {static} mul(a:double2, b:double2x4) : double4
    + {static} mul(a:double3, b:double3) : double
    + {static} mul(a:double3, b:double3x2) : double2
    + {static} mul(a:double3, b:double3x3) : double3
    + {static} mul(a:double3, b:double3x4) : double4
    + {static} mul(a:double4, b:double4) : double
    + {static} mul(a:double4, b:double4x2) : double2
    + {static} mul(a:double4, b:double4x3) : double3
    + {static} mul(a:double4, b:double4x4) : double4
    + {static} mul(a:double2x2, b:double2) : double2
    + {static} mul(a:double2x2, b:double2x2) : double2x2
    + {static} mul(a:double2x2, b:double2x3) : double2x3
    + {static} mul(a:double2x2, b:double2x4) : double2x4
    + {static} mul(a:double2x3, b:double3) : double2
    + {static} mul(a:double2x3, b:double3x2) : double2x2
    + {static} mul(a:double2x3, b:double3x3) : double2x3
    + {static} mul(a:double2x3, b:double3x4) : double2x4
    + {static} mul(a:double2x4, b:double4) : double2
    + {static} mul(a:double2x4, b:double4x2) : double2x2
    + {static} mul(a:double2x4, b:double4x3) : double2x3
    + {static} mul(a:double2x4, b:double4x4) : double2x4
    + {static} mul(a:double3x2, b:double2) : double3
    + {static} mul(a:double3x2, b:double2x2) : double3x2
    + {static} mul(a:double3x2, b:double2x3) : double3x3
    + {static} mul(a:double3x2, b:double2x4) : double3x4
    + {static} mul(a:double3x3, b:double3) : double3
    + {static} mul(a:double3x3, b:double3x2) : double3x2
    + {static} mul(a:double3x3, b:double3x3) : double3x3
    + {static} mul(a:double3x3, b:double3x4) : double3x4
    + {static} mul(a:double3x4, b:double4) : double3
    + {static} mul(a:double3x4, b:double4x2) : double3x2
    + {static} mul(a:double3x4, b:double4x3) : double3x3
    + {static} mul(a:double3x4, b:double4x4) : double3x4
    + {static} mul(a:double4x2, b:double2) : double4
    + {static} mul(a:double4x2, b:double2x2) : double4x2
    + {static} mul(a:double4x2, b:double2x3) : double4x3
    + {static} mul(a:double4x2, b:double2x4) : double4x4
    + {static} mul(a:double4x3, b:double3) : double4
    + {static} mul(a:double4x3, b:double3x2) : double4x2
    + {static} mul(a:double4x3, b:double3x3) : double4x3
    + {static} mul(a:double4x3, b:double3x4) : double4x4
    + {static} mul(a:double4x4, b:double4) : double4
    + {static} mul(a:double4x4, b:double4x2) : double4x2
    + {static} mul(a:double4x4, b:double4x3) : double4x3
    + {static} mul(a:double4x4, b:double4x4) : double4x4
    + {static} mul(a:int, b:int) : int
    + {static} mul(a:int2, b:int2) : int
    + {static} mul(a:int2, b:int2x2) : int2
    + {static} mul(a:int2, b:int2x3) : int3
    + {static} mul(a:int2, b:int2x4) : int4
    + {static} mul(a:int3, b:int3) : int
    + {static} mul(a:int3, b:int3x2) : int2
    + {static} mul(a:int3, b:int3x3) : int3
    + {static} mul(a:int3, b:int3x4) : int4
    + {static} mul(a:int4, b:int4) : int
    + {static} mul(a:int4, b:int4x2) : int2
    + {static} mul(a:int4, b:int4x3) : int3
    + {static} mul(a:int4, b:int4x4) : int4
    + {static} mul(a:int2x2, b:int2) : int2
    + {static} mul(a:int2x2, b:int2x2) : int2x2
    + {static} mul(a:int2x2, b:int2x3) : int2x3
    + {static} mul(a:int2x2, b:int2x4) : int2x4
    + {static} mul(a:int2x3, b:int3) : int2
    + {static} mul(a:int2x3, b:int3x2) : int2x2
    + {static} mul(a:int2x3, b:int3x3) : int2x3
    + {static} mul(a:int2x3, b:int3x4) : int2x4
    + {static} mul(a:int2x4, b:int4) : int2
    + {static} mul(a:int2x4, b:int4x2) : int2x2
    + {static} mul(a:int2x4, b:int4x3) : int2x3
    + {static} mul(a:int2x4, b:int4x4) : int2x4
    + {static} mul(a:int3x2, b:int2) : int3
    + {static} mul(a:int3x2, b:int2x2) : int3x2
    + {static} mul(a:int3x2, b:int2x3) : int3x3
    + {static} mul(a:int3x2, b:int2x4) : int3x4
    + {static} mul(a:int3x3, b:int3) : int3
    + {static} mul(a:int3x3, b:int3x2) : int3x2
    + {static} mul(a:int3x3, b:int3x3) : int3x3
    + {static} mul(a:int3x3, b:int3x4) : int3x4
    + {static} mul(a:int3x4, b:int4) : int3
    + {static} mul(a:int3x4, b:int4x2) : int3x2
    + {static} mul(a:int3x4, b:int4x3) : int3x3
    + {static} mul(a:int3x4, b:int4x4) : int3x4
    + {static} mul(a:int4x2, b:int2) : int4
    + {static} mul(a:int4x2, b:int2x2) : int4x2
    + {static} mul(a:int4x2, b:int2x3) : int4x3
    + {static} mul(a:int4x2, b:int2x4) : int4x4
    + {static} mul(a:int4x3, b:int3) : int4
    + {static} mul(a:int4x3, b:int3x2) : int4x2
    + {static} mul(a:int4x3, b:int3x3) : int4x3
    + {static} mul(a:int4x3, b:int3x4) : int4x4
    + {static} mul(a:int4x4, b:int4) : int4
    + {static} mul(a:int4x4, b:int4x2) : int4x2
    + {static} mul(a:int4x4, b:int4x3) : int4x3
    + {static} mul(a:int4x4, b:int4x4) : int4x4
    + {static} mul(a:uint, b:uint) : uint
    + {static} mul(a:uint2, b:uint2) : uint
    + {static} mul(a:uint2, b:uint2x2) : uint2
    + {static} mul(a:uint2, b:uint2x3) : uint3
    + {static} mul(a:uint2, b:uint2x4) : uint4
    + {static} mul(a:uint3, b:uint3) : uint
    + {static} mul(a:uint3, b:uint3x2) : uint2
    + {static} mul(a:uint3, b:uint3x3) : uint3
    + {static} mul(a:uint3, b:uint3x4) : uint4
    + {static} mul(a:uint4, b:uint4) : uint
    + {static} mul(a:uint4, b:uint4x2) : uint2
    + {static} mul(a:uint4, b:uint4x3) : uint3
    + {static} mul(a:uint4, b:uint4x4) : uint4
    + {static} mul(a:uint2x2, b:uint2) : uint2
    + {static} mul(a:uint2x2, b:uint2x2) : uint2x2
    + {static} mul(a:uint2x2, b:uint2x3) : uint2x3
    + {static} mul(a:uint2x2, b:uint2x4) : uint2x4
    + {static} mul(a:uint2x3, b:uint3) : uint2
    + {static} mul(a:uint2x3, b:uint3x2) : uint2x2
    + {static} mul(a:uint2x3, b:uint3x3) : uint2x3
    + {static} mul(a:uint2x3, b:uint3x4) : uint2x4
    + {static} mul(a:uint2x4, b:uint4) : uint2
    + {static} mul(a:uint2x4, b:uint4x2) : uint2x2
    + {static} mul(a:uint2x4, b:uint4x3) : uint2x3
    + {static} mul(a:uint2x4, b:uint4x4) : uint2x4
    + {static} mul(a:uint3x2, b:uint2) : uint3
    + {static} mul(a:uint3x2, b:uint2x2) : uint3x2
    + {static} mul(a:uint3x2, b:uint2x3) : uint3x3
    + {static} mul(a:uint3x2, b:uint2x4) : uint3x4
    + {static} mul(a:uint3x3, b:uint3) : uint3
    + {static} mul(a:uint3x3, b:uint3x2) : uint3x2
    + {static} mul(a:uint3x3, b:uint3x3) : uint3x3
    + {static} mul(a:uint3x3, b:uint3x4) : uint3x4
    + {static} mul(a:uint3x4, b:uint4) : uint3
    + {static} mul(a:uint3x4, b:uint4x2) : uint3x2
    + {static} mul(a:uint3x4, b:uint4x3) : uint3x3
    + {static} mul(a:uint3x4, b:uint4x4) : uint3x4
    + {static} mul(a:uint4x2, b:uint2) : uint4
    + {static} mul(a:uint4x2, b:uint2x2) : uint4x2
    + {static} mul(a:uint4x2, b:uint2x3) : uint4x3
    + {static} mul(a:uint4x2, b:uint2x4) : uint4x4
    + {static} mul(a:uint4x3, b:uint3) : uint4
    + {static} mul(a:uint4x3, b:uint3x2) : uint4x2
    + {static} mul(a:uint4x3, b:uint3x3) : uint4x3
    + {static} mul(a:uint4x3, b:uint3x4) : uint4x4
    + {static} mul(a:uint4x4, b:uint4) : uint4
    + {static} mul(a:uint4x4, b:uint4x2) : uint4x2
    + {static} mul(a:uint4x4, b:uint4x3) : uint4x3
    + {static} mul(a:uint4x4, b:uint4x4) : uint4x4
}
class PostNormalizeAttribute {
}
class DoNotNormalizeAttribute {
}
class quaternion <<struct>> {
    + quaternion(x:float, y:float, z:float, w:float)
    + quaternion(value:float4)
    + quaternion(m:float3x3)
    + quaternion(m:float4x4)
    + {static} AxisAngle(axis:float3, angle:float) : quaternion
    + {static} EulerXYZ(xyz:float3) : quaternion
    + {static} EulerXZY(xyz:float3) : quaternion
    + {static} EulerYXZ(xyz:float3) : quaternion
    + {static} EulerYZX(xyz:float3) : quaternion
    + {static} EulerZXY(xyz:float3) : quaternion
    + {static} EulerZYX(xyz:float3) : quaternion
    + {static} EulerXYZ(x:float, y:float, z:float) : quaternion
    + {static} EulerXZY(x:float, y:float, z:float) : quaternion
    + {static} EulerYXZ(x:float, y:float, z:float) : quaternion
    + {static} EulerYZX(x:float, y:float, z:float) : quaternion
    + {static} EulerZXY(x:float, y:float, z:float) : quaternion
    + {static} EulerZYX(x:float, y:float, z:float) : quaternion
    + {static} Euler(xyz:float3, order:RotationOrder) : quaternion
    + {static} Euler(x:float, y:float, z:float, order:RotationOrder) : quaternion
    + {static} RotateX(angle:float) : quaternion
    + {static} RotateY(angle:float) : quaternion
    + {static} RotateZ(angle:float) : quaternion
    + {static} LookRotation(forward:float3, up:float3) : quaternion
    + {static} LookRotationSafe(forward:float3, up:float3) : quaternion
    + Equals(x:quaternion) : bool
    + <<override>> Equals(x:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} quaternion(x:float, y:float, z:float, w:float) : quaternion
    + {static} quaternion(value:float4) : quaternion
    + {static} quaternion(m:float3x3) : quaternion
    + {static} quaternion(m:float4x4) : quaternion
    + {static} conjugate(q:quaternion) : quaternion
    + {static} inverse(q:quaternion) : quaternion
    + {static} dot(a:quaternion, b:quaternion) : float
    + {static} length(q:quaternion) : float
    + {static} lengthsq(q:quaternion) : float
    + {static} normalize(q:quaternion) : quaternion
    + {static} normalizesafe(q:quaternion) : quaternion
    + {static} normalizesafe(q:quaternion, defaultvalue:quaternion) : quaternion
    + {static} unitexp(q:quaternion) : quaternion
    + {static} exp(q:quaternion) : quaternion
    + {static} unitlog(q:quaternion) : quaternion
    + {static} log(q:quaternion) : quaternion
    + {static} mul(a:quaternion, b:quaternion) : quaternion
    + {static} mul(q:quaternion, v:float3) : float3
    + {static} rotate(q:quaternion, v:float3) : float3
    + {static} nlerp(q1:quaternion, q2:quaternion, t:float) : quaternion
    + {static} slerp(q1:quaternion, q2:quaternion, t:float) : quaternion
    + {static} hash(q:quaternion) : uint
    + {static} hashwide(q:quaternion) : uint4
    + {static} forward(q:quaternion) : float3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- quaternion
quaternion --> "value" float4
quaternion o-> "identity" quaternion
class Random <<struct>> {
    + state : uint
    + Random(seed:uint)
    + InitState(seed:uint) : void
    + NextBool() : bool
    + NextBool2() : bool2
    + NextBool3() : bool3
    + NextBool4() : bool4
    + NextInt() : int
    + NextInt2() : int2
    + NextInt3() : int3
    + NextInt4() : int4
    + NextInt(max:int) : int
    + NextInt2(max:int2) : int2
    + NextInt3(max:int3) : int3
    + NextInt4(max:int4) : int4
    + NextInt(min:int, max:int) : int
    + NextInt2(min:int2, max:int2) : int2
    + NextInt3(min:int3, max:int3) : int3
    + NextInt4(min:int4, max:int4) : int4
    + NextUInt() : uint
    + NextUInt2() : uint2
    + NextUInt3() : uint3
    + NextUInt4() : uint4
    + NextUInt(max:uint) : uint
    + NextUInt2(max:uint2) : uint2
    + NextUInt3(max:uint3) : uint3
    + NextUInt4(max:uint4) : uint4
    + NextUInt(min:uint, max:uint) : uint
    + NextUInt2(min:uint2, max:uint2) : uint2
    + NextUInt3(min:uint3, max:uint3) : uint3
    + NextUInt4(min:uint4, max:uint4) : uint4
    + NextFloat() : float
    + NextFloat2() : float2
    + NextFloat3() : float3
    + NextFloat4() : float4
    + NextFloat(max:float) : float
    + NextFloat2(max:float2) : float2
    + NextFloat3(max:float3) : float3
    + NextFloat4(max:float4) : float4
    + NextFloat(min:float, max:float) : float
    + NextFloat2(min:float2, max:float2) : float2
    + NextFloat3(min:float3, max:float3) : float3
    + NextFloat4(min:float4, max:float4) : float4
    + NextDouble() : double
    + NextDouble2() : double2
    + NextDouble3() : double3
    + NextDouble4() : double4
    + NextDouble(max:double) : double
    + NextDouble2(max:double2) : double2
    + NextDouble3(max:double3) : double3
    + NextDouble4(max:double4) : double4
    + NextDouble(min:double, max:double) : double
    + NextDouble2(min:double2, max:double2) : double2
    + NextDouble3(min:double3, max:double3) : double3
    + NextDouble4(min:double4, max:double4) : double4
    + NextFloat2Direction() : float2
    + NextDouble2Direction() : double2
    + NextFloat3Direction() : float3
    + NextDouble3Direction() : double3
    + NextQuaternionRotation() : quaternion
}
class RigidTransform <<struct>> {
    + RigidTransform(rotation:quaternion, translation:float3)
    + RigidTransform(rotation:float3x3, translation:float3)
    + RigidTransform(transform:float4x4)
    + {static} AxisAngle(axis:float3, angle:float) : RigidTransform
    + {static} EulerXYZ(xyz:float3) : RigidTransform
    + {static} EulerXZY(xyz:float3) : RigidTransform
    + {static} EulerYXZ(xyz:float3) : RigidTransform
    + {static} EulerYZX(xyz:float3) : RigidTransform
    + {static} EulerZXY(xyz:float3) : RigidTransform
    + {static} EulerZYX(xyz:float3) : RigidTransform
    + {static} EulerXYZ(x:float, y:float, z:float) : RigidTransform
    + {static} EulerXZY(x:float, y:float, z:float) : RigidTransform
    + {static} EulerYXZ(x:float, y:float, z:float) : RigidTransform
    + {static} EulerYZX(x:float, y:float, z:float) : RigidTransform
    + {static} EulerZXY(x:float, y:float, z:float) : RigidTransform
    + {static} EulerZYX(x:float, y:float, z:float) : RigidTransform
    + {static} Euler(xyz:float3, order:RotationOrder) : RigidTransform
    + {static} Euler(x:float, y:float, z:float, order:RotationOrder) : RigidTransform
    + {static} RotateX(angle:float) : RigidTransform
    + {static} RotateY(angle:float) : RigidTransform
    + {static} RotateZ(angle:float) : RigidTransform
    + {static} Translate(vector:float3) : RigidTransform
    + Equals(x:RigidTransform) : bool
    + <<override>> Equals(x:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} RigidTransform(rot:quaternion, pos:float3) : RigidTransform
    + {static} RigidTransform(rotation:float3x3, translation:float3) : RigidTransform
    + {static} RigidTransform(transform:float4x4) : RigidTransform
    + {static} inverse(t:RigidTransform) : RigidTransform
    + {static} mul(a:RigidTransform, b:RigidTransform) : RigidTransform
    + {static} mul(a:RigidTransform, pos:float4) : float4
    + {static} rotate(a:RigidTransform, dir:float3) : float3
    + {static} transform(a:RigidTransform, pos:float3) : float3
    + {static} hash(t:RigidTransform) : uint
    + {static} hashwide(t:RigidTransform) : uint4
}
RigidTransform --> "rot" quaternion
RigidTransform --> "pos" float3
RigidTransform o-> "identity" RigidTransform
class uint2 <<struct>> {
    + x : uint
    + y : uint
    + uint2(x:uint, y:uint)
    + uint2(xy:uint2)
    + uint2(v:uint)
    + uint2(v:bool)
    + uint2(v:bool2)
    + uint2(v:int)
    + uint2(v:int2)
    + uint2(v:float)
    + uint2(v:float2)
    + uint2(v:double)
    + uint2(v:double2)
    + Equals(rhs:uint2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint2(x:uint, y:uint) : uint2
    + {static} uint2(xy:uint2) : uint2
    + {static} uint2(v:uint) : uint2
    + {static} uint2(v:bool) : uint2
    + {static} uint2(v:bool2) : uint2
    + {static} uint2(v:int) : uint2
    + {static} uint2(v:int2) : uint2
    + {static} uint2(v:float) : uint2
    + {static} uint2(v:float2) : uint2
    + {static} uint2(v:double) : uint2
    + {static} uint2(v:double2) : uint2
    + {static} hash(v:uint2) : uint
    + {static} hashwide(v:uint2) : uint2
    + {static} shuffle(a:uint2, b:uint2, x:ShuffleComponent) : uint
    + {static} shuffle(a:uint2, b:uint2, x:ShuffleComponent, y:ShuffleComponent) : uint2
    + {static} shuffle(a:uint2, b:uint2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : uint3
    + {static} shuffle(a:uint2, b:uint2, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : uint4
    <<internal>> {static} select_shuffle_component(a:uint2, b:uint2, component:ShuffleComponent) : uint
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : uint
    + y : uint
    + DebuggerProxy(v:uint2)
}
IFormattable <|-- uint2
uint2 --> "zero" uint2
uint2 --> "xxxx" uint4
uint2 --> "xxxy" uint4
uint2 --> "xxyx" uint4
uint2 --> "xxyy" uint4
uint2 --> "xyxx" uint4
uint2 --> "xyxy" uint4
uint2 --> "xyyx" uint4
uint2 --> "xyyy" uint4
uint2 --> "yxxx" uint4
uint2 --> "yxxy" uint4
uint2 --> "yxyx" uint4
uint2 --> "yxyy" uint4
uint2 --> "yyxx" uint4
uint2 --> "yyxy" uint4
uint2 --> "yyyx" uint4
uint2 --> "yyyy" uint4
uint2 --> "xxx" uint3
uint2 --> "xxy" uint3
uint2 --> "xyx" uint3
uint2 --> "xyy" uint3
uint2 --> "yxx" uint3
uint2 --> "yxy" uint3
uint2 --> "yyx" uint3
uint2 --> "yyy" uint3
uint2 --> "xx" uint2
uint2 --> "xy" uint2
uint2 --> "yx" uint2
uint2 --> "yy" uint2
uint2 +-- DebuggerProxy
class uint2x2 <<struct>> {
    + uint2x2(c0:uint2, c1:uint2)
    + uint2x2(m00:uint, m01:uint, m10:uint, m11:uint)
    + uint2x2(v:uint)
    + uint2x2(v:bool)
    + uint2x2(v:bool2x2)
    + uint2x2(v:int)
    + uint2x2(v:int2x2)
    + uint2x2(v:float)
    + uint2x2(v:float2x2)
    + uint2x2(v:double)
    + uint2x2(v:double2x2)
    + Equals(rhs:uint2x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint2x2(c0:uint2, c1:uint2) : uint2x2
    + {static} uint2x2(m00:uint, m01:uint, m10:uint, m11:uint) : uint2x2
    + {static} uint2x2(v:uint) : uint2x2
    + {static} uint2x2(v:bool) : uint2x2
    + {static} uint2x2(v:bool2x2) : uint2x2
    + {static} uint2x2(v:int) : uint2x2
    + {static} uint2x2(v:int2x2) : uint2x2
    + {static} uint2x2(v:float) : uint2x2
    + {static} uint2x2(v:float2x2) : uint2x2
    + {static} uint2x2(v:double) : uint2x2
    + {static} uint2x2(v:double2x2) : uint2x2
    + {static} transpose(v:uint2x2) : uint2x2
    + {static} hash(v:uint2x2) : uint
    + {static} hashwide(v:uint2x2) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint2x2
uint2x2 --> "c0" uint2
uint2x2 --> "c1" uint2
uint2x2 o-> "identity" uint2x2
uint2x2 --> "zero" uint2x2
class uint2x3 <<struct>> {
    + uint2x3(c0:uint2, c1:uint2, c2:uint2)
    + uint2x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint)
    + uint2x3(v:uint)
    + uint2x3(v:bool)
    + uint2x3(v:bool2x3)
    + uint2x3(v:int)
    + uint2x3(v:int2x3)
    + uint2x3(v:float)
    + uint2x3(v:float2x3)
    + uint2x3(v:double)
    + uint2x3(v:double2x3)
    + Equals(rhs:uint2x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint2x3(c0:uint2, c1:uint2, c2:uint2) : uint2x3
    + {static} uint2x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint) : uint2x3
    + {static} uint2x3(v:uint) : uint2x3
    + {static} uint2x3(v:bool) : uint2x3
    + {static} uint2x3(v:bool2x3) : uint2x3
    + {static} uint2x3(v:int) : uint2x3
    + {static} uint2x3(v:int2x3) : uint2x3
    + {static} uint2x3(v:float) : uint2x3
    + {static} uint2x3(v:float2x3) : uint2x3
    + {static} uint2x3(v:double) : uint2x3
    + {static} uint2x3(v:double2x3) : uint2x3
    + {static} transpose(v:uint2x3) : uint3x2
    + {static} hash(v:uint2x3) : uint
    + {static} hashwide(v:uint2x3) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint2x3
uint2x3 --> "c0" uint2
uint2x3 --> "c1" uint2
uint2x3 --> "c2" uint2
uint2x3 --> "zero" uint2x3
class uint2x4 <<struct>> {
    + uint2x4(c0:uint2, c1:uint2, c2:uint2, c3:uint2)
    + uint2x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint)
    + uint2x4(v:uint)
    + uint2x4(v:bool)
    + uint2x4(v:bool2x4)
    + uint2x4(v:int)
    + uint2x4(v:int2x4)
    + uint2x4(v:float)
    + uint2x4(v:float2x4)
    + uint2x4(v:double)
    + uint2x4(v:double2x4)
    + Equals(rhs:uint2x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint2x4(c0:uint2, c1:uint2, c2:uint2, c3:uint2) : uint2x4
    + {static} uint2x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint) : uint2x4
    + {static} uint2x4(v:uint) : uint2x4
    + {static} uint2x4(v:bool) : uint2x4
    + {static} uint2x4(v:bool2x4) : uint2x4
    + {static} uint2x4(v:int) : uint2x4
    + {static} uint2x4(v:int2x4) : uint2x4
    + {static} uint2x4(v:float) : uint2x4
    + {static} uint2x4(v:float2x4) : uint2x4
    + {static} uint2x4(v:double) : uint2x4
    + {static} uint2x4(v:double2x4) : uint2x4
    + {static} transpose(v:uint2x4) : uint4x2
    + {static} hash(v:uint2x4) : uint
    + {static} hashwide(v:uint2x4) : uint2
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint2x4
uint2x4 --> "c0" uint2
uint2x4 --> "c1" uint2
uint2x4 --> "c2" uint2
uint2x4 --> "c3" uint2
uint2x4 --> "zero" uint2x4
class uint3 <<struct>> {
    + x : uint
    + y : uint
    + z : uint
    + uint3(x:uint, y:uint, z:uint)
    + uint3(x:uint, yz:uint2)
    + uint3(xy:uint2, z:uint)
    + uint3(xyz:uint3)
    + uint3(v:uint)
    + uint3(v:bool)
    + uint3(v:bool3)
    + uint3(v:int)
    + uint3(v:int3)
    + uint3(v:float)
    + uint3(v:float3)
    + uint3(v:double)
    + uint3(v:double3)
    + Equals(rhs:uint3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint3(x:uint, y:uint, z:uint) : uint3
    + {static} uint3(x:uint, yz:uint2) : uint3
    + {static} uint3(xy:uint2, z:uint) : uint3
    + {static} uint3(xyz:uint3) : uint3
    + {static} uint3(v:uint) : uint3
    + {static} uint3(v:bool) : uint3
    + {static} uint3(v:bool3) : uint3
    + {static} uint3(v:int) : uint3
    + {static} uint3(v:int3) : uint3
    + {static} uint3(v:float) : uint3
    + {static} uint3(v:float3) : uint3
    + {static} uint3(v:double) : uint3
    + {static} uint3(v:double3) : uint3
    + {static} hash(v:uint3) : uint
    + {static} hashwide(v:uint3) : uint3
    + {static} shuffle(a:uint3, b:uint3, x:ShuffleComponent) : uint
    + {static} shuffle(a:uint3, b:uint3, x:ShuffleComponent, y:ShuffleComponent) : uint2
    + {static} shuffle(a:uint3, b:uint3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : uint3
    + {static} shuffle(a:uint3, b:uint3, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : uint4
    <<internal>> {static} select_shuffle_component(a:uint3, b:uint3, component:ShuffleComponent) : uint
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : uint
    + y : uint
    + z : uint
    + DebuggerProxy(v:uint3)
}
IFormattable <|-- uint3
uint3 --> "zero" uint3
uint3 --> "xxxx" uint4
uint3 --> "xxxy" uint4
uint3 --> "xxxz" uint4
uint3 --> "xxyx" uint4
uint3 --> "xxyy" uint4
uint3 --> "xxyz" uint4
uint3 --> "xxzx" uint4
uint3 --> "xxzy" uint4
uint3 --> "xxzz" uint4
uint3 --> "xyxx" uint4
uint3 --> "xyxy" uint4
uint3 --> "xyxz" uint4
uint3 --> "xyyx" uint4
uint3 --> "xyyy" uint4
uint3 --> "xyyz" uint4
uint3 --> "xyzx" uint4
uint3 --> "xyzy" uint4
uint3 --> "xyzz" uint4
uint3 --> "xzxx" uint4
uint3 --> "xzxy" uint4
uint3 --> "xzxz" uint4
uint3 --> "xzyx" uint4
uint3 --> "xzyy" uint4
uint3 --> "xzyz" uint4
uint3 --> "xzzx" uint4
uint3 --> "xzzy" uint4
uint3 --> "xzzz" uint4
uint3 --> "yxxx" uint4
uint3 --> "yxxy" uint4
uint3 --> "yxxz" uint4
uint3 --> "yxyx" uint4
uint3 --> "yxyy" uint4
uint3 --> "yxyz" uint4
uint3 --> "yxzx" uint4
uint3 --> "yxzy" uint4
uint3 --> "yxzz" uint4
uint3 --> "yyxx" uint4
uint3 --> "yyxy" uint4
uint3 --> "yyxz" uint4
uint3 --> "yyyx" uint4
uint3 --> "yyyy" uint4
uint3 --> "yyyz" uint4
uint3 --> "yyzx" uint4
uint3 --> "yyzy" uint4
uint3 --> "yyzz" uint4
uint3 --> "yzxx" uint4
uint3 --> "yzxy" uint4
uint3 --> "yzxz" uint4
uint3 --> "yzyx" uint4
uint3 --> "yzyy" uint4
uint3 --> "yzyz" uint4
uint3 --> "yzzx" uint4
uint3 --> "yzzy" uint4
uint3 --> "yzzz" uint4
uint3 --> "zxxx" uint4
uint3 --> "zxxy" uint4
uint3 --> "zxxz" uint4
uint3 --> "zxyx" uint4
uint3 --> "zxyy" uint4
uint3 --> "zxyz" uint4
uint3 --> "zxzx" uint4
uint3 --> "zxzy" uint4
uint3 --> "zxzz" uint4
uint3 --> "zyxx" uint4
uint3 --> "zyxy" uint4
uint3 --> "zyxz" uint4
uint3 --> "zyyx" uint4
uint3 --> "zyyy" uint4
uint3 --> "zyyz" uint4
uint3 --> "zyzx" uint4
uint3 --> "zyzy" uint4
uint3 --> "zyzz" uint4
uint3 --> "zzxx" uint4
uint3 --> "zzxy" uint4
uint3 --> "zzxz" uint4
uint3 --> "zzyx" uint4
uint3 --> "zzyy" uint4
uint3 --> "zzyz" uint4
uint3 --> "zzzx" uint4
uint3 --> "zzzy" uint4
uint3 --> "zzzz" uint4
uint3 --> "xxx" uint3
uint3 --> "xxy" uint3
uint3 --> "xxz" uint3
uint3 --> "xyx" uint3
uint3 --> "xyy" uint3
uint3 --> "xyz" uint3
uint3 --> "xzx" uint3
uint3 --> "xzy" uint3
uint3 --> "xzz" uint3
uint3 --> "yxx" uint3
uint3 --> "yxy" uint3
uint3 --> "yxz" uint3
uint3 --> "yyx" uint3
uint3 --> "yyy" uint3
uint3 --> "yyz" uint3
uint3 --> "yzx" uint3
uint3 --> "yzy" uint3
uint3 --> "yzz" uint3
uint3 --> "zxx" uint3
uint3 --> "zxy" uint3
uint3 --> "zxz" uint3
uint3 --> "zyx" uint3
uint3 --> "zyy" uint3
uint3 --> "zyz" uint3
uint3 --> "zzx" uint3
uint3 --> "zzy" uint3
uint3 --> "zzz" uint3
uint3 --> "xx" uint2
uint3 --> "xy" uint2
uint3 --> "xz" uint2
uint3 --> "yx" uint2
uint3 --> "yy" uint2
uint3 --> "yz" uint2
uint3 --> "zx" uint2
uint3 --> "zy" uint2
uint3 --> "zz" uint2
uint3 +-- DebuggerProxy
class uint3x2 <<struct>> {
    + uint3x2(c0:uint3, c1:uint3)
    + uint3x2(m00:uint, m01:uint, m10:uint, m11:uint, m20:uint, m21:uint)
    + uint3x2(v:uint)
    + uint3x2(v:bool)
    + uint3x2(v:bool3x2)
    + uint3x2(v:int)
    + uint3x2(v:int3x2)
    + uint3x2(v:float)
    + uint3x2(v:float3x2)
    + uint3x2(v:double)
    + uint3x2(v:double3x2)
    + Equals(rhs:uint3x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint3x2(c0:uint3, c1:uint3) : uint3x2
    + {static} uint3x2(m00:uint, m01:uint, m10:uint, m11:uint, m20:uint, m21:uint) : uint3x2
    + {static} uint3x2(v:uint) : uint3x2
    + {static} uint3x2(v:bool) : uint3x2
    + {static} uint3x2(v:bool3x2) : uint3x2
    + {static} uint3x2(v:int) : uint3x2
    + {static} uint3x2(v:int3x2) : uint3x2
    + {static} uint3x2(v:float) : uint3x2
    + {static} uint3x2(v:float3x2) : uint3x2
    + {static} uint3x2(v:double) : uint3x2
    + {static} uint3x2(v:double3x2) : uint3x2
    + {static} transpose(v:uint3x2) : uint2x3
    + {static} hash(v:uint3x2) : uint
    + {static} hashwide(v:uint3x2) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint3x2
uint3x2 --> "c0" uint3
uint3x2 --> "c1" uint3
uint3x2 --> "zero" uint3x2
class uint3x3 <<struct>> {
    + uint3x3(c0:uint3, c1:uint3, c2:uint3)
    + uint3x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint, m20:uint, m21:uint, m22:uint)
    + uint3x3(v:uint)
    + uint3x3(v:bool)
    + uint3x3(v:bool3x3)
    + uint3x3(v:int)
    + uint3x3(v:int3x3)
    + uint3x3(v:float)
    + uint3x3(v:float3x3)
    + uint3x3(v:double)
    + uint3x3(v:double3x3)
    + Equals(rhs:uint3x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint3x3(c0:uint3, c1:uint3, c2:uint3) : uint3x3
    + {static} uint3x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint, m20:uint, m21:uint, m22:uint) : uint3x3
    + {static} uint3x3(v:uint) : uint3x3
    + {static} uint3x3(v:bool) : uint3x3
    + {static} uint3x3(v:bool3x3) : uint3x3
    + {static} uint3x3(v:int) : uint3x3
    + {static} uint3x3(v:int3x3) : uint3x3
    + {static} uint3x3(v:float) : uint3x3
    + {static} uint3x3(v:float3x3) : uint3x3
    + {static} uint3x3(v:double) : uint3x3
    + {static} uint3x3(v:double3x3) : uint3x3
    + {static} transpose(v:uint3x3) : uint3x3
    + {static} hash(v:uint3x3) : uint
    + {static} hashwide(v:uint3x3) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint3x3
uint3x3 --> "c0" uint3
uint3x3 --> "c1" uint3
uint3x3 --> "c2" uint3
uint3x3 o-> "identity" uint3x3
uint3x3 --> "zero" uint3x3
class uint3x4 <<struct>> {
    + uint3x4(c0:uint3, c1:uint3, c2:uint3, c3:uint3)
    + uint3x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint, m20:uint, m21:uint, m22:uint, m23:uint)
    + uint3x4(v:uint)
    + uint3x4(v:bool)
    + uint3x4(v:bool3x4)
    + uint3x4(v:int)
    + uint3x4(v:int3x4)
    + uint3x4(v:float)
    + uint3x4(v:float3x4)
    + uint3x4(v:double)
    + uint3x4(v:double3x4)
    + Equals(rhs:uint3x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint3x4(c0:uint3, c1:uint3, c2:uint3, c3:uint3) : uint3x4
    + {static} uint3x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint, m20:uint, m21:uint, m22:uint, m23:uint) : uint3x4
    + {static} uint3x4(v:uint) : uint3x4
    + {static} uint3x4(v:bool) : uint3x4
    + {static} uint3x4(v:bool3x4) : uint3x4
    + {static} uint3x4(v:int) : uint3x4
    + {static} uint3x4(v:int3x4) : uint3x4
    + {static} uint3x4(v:float) : uint3x4
    + {static} uint3x4(v:float3x4) : uint3x4
    + {static} uint3x4(v:double) : uint3x4
    + {static} uint3x4(v:double3x4) : uint3x4
    + {static} transpose(v:uint3x4) : uint4x3
    + {static} hash(v:uint3x4) : uint
    + {static} hashwide(v:uint3x4) : uint3
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint3x4
uint3x4 --> "c0" uint3
uint3x4 --> "c1" uint3
uint3x4 --> "c2" uint3
uint3x4 --> "c3" uint3
uint3x4 --> "zero" uint3x4
class uint4 <<struct>> {
    + x : uint
    + y : uint
    + z : uint
    + w : uint
    + uint4(x:uint, y:uint, z:uint, w:uint)
    + uint4(x:uint, y:uint, zw:uint2)
    + uint4(x:uint, yz:uint2, w:uint)
    + uint4(x:uint, yzw:uint3)
    + uint4(xy:uint2, z:uint, w:uint)
    + uint4(xy:uint2, zw:uint2)
    + uint4(xyz:uint3, w:uint)
    + uint4(xyzw:uint4)
    + uint4(v:uint)
    + uint4(v:bool)
    + uint4(v:bool4)
    + uint4(v:int)
    + uint4(v:int4)
    + uint4(v:float)
    + uint4(v:float4)
    + uint4(v:double)
    + uint4(v:double4)
    + Equals(rhs:uint4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint4(x:uint, y:uint, z:uint, w:uint) : uint4
    + {static} uint4(x:uint, y:uint, zw:uint2) : uint4
    + {static} uint4(x:uint, yz:uint2, w:uint) : uint4
    + {static} uint4(x:uint, yzw:uint3) : uint4
    + {static} uint4(xy:uint2, z:uint, w:uint) : uint4
    + {static} uint4(xy:uint2, zw:uint2) : uint4
    + {static} uint4(xyz:uint3, w:uint) : uint4
    + {static} uint4(xyzw:uint4) : uint4
    + {static} uint4(v:uint) : uint4
    + {static} uint4(v:bool) : uint4
    + {static} uint4(v:bool4) : uint4
    + {static} uint4(v:int) : uint4
    + {static} uint4(v:int4) : uint4
    + {static} uint4(v:float) : uint4
    + {static} uint4(v:float4) : uint4
    + {static} uint4(v:double) : uint4
    + {static} uint4(v:double4) : uint4
    + {static} hash(v:uint4) : uint
    + {static} hashwide(v:uint4) : uint4
    + {static} shuffle(a:uint4, b:uint4, x:ShuffleComponent) : uint
    + {static} shuffle(a:uint4, b:uint4, x:ShuffleComponent, y:ShuffleComponent) : uint2
    + {static} shuffle(a:uint4, b:uint4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent) : uint3
    + {static} shuffle(a:uint4, b:uint4, x:ShuffleComponent, y:ShuffleComponent, z:ShuffleComponent, w:ShuffleComponent) : uint4
    <<internal>> {static} select_shuffle_component(a:uint4, b:uint4, component:ShuffleComponent) : uint
}
class "IEquatable`1"<T> {
}
class DebuggerProxy <<sealed>> {
    + x : uint
    + y : uint
    + z : uint
    + w : uint
    + DebuggerProxy(v:uint4)
}
IFormattable <|-- uint4
uint4 --> "zero" uint4
uint4 --> "xxxx" uint4
uint4 --> "xxxy" uint4
uint4 --> "xxxz" uint4
uint4 --> "xxxw" uint4
uint4 --> "xxyx" uint4
uint4 --> "xxyy" uint4
uint4 --> "xxyz" uint4
uint4 --> "xxyw" uint4
uint4 --> "xxzx" uint4
uint4 --> "xxzy" uint4
uint4 --> "xxzz" uint4
uint4 --> "xxzw" uint4
uint4 --> "xxwx" uint4
uint4 --> "xxwy" uint4
uint4 --> "xxwz" uint4
uint4 --> "xxww" uint4
uint4 --> "xyxx" uint4
uint4 --> "xyxy" uint4
uint4 --> "xyxz" uint4
uint4 --> "xyxw" uint4
uint4 --> "xyyx" uint4
uint4 --> "xyyy" uint4
uint4 --> "xyyz" uint4
uint4 --> "xyyw" uint4
uint4 --> "xyzx" uint4
uint4 --> "xyzy" uint4
uint4 --> "xyzz" uint4
uint4 --> "xyzw" uint4
uint4 --> "xywx" uint4
uint4 --> "xywy" uint4
uint4 --> "xywz" uint4
uint4 --> "xyww" uint4
uint4 --> "xzxx" uint4
uint4 --> "xzxy" uint4
uint4 --> "xzxz" uint4
uint4 --> "xzxw" uint4
uint4 --> "xzyx" uint4
uint4 --> "xzyy" uint4
uint4 --> "xzyz" uint4
uint4 --> "xzyw" uint4
uint4 --> "xzzx" uint4
uint4 --> "xzzy" uint4
uint4 --> "xzzz" uint4
uint4 --> "xzzw" uint4
uint4 --> "xzwx" uint4
uint4 --> "xzwy" uint4
uint4 --> "xzwz" uint4
uint4 --> "xzww" uint4
uint4 --> "xwxx" uint4
uint4 --> "xwxy" uint4
uint4 --> "xwxz" uint4
uint4 --> "xwxw" uint4
uint4 --> "xwyx" uint4
uint4 --> "xwyy" uint4
uint4 --> "xwyz" uint4
uint4 --> "xwyw" uint4
uint4 --> "xwzx" uint4
uint4 --> "xwzy" uint4
uint4 --> "xwzz" uint4
uint4 --> "xwzw" uint4
uint4 --> "xwwx" uint4
uint4 --> "xwwy" uint4
uint4 --> "xwwz" uint4
uint4 --> "xwww" uint4
uint4 --> "yxxx" uint4
uint4 --> "yxxy" uint4
uint4 --> "yxxz" uint4
uint4 --> "yxxw" uint4
uint4 --> "yxyx" uint4
uint4 --> "yxyy" uint4
uint4 --> "yxyz" uint4
uint4 --> "yxyw" uint4
uint4 --> "yxzx" uint4
uint4 --> "yxzy" uint4
uint4 --> "yxzz" uint4
uint4 --> "yxzw" uint4
uint4 --> "yxwx" uint4
uint4 --> "yxwy" uint4
uint4 --> "yxwz" uint4
uint4 --> "yxww" uint4
uint4 --> "yyxx" uint4
uint4 --> "yyxy" uint4
uint4 --> "yyxz" uint4
uint4 --> "yyxw" uint4
uint4 --> "yyyx" uint4
uint4 --> "yyyy" uint4
uint4 --> "yyyz" uint4
uint4 --> "yyyw" uint4
uint4 --> "yyzx" uint4
uint4 --> "yyzy" uint4
uint4 --> "yyzz" uint4
uint4 --> "yyzw" uint4
uint4 --> "yywx" uint4
uint4 --> "yywy" uint4
uint4 --> "yywz" uint4
uint4 --> "yyww" uint4
uint4 --> "yzxx" uint4
uint4 --> "yzxy" uint4
uint4 --> "yzxz" uint4
uint4 --> "yzxw" uint4
uint4 --> "yzyx" uint4
uint4 --> "yzyy" uint4
uint4 --> "yzyz" uint4
uint4 --> "yzyw" uint4
uint4 --> "yzzx" uint4
uint4 --> "yzzy" uint4
uint4 --> "yzzz" uint4
uint4 --> "yzzw" uint4
uint4 --> "yzwx" uint4
uint4 --> "yzwy" uint4
uint4 --> "yzwz" uint4
uint4 --> "yzww" uint4
uint4 --> "ywxx" uint4
uint4 --> "ywxy" uint4
uint4 --> "ywxz" uint4
uint4 --> "ywxw" uint4
uint4 --> "ywyx" uint4
uint4 --> "ywyy" uint4
uint4 --> "ywyz" uint4
uint4 --> "ywyw" uint4
uint4 --> "ywzx" uint4
uint4 --> "ywzy" uint4
uint4 --> "ywzz" uint4
uint4 --> "ywzw" uint4
uint4 --> "ywwx" uint4
uint4 --> "ywwy" uint4
uint4 --> "ywwz" uint4
uint4 --> "ywww" uint4
uint4 --> "zxxx" uint4
uint4 --> "zxxy" uint4
uint4 --> "zxxz" uint4
uint4 --> "zxxw" uint4
uint4 --> "zxyx" uint4
uint4 --> "zxyy" uint4
uint4 --> "zxyz" uint4
uint4 --> "zxyw" uint4
uint4 --> "zxzx" uint4
uint4 --> "zxzy" uint4
uint4 --> "zxzz" uint4
uint4 --> "zxzw" uint4
uint4 --> "zxwx" uint4
uint4 --> "zxwy" uint4
uint4 --> "zxwz" uint4
uint4 --> "zxww" uint4
uint4 --> "zyxx" uint4
uint4 --> "zyxy" uint4
uint4 --> "zyxz" uint4
uint4 --> "zyxw" uint4
uint4 --> "zyyx" uint4
uint4 --> "zyyy" uint4
uint4 --> "zyyz" uint4
uint4 --> "zyyw" uint4
uint4 --> "zyzx" uint4
uint4 --> "zyzy" uint4
uint4 --> "zyzz" uint4
uint4 --> "zyzw" uint4
uint4 --> "zywx" uint4
uint4 --> "zywy" uint4
uint4 --> "zywz" uint4
uint4 --> "zyww" uint4
uint4 --> "zzxx" uint4
uint4 --> "zzxy" uint4
uint4 --> "zzxz" uint4
uint4 --> "zzxw" uint4
uint4 --> "zzyx" uint4
uint4 --> "zzyy" uint4
uint4 --> "zzyz" uint4
uint4 --> "zzyw" uint4
uint4 --> "zzzx" uint4
uint4 --> "zzzy" uint4
uint4 --> "zzzz" uint4
uint4 --> "zzzw" uint4
uint4 --> "zzwx" uint4
uint4 --> "zzwy" uint4
uint4 --> "zzwz" uint4
uint4 --> "zzww" uint4
uint4 --> "zwxx" uint4
uint4 --> "zwxy" uint4
uint4 --> "zwxz" uint4
uint4 --> "zwxw" uint4
uint4 --> "zwyx" uint4
uint4 --> "zwyy" uint4
uint4 --> "zwyz" uint4
uint4 --> "zwyw" uint4
uint4 --> "zwzx" uint4
uint4 --> "zwzy" uint4
uint4 --> "zwzz" uint4
uint4 --> "zwzw" uint4
uint4 --> "zwwx" uint4
uint4 --> "zwwy" uint4
uint4 --> "zwwz" uint4
uint4 --> "zwww" uint4
uint4 --> "wxxx" uint4
uint4 --> "wxxy" uint4
uint4 --> "wxxz" uint4
uint4 --> "wxxw" uint4
uint4 --> "wxyx" uint4
uint4 --> "wxyy" uint4
uint4 --> "wxyz" uint4
uint4 --> "wxyw" uint4
uint4 --> "wxzx" uint4
uint4 --> "wxzy" uint4
uint4 --> "wxzz" uint4
uint4 --> "wxzw" uint4
uint4 --> "wxwx" uint4
uint4 --> "wxwy" uint4
uint4 --> "wxwz" uint4
uint4 --> "wxww" uint4
uint4 --> "wyxx" uint4
uint4 --> "wyxy" uint4
uint4 --> "wyxz" uint4
uint4 --> "wyxw" uint4
uint4 --> "wyyx" uint4
uint4 --> "wyyy" uint4
uint4 --> "wyyz" uint4
uint4 --> "wyyw" uint4
uint4 --> "wyzx" uint4
uint4 --> "wyzy" uint4
uint4 --> "wyzz" uint4
uint4 --> "wyzw" uint4
uint4 --> "wywx" uint4
uint4 --> "wywy" uint4
uint4 --> "wywz" uint4
uint4 --> "wyww" uint4
uint4 --> "wzxx" uint4
uint4 --> "wzxy" uint4
uint4 --> "wzxz" uint4
uint4 --> "wzxw" uint4
uint4 --> "wzyx" uint4
uint4 --> "wzyy" uint4
uint4 --> "wzyz" uint4
uint4 --> "wzyw" uint4
uint4 --> "wzzx" uint4
uint4 --> "wzzy" uint4
uint4 --> "wzzz" uint4
uint4 --> "wzzw" uint4
uint4 --> "wzwx" uint4
uint4 --> "wzwy" uint4
uint4 --> "wzwz" uint4
uint4 --> "wzww" uint4
uint4 --> "wwxx" uint4
uint4 --> "wwxy" uint4
uint4 --> "wwxz" uint4
uint4 --> "wwxw" uint4
uint4 --> "wwyx" uint4
uint4 --> "wwyy" uint4
uint4 --> "wwyz" uint4
uint4 --> "wwyw" uint4
uint4 --> "wwzx" uint4
uint4 --> "wwzy" uint4
uint4 --> "wwzz" uint4
uint4 --> "wwzw" uint4
uint4 --> "wwwx" uint4
uint4 --> "wwwy" uint4
uint4 --> "wwwz" uint4
uint4 --> "wwww" uint4
uint4 --> "xxx" uint3
uint4 --> "xxy" uint3
uint4 --> "xxz" uint3
uint4 --> "xxw" uint3
uint4 --> "xyx" uint3
uint4 --> "xyy" uint3
uint4 --> "xyz" uint3
uint4 --> "xyw" uint3
uint4 --> "xzx" uint3
uint4 --> "xzy" uint3
uint4 --> "xzz" uint3
uint4 --> "xzw" uint3
uint4 --> "xwx" uint3
uint4 --> "xwy" uint3
uint4 --> "xwz" uint3
uint4 --> "xww" uint3
uint4 --> "yxx" uint3
uint4 --> "yxy" uint3
uint4 --> "yxz" uint3
uint4 --> "yxw" uint3
uint4 --> "yyx" uint3
uint4 --> "yyy" uint3
uint4 --> "yyz" uint3
uint4 --> "yyw" uint3
uint4 --> "yzx" uint3
uint4 --> "yzy" uint3
uint4 --> "yzz" uint3
uint4 --> "yzw" uint3
uint4 --> "ywx" uint3
uint4 --> "ywy" uint3
uint4 --> "ywz" uint3
uint4 --> "yww" uint3
uint4 --> "zxx" uint3
uint4 --> "zxy" uint3
uint4 --> "zxz" uint3
uint4 --> "zxw" uint3
uint4 --> "zyx" uint3
uint4 --> "zyy" uint3
uint4 --> "zyz" uint3
uint4 --> "zyw" uint3
uint4 --> "zzx" uint3
uint4 --> "zzy" uint3
uint4 --> "zzz" uint3
uint4 --> "zzw" uint3
uint4 --> "zwx" uint3
uint4 --> "zwy" uint3
uint4 --> "zwz" uint3
uint4 --> "zww" uint3
uint4 --> "wxx" uint3
uint4 --> "wxy" uint3
uint4 --> "wxz" uint3
uint4 --> "wxw" uint3
uint4 --> "wyx" uint3
uint4 --> "wyy" uint3
uint4 --> "wyz" uint3
uint4 --> "wyw" uint3
uint4 --> "wzx" uint3
uint4 --> "wzy" uint3
uint4 --> "wzz" uint3
uint4 --> "wzw" uint3
uint4 --> "wwx" uint3
uint4 --> "wwy" uint3
uint4 --> "wwz" uint3
uint4 --> "www" uint3
uint4 --> "xx" uint2
uint4 --> "xy" uint2
uint4 --> "xz" uint2
uint4 --> "xw" uint2
uint4 --> "yx" uint2
uint4 --> "yy" uint2
uint4 --> "yz" uint2
uint4 --> "yw" uint2
uint4 --> "zx" uint2
uint4 --> "zy" uint2
uint4 --> "zz" uint2
uint4 --> "zw" uint2
uint4 --> "wx" uint2
uint4 --> "wy" uint2
uint4 --> "wz" uint2
uint4 --> "ww" uint2
uint4 +-- DebuggerProxy
class uint4x2 <<struct>> {
    + uint4x2(c0:uint4, c1:uint4)
    + uint4x2(m00:uint, m01:uint, m10:uint, m11:uint, m20:uint, m21:uint, m30:uint, m31:uint)
    + uint4x2(v:uint)
    + uint4x2(v:bool)
    + uint4x2(v:bool4x2)
    + uint4x2(v:int)
    + uint4x2(v:int4x2)
    + uint4x2(v:float)
    + uint4x2(v:float4x2)
    + uint4x2(v:double)
    + uint4x2(v:double4x2)
    + Equals(rhs:uint4x2) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint4x2(c0:uint4, c1:uint4) : uint4x2
    + {static} uint4x2(m00:uint, m01:uint, m10:uint, m11:uint, m20:uint, m21:uint, m30:uint, m31:uint) : uint4x2
    + {static} uint4x2(v:uint) : uint4x2
    + {static} uint4x2(v:bool) : uint4x2
    + {static} uint4x2(v:bool4x2) : uint4x2
    + {static} uint4x2(v:int) : uint4x2
    + {static} uint4x2(v:int4x2) : uint4x2
    + {static} uint4x2(v:float) : uint4x2
    + {static} uint4x2(v:float4x2) : uint4x2
    + {static} uint4x2(v:double) : uint4x2
    + {static} uint4x2(v:double4x2) : uint4x2
    + {static} transpose(v:uint4x2) : uint2x4
    + {static} hash(v:uint4x2) : uint
    + {static} hashwide(v:uint4x2) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint4x2
uint4x2 --> "c0" uint4
uint4x2 --> "c1" uint4
uint4x2 --> "zero" uint4x2
class uint4x3 <<struct>> {
    + uint4x3(c0:uint4, c1:uint4, c2:uint4)
    + uint4x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint, m20:uint, m21:uint, m22:uint, m30:uint, m31:uint, m32:uint)
    + uint4x3(v:uint)
    + uint4x3(v:bool)
    + uint4x3(v:bool4x3)
    + uint4x3(v:int)
    + uint4x3(v:int4x3)
    + uint4x3(v:float)
    + uint4x3(v:float4x3)
    + uint4x3(v:double)
    + uint4x3(v:double4x3)
    + Equals(rhs:uint4x3) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint4x3(c0:uint4, c1:uint4, c2:uint4) : uint4x3
    + {static} uint4x3(m00:uint, m01:uint, m02:uint, m10:uint, m11:uint, m12:uint, m20:uint, m21:uint, m22:uint, m30:uint, m31:uint, m32:uint) : uint4x3
    + {static} uint4x3(v:uint) : uint4x3
    + {static} uint4x3(v:bool) : uint4x3
    + {static} uint4x3(v:bool4x3) : uint4x3
    + {static} uint4x3(v:int) : uint4x3
    + {static} uint4x3(v:int4x3) : uint4x3
    + {static} uint4x3(v:float) : uint4x3
    + {static} uint4x3(v:float4x3) : uint4x3
    + {static} uint4x3(v:double) : uint4x3
    + {static} uint4x3(v:double4x3) : uint4x3
    + {static} transpose(v:uint4x3) : uint3x4
    + {static} hash(v:uint4x3) : uint
    + {static} hashwide(v:uint4x3) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint4x3
uint4x3 --> "c0" uint4
uint4x3 --> "c1" uint4
uint4x3 --> "c2" uint4
uint4x3 --> "zero" uint4x3
class uint4x4 <<struct>> {
    + uint4x4(c0:uint4, c1:uint4, c2:uint4, c3:uint4)
    + uint4x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint, m20:uint, m21:uint, m22:uint, m23:uint, m30:uint, m31:uint, m32:uint, m33:uint)
    + uint4x4(v:uint)
    + uint4x4(v:bool)
    + uint4x4(v:bool4x4)
    + uint4x4(v:int)
    + uint4x4(v:int4x4)
    + uint4x4(v:float)
    + uint4x4(v:float4x4)
    + uint4x4(v:double)
    + uint4x4(v:double4x4)
    + Equals(rhs:uint4x4) : bool
    + <<override>> Equals(o:object) : bool
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + ToString(format:string, formatProvider:IFormatProvider) : string
}
class math <<static>> <<partial>> {
    + {static} uint4x4(c0:uint4, c1:uint4, c2:uint4, c3:uint4) : uint4x4
    + {static} uint4x4(m00:uint, m01:uint, m02:uint, m03:uint, m10:uint, m11:uint, m12:uint, m13:uint, m20:uint, m21:uint, m22:uint, m23:uint, m30:uint, m31:uint, m32:uint, m33:uint) : uint4x4
    + {static} uint4x4(v:uint) : uint4x4
    + {static} uint4x4(v:bool) : uint4x4
    + {static} uint4x4(v:bool4x4) : uint4x4
    + {static} uint4x4(v:int) : uint4x4
    + {static} uint4x4(v:int4x4) : uint4x4
    + {static} uint4x4(v:float) : uint4x4
    + {static} uint4x4(v:float4x4) : uint4x4
    + {static} uint4x4(v:double) : uint4x4
    + {static} uint4x4(v:double4x4) : uint4x4
    + {static} transpose(v:uint4x4) : uint4x4
    + {static} hash(v:uint4x4) : uint
    + {static} hashwide(v:uint4x4) : uint4
}
class "IEquatable`1"<T> {
}
IFormattable <|-- uint4x4
uint4x4 --> "c0" uint4
uint4x4 --> "c1" uint4
uint4x4 --> "c2" uint4
uint4x4 --> "c3" uint4
uint4x4 o-> "identity" uint4x4
uint4x4 --> "zero" uint4x4
class MatrixDrawer {
    + <<override>> CanCacheInspectorGUI(property:SerializedProperty) : bool
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    DoUtilityMenu(property:SerializedProperty) : void
}
class "ReadOnlyCollection`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
PropertyDrawer <|-- MatrixDrawer
MatrixDrawer o-> "k_ColPropertyPaths<string>" "ReadOnlyCollection`1"
MatrixDrawer o-> "k_RowPropertyPaths<string>" "ReadOnlyCollection`1"
MatrixDrawer o-> "k_UtilityValueSetters<SerializedPropertyType,Action<SerializedProperty, bool>>" "Dictionary`2"
class PostNormalizedVectorDrawer {
    GetGUIData(property:SerializedProperty) : VectorPropertyGUIData
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
}
class Content <<static>> {
    + {static} <<readonly>> tooltip : string
}
class VectorPropertyGUIData {
    <<const>> k_MaxElements : int = 4
    + <<readonly>> Valid : bool
    <<readonly>> m_NumElements : int
    + VectorPropertyGUIData(property:SerializedProperty)
    UpdatePostNormalizedValues() : void
    + UpdatePreNormalizedValues() : void
    + ApplyPreNormalizedValues() : void
    + UnapplyPreNormalizedValues() : void
    + PostNormalize(normalize:Func<double4, double4>) : void
    + RebuildIfDirty() : void
}
class "Dictionary`2"<T1,T2> {
}
class "IReadOnlyList`1"<T> {
}
PrimitiveVectorDrawer <|-- PostNormalizedVectorDrawer
PostNormalizedVectorDrawer o-> "m_GUIDataPerPropertyPath<string,VectorPropertyGUIData>" "Dictionary`2"
PostNormalizedVectorDrawer +-- Content
PostNormalizedVectorDrawer +-- VectorPropertyGUIData
VectorPropertyGUIData --> "m_VectorProperty" SerializedProperty
VectorPropertyGUIData --> "m_ElementPaths<string>" "IReadOnlyList`1"
VectorPropertyGUIData o-> "m_PostNormalizedValues<SerializedProperty,double4>" "Dictionary`2"
class PrimitiveVectorDrawer {
    + <<override>> CanCacheInspectorGUI(property:SerializedProperty) : bool
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
}
class Content <<static>> {
    + {static} <<readonly>> doNotNormalizeCompatibility : string
    + {static} <<readonly>> doNotNormalizeTooltip : string
}
PropertyDrawer <|-- PrimitiveVectorDrawer
PrimitiveVectorDrawer +-- Content
class QuaternionDrawer {
}
PostNormalizedVectorDrawer <|-- QuaternionDrawer
class RequireApiProfileAttribute {
    + RequireApiProfileAttribute(apiProfiles:ApiCompatibilityLevel[])
    ApplyToTest(test:Test) : void
}
NUnitAttribute <|-- RequireApiProfileAttribute
IApplyToTest <|-- RequireApiProfileAttribute
class RequirePlatformSupportAttribute {
    + RequirePlatformSupportAttribute(platforms:BuildTarget[])
    ApplyToTest(test:Test) : void
}
NUnitAttribute <|-- RequirePlatformSupportAttribute
IApplyToTest <|-- RequirePlatformSupportAttribute
class TestBuildAssemblyFilter {
    + callbackOrder : int <<get>>
    + OnFilterAssemblies(buildOptions:BuildOptions, assemblies:string[]) : string[]
}
IFilterBuildAssemblies <|-- TestBuildAssemblyFilter
class TestResultSerializer {
    + id : string
    + fullName : string
    + uniqueName : string
    + {static} MakeFromTestResult(result:ITestResult) : TestResultSerializer
    + RestoreTestResult(result:TestResult) : void
    + IsPassed() : bool
}
class TestRunnerWindow {
    + {static} ShowWindow() : void
    <<internal>> {static} ShowPlaymodeTestsRunnerWindowCodeBased() : void
    {static} TestRunnerWindow()
    <<internal>> OnDestroy() : void
    <<internal>> OnGUI() : void
    + AddItemsToMenu(menu:GenericMenu) : void
    <<internal>> RebuildUIFilter() : void
    <<internal>> {static} UpdateWindow() : void
}
class Styles <<static>> {
    {static} Styles()
}
enum TestRunnerMenuLabels {
    PlayMode= 0,
    EditMode= 1,
}
EditorWindow <|-- TestRunnerWindow
IHasCustomMenu <|-- TestRunnerWindow
TestRunnerWindow --> "s_Instance" TestRunnerWindow
TestRunnerWindow --> "filterSettings" TestFilterSettings
TestRunnerWindow --> "m_SelectedTestTypes" TestListGUI
TestRunnerWindow +-- Styles
Styles --> "info" GUIStyle
Styles --> "testList" GUIStyle
TestRunnerWindow +-- TestRunnerMenuLabels
class TestRunnerWindowSettings {
    + verticalSplit : bool
    + TestRunnerWindowSettings(prefsKey:string)
    + ToggleVerticalSplit() : void
}
class CurveEditUtility <<static>> {
    {static} IsRotationKey(binding:EditorCurveBinding) : bool
    + {static} AddKey(clip:AnimationClip, sourceBinding:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    {static} AddObjectKey(clip:AnimationClip, sourceBinding:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    {static} AddRotationKey(clip:AnimationClip, sourceBind:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    {static} AddFloatKey(clip:AnimationClip, sourceBind:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    + {static} RemoveKey(clip:AnimationClip, sourceBinding:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    + {static} RemoveObjectKey(clip:AnimationClip, sourceBinding:EditorCurveBinding, time:double) : void
    + {static} GetObjectKeyCount(clip:AnimationClip, sourceBinding:EditorCurveBinding) : int
    {static} RemoveRotationKey(clip:AnimationClip, sourceBind:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    {static} RemoveFloatKey(clip:AnimationClip, sourceBind:EditorCurveBinding, prop:SerializedProperty, time:double) : void
    {static} UpdateEditorCurve(clip:AnimationClip, binding:EditorCurveBinding, curve:AnimationCurve) : void
    {static} UpdateEditorCurves(clip:AnimationClip, bindings:List<EditorCurveBinding>, curves:List<AnimationCurve>) : void
    + {static} RemoveCurves(clip:AnimationClip, prop:SerializedProperty) : void
    + {static} AddKeyFrameToCurve(curve:AnimationCurve, time:float, framerate:float, value:float, stepped:bool) : void
    + {static} RemoveKeyFrameFromCurve(curve:AnimationCurve, time:float, framerate:float) : bool
    + {static} GetKeyValue(prop:SerializedProperty) : float
    + {static} SetFromKeyValue(prop:SerializedProperty, keyValue:float) : void
    + {static} GetKeyframeAtTime(curve:AnimationCurve, time:float, frameRate:float) : int
    + {static} GetKeyframeAtTime(curve:ObjectReferenceKeyframe[], time:float, frameRate:float) : int
    + {static} GetKeyTime(time:float, frameRate:float) : float
    + {static} KeyCompare(timeA:float, timeB:float, frameRate:float) : int
    + {static} Evaluate(curve:ObjectReferenceKeyframe[], time:float) : Object
    + {static} EvaluateIndex(curve:ObjectReferenceKeyframe[], time:float) : int
    + {static} ShiftBySeconds(clip:AnimationClip, time:float) : void
    + {static} ScaleTime(clip:AnimationClip, scale:float) : void
    + {static} CreateMatchingCurve(curve:AnimationCurve) : AnimationCurve
    + {static} SanitizeCurveKeys(keys:Keyframe[], easeIn:bool) : Keyframe[]
}
class DirectorNamedColor {
    + SetDefault() : void
    + ToText(path:string) : void
    + FromText(text:string) : void
    {static} ParseFloat(str:string, f:float) : bool
    + {static} CreateAndLoadFromText(text:string) : DirectorNamedColor
}
ScriptableObject <|-- DirectorNamedColor
DirectorNamedColor --> "colorPlayhead" Color
DirectorNamedColor --> "colorSelection" Color
DirectorNamedColor --> "colorEndmarker" Color
DirectorNamedColor --> "colorGroup" Color
DirectorNamedColor --> "colorGroupTrackBackground" Color
DirectorNamedColor --> "colorAnimation" Color
DirectorNamedColor --> "colorAnimationRecorded" Color
DirectorNamedColor --> "colorAudio" Color
DirectorNamedColor --> "colorAudioWaveform" Color
DirectorNamedColor --> "colorActivation" Color
DirectorNamedColor --> "colorDropTarget" Color
DirectorNamedColor --> "colorClipFont" Color
DirectorNamedColor --> "colorInvalidClipOverlay" Color
DirectorNamedColor --> "colorTrackBackground" Color
DirectorNamedColor --> "colorTrackHeaderBackground" Color
DirectorNamedColor --> "colorTrackDarken" Color
DirectorNamedColor --> "colorTrackBackgroundRecording" Color
DirectorNamedColor --> "colorInfiniteTrackBackgroundRecording" Color
DirectorNamedColor --> "colorTrackBackgroundSelected" Color
DirectorNamedColor --> "colorTrackFont" Color
DirectorNamedColor --> "colorClipUnion" Color
DirectorNamedColor --> "colorTopOutline3" Color
DirectorNamedColor --> "colorDurationLine" Color
DirectorNamedColor --> "colorRange" Color
DirectorNamedColor --> "colorSequenceBackground" Color
DirectorNamedColor --> "colorTooltipBackground" Color
DirectorNamedColor --> "colorInfiniteClipLine" Color
DirectorNamedColor --> "colorDefaultTrackDrawer" Color
DirectorNamedColor o-> "colorDuration" Color
DirectorNamedColor o-> "colorRecordingClipOutline" Color
DirectorNamedColor o-> "colorAnimEditorBinding" Color
DirectorNamedColor o-> "colorTimelineBackground" Color
DirectorNamedColor o-> "colorLockTextBG" Color
DirectorNamedColor o-> "colorInlineCurveVerticalLines" Color
DirectorNamedColor o-> "colorInlineCurveOutOfRangeOverlay" Color
DirectorNamedColor --> "colorInlineCurvesBackground" Color
DirectorNamedColor o-> "markerDrawerBackgroundColor" Color
DirectorNamedColor o-> "markerHeaderDrawerBackgroundColor" Color
DirectorNamedColor o-> "colorControl" Color
DirectorNamedColor o-> "colorSubSequenceBackground" Color
DirectorNamedColor o-> "colorTrackSubSequenceBackground" Color
DirectorNamedColor o-> "colorTrackSubSequenceBackgroundSelected" Color
DirectorNamedColor o-> "colorSubSequenceOverlay" Color
DirectorNamedColor o-> "colorSubSequenceDurationLine" Color
DirectorNamedColor o-> "clipBckg" Color
DirectorNamedColor o-> "clipSelectedBckg" Color
DirectorNamedColor o-> "clipBorderColor" Color
DirectorNamedColor o-> "clipEaseBckgColor" Color
DirectorNamedColor --> "clipBlendIn" Color
DirectorNamedColor --> "clipBlendInSelected" Color
DirectorNamedColor --> "clipBlendOut" Color
DirectorNamedColor --> "clipBlendOutSelected" Color
class DirectorStyles {
    <<const>> k_Elipsis : string = "…"
    <<const>> k_ImagePath : string = "Packages/com.unity.timeline/Editor/StyleSheets/Images/Icons/{0&#125;.png"
    + <<const>> resourcesPath : string = "Packages/com.unity.timeline/Editor/StyleSheets/res/"
    + {static} <<readonly>> kBaseIndent : float = 15.0f
    + {static} <<readonly>> kDurationGuiThickness : float = 5.0f
    + <<const>> markerDefaultStyle : string = "MarkerItem"
    <<const>> k_DarkSkinPath : string
    <<const>> k_LightSkinPath : string
    + {static} IsInitialized : bool <<get>>
    + {static} ReloadStylesIfNeeded() : void
    LoadColorSkin(path:string) : DirectorNamedColor
    {static} CreateDefaultSkin() : DirectorNamedColor
    + ExportSkinToFile() : void
    + ReloadSkin() : void
    + Initialize() : void
    DirectorStyles()
    ShouldLoadStyles() : bool
    LoadStyles() : void
    + {static} GetGUIStyle(s:string) : GUIStyle
    + {static} TrIconContent(iconName:string, tooltip:string) : GUIContent
    + {static} IconContent(iconName:string) : GUIContent
    + {static} TrTextContentWithIcon(text:string, tooltip:string, iconName:string) : GUIContent
    + {static} TrTextContent(text:string, tooltip:string) : GUIContent
    + {static} LoadIcon(iconName:string) : Texture2D
    {static} ResolveIcon(icon:string) : string
    + {static} Elipsify(label:string, rect:Rect, style:GUIStyle) : string
    + {static} Elipsify(label:string, destinationWidth:float, neededWidth:float) : string
    + {static} GetBackgroundImage(style:GUIStyle, state:StyleState) : Texture2D
}
DirectorStyles o-> "referenceTrackLabel" GUIContent
DirectorStyles o-> "recordingLabel" GUIContent
DirectorStyles o-> "noTimelineAssetSelected" GUIContent
DirectorStyles o-> "createTimelineOnSelection" GUIContent
DirectorStyles o-> "noTimelinesInScene" GUIContent
DirectorStyles o-> "createNewTimelineText" GUIContent
DirectorStyles o-> "previewContent" GUIContent
DirectorStyles o-> "mixOff" GUIContent
DirectorStyles o-> "mixOn" GUIContent
DirectorStyles o-> "rippleOff" GUIContent
DirectorStyles o-> "rippleOn" GUIContent
DirectorStyles o-> "replaceOff" GUIContent
DirectorStyles o-> "replaceOn" GUIContent
DirectorStyles o-> "showMarkersOn" GUIContent
DirectorStyles o-> "showMarkersOff" GUIContent
DirectorStyles o-> "showMarkersOnTimeline" GUIContent
DirectorStyles o-> "timelineMarkerTrackHeader" GUIContent
DirectorStyles o-> "markerCollapseButton" GUIContent
DirectorStyles o-> "signalTrackIcon" GUIContent
DirectorStyles o-> "playContent" GUIContent
DirectorStyles o-> "gotoBeginingContent" GUIContent
DirectorStyles o-> "gotoEndContent" GUIContent
DirectorStyles o-> "nextFrameContent" GUIContent
DirectorStyles o-> "previousFrameContent" GUIContent
DirectorStyles o-> "newContent" GUIContent
DirectorStyles o-> "optionsCogIcon" GUIContent
DirectorStyles o-> "animationTrackIcon" GUIContent
DirectorStyles o-> "audioTrackIcon" GUIContent
DirectorStyles o-> "playableTrackIcon" GUIContent
DirectorStyles o-> "timelineSelectorArrow" GUIContent
DirectorStyles --> "playrangeContent" GUIContent
DirectorStyles o-> "kClipErrorColor" Color
DirectorStyles o-> "kMixToolColor" Color
DirectorStyles o-> "kRippleToolColor" Color
DirectorStyles o-> "kReplaceToolColor" Color
DirectorStyles --> "groupBackground" GUIStyle
DirectorStyles --> "displayBackground" GUIStyle
DirectorStyles --> "fontClip" GUIStyle
DirectorStyles --> "fontClipLoop" GUIStyle
DirectorStyles --> "trackHeaderFont" GUIStyle
DirectorStyles --> "trackGroupAddButton" GUIStyle
DirectorStyles --> "groupFont" GUIStyle
DirectorStyles --> "timeCursor" GUIStyle
DirectorStyles --> "endmarker" GUIStyle
DirectorStyles --> "tinyFont" GUIStyle
DirectorStyles --> "foldout" GUIStyle
DirectorStyles --> "mute" GUIStyle
DirectorStyles --> "locked" GUIStyle
DirectorStyles --> "autoKey" GUIStyle
DirectorStyles --> "playTimeRangeStart" GUIStyle
DirectorStyles --> "playTimeRangeEnd" GUIStyle
DirectorStyles --> "selectedStyle" GUIStyle
DirectorStyles --> "trackSwatchStyle" GUIStyle
DirectorStyles --> "connector" GUIStyle
DirectorStyles --> "keyframe" GUIStyle
DirectorStyles --> "warning" GUIStyle
DirectorStyles --> "extrapolationHold" GUIStyle
DirectorStyles --> "extrapolationLoop" GUIStyle
DirectorStyles --> "extrapolationPingPong" GUIStyle
DirectorStyles --> "extrapolationContinue" GUIStyle
DirectorStyles --> "collapseMarkers" GUIStyle
DirectorStyles --> "markerMultiOverlay" GUIStyle
DirectorStyles --> "bottomShadow" GUIStyle
DirectorStyles --> "trackOptions" GUIStyle
DirectorStyles --> "infiniteTrack" GUIStyle
DirectorStyles --> "clipOut" GUIStyle
DirectorStyles --> "clipIn" GUIStyle
DirectorStyles --> "curves" GUIStyle
DirectorStyles --> "lockedBG" GUIStyle
DirectorStyles --> "activation" GUIStyle
DirectorStyles --> "playrange" GUIStyle
DirectorStyles --> "lockButton" GUIStyle
DirectorStyles --> "avatarMaskOn" GUIStyle
DirectorStyles --> "avatarMaskOff" GUIStyle
DirectorStyles --> "markerWarning" GUIStyle
DirectorStyles --> "editModeBtn" GUIStyle
DirectorStyles --> "showMarkersBtn" GUIStyle
DirectorStyles --> "sequenceSwitcher" GUIStyle
DirectorStyles --> "s_Instance" DirectorStyles
DirectorStyles --> "m_DarkSkinColors" DirectorNamedColor
DirectorStyles --> "m_LightSkinColors" DirectorNamedColor
DirectorStyles --> "m_DefaultSkinColors" DirectorNamedColor
DirectorStyles o-> "s_TempContent" GUIContent
DirectorStyles --> "Instance" DirectorStyles
DirectorStyles --> "customSkin" DirectorNamedColor
class MenuOrder <<static>> {
    + <<const>> DefaultPriority : int = 9000
    + <<const>> SeparatorAt : int = 1000
    + <<const>> AddGroupItemStart : int
    + <<const>> AddTrackItemStart : int
    + <<const>> AddCustomTrackItemStart : int
    + <<const>> AddClipItemStart : int
    + <<const>> AddCustomClipItemStart : int
    + <<const>> AddMarkerItemStart : int
    + <<const>> AddCustomMarkerItemStart : int
}
class TimelineAction <<static>> {
    + <<const>> Start : int = 1000
    + <<const>> Copy : int
    + <<const>> Paste : int
    + <<const>> Duplicate : int
    + <<const>> Delete : int
    + <<const>> MatchContent : int
}
class TrackAction <<static>> {
    + <<const>> Start : int
    + <<const>> LockTrack : int
    + <<const>> LockSelected : int
    + <<const>> MuteTrack : int
    + <<const>> MuteSelected : int
    + <<const>> ShowHideMarkers : int
    + <<const>> RemoveInvalidMarkers : int
    + <<const>> EditInAnimationWindow : int
}
class TrackAddMenu <<static>> {
    + <<const>> Start : int
    + <<const>> AddLayerTrack : int
}
class ClipEditAction <<static>> {
    + <<const>> Start : int
    + <<const>> EditInAnimationWindow : int
    + <<const>> EditSubTimeline : int
}
class ClipAction <<static>> {
    + <<const>> Start : int
    + <<const>> TrimStart : int
    + <<const>> TrimEnd : int
    + <<const>> Split : int
    + <<const>> CompleteLastLoop : int
    + <<const>> TrimLastLoop : int
    + <<const>> MatchDuration : int
    + <<const>> DoubleSpeed : int
    + <<const>> HalfSpeed : int
    + <<const>> ResetDuration : int
    + <<const>> ResetSpeed : int
    + <<const>> ResetAll : int
    + <<const>> Tile : int
    + <<const>> FindSourceAsset : int
}
class MarkerAction <<static>> {
    + <<const>> Start : int
}
class CustomTrackAction <<static>> {
    + <<const>> Start : int
    + <<const>> AnimConvertToClipMode : int
    + <<const>> AnimConvertFromClipMode : int
    + <<const>> AnimApplyTrackOffset : int
    + <<const>> AnimApplySceneOffset : int
    + <<const>> AnimApplyAutoOffset : int
    + <<const>> AnimAddOverrideTrack : int
}
class CustomClipAction <<static>> {
    + <<const>> Start : int
    + <<const>> AnimClipMatchPrevious : int
    + <<const>> AnimClipMatchNext : int
    + <<const>> AnimClipResetOffset : int
}
MenuOrder +-- TimelineAction
MenuOrder +-- TrackAction
MenuOrder +-- TrackAddMenu
MenuOrder +-- ClipEditAction
MenuOrder +-- ClipAction
MenuOrder +-- MarkerAction
MenuOrder +-- CustomTrackAction
MenuOrder +-- CustomClipAction
class Shortcuts <<static>> {
    {static} GetState(args:ShortcutManagement.ShortcutArguments) : WindowState
    {static} SendEventToInvokeShortcut(timelineShortcutId:string, context:object) : void
}
class Clip <<static>> {
    + <<const>> split : string = "Timeline/Editing/Split"
    + <<const>> trimStart : string = "Timeline/Editing/TrimStart"
    + <<const>> trimEnd : string = "Timeline/Editing/TrimEnd"
    {static} Split(args:ShortcutManagement.ShortcutArguments) : void
    {static} TrimStart(args:ShortcutManagement.ShortcutArguments) : void
    {static} TrimEnd(args:ShortcutManagement.ShortcutArguments) : void
}
class Timeline <<static>> {
    + <<const>> play : string = "Timeline/Play"
    + <<const>> previousFrame : string = "Timeline/PrevFrame"
    + <<const>> nextFrame : string = "Timeline/NextFrame"
    + <<const>> frameAll : string = "Timeline/FrameAll"
    + <<const>> previousKey : string = "Timeline/PrevKey"
    + <<const>> nextKey : string = "Timeline/NextKey"
    + <<const>> goToStart : string = "Timeline/GotoStart"
    + <<const>> goToEnd : string = "Timeline/GotoEnd"
    + <<const>> zoomIn : string = "Timeline/ZoomIn"
    + <<const>> zoomOut : string = "Timeline/ZoomOut"
    + <<const>> collapseGroup : string = "Timeline/CollapseGroup"
    + <<const>> unCollapseGroup : string = "Timeline/UnCollapseGroup"
    + <<const>> selectLeftItem : string = "Timeline/SelectLeftItem"
    + <<const>> selectRightItem : string = "Timeline/SelectRightItem"
    + <<const>> selectUpItem : string = "Timeline/SelectUpItem"
    + <<const>> selectUpTrack : string = "Timeline/SelectUpTrack"
    + <<const>> selectDownItem : string = "Timeline/SelectDownItem"
    + <<const>> selectDownTrack : string = "Timeline/SelectDownTrack"
    + <<const>> multiSelectLeft : string = "Timeline/SelectLeft"
    + <<const>> multiSelectRight : string = "Timeline/SelectRight"
    + <<const>> multiSelectUp : string = "Timeline/SelectUp"
    + <<const>> multiSelectDown : string = "Timeline/SelectDown"
    + <<const>> toggleClipTrackArea : string = "Timeline/ToggleClipTrackArea"
    + <<const>> matchContent : string = "Timeline/MatchContent"
    + <<const>> toggleLock : string = "Timeline/ToggleLock"
    + <<const>> toggleMute : string = "Timeline/ToggleMute"
    + <<const>> moveLeft : string = "Timeline/MoveLeft"
    + <<const>> moveRight : string = "Timeline/MoveRight"
    + <<const>> moveUp : string = "Timeline/MoveUp"
    + <<const>> moveDown : string = "Timeline/MoveDown"
    {static} Play(args:ShortcutManagement.ShortcutArguments) : void
    {static} PreviousFrame(args:ShortcutManagement.ShortcutArguments) : void
    {static} NextFrame(args:ShortcutManagement.ShortcutArguments) : void
    {static} FrameAll(args:ShortcutManagement.ShortcutArguments) : void
    {static} PrevKey(args:ShortcutManagement.ShortcutArguments) : void
    {static} NextKey(args:ShortcutManagement.ShortcutArguments) : void
    {static} GoToStart(args:ShortcutManagement.ShortcutArguments) : void
    {static} GoToEnd(args:ShortcutManagement.ShortcutArguments) : void
    {static} ZoomIn(args:ShortcutManagement.ShortcutArguments) : void
    {static} ZoomOut(args:ShortcutManagement.ShortcutArguments) : void
    {static} SelectLeft(args:ShortcutManagement.ShortcutArguments) : void
    {static} SelectRight(args:ShortcutManagement.ShortcutArguments) : void
    {static} SelectUp(args:ShortcutManagement.ShortcutArguments) : void
    {static} SelectDown(args:ShortcutManagement.ShortcutArguments) : void
    {static} MultiSelectLeft(args:ShortcutManagement.ShortcutArguments) : void
    {static} MultiSelectRight(args:ShortcutManagement.ShortcutArguments) : void
    {static} MultiSelectUp(args:ShortcutManagement.ShortcutArguments) : void
    {static} MultiSelectDown(args:ShortcutManagement.ShortcutArguments) : void
    {static} ToggleClipTrackArea(args:ShortcutManagement.ShortcutArguments) : void
    {static} Shortcut(args:ShortcutManagement.ShortcutArguments) : void
    {static} Lock(args:ShortcutManagement.ShortcutArguments) : void
    {static} Mute(args:ShortcutManagement.ShortcutArguments) : void
}
Shortcuts +-- Clip
Shortcuts +-- Timeline
class TimelineEditor <<static>> {
    + {static} Refresh(reason:RefreshReason) : void
}
enum RefreshReason {
    WindowNeedsRedraw= 1 << 0,
    SceneNeedsUpdate= 1 << 1,
    ContentsModified= 1 << 2,
    ContentsAddedOrRemoved= 1 << 3,
}
TimelineEditor --> "inspectedDirector" PlayableDirector
TimelineEditor --> "masterDirector" PlayableDirector
TimelineEditor --> "inspectedAsset" TimelineAsset
TimelineEditor --> "masterAsset" TimelineAsset
TimelineEditor --> "playableDirector" PlayableDirector
TimelineEditor --> "timelineAsset" TimelineAsset
TimelineEditor --> "window" TimelineWindow
TimelineEditor --> "state" WindowState
TimelineEditor o-> "clipboard" Clipboard
TimelineEditor --> "selectedClip" TimelineClip
class TimelineHelpers <<static>> {
    {static} IsExposedReferenceExplicitlyNamed(name:string) : bool
    {static} GenerateExposedReferenceName() : string
    + {static} CloneExposedReferences(clone:ScriptableObject, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable) : void
    + {static} CloneReferencedPlayableAsset(original:ScriptableObject, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, newOwner:Object) : ScriptableObject
    {static} SaveCloneToAsset(clone:Object, newOwner:Object) : void
    {static} CloneAnimationClip(clip:AnimationClip, owner:Object) : AnimationClip
    + {static} Clone(clip:TimelineClip, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, time:double, newOwner:PlayableAsset) : TimelineClip
    + {static} Clone(parent:PlayableAsset, trackAsset:TrackAsset, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, assetOwner:PlayableAsset) : TrackAsset
    + {static} DuplicateItemsUsingCurrentEditMode(state:WindowState, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, items:ItemsPerTrack, targetParent:TrackAsset, candidateTime:double, undoOperation:string) : IEnumerable<ITimelineItem>
    + {static} DuplicateItemsUsingCurrentEditMode(state:WindowState, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, items:IEnumerable<ItemsPerTrack>, candidateTime:double, undoOperation:string) : IEnumerable<ITimelineItem>
    <<internal>> {static} DuplicateItems(items:ItemsPerTrack, target:TrackAsset, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, undoOperation:string) : ItemsPerTrack
    {static} FinalizeInsertItemsUsingCurrentEditMode(state:WindowState, itemsGroups:IList<ItemsPerTrack>, candidateTime:double) : void
    <<internal>> {static} Clone(clip:TimelineClip, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, newOwner:PlayableAsset) : TimelineClip
    {static} DuplicateClips(clips:IEnumerable<TimelineClip>, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, newOwner:PlayableAsset) : TimelineClip[]
    {static} DuplicateClip(clip:TimelineClip, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, newOwner:PlayableAsset) : TimelineClip
    + {static} GetCustomDrawer(trackType:Type) : Type
    + {static} HaveSameContainerAsset(assetA:Object, assetB:Object) : bool
    + {static} SaveAnimClipIntoObject(clip:AnimationClip, asset:Object) : void
    + {static} AddRequiredComponent(go:GameObject, asset:TrackAsset) : Component
    + {static} GetTrackCategoryName(trackType:System.Type) : string
    + {static} GetItemCategoryName(itemType:System.Type) : string
    + {static} GetTrackMenuName(trackType:System.Type) : string
    + {static} GetLoopDuration(clip:TimelineClip) : double
    + {static} GetClipAssetEndTime(clip:TimelineClip) : double
    + {static} HasUsableAssetDuration(clip:TimelineClip) : bool
    + {static} GetLoopTimes(clip:TimelineClip) : double[]
    + {static} GetCandidateTime(state:WindowState, mousePosition:Vector2?, trackAssets:TrackAsset[]) : double
    + {static} CreateClipOnTrack(asset:Object, parentTrack:TrackAsset, state:WindowState) : TimelineClip
    + {static} CreateClipOnTrack(asset:Object, parentTrack:TrackAsset, candidateTime:double) : TimelineClip
    + {static} CreateClipOnTrack(playableAssetType:Type, parentTrack:TrackAsset, state:WindowState) : TimelineClip
    + {static} CreateClipOnTrack(playableAssetType:Type, parentTrack:TrackAsset, candidateTime:double) : TimelineClip
    + {static} CreateClipOnTrack(asset:Object, parentTrack:TrackAsset, candidateTime:double, state:WindowState) : TimelineClip
    + {static} CreateClipOnTrack(playableAssetType:Type, assignableObject:Object, parentTrack:TrackAsset, candidateTime:double) : TimelineClip
    + {static} CreateClipOnTrack(playableAssetType:Type, assignableObject:Object, parentTrack:TrackAsset, candidateTime:double, state:WindowState) : TimelineClip
    + {static} CreateClipOnTrackFromPlayableAsset(asset:IPlayableAsset, parentTrack:TrackAsset, candidateTime:double) : TimelineClip
    + {static} CreateClipsFromObjects(assetType:Type, targetTrack:TrackAsset, candidateTime:double, objects:IEnumerable<Object>) : void
    + {static} CreateMarkersFromObjects(assetType:Type, targetTrack:TrackAsset, candidateTime:double, objects:IEnumerable<Object>) : void
    + {static} CreateMarkerOnTrack(markerType:Type, assignableObject:Object, parentTrack:TrackAsset, candidateTime:double) : IMarker
    + {static} CreateClipsFromTypes(assetTypes:IEnumerable<Type>, targetTrack:TrackAsset, candidateTime:double) : void
    + {static} FrameItems(state:WindowState, items:IEnumerable<ITimelineItem>) : void
    + {static} Frame(state:WindowState, start:double, end:double) : void
    + {static} RangeSelect(totalCollection:IList<T>, currentSelection:IList<T>, clickedItem:T, selector:Action<T>, remover:Action<T>) : void
    + {static} Bind(track:TrackAsset, obj:Object, director:PlayableDirector) : void
    {static} AddClipOnTrack(newClip:TimelineClip, parentTrack:TrackAsset, candidateTime:double, assignableObject:Object, state:WindowState) : void
    + {static} CreateTrack(asset:TimelineAsset, type:Type, parent:TrackAsset, name:string) : TrackAsset
    + {static} CreateTrack(type:Type, parent:TrackAsset, name:string) : TrackAsset
    + {static} CreateTrack(asset:TimelineAsset, parent:TrackAsset, name:string) : T
    + {static} CreateTrack(parent:TrackAsset, name:string) : T
}
class "List`1"<T> {
}
TimelineHelpers --> "s_SubClassesOfTrackDrawer<Type>" "List`1"
class SelectionManager <<static>> {
    + {static} AddObject(obj:Object) : void
    + {static} Add(obj:TrackAsset) : void
    + {static} Add(item:TimelineClip) : void
    + {static} Add(marker:IMarker) : void
    + {static} Add(item:ITimelineItem) : void
    + {static} SelectOnly(track:TrackAsset) : void
    + {static} SelectOnly(clip:TimelineClip) : void
    + {static} SelectOnly(item:IMarker) : void
    + {static} SelectOnly(item:ITimelineItem) : void
    + {static} SelectInlineCurveEditor(selection:IClipCurveEditorOwner) : void
    + {static} GetCurrentInlineEditorCurve() : IClipCurveEditorOwner
    + {static} IsCurveEditorFocused(selection:IClipCurveEditorOwner) : bool
    + {static} Contains(item:TrackAsset) : bool
    + {static} Contains(item:TimelineClip) : bool
    + {static} Contains(obj:Object) : bool
    + {static} Contains(marker:IMarker) : bool
    + {static} Contains(item:ITimelineItem) : bool
    + {static} Clear() : void
    + {static} UnSelectTracks() : void
    + {static} Remove(item:TimelineClip) : void
    + {static} Remove(marker:IMarker) : void
    {static} Remove(item:Object) : void
    + {static} Remove(item:TrackAsset) : void
    + {static} Remove(item:ITimelineItem) : void
    + {static} RemoveTimelineSelection() : void
    + {static} RemoveAllClips() : void
    + {static} Count() : int
    + {static} SelectedClipGUI() : IEnumerable<TimelineClipGUI>
    + {static} SelectedClips() : IEnumerable<TimelineClip>
    + {static} SelectedMarkers() : IEnumerable<IMarker>
    + {static} SelectedTracks() : IEnumerable<TrackAsset>
    + {static} SelectedItemOfType() : IEnumerable<T>
    + {static} SelectedTrackGUI() : IEnumerable<TimelineTrackBaseGUI>
    {static} IsTimelineType(o:Object) : bool
    + {static} SelectedItems() : IEnumerable<ITimelineItem>
}
SelectionManager --> "currentInlineEditorCurve" IClipCurveEditorOwner
class TimelineUtility <<static>> {
    + {static} ReorderTracks(allTracks:List<ScriptableObject>, tracks:List<TrackAsset>, insertAfterAsset:ScriptableObject, up:bool) : void
    + {static} GetSceneReferenceTrack(asset:TrackAsset) : TrackAsset
    + {static} TrackHasAnimationCurves(track:TrackAsset) : bool
    + {static} GetSceneGameObject(director:PlayableDirector, asset:TrackAsset) : GameObject
    + {static} SetSceneGameObject(director:PlayableDirector, asset:TrackAsset, go:GameObject) : void
    + {static} GetDirectorsInSceneUsingAsset(asset:PlayableAsset) : PlayableDirector[]
    + {static} GetDirectorComponentForGameObject(gameObject:GameObject) : PlayableDirector
    + {static} GetTimelineAssetForDirectorComponent(director:PlayableDirector) : TimelineAsset
    + {static} IsPrefabOrAsset(obj:Object) : bool
    <<internal>> {static} PropertyToString(property:SerializedProperty) : string
    <<internal>> {static} IsRecordableAnimationClip(clip:TimelineClip) : bool
    + {static} GetSubTimelines(clip:TimelineClip, director:IExposedPropertyTable) : IList<PlayableDirector>
    + {static} IsAllSubTrackMuted(asset:TrackAsset) : bool
    + {static} IsParentMuted(asset:TrackAsset) : bool
    + {static} GetAllDirectorsInHierarchy(mainDirector:PlayableDirector) : IEnumerable<PlayableDirector>
    {static} GetAllDirectorsInHierarchy(director:PlayableDirector, directors:ISet<PlayableDirector>) : void
    + {static} GetBindingsFromDirectors(directors:IEnumerable<PlayableDirector>) : IEnumerable<T>
    + {static} IsLockedFromGroup(asset:TrackAsset) : bool
    <<internal>> {static} IsCurrentSequenceValid() : bool
}
class Tooltip {
    + text : string <<get>> <<set>>
    m_Pad : float = 4.0f
    + pad : float <<get>> <<set>>
    + Tooltip(theStyle:GUIStyle, font:GUIStyle)
    + Tooltip()
    + Draw() : void
}
Tooltip --> "style" GUIStyle
Tooltip --> "m_Font" GUIStyle
Tooltip --> "font" GUIStyle
Tooltip --> "m_TextContent" GUIContent
Tooltip --> "textContent" GUIContent
Tooltip o-> "m_ForeColor" Color
Tooltip --> "foreColor" Color
Tooltip --> "m_Bounds" Rect
Tooltip --> "bounds" Rect
class Gaps <<static>> {
    {static} <<readonly>> kInsertTime : string = "Insert Time"
    + {static} Insert(asset:TimelineAsset, at:double, amount:double, tolerance:double) : void
}
class PlayheadContextMenu {
    + PlayheadContextMenu(timeAreaItem:TimeAreaItem)
    {static} SelectBlendingIntersecting(clip:TimelineClip, time:double) : bool
    {static} SelectMenuCallback(selector:Func<TimelineClip, bool>, state:WindowState) : void
}
class TimeAreaContextMenu {
    <<internal>> {static} AddTimeAreaMenuItems(menu:GenericMenu, state:WindowState) : void
    {static} SelectDurationCallback(state:WindowState, mode:TimelineAsset.DurationMode) : void
}
class Scrub {
    m_IsCaptured : bool
    + Scrub(onMouseDown:Func<Event, WindowState, bool>, onMouseDrag:Action<double>, onMouseUp:Action)
}
class TimeAreaItem {
    + drawLine : bool <<get>> <<set>>
    + drawHead : bool <<get>> <<set>>
    + canMoveHead : bool <<get>> <<set>>
    + tooltip : string <<get>> <<set>>
    widgetHeight : float <<get>>
    widgetWidth : float <<get>>
    + showTooltip : bool <<get>> <<set>>
    + firstDrag : bool <<get>>
    + TimeAreaItem(style:GUIStyle, onDrag:Action<double>)
    + Draw(rect:Rect, state:WindowState, time:double) : void
}
class "Func`3"<T1,T2,T3> {
}
class "Action`1"<T> {
}
Manipulator <|-- PlayheadContextMenu
PlayheadContextMenu --> "m_TimeAreaItem" TimeAreaItem
Manipulator <|-- TimeAreaContextMenu
Manipulator <|-- Scrub
Scrub --> "m_OnMouseDown<Event,WindowState,bool>" "Func`3"
Scrub --> "m_OnMouseDrag<double>" "Action`1"
Scrub --> "m_OnMouseUp" Action
Control <|-- TimeAreaItem
TimeAreaItem --> "headColor" Color
TimeAreaItem --> "lineColor" Color
TimeAreaItem --> "boundOffset" Vector2
TimeAreaItem o-> "m_HeaderContent" GUIContent
TimeAreaItem --> "m_Style" GUIStyle
TimeAreaItem --> "m_Tooltip" Tooltip
TimeAreaItem --> "m_BoundingRect" Rect
TimeAreaItem --> "bounds" Rect
TimeAreaItem --> "style" GUIStyle
class UnityEditorInternals <<static>> {
    + {static} DoObjectField(position:Rect, obj:Object, type:Type, controlId:int, allowScene:bool) : Object
}
enum ClipCaps {
    None= 0,
    Looping= 1 << 0,
    Extrapolation= 1 << 1,
    ClipIn= 1 << 2,
    SpeedMultiplier= 1 << 3,
    Blending= 1 << 4,
    All= ~None,
}
class TimelineClipCapsExtensions <<static>> {
    + {static} SupportsLooping(clip:TimelineClip) : bool
    + {static} SupportsExtrapolation(clip:TimelineClip) : bool
    + {static} SupportsClipIn(clip:TimelineClip) : bool
    + {static} SupportsSpeedMultiplier(clip:TimelineClip) : bool
    + {static} SupportsBlending(clip:TimelineClip) : bool
    + {static} HasAll(caps:ClipCaps, flags:ClipCaps) : bool
    + {static} HasAny(caps:ClipCaps, flags:ClipCaps) : bool
}
class DiscreteTime <<struct>> {
    <<const>> k_Tick : double = 1e-12
    + {static} tickValue : double <<get>>
    + DiscreteTime(time:DiscreteTime)
    DiscreteTime(time:Int64)
    + DiscreteTime(time:double)
    + DiscreteTime(time:float)
    + DiscreteTime(time:int)
    + DiscreteTime(frame:int, fps:double)
    + OneTickBefore() : DiscreteTime
    + OneTickAfter() : DiscreteTime
    + GetTick() : Int64
    + {static} FromTicks(ticks:Int64) : DiscreteTime
    + CompareTo(obj:object) : int
    + Equals(other:DiscreteTime) : bool
    + <<override>> Equals(obj:object) : bool
    {static} DoubleToDiscreteTime(time:double) : Int64
    {static} FloatToDiscreteTime(time:float) : Int64
    {static} IntToDiscreteTime(time:int) : Int64
    {static} ToDouble(time:Int64) : double
    {static} ToFloat(time:Int64) : float
    + <<override>> ToString() : string
    + <<override>> GetHashCode() : int
    + {static} Min(lhs:DiscreteTime, rhs:DiscreteTime) : DiscreteTime
    + {static} Max(lhs:DiscreteTime, rhs:DiscreteTime) : DiscreteTime
    + {static} SnapToNearestTick(time:double) : double
    + {static} SnapToNearestTick(time:float) : float
    + {static} GetNearestTick(time:double) : Int64
}
IComparable <|-- DiscreteTime
DiscreteTime o-> "kMaxTime" DiscreteTime
DiscreteTime --> "m_DiscreteTime" Int64
class GroupTrack {
    <<internal>> <<override>> CanCompileClips() : bool
}
class "IEnumerable`1"<T> {
}
TrackAsset <|-- GroupTrack
GroupTrack --> "outputs<PlayableBinding>" "IEnumerable`1"
interface ILayerable {
    CreateLayerMixer(graph:PlayableGraph, go:GameObject, inputCount:int) : Playable
}
class TimelineAsset <<partial>> {
}
class TrackMediaType {
    + TrackMediaType(mt:TimelineAsset.MediaType)
}
enum MediaType {
    Animation,
    Audio,
    Texture= 2,
    Video= 2,
    Script,
    Hybrid,
    Group,
}
Attribute <|-- TrackMediaType
TimelineAsset +-- MediaType
class TimelineAsset <<partial>> {
    m_FixedDuration : double
    + <<override>> duration : double <<get>>
    + fixedDuration : double <<get>> <<set>>
    + outputTrackCount : int <<get>>
    + rootTrackCount : int <<get>>
    OnValidate() : void
    {static} GetValidFramerate(framerate:float) : float
    + GetRootTrack(index:int) : TrackAsset
    + GetRootTracks() : IEnumerable<TrackAsset>
    + GetOutputTrack(index:int) : TrackAsset
    + GetOutputTracks() : IEnumerable<TrackAsset>
    UpdateRootTrackCache() : void
    UpdateOutputTrackCache() : void
    <<internal>> AddTrackInternal(track:TrackAsset) : void
    <<internal>> RemoveTrack(track:TrackAsset) : void
    + <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
    __internalAwake() : void
    + GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
    + CreateMarkerTrack() : void
    <<internal>> Invalidate() : void
    CalculateDuration() : double
    {static} AddSubTracksRecursive(track:TrackAsset, allTracks:List<TrackAsset>) : void
}
enum DurationMode {
    BasedOnClips,
    FixedLength,
}
class EditorSettings {
    <<internal>> {static} <<readonly>> kMinFps : float
    <<internal>> {static} <<readonly>> kMaxFps : float = 1000.0f
    <<internal>> {static} <<readonly>> kDefaultFps : float = 60.0f
    m_Framerate : float
    + fps : float <<get>> <<set>>
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
PlayableAsset <|-- TimelineAsset
ISerializationCallbackReceiver <|-- TimelineAsset
ITimelineClipAsset <|-- TimelineAsset
IPropertyPreview <|-- TimelineAsset
TimelineAsset --> "m_Tracks<ScriptableObject>" "List`1"
TimelineAsset --> "m_CacheRootTracks<TrackAsset>" "List`1"
TimelineAsset --> "m_CacheFlattenedTracks<TrackAsset>" "List`1"
TimelineAsset o-> "m_EditorSettings" EditorSettings
TimelineAsset --> "m_DurationMode" DurationMode
TimelineAsset --> "m_MarkerTrack" MarkerTrack
TimelineAsset --> "editorSettings" EditorSettings
TimelineAsset --> "durationMode" DurationMode
TimelineAsset --> "outputs<PlayableBinding>" "IEnumerable`1"
TimelineAsset --> "clipCaps" ClipCaps
TimelineAsset --> "flattenedTracks<TrackAsset>" "IEnumerable`1"
TimelineAsset --> "markerTrack" MarkerTrack
TimelineAsset --> "trackObjects<ScriptableObject>" "List`1"
TimelineAsset +-- DurationMode
TimelineAsset +-- EditorSettings
class TimelineAsset <<partial>> {
    + CreateTrack(type:Type, parent:TrackAsset, name:string) : TrackAsset
    + CreateTrack(parent:TrackAsset, trackName:string) : T
    + CreateTrack(trackName:string) : T
    + CreateTrack() : T
    + DeleteClip(clip:TimelineClip) : bool
    + DeleteTrack(track:TrackAsset) : bool
    <<internal>> MoveLastTrackBefore(asset:TrackAsset) : void
    <<internal>> AllocateTrack(trackAssetParent:TrackAsset, trackName:string, trackType:Type) : TrackAsset
    DeleteRecordedAnimation(track:TrackAsset) : void
    DeleteRecordedAnimation(clip:TimelineClip) : void
}
class TrackClipTypeAttribute {
    + <<readonly>> allowAutoCreate : bool
    + TrackClipTypeAttribute(clipClass:Type)
    + TrackClipTypeAttribute(clipClass:Type, allowAutoCreate:bool)
}
class NotKeyableAttribute {
}
enum TrackBindingFlags {
    None= 0,
    AllowCreateComponent= 1,
    All= AllowCreateComponent,
}
class TrackBindingTypeAttribute {
    + TrackBindingTypeAttribute(type:Type)
    + TrackBindingTypeAttribute(type:Type, flags:TrackBindingFlags)
}
class SupportsChildTracksAttribute {
    + <<readonly>> levels : int
    + SupportsChildTracksAttribute(childType:Type, levels:int)
}
class IgnoreOnPlayableTrackAttribute {
}
class TimeFieldAttribute {
    + TimeFieldAttribute(useEditMode:UseEditMode)
}
class HideInMenuAttribute {
}
class CustomStyleAttribute {
    + <<readonly>> ussStyle : string
    + CustomStyleAttribute(ussStyle:string)
}
class MenuCategoryAttribute {
    + <<readonly>> category : string
    + MenuCategoryAttribute(category:string)
}
enum UseEditMode {
    None,
    ApplyEditMode,
}
Attribute <|-- TrackClipTypeAttribute
TrackClipTypeAttribute --> "inspectedType" Type
Attribute <|-- NotKeyableAttribute
Attribute <|-- TrackBindingTypeAttribute
TrackBindingTypeAttribute --> "type" Type
TrackBindingTypeAttribute --> "flags" TrackBindingFlags
Attribute <|-- SupportsChildTracksAttribute
SupportsChildTracksAttribute --> "childType" Type
PropertyAttribute <|-- TimeFieldAttribute
TimeFieldAttribute --> "useEditMode" UseEditMode
Attribute <|-- HideInMenuAttribute
Attribute <|-- CustomStyleAttribute
Attribute <|-- MenuCategoryAttribute
TimeFieldAttribute +-- UseEditMode
interface ITimelineClipAsset {
}
class TimelineClip <<partial>> {
    + {static} <<readonly>> kDefaultClipDurationInSeconds : float = 5
    + {static} <<readonly>> kTimeScaleMin : double
    + {static} <<readonly>> kTimeScaleMax : double = 1000
    <<internal>> {static} <<readonly>> kDefaultCurvesName : string = "Clip Parameters"
    <<internal>> {static} <<readonly>> kMinDuration : double
    <<internal>> {static} <<readonly>> kMaxTimeValue : double = 1000000
    <<internal>> TimelineClip(parent:TrackAsset)
    m_Start : double
    m_ClipIn : double
    m_Duration : double
    m_TimeScale : double = 1.0
    m_EaseInDuration : double
    m_EaseOutDuration : double
    m_BlendInDuration : double
    m_BlendOutDuration : double
    m_Recordable : bool
    m_PostExtrapolationTime : double
    m_PreExtrapolationTime : double
    m_DisplayName : string
    + hasPreExtrapolation : bool <<get>>
    + hasPostExtrapolation : bool <<get>>
    + timeScale : double <<get>> <<set>>
    + start : double <<get>> <<set>>
    + duration : double <<get>> <<set>>
    + end : double <<get>>
    + clipIn : double <<get>> <<set>>
    + displayName : string <<get>> <<set>>
    + clipAssetDuration : double <<get>>
    defaultCurvesName : string <<get>>
    + hasCurves : bool <<get>>
    + easeInDuration : double <<get>> <<set>>
    + easeOutDuration : double <<get>> <<set>>
    + eastOutTime : double <<get>>
    + easeOutTime : double <<get>>
    + blendInDuration : double <<get>> <<set>>
    + blendOutDuration : double <<get>> <<set>>
    + hasBlendIn : bool <<get>>
    + hasBlendOut : bool <<get>>
    + mixInPercentage : float <<get>>
    + mixInDuration : double <<get>>
    + mixOutTime : double <<get>>
    + mixOutDuration : double <<get>>
    + mixOutPercentage : float <<get>>
    + recordable : bool <<get>> <<internal set>>
    <<internal>> Hash() : int
    + EvaluateMixOut(time:double) : float
    + EvaluateMixIn(time:double) : float
    {static} GetDefaultMixInCurve() : AnimationCurve
    {static} GetDefaultMixOutCurve() : AnimationCurve
    + ToLocalTime(time:double) : double
    + ToLocalTimeUnbound(time:double) : double
    <<internal>> FromLocalTimeUnbound(time:double) : double
    {static} SanitizeTimeValue(value:double, defaultValue:double) : double
    <<internal>> SetPostExtrapolationTime(time:double) : void
    <<internal>> SetPreExtrapolationTime(time:double) : void
    + IsExtrapolatedTime(sequenceTime:double) : bool
    + IsPreExtrapolatedTime(sequenceTime:double) : bool
    + IsPostExtrapolatedTime(sequenceTime:double) : bool
    + extrapolatedStart : double <<get>>
    + extrapolatedDuration : double <<get>>
    {static} GetExtrapolatedTime(time:double, mode:ClipExtrapolation, duration:double) : double
    + CreateCurves(curvesClipName:string) : void
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
    + <<override>> ToString() : string
    UpdateDirty(oldValue:double, newValue:double) : void
}
enum ClipExtrapolation {
    None,
    Hold,
    Loop,
    PingPong,
    Continue,
}
enum BlendCurveMode {
    Auto,
    Manual,
}
class "List`1"<T> {
}
ITimelineClipAsset --> "clipCaps" ClipCaps
ICurvesOwner <|-- TimelineClip
ISerializationCallbackReceiver <|-- TimelineClip
TimelineClip o-> "kDefaultClipCaps" ClipCaps
TimelineClip --> "m_Asset" Object
TimelineClip --> "m_ParentTrack" TrackAsset
TimelineClip --> "m_MixInCurve" AnimationCurve
TimelineClip --> "m_MixOutCurve" AnimationCurve
TimelineClip o-> "m_BlendInCurveMode" BlendCurveMode
TimelineClip o-> "m_BlendOutCurveMode" BlendCurveMode
TimelineClip --> "m_ExposedParameterNames<string>" "List`1"
TimelineClip --> "m_AnimationCurves" AnimationClip
TimelineClip --> "m_PostExtrapolationMode" ClipExtrapolation
TimelineClip --> "m_PreExtrapolationMode" ClipExtrapolation
TimelineClip --> "curves" AnimationClip
TimelineClip --> "asset" Object
TimelineClip --> "assetOwner" Object
TimelineClip --> "targetTrack" TrackAsset
TimelineClip --> "underlyingAsset" Object
TimelineClip --> "parentTrack" TrackAsset
TimelineClip --> "blendInCurveMode" BlendCurveMode
TimelineClip --> "blendOutCurveMode" BlendCurveMode
TimelineClip --> "mixInCurve" AnimationCurve
TimelineClip --> "mixOutCurve" AnimationCurve
TimelineClip --> "exposedParameters<string>" "List`1"
TimelineClip --> "clipCaps" ClipCaps
TimelineClip --> "animationClip" AnimationClip
TimelineClip --> "postExtrapolationMode" ClipExtrapolation
TimelineClip --> "preExtrapolationMode" ClipExtrapolation
TimelineClip +-- ClipExtrapolation
TimelineClip +-- BlendCurveMode
interface ITimelineEvaluateCallback {
    Evaluate() : void
}
class TimelinePlayable {
    <<internal>> {static} muteAudioScrubbing : bool = true
    + {static} Create(graph:PlayableGraph, tracks:IEnumerable<TrackAsset>, go:GameObject, autoRebalance:bool, createOutputs:bool) : ScriptPlayable<TimelinePlayable>
    + Compile(graph:PlayableGraph, timelinePlayable:Playable, tracks:IEnumerable<TrackAsset>, go:GameObject, autoRebalance:bool, createOutputs:bool) : void
    CreateTrackOutput(graph:PlayableGraph, track:TrackAsset, go:GameObject, playable:Playable, port:int) : void
    EvaluateWeightsForAnimationPlayableOutput(track:TrackAsset, animOutput:AnimationPlayableOutput) : void
    EvaluateAnimationPreviewUpdateCallback(track:TrackAsset, animOutput:AnimationPlayableOutput) : void
    + <<override>> PrepareFrame(playable:Playable, info:FrameData) : void
    {static} ForAOTCompilationOnly() : void
}
PlayableBehaviour <|-- TimelinePlayable
abstract class TrackAsset <<partial>> {
    <<internal>> <<const>> kDefaultCurvesName : string = "Track Parameters"
    <<internal>> {static}  <<event>> OnClipPlayableCreate : Action<TimelineClip, GameObject, Playable> 
    <<internal>> {static}  <<event>> OnTrackAnimationPlayableCreate : Action<TrackAsset, GameObject, Playable> 
    m_Locked : bool
    m_Muted : bool
    m_CustomPlayableFullTypename : string
    m_ItemsHash : int
    m_CacheSorted : bool
    m_SupportsNotifications : bool?
    + start : double <<get>>
    + end : double <<get>>
    + <<sealed>> <<override>> duration : double <<get>>
    + muted : bool <<get>> <<set>>
    + mutedInHierarchy : bool <<get>>
    + GetClips() : IEnumerable<TimelineClip>
    + <<virtual>> isEmpty : bool <<get>>
    + hasClips : bool <<get>>
    + hasCurves : bool <<get>>
    + isSubTrack : bool <<get>>
    + GetChildTracks() : IEnumerable<TrackAsset>
    <<internal>> customPlayableTypename : string <<get>> <<set>>
    defaultCurvesName : string <<get>>
    + locked : bool <<get>> <<set>>
    + lockedInHierarchy : bool <<get>>
    + supportsNotifications : bool <<get>>
    __internalAwake() : void
    + CreateCurves(curvesClipName:string) : void
    + <<virtual>> CreateTrackMixer(graph:PlayableGraph, go:GameObject, inputCount:int) : Playable
    + <<sealed>> <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
    + CreateDefaultClip() : TimelineClip
    + CreateClip() : TimelineClip
    + CreateMarker(type:Type, time:double) : IMarker
    + CreateMarker(time:double) : T
    + DeleteMarker(marker:IMarker) : bool
    + GetMarkers() : IEnumerable<IMarker>
    + GetMarkerCount() : int
    + GetMarker(idx:int) : IMarker
    <<internal>> CreateClip(requestedType:System.Type) : TimelineClip
    <<internal>> CreateAndAddNewClipOfType(requestedType:Type) : TimelineClip
    <<internal>> CreateClipOfType(requestedType:Type) : TimelineClip
    <<internal>> CreateClipFromPlayableAsset(asset:IPlayableAsset) : TimelineClip
    <<internal>> GetMarkersRaw() : IEnumerable<ScriptableObject>
    <<internal>> ClearMarkers() : void
    <<internal>> AddMarker(e:ScriptableObject) : void
    <<internal>> DeleteMarkerRaw(marker:ScriptableObject) : bool
    GetTimeRangeHash() : int
    <<internal>> AddClip(newClip:TimelineClip) : void
    CreateNotificationsPlayable(graph:PlayableGraph, mixerPlayable:Playable, go:GameObject, timelinePlayable:Playable) : Playable
    <<internal>> CreatePlayableGraph(graph:PlayableGraph, go:GameObject, tree:IntervalTree<RuntimeElement>, timelinePlayable:Playable) : Playable
    <<internal>> <<virtual>> CompileClips(graph:PlayableGraph, go:GameObject, timelineClips:IList<TimelineClip>, tree:IntervalTree<RuntimeElement>) : Playable
    GatherCompilableTracks(tracks:IList<TrackAsset>) : void
    GatherNotificiations(markers:List<IMarker>) : void
    <<internal>> <<virtual>> OnCreateClipPlayableGraph(graph:PlayableGraph, go:GameObject, tree:IntervalTree<RuntimeElement>) : Playable
    <<internal>> ConfigureTrackAnimation(tree:IntervalTree<RuntimeElement>, go:GameObject, blend:Playable) : void
    <<internal>> SortClips() : void
    <<internal>> ClearClipsInternal() : void
    <<internal>> ClearSubTracksInternal() : void
    <<internal>> OnClipMove() : void
    <<internal>> CreateNewClipContainerInternal() : TimelineClip
    <<internal>> AddChild(child:TrackAsset) : void
    <<internal>> MoveLastTrackBefore(asset:TrackAsset) : void
    <<internal>> RemoveSubTrack(child:TrackAsset) : bool
    <<internal>> RemoveClip(clip:TimelineClip) : void
    <<internal>> <<virtual>> GetEvaluationTime(outStart:double, outDuration:double) : void
    <<internal>> <<virtual>> GetSequenceTime(outStart:double, outDuration:double) : void
    + <<virtual>> GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
    <<internal>> GetGameObjectBinding(director:PlayableDirector) : GameObject
    <<internal>> ValidateClipType(clipType:Type) : bool
    UpdateDuration() : void
    <<internal>> Invalidate() : void
    <<internal>> GetNotificationDuration() : double
    <<internal>> <<virtual>> CanCompileClips() : bool
    <<internal>> IsCompilable() : bool
    <<internal>> <<virtual>> Hash() : int
    GetClipsHash() : int
    HasNotifications() : bool
    CanCompileNotifications() : bool
    CanCompileClipsRecursive() : bool
}
class TransientBuildData <<struct>> {
    + {static} Create() : TransientBuildData
    + Clear() : void
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
PlayableAsset <|-- TrackAsset
IPropertyPreview <|-- TrackAsset
ICurvesOwner <|-- TrackAsset
TrackAsset --> "m_Curves" AnimationClip
TrackAsset --> "m_Parent" PlayableAsset
TrackAsset --> "m_Children<ScriptableObject>" "List`1"
TrackAsset --> "m_Start" DiscreteTime
TrackAsset --> "m_End" DiscreteTime
TrackAsset --> "m_ChildTrackCache<TrackAsset>" "IEnumerable`1"
TrackAsset o-> "s_TrackBindingTypeAttributeCache<Type,TrackBindingTypeAttribute>" "Dictionary`2"
TrackAsset o-> "m_Markers" MarkerList
TrackAsset --> "timelineAsset" TimelineAsset
TrackAsset --> "parent" PlayableAsset
TrackAsset --> "outputs<PlayableBinding>" "IEnumerable`1"
TrackAsset --> "curves" AnimationClip
TrackAsset --> "asset" Object
TrackAsset --> "assetOwner" Object
TrackAsset --> "targetTrack" TrackAsset
TrackAsset --> "subTracksObjects<ScriptableObject>" "List`1"
TrackAsset +-- TransientBuildData
TransientBuildData --> "trackList<TrackAsset>" "List`1"
TransientBuildData --> "clipList<TimelineClip>" "List`1"
TransientBuildData --> "markerList<IMarker>" "List`1"
class DOTweenModuleAudio <<static>> {
    + {static} DOFade(target:AudioSource, endValue:float, duration:float) : TweenerCore<float, float, FloatOptions>
    + {static} DOPitch(target:AudioSource, endValue:float, duration:float) : TweenerCore<float, float, FloatOptions>
}
class DOTweenModulePhysics <<static>> {
    + {static} DOMove(target:Rigidbody, endValue:Vector3, duration:float, snapping:bool) : TweenerCore<Vector3, Vector3, VectorOptions>
    + {static} DOMoveX(target:Rigidbody, endValue:float, duration:float, snapping:bool) : TweenerCore<Vector3, Vector3, VectorOptions>
    + {static} DOMoveY(target:Rigidbody, endValue:float, duration:float, snapping:bool) : TweenerCore<Vector3, Vector3, VectorOptions>
    + {static} DOMoveZ(target:Rigidbody, endValue:float, duration:float, snapping:bool) : TweenerCore<Vector3, Vector3, VectorOptions>
    + {static} DORotate(target:Rigidbody, endValue:Vector3, duration:float, mode:RotateMode) : TweenerCore<Quaternion, Vector3, QuaternionOptions>
    + {static} DOLookAt(target:Rigidbody, towards:Vector3, duration:float, axisConstraint:AxisConstraint, up:Vector3?) : TweenerCore<Quaternion, Vector3, QuaternionOptions>
    + {static} DOJump(target:Rigidbody, endValue:Vector3, jumpPower:float, numJumps:int, duration:float, snapping:bool) : Sequence
    + {static} DOPath(target:Rigidbody, path:Vector3[], duration:float, pathType:PathType, pathMode:PathMode, resolution:int, gizmoColor:Color?) : TweenerCore<Vector3, Path, PathOptions>
    + {static} DOLocalPath(target:Rigidbody, path:Vector3[], duration:float, pathType:PathType, pathMode:PathMode, resolution:int, gizmoColor:Color?) : TweenerCore<Vector3, Path, PathOptions>
    <<internal>> {static} DOPath(target:Rigidbody, path:Path, duration:float, pathMode:PathMode) : TweenerCore<Vector3, Path, PathOptions>
    <<internal>> {static} DOLocalPath(target:Rigidbody, path:Path, duration:float, pathMode:PathMode) : TweenerCore<Vector3, Path, PathOptions>
}
class DOTweenModuleUnityVersion <<static>> {
}
class DOTweenModuleUtils <<static>> {
    {static} _initialized : bool
    + {static} Init() : void
}
class Physics <<static>> {
    + {static} SetOrientationOnPath(options:PathOptions, t:Tween, newRot:Quaternion, trans:Transform) : void
    + {static} HasRigidbody2D(target:Component) : bool
    + {static} HasRigidbody(target:Component) : bool
    + {static} CreateDOTweenPathTween(target:MonoBehaviour, tweenRigidbody:bool, isLocal:bool, path:Path, duration:float, pathMode:PathMode) : TweenerCore<Vector3, Path, PathOptions>
}
DOTweenModuleUtils +-- Physics
class DoublePoint <<struct>> {
    + X : double
    + Y : double
    + DoublePoint(x:double, y:double)
    + DoublePoint(dp:DoublePoint)
    + DoublePoint(ip:IntPoint)
}
class PolyTree {
    + Clear() : void
    + GetFirst() : PolyNode
    + Total : int <<get>>
}
class PolyNode {
    <<internal>> m_Index : int
    + ChildCount : int <<get>>
    <<internal>> AddChild(Child:PolyNode) : void
    + GetNext() : PolyNode
    <<internal>> GetNextSiblingUp() : PolyNode
    + IsHole : bool <<get>>
    + IsOpen : bool <<get>> <<set>>
}
class Int128 <<struct>> {
    + Int128(_lo:Int64)
    + Int128(_hi:Int64, _lo:UInt64)
    + Int128(val:Int128)
    + IsNegative() : bool
    + <<override>> Equals(obj:System.Object) : bool
    + <<override>> GetHashCode() : int
    + {static} Int128Mul(lhs:Int64, rhs:Int64) : Int128
}
class IntPoint <<struct>> {
    + IntPoint(X:cInt, Y:cInt)
    + IntPoint(x:double, y:double)
    + IntPoint(pt:IntPoint)
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class IntRect <<struct>> {
    + IntRect(l:cInt, t:cInt, r:cInt, b:cInt)
    + IntRect(ir:IntRect)
}
enum ClipType {
    ctIntersection,
    ctUnion,
    ctDifference,
    ctXor,
}
enum PolyType {
    ptSubject,
    ptClip,
}
enum PolyFillType {
    pftEvenOdd,
    pftNonZero,
    pftPositive,
    pftNegative,
}
enum JoinType {
    jtSquare,
    jtRound,
    jtMiter,
}
enum EndType {
    etClosedPolygon,
    etClosedLine,
    etOpenButt,
    etOpenSquare,
    etOpenRound,
}
enum EdgeSide {
    esLeft,
    esRight,
}
enum Direction {
    dRightToLeft,
    dLeftToRight,
}
class TEdge {
    <<internal>> Dx : double
    <<internal>> WindDelta : int
    <<internal>> WindCnt : int
    <<internal>> WindCnt2 : int
    <<internal>> OutIdx : int
}
class IntersectNode {
}
class MyIntersectNodeSort {
    + Compare(node1:IntersectNode, node2:IntersectNode) : int
}
class LocalMinima {
}
class Scanbeam {
}
class Maxima {
}
class OutRec {
    <<internal>> Idx : int
    <<internal>> IsHole : bool
    <<internal>> IsOpen : bool
}
class OutPt {
    <<internal>> Idx : int
}
class Join {
}
class ClipperBase {
    <<internal>> <<const>> horizontal : double
    <<internal>> <<const>> Skip : int
    <<internal>> <<const>> Unassigned : int
    <<internal>> <<const>> tolerance : double = 1.0E-20
    <<internal>> {static} near_zero(val:double) : bool
    <<internal>> m_UseFullRange : bool
    <<internal>> m_HasOpenPaths : bool
    + PreserveCollinear : bool <<get>> <<set>>
    + Swap(val1:cInt, val2:cInt) : void
    <<internal>> {static} IsHorizontal(e:TEdge) : bool
    <<internal>> PointIsVertex(pt:IntPoint, pp:OutPt) : bool
    <<internal>> PointOnLineSegment(pt:IntPoint, linePt1:IntPoint, linePt2:IntPoint, UseFullRange:bool) : bool
    <<internal>> PointOnPolygon(pt:IntPoint, pp:OutPt, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(e1:TEdge, e2:TEdge, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint, pt4:IntPoint, UseFullRange:bool) : bool
    <<internal>> ClipperBase()
    + <<virtual>> Clear() : void
    RangeTest(Pt:IntPoint, useFullRange:bool) : void
    + AddPath(pg:Path, polyType:PolyType, Closed:bool) : bool
    + AddPaths(ppg:Paths, polyType:PolyType, closed:bool) : bool
    <<internal>> Pt2IsBetweenPt1AndPt3(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint) : bool
    RemoveEdge(e:TEdge) : TEdge
    <<internal>> PopLocalMinima(Y:cInt, current:LocalMinima) : Boolean
    <<internal>> <<virtual>> Reset() : void
    + {static} GetBounds(paths:Paths) : IntRect
    <<internal>> InsertScanbeam(Y:cInt) : void
    <<internal>> PopScanbeam(Y:cInt) : Boolean
    <<internal>> LocalMinimaPending() : Boolean
    <<internal>> CreateOutRec() : OutRec
    <<internal>> DisposeOutRec(index:int) : void
    <<internal>> UpdateEdgeIntoAEL(e:TEdge) : void
    <<internal>> SwapPositionsInAEL(edge1:TEdge, edge2:TEdge) : void
    <<internal>> DeleteFromAEL(e:TEdge) : void
}
class Clipper {
    + <<const>> ioReverseSolution : int = 1
    + <<const>> ioStrictlySimple : int = 2
    + <<const>> ioPreserveCollinear : int = 4
    + Clipper(InitOptions:int)
    + ReverseSolution : bool <<get>> <<set>>
    + StrictlySimple : bool <<get>> <<set>>
    + Execute(clipType:ClipType, solution:Paths, FillType:PolyFillType) : bool
    + Execute(clipType:ClipType, polytree:PolyTree, FillType:PolyFillType) : bool
    + Execute(clipType:ClipType, solution:Paths, subjFillType:PolyFillType, clipFillType:PolyFillType) : bool
    + Execute(clipType:ClipType, polytree:PolyTree, subjFillType:PolyFillType, clipFillType:PolyFillType) : bool
    <<internal>> FixHoleLinkage(outRec:OutRec) : void
    <<internal>> PopEdgeFromSEL(e:TEdge) : Boolean
    <<internal>> SwapPoints(pt1:IntPoint, pt2:IntPoint) : void
    OutRec1RightOfOutRec2(outRec1:OutRec, outRec2:OutRec) : bool
    GetHorzDirection(HorzEdge:TEdge, Dir:Direction, Left:cInt, Right:cInt) : void
    <<internal>> GetMaximaPair(e:TEdge) : TEdge
    <<internal>> GetMaximaPairEx(e:TEdge) : TEdge
    <<internal>> {static} Round(value:double) : cInt
    + {static} ReversePaths(polys:Paths) : void
    + {static} Orientation(poly:Path) : bool
    DupOutPt(outPt:OutPt, InsertAfter:bool) : OutPt
    GetOverlap(a1:cInt, a2:cInt, b1:cInt, b2:cInt, Left:cInt, Right:cInt) : bool
    JoinHorz(op1:OutPt, op1b:OutPt, op2:OutPt, op2b:OutPt, Pt:IntPoint, DiscardLeft:bool) : bool
    + {static} PointInPolygon(pt:IntPoint, path:Path) : int
    + {static} Area(poly:Path) : double
    <<internal>> Area(outRec:OutRec) : double
    <<internal>> Area(op:OutPt) : double
    + {static} SimplifyPolygon(poly:Path, fillType:PolyFillType) : Paths
    + {static} SimplifyPolygons(polys:Paths, fillType:PolyFillType) : Paths
    + {static} CleanPolygon(path:Path, distance:double) : Path
    + {static} CleanPolygons(polys:Paths, distance:double) : Paths
    <<internal>> {static} Minkowski(pattern:Path, path:Path, IsSum:bool, IsClosed:bool) : Paths
    + {static} MinkowskiSum(pattern:Path, path:Path, pathIsClosed:bool) : Paths
    + {static} MinkowskiSum(pattern:Path, paths:Paths, pathIsClosed:bool) : Paths
    + {static} MinkowskiDiff(poly1:Path, poly2:Path) : Paths
    + {static} PolyTreeToPaths(polytree:PolyTree) : Paths
    <<internal>> {static} AddPolyNodeToPaths(polynode:PolyNode, nt:NodeType, paths:Paths) : void
    + {static} OpenPathsFromPolyTree(polytree:PolyTree) : Paths
    + {static} ClosedPathsFromPolyTree(polytree:PolyTree) : Paths
}
class ClipperOffset {
    + ArcTolerance : double <<get>> <<set>>
    + MiterLimit : double <<get>> <<set>>
    + ClipperOffset(miterLimit:double, arcTolerance:double)
    + Clear() : void
    <<internal>> {static} Round(value:double) : cInt
    + AddPath(path:Path, joinType:JoinType, endType:EndType) : void
    + AddPaths(paths:Paths, joinType:JoinType, endType:EndType) : void
    <<internal>> {static} GetUnitNormal(pt1:IntPoint, pt2:IntPoint) : DoublePoint
    + Execute(solution:Paths, delta:double) : void
    + Execute(solution:PolyTree, delta:double) : void
    OffsetPoint(j:int, k:int, jointype:JoinType) : void
    <<internal>> DoSquare(j:int, k:int) : void
    <<internal>> DoMiter(j:int, k:int, r:double) : void
    <<internal>> DoRound(j:int, k:int) : void
}
class ClipperException {
    + ClipperException(description:string)
}
class "List`1"<T> {
}
class "IComparer`1"<T> {
}
enum NodeType {
    ntAny,
    ntOpen,
    ntClosed,
}
PolyNode <|-- PolyTree
PolyTree o-> "m_AllPolys<PolyNode>" "List`1"
PolyNode --> "m_Parent" PolyNode
PolyNode o-> "m_polygon" Path
PolyNode --> "m_jointype" JoinType
PolyNode --> "m_endtype" EndType
PolyNode o-> "m_Childs<PolyNode>" "List`1"
PolyNode --> "Contour" Path
PolyNode --> "Childs<PolyNode>" "List`1"
PolyNode --> "Parent" PolyNode
IntPoint --> "X" cInt
IntPoint --> "Y" cInt
IntRect --> "left" cInt
IntRect --> "top" cInt
IntRect --> "right" cInt
IntRect --> "bottom" cInt
TEdge --> "Bot" IntPoint
TEdge --> "Curr" IntPoint
TEdge --> "Top" IntPoint
TEdge --> "Delta" IntPoint
TEdge --> "PolyTyp" PolyType
TEdge --> "Side" EdgeSide
TEdge --> "Next" TEdge
TEdge --> "Prev" TEdge
TEdge --> "NextInLML" TEdge
TEdge --> "NextInAEL" TEdge
TEdge --> "PrevInAEL" TEdge
TEdge --> "NextInSEL" TEdge
TEdge --> "PrevInSEL" TEdge
IntersectNode --> "Edge1" TEdge
IntersectNode --> "Edge2" TEdge
IntersectNode --> "Pt" IntPoint
"IComparer`1" "<IntersectNode>" <|-- MyIntersectNodeSort
LocalMinima --> "Y" cInt
LocalMinima --> "LeftBound" TEdge
LocalMinima --> "RightBound" TEdge
LocalMinima --> "Next" LocalMinima
Scanbeam --> "Y" cInt
Scanbeam --> "Next" Scanbeam
Maxima --> "X" cInt
Maxima --> "Next" Maxima
Maxima --> "Prev" Maxima
OutRec --> "FirstLeft" OutRec
OutRec --> "Pts" OutPt
OutRec --> "BottomPt" OutPt
OutRec --> "PolyNode" PolyNode
OutPt --> "Pt" IntPoint
OutPt --> "Next" OutPt
OutPt --> "Prev" OutPt
Join --> "OutPt1" OutPt
Join --> "OutPt2" OutPt
Join --> "OffPt" IntPoint
ClipperBase o-> "loRange" cInt
ClipperBase o-> "hiRange" cInt
ClipperBase --> "m_MinimaList" LocalMinima
ClipperBase --> "m_CurrentLM" LocalMinima
ClipperBase o-> "m_edges<List<TEdge>>" "List`1"
ClipperBase --> "m_Scanbeam" Scanbeam
ClipperBase --> "m_PolyOuts<OutRec>" "List`1"
ClipperBase --> "m_ActiveEdges" TEdge
ClipperBase <|-- Clipper
Clipper --> "m_IntersectNodeComparer<IntersectNode>" "IComparer`1"
Exception <|-- ClipperException
Clipper +-- NodeType
class DropdownMenu {
}
class DropdownMenuFactory {
}
class DropdownMenuUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- DropdownMenu
DropdownMenu +-- DropdownMenuFactory
"UxmlFactory`2" "<DropdownMenu,DropdownMenuUxmlTraits>" <|-- DropdownMenuFactory
DropdownMenu +-- DropdownMenuUxmlTraits
UxmlTraits <|-- DropdownMenuUxmlTraits
class LayoutOverlay {
    + hasScrollbar : bool <<get>> <<set>>
    + LayoutOverlay()
}
class LayoutOverlayFactory {
}
class LayoutOverlayUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- LayoutOverlay
LayoutOverlay --> "horizontalToolbar" ScrollableToolbar
LayoutOverlay --> "verticalToolbar" ScrollableToolbar
LayoutOverlay --> "horizontalHolder" VisualElement
LayoutOverlay --> "leftOverlay" VisualElement
LayoutOverlay --> "rightOverlay" VisualElement
LayoutOverlay --> "dropdownOverlay" DropdownMenu
LayoutOverlay +-- LayoutOverlayFactory
"UxmlFactory`2" "<LayoutOverlay,LayoutOverlayUxmlTraits>" <|-- LayoutOverlayFactory
LayoutOverlay +-- LayoutOverlayUxmlTraits
UxmlTraits <|-- LayoutOverlayUxmlTraits
class LayoutOverlayUtility <<static>> {
    + {static} CreateButton(name:string, clickEvent:Action, tooltip:string, text:string, imageResourcePath:string, stylesheetPath:string) : Button
}
class ScrollableToolbar {
    + isHorizontal : bool <<get>> <<set>>
    + ScrollableToolbar()
    + ScrollableToolbar(isHorizontal:bool)
    + AddToContainer(element:VisualElement) : void
    + Collapse(collapse:bool) : void
    OnScrollWheel(evt:WheelEvent) : void
}
class ScrollableToolbarFactory {
}
class ScrollableToolbarUxmlTraits {
    + ScrollableToolbarUxmlTraits()
    + <<override>> Init(ve:VisualElement, bag:IUxmlAttributes, cc:CreationContext) : void
}
class "UxmlFactory`2"<T1,T2> {
}
class "IEnumerable`1"<T> {
}
VisualElement <|-- ScrollableToolbar
ScrollableToolbar +-- ScrollableToolbarFactory
"UxmlFactory`2" "<ScrollableToolbar,ScrollableToolbarUxmlTraits>" <|-- ScrollableToolbarFactory
ScrollableToolbar +-- ScrollableToolbarUxmlTraits
UxmlTraits <|-- ScrollableToolbarUxmlTraits
ScrollableToolbarUxmlTraits --> "m_IsHorizontal" UxmlBoolAttributeDescription
ScrollableToolbarUxmlTraits --> "uxmlChildElementsDescription<UxmlChildElementDescription>" "IEnumerable`1"
class AssociateBonesScope {
    + AssociateBonesScope(sprite:SpriteCache)
    + Dispose() : void
}
IDisposable <|-- AssociateBonesScope
interface ITool {
}
abstract class BaseTool {
    + isActive : bool <<get>>
    + <<virtual>> defaultControlID : int <<get>>
    <<internal>> <<override>> OnDestroy() : void
    + Activate() : void
    + Deactivate() : void
    + DoGUI() : void
    + <<virtual>> Initialize(layout:LayoutOverlay) : void
}
SkinningObject <|-- BaseTool
ITool <|-- BaseTool
BaseTool --> "layoutOverlay" LayoutOverlay
BaseTool --> "previewBehaviour" IMeshPreviewBehaviour
class BoneDrawingUtility <<static>> {
    + {static} GetBoneRadius(position:Vector3, scale:float) : float
    + {static} DrawBoneNode(position:Vector3, forward:Vector3, color:Color, scale:float) : void
    + {static} DrawBone(position:Vector3, endPosition:Vector3, forward:Vector3, color:Color, scale:float) : void
    + {static} DrawBoneOutline(position:Vector3, endPosition:Vector3, forward:Vector3, color:Color, outlineScale:float, scale:float) : void
}
class ColorExtensions <<static>> {
    + {static} AlphaMultiplied(c:Color, multiplier:float) : Color
}
interface ICopyToolStringStore {
    stringStore : string <<get>> <<set>>
}
class SystemCopyBufferStringStore {
    + stringStore : string <<get>> <<set>>
}
class CopyTool {
    + pixelsPerUnit : float <<set>>
    <<internal>> <<override>> OnCreate() : void
    + <<override>> Initialize(layout:LayoutOverlay) : void
    + OnCopyActivated() : void
    + CopyAll() : SkinningCopyData
    + CopySingle(sprite:SpriteCache) : SkinningCopyData
    + OnPasteActivated(bone:bool, mesh:bool, flipX:bool, flipY:bool) : void
    SetBonePositionAndRotation(boneCache:BoneCache[], bone:TransformCache, position:Vector3[], rotation:Quaternion[]) : void
    + PasteSkeletonBones(sprite:SpriteCache, spriteBones:List<SpriteBone>, flipX:bool, flipY:bool, scale:float) : NewBonesStore
    + PasteMesh(sprite:SpriteCache, skinningSpriteData:SkinningCopySpriteData, flipX:bool, flipY:bool, scale:float, newBonesStore:NewBonesStore) : void
}
class CopyToolView {
    +  <<event>> onPasteActivated : Action<bool, bool, bool, bool> 
    + Show() : void
    + Hide() : void
    + Initialize(layoutOverlay:LayoutOverlay) : void
    BindElements() : void
    OnPasteActivated(bone:bool, mesh:bool, flipX:bool, flipY:bool) : void
}
class NewBonesStore {
    + NewBonesStore()
    + MapAllExistingBones() : void
}
class "Dictionary`2"<T1,T2> {
}
ICopyToolStringStore <|-- SystemCopyBufferStringStore
MeshToolWrapper <|-- CopyTool
CopyTool --> "copyToolStringStore" ICopyToolStringStore
CopyTool +-- NewBonesStore
NewBonesStore --> "newBoneNameDict<string,string>" "Dictionary`2"
class DefaultPoseScope {
    + DefaultPoseScope(skeleton:SkeletonCache, useLocalPose:bool)
    + Dispose() : void
}
IDisposable <|-- DefaultPoseScope
class DrawingUtility {
    + {static} DrawLine(p1:Vector3, p2:Vector3, normal:Vector3, width:float) : void
    + {static} DrawLine(p1:Vector3, p2:Vector3, normal:Vector3, widthP1:float, widthP2:float) : void
    + {static} DrawLine(p1:Vector3, p2:Vector3, normal:Vector3, widthP1:float, widthP2:float, color:Color) : void
    + {static} BeginLines(color:Color) : void
    + {static} BeginSolidLines() : void
    + {static} EndLines() : void
    + {static} DrawLine(p1:Vector3, p2:Vector3) : void
    + {static} DrawSolidLine(width:float, p1:Vector3, p2:Vector3) : void
    + {static} DrawSolidLine(p1:Vector3, p2:Vector3, normal:Vector3, widthP1:float, widthP2:float) : void
    + {static} DrawBox(position:Rect) : void
    + {static} DrawMesh(mesh:Mesh, material:Material, matrix:Matrix4x4) : void
    + {static} DrawGUIStyleCap(controlID:int, position:Vector3, rotation:Quaternion, size:float, guiStyle:GUIStyle) : void
    + {static} DrawRect(rect:Rect, position:Vector3, rotation:Quaternion, color:Color, rectAlpha:float, outlineAlpha:float) : void
    + {static} DrawSolidArc(center:Vector3, normal:Vector3, from:Vector3, angle:float, radius:float, numSamples:int) : void
    + {static} DrawSolidArc(center:Vector3, normal:Vector3, from:Vector3, angle:float, radius:float, outlineScale:float, numSamples:int) : void
}
DrawingUtility o-> "kSpriteBorderColor" Color
class GenerateGeometryTool {
    <<internal>> <<override>> OnCreate() : void
    + <<override>> Initialize(layout:LayoutOverlay) : void
}
MeshToolWrapper <|-- GenerateGeometryTool
class GenerateWeightsTool {
    <<internal>> <<override>> OnCreate() : void
    + <<override>> Initialize(layout:LayoutOverlay) : void
    OnModeChanged(mode:SkinningMode) : void
    OnSpriteSelectionChanged(sprite:SpriteCache) : void
}
MeshToolWrapper <|-- GenerateWeightsTool
class HorizontalToggleTools {
    + collapseToolbar : bool <<get>> <<set>>
    <<internal>> HorizontalToggleTools(s:SkinningCache)
    <<internal>> DoGUI(drawArea:Rect, currentTool:BaseTool, isDisabled:bool) : void
    <<internal>> TogglePasteTool(currentTool:BaseTool) : void
    DoVisibilityToggle(currentTool:BaseTool) : void
    <<internal>> ToggleVisibilityTool(currentTool:BaseTool) : void
}
class Styles <<static>> {
}
class "Action`1"<T> {
}
HorizontalToggleTools o-> "onActivateTool<BaseTool>" "Action`1"
HorizontalToggleTools --> "visbilityIcon" GUIContent
HorizontalToggleTools --> "characterIcon" GUIContent
HorizontalToggleTools +-- Styles
Styles o-> "visibilityCollapseIcon" GUIContent
Styles o-> "visibilityIcon" GUIContent
Styles o-> "characterCollapseIcon" GUIContent
Styles o-> "characterIcon" GUIContent
Styles o-> "spriteSheetIcon" GUIContent
Styles o-> "spriteSheetCollapseIcon" GUIContent
Styles o-> "copyIcon" GUIContent
Styles o-> "copyCollapseIcon" GUIContent
Styles o-> "pasteIcon" GUIContent
Styles o-> "pasteCollapseIcon" GUIContent
class IconUtility <<static>> {
    {static} + <<readonly>> k_LightIconResourcePath : string = "SkinningModule/Icons/Light"
    {static} + <<readonly>> k_DarkIconResourcePath : string = "SkinningModule/Icons/Dark"
    {static} + <<readonly>> k_SelectedResourceIconPath : string = "SkinningModule/Icons/Selected"
    + {static} LoadIconResource(name:string, personalPath:string, proPath:string) : Texture2D
}
class MathUtility <<static>> {
    + {static} DistanceToSegmentClamp(p:Vector3, p1:Vector3, p2:Vector3) : float
    + {static} ClampPositionToRect(position:Vector2, rect:Rect) : Vector2
    + {static} MoveRectInsideFrame(rect:Rect, frame:Rect, delta:Vector2) : Vector2
    + {static} SegmentIntersection(p0:Vector2, p1:Vector2, p2:Vector2, p3:Vector2, point:Vector2) : bool
    + {static} Barycentric(p:Vector2, a:Vector2, b:Vector2, c:Vector2, coords:Vector3) : void
    + {static} NormalizeQuaternion(q:Quaternion) : Quaternion
    + {static} Intersect(p1:Vector3, p2:Vector3, p3:Vector3, ray:Ray) : bool
}
class ModuleToolGroup {
    + AddToolToGroup(groupId:int, tool:BaseTool, toolActivatedCallback:Action) : void
    + ActivateTool(tool:BaseTool) : void
}
class ToolGroupEntry {
}
class ToolGroup {
    + groupId : int
    + previousToolIndex : int
}
class "List`1"<T> {
}
ModuleToolGroup o-> "m_ToolGroups<ToolGroup>" "List`1"
ModuleToolGroup +-- ToolGroupEntry
ToolGroupEntry --> "tool" BaseTool
ToolGroupEntry --> "activateCallback" Action
ModuleToolGroup +-- ToolGroup
ToolGroup o-> "tools<ToolGroupEntry>" "List`1"
class ModuleUtility <<static>> {
    + {static} GUIToWorld(guiPosition:Vector3) : Vector3
    + {static} GUIToWorld(guiPosition:Vector3, planeNormal:Vector3, planePos:Vector3) : Vector3
    + {static} ToGUIContentArray(names:string[]) : GUIContent[]
    + {static} CalculateNiceColor(index:int, numColors:int) : Color
    + {static} UpdateLocalToWorldMatrices(spriteBoneDataList:List<SpriteBoneData>, rootMatrix:Matrix4x4, localToWorldMatrices:Matrix4x4[]) : void
    + {static} CreateSpriteBoneData(spriteBoneList:UnityEngine.U2D.SpriteBone[], rootMatrix:Matrix4x4) : List<SpriteBoneData>
}
class SelectionTool {
    +  <<event>> CanSelect : Func<bool> 
    + <<override>> Initialize(layoutOverlay:LayoutOverlay) : void
}
BaseTool <|-- SelectionTool
SelectionTool --> "spriteEditor" ISpriteEditor
class "SerializableDictionary`2"<TKey,TValue> {
    + Add(key:TKey, value:TValue) : void
    + ContainsKey(key:TKey) : bool
    + Remove(key:TKey) : bool
    + TryGetValue(key:TKey, value:TValue) : bool
    + Clear() : void
    + Count : int <<get>>
    IsReadOnly : bool <<get>>
    Add(item:KeyValuePair<TKey, TValue>) : void
    Contains(item:KeyValuePair<TKey, TValue>) : bool
    CopyTo(array:KeyValuePair<TKey, TValue>[], arrayIndex:int) : void
    Remove(item:KeyValuePair<TKey, TValue>) : bool
    GetEnumerator() : IEnumerator<KeyValuePair<TKey, TValue>>
    + GetEnumerator() : IEnumerator
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
}
class "IDictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
class "ICollection`1"<T> {
}
"IDictionary`2" "<TKey,TValue>" <|-- "SerializableDictionary`2"
ISerializationCallbackReceiver <|-- "SerializableDictionary`2"
"SerializableDictionary`2" --> "Keys<TKey>" "ICollection`1"
"SerializableDictionary`2" --> "Values<TValue>" "ICollection`1"
class SkinningCopyUtility <<static>> {
    + {static} SerializeSkinningCopyDataToString(skinningData:SkinningCopyData) : string
    + {static} CanDeserializeSystemCopyBufferToSkinningCopyData() : bool
    + {static} CanDeserializeStringToSkinningCopyData(data:string) : bool
    + {static} DeserializeStringToSkinningCopyData(data:string) : SkinningCopyData
}
SkinningCopyUtility --> "Serializer" ISkinningSerializer
class SkinningModule <<partial>> {
    m_CollapseToolbar : bool
    + <<override>> moduleName : string <<get>>
    + <<override>> OnModuleActivate() : void
    + <<override>> OnModuleDeactivate() : void
    + <<override>> CanBeActivated() : bool
    + <<override>> DoPostGUI() : void
    + <<override>> DoMainGUI() : void
    + <<override>> DoToolbarGUI(drawArea:Rect) : void
    DoCopyPasteKeyboardEventHandling() : void
    + <<override>> ApplyRevert(apply:bool) : bool
    OnSpriteLibraryChanged() : void
    OnMeshPreviewBehaviourChange(meshPreviewBehaviour:IMeshPreviewBehaviour) : void
}
class Styles <<static>> {
    + {static} moduleName : string
}
SpriteEditorModuleBase <|-- SkinningModule
SkinningModule o-> "m_MeshPreviewBehaviourOverride" IMeshPreviewBehaviour
SkinningModule --> "skinningCache" SkinningCache
SkinningModule +-- Styles
class SkinningModule <<partial>> {
}
class TextContent <<static>> {
    + {static} setMode : string = "Set Mode"
    + {static} setTool : string = "Set Tool"
    + {static} pasteData : string = "Paste Data"
    + {static} generateGeometry : string = "Generate Geometry"
    + {static} generateWeights : string = "Generate Weights"
    + {static} normalizeWeights : string = "Normalize Weights"
    + {static} clearWeights : string = "Clear Weights"
    + {static} restorePose : string = "Restore Pose"
    + {static} selection : string = "Selection"
    + {static} clearSelection : string = "Clear Selection"
    + {static} editWeights : string = "Edit Weights"
    + {static} boneName : string = "Bone Name"
    + {static} boneDepth : string = "Bone Depth"
    + {static} rotateBone : string = "Rotate Bone"
    + {static} moveBone : string = "Move Bone"
    + {static} freeMoveBone : string = "Free Move Bone"
    + {static} moveJoint : string = "Move Joint"
    + {static} moveEndPoint : string = "Move End Point"
    + {static} boneLength : string = "Bone Length"
    + {static} createBone : string = "Create Bone"
    + {static} splitBone : string = "Split Bone"
    + {static} removeBone : string = "Remove Bone"
    + {static} moveVertices : string = "Move Vertices"
    + {static} createVertex : string = "Create Vertex"
    + {static} createEdge : string = "Create Edge"
    + {static} splitEdge : string = "Split Edge"
    + {static} removeEdge : string = "Remove Edge"
    + {static} removeVertices : string = "Remove Vertices"
    + {static} selectionChange : string = "Selection Change"
    + {static} boneVisibility : string = "Bone Visibility"
    + {static} setParentBone : string = "Set Parent Bone"
    + {static} visibilityChange : string = "VisibilityChange"
    + {static} boneSelection : string = "Bone Selection"
    + {static} expandBones : string = "Expand Bones"
    + {static} meshVisibility : string = "Mesh Visibility"
    + {static} meshOpacity : string = "Mesh Opacity"
    + {static} opacityChange : string = "Opacity Change"
    + {static} visibilityIconTooltip : string = "Visibility tool"
    + {static} characterIconTooltip : string = "Restore bind pose"
    + {static} spriteSheetIconTooltip : string = "Switch between Sprite sheet and Character mode"
    + {static} copyTooltip : string = "Copy"
    + {static} pasteTooltip : string = "Paste"
    + {static} onTooltip : string = "On"
    + {static} offTooltip : string = "Off"
    + {static} visibilityIconText : string = "Visibility"
    + {static} characterIconText : string = "Reset Pose"
    + {static} spriteSheetIconText : string = "Sprite Sheet"
    + {static} copyText : string = "Copy"
    + {static} pasteText : string = "Paste"
    + {static} selectedOutlineColor : string = "Selected Outline Color"
    + {static} spriteOutlineSize : string = "Sprite Outline Size"
    + {static} boneOutlineSize : string = "Bone Outline Size"
    + {static} convertGroupToCategory : string = "Convert Group to Category"
    + {static} newTrailingDots : string = "New..."
    + {static} removeEmptyCategory : string = "Remove Empty Category"
    + {static} convertLayerToCategory : string = "Convert Layer to Category"
    + {static} clearAllCategory : string = "Clear All Category"
    + {static} spriteCategoryChanged : string = "Sprite Category Changed"
    + {static} spriteCategoryIndexChanged : string = "Sprite Category Index Changed"
    + {static} category : string = "Category"
    + {static} label : string = "Label"
    + {static} generatingGeometry : string = "Generating Geometry"
    + {static} generatingWeights : string = "Generating Weights"
    + {static} vertexWeight : string = "Vertex Weight"
    + {static} vertexWeightToolTip : string = "Adjust bone weights for selected vertex"
    + {static} bone : string = "Bone"
    + {static} depth : string = "Depth"
    + {static} sprite : string = "Sprite"
    + {static} spriteVisibility : string = "SpriteVisibility"
    + {static} name : string = "Name"
    + {static} none : string = "None"
    + {static} size : string = "Size"
    + {static} visibilityTab : string = "Visibility Tab"
    + {static} addBoneInfluence : string = "Add Bone Influence"
    + {static} removeBoneInfluence : string = "Remove Bone Influence"
    + {static} reorderBoneInfluence : string = "Reorder Bone Influence"
    + {static} noSpriteSelected : string = "No sprite selected"
    + {static} weightSlider : string = "Weight Slider"
    + {static} weightBrush : string = "Weight Brush"
    + {static} generateAll : string = "Generate All"
    + {static} generate : string = "Generate"
    + {static} smoothMeshError : string = "Generated mesh could not be smoothed. Please try using different parameters"
    + {static} copyError1 : string = "Unable to convert copied data to Skinning Module paste data."
    + {static} copyError2 : string = "There is no copied data to paste."
    + {static} copyError3 : string = "Target has a different number of Sprites ({0&#125;) compared to copied source ({1&#125;) for Mesh copy."
    + {static} mode : string = "Mode"
    + {static} modeTooltip : string = "Different operation mode for weight adjustment"
    + {static} boneToolTip : string = "The bone that is affecting"
}
class SkinningModuleSettings {
    + <<const>> kCompactToolbarKey : string
    + {static} compactToolBar : bool <<get>> <<set>>
    + OnGUI() : void
}
class VisibilityToolSettings {
    + <<const>> kBoneOpacitykey : string
    + <<const>> kMeshOpacityKey : string
    + {static} boneOpacity : float <<get>> <<set>>
    + {static} meshOpacity : float <<get>> <<set>>
}
class GenerateGeomertySettings {
    + <<const>> kDefaultOutlineDetail : int = 10
    + <<const>> kDefaultAlphaTolerance : int = 10
    + <<const>> kDefaultSubdivide : int = 20
    + <<const>> kOutlineDetailKey : string
    + <<const>> kAlphaToleranceKey : string
    + <<const>> kSubdivideKey : string
    + <<const>> kGenerateWeightsKey : string
    + {static} outlineDetail : int <<get>> <<set>>
    + {static} alphaTolerance : int <<get>> <<set>>
    + {static} subdivide : int <<get>> <<set>>
    + {static} generateWeights : bool <<get>> <<set>>
}
class SelectionOutlineSettings {
    + <<const>> kSelectedOutlineRedKey : string
    + <<const>> kSelectedOutlineGreenKey : string
    + <<const>> kSelectedOutlineBlueKey : string
    + <<const>> kSelectedOutlineAlphaKey : string
    + <<const>> kSelectedSpriteOutlineSize : string
    + <<const>> kSelectedBoneOutlineSize : string
    + {static} selectedSpriteOutlineSize : int <<get>> <<set>>
    + {static} selectedBoneOutlineSize : float <<get>> <<set>>
    + OnGUI() : void
}
class UserSettings {
    + <<const>> kSettingsUniqueKey : string = "UnityEditor.U2D.Animation/"
    + UserSettings()
}
SkinningModuleSettings o-> "kCompactToolbarLabel" GUIContent
SelectionOutlineSettings o-> "kSelectedOutlineColorLabel" GUIContent
SelectionOutlineSettings o-> "kSelectedOutlineSizeLabel" GUIContent
SelectionOutlineSettings o-> "kSelectedBoneOutlineSizeLabel" GUIContent
SelectionOutlineSettings --> "outlineColor" Color
SettingsProvider <|-- UserSettings
enum WeightPainterMode {
    Brush,
    Slider,
}
class WeightPainterTool {
    + <<override>> defaultControlID : int <<get>>
    <<internal>> <<override>> OnCreate() : void
    + panelTitle : string <<set>>
    + <<override>> Initialize(layout:LayoutOverlay) : void
    <<internal>> SetWeightPainterPanelTitle(title:string) : void
}
MeshToolWrapper <|-- WeightPainterTool
WeightPainterTool --> "paintMode" WeightPainterMode
class WeightPainterToolWrapper {
    + title : string <<set>>
    + <<override>> defaultControlID : int <<get>>
}
BaseTool <|-- WeightPainterToolWrapper
WeightPainterToolWrapper --> "previewBehaviour" IMeshPreviewBehaviour
WeightPainterToolWrapper --> "weightPainterTool" WeightPainterTool
WeightPainterToolWrapper --> "paintMode" WeightPainterMode
class SpriteLibraryAssetInspector {
    + OnEnable() : void
    + OnDisable() : void
    GetElementHeight(index:int) : float
    DrawElement(rect:Rect, index:int, selected:bool, focused:bool) : void
    DrawSpriteListProperty(rect:Rect, spriteListProp:SerializedProperty) : void
    + <<override>> OnInspectorGUI() : void
    IsNameInUsed(name:string, property:SerializedProperty, propertyField:string, threshold:int) : bool
    OnAddCallback(list:ReorderableList) : void
}
class Style <<static>> {
    + {static} lineSpacing : int = 3
}
Editor <|-- SpriteLibraryAssetInspector
SpriteLibraryAssetInspector +-- Style
Style o-> "duplicateWarningText" GUIContent
Style o-> "duplicateWarning" GUIContent
Style o-> "nameLabel" GUIContent
class SpriteCategoryLabel <<struct>> {
    m_Name : string
    m_SpriteId : string
    + name : string <<get>> <<set>>
    + spriteId : string <<get>> <<set>>
}
class SpriteCategory <<struct>> {
    m_Name : string
    + name : string <<get>> <<set>>
}
class SpriteCategoryList <<struct>> {
}
class SpriteCategoryListCacheObject {
    + CopyFrom(categoryList:SpriteCategoryList) : void
    + ToSpriteLibrary() : SpriteCategoryList
    + RemoveSpriteFromCategory(sprite:string) : void
    + AddSpriteToCategory(category:string, label:SpriteCategoryLabel) : void
    + ChangeSpriteLabelName(labelname:string, sprite:string) : void
}
interface ISpriteLibDataProvider {
    GetSpriteCategoryList() : SpriteCategoryList
    SetSpriteCategoryList(spriteCategoryList:SpriteCategoryList) : void
}
class "List`1"<T> {
}
SpriteCategory --> "m_Labels<SpriteCategoryLabel>" "List`1"
SpriteCategory --> "labels<SpriteCategoryLabel>" "List`1"
SpriteCategoryList --> "m_Categories<SpriteCategory>" "List`1"
SpriteCategoryList --> "categories<SpriteCategory>" "List`1"
SkinningObject <|-- SpriteCategoryListCacheObject
SpriteCategoryListCacheObject o-> "categories<SpriteCategory>" "List`1"
class SpriteLibraryInspector {
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
}
Editor <|-- SpriteLibraryInspector
class SpriteResolverInspector {
    m_CategorySelectionIndex : int = 0
    m_PreviousCategoryHash : int = 0
    m_labelSelectionIndex : int = 0
    m_PreviouslabelHash : int = 0
    + OnEnable() : void
    UpdateSpriteLibrary() : void
    ValidateCategorySelectionIndexValue() : void
    + <<override>> OnInspectorGUI() : void
}
class Style <<static>> {
}
class SpriteCategorySelectionList <<struct>> {
    + categoryName : string
    + categoryNameHash : int
}
class "Dictionary`2"<T1,T2> {
}
Editor <|-- SpriteResolverInspector
SpriteResolverInspector o-> "m_SpriteLibSelection<int,SpriteCategorySelectionList>" "Dictionary`2"
SpriteResolverInspector o-> "m_SpriteSelectorWidget" SpriteSelectorWidget
SpriteResolverInspector --> "spriteResolver" SpriteResolver
SpriteResolverInspector +-- Style
Style o-> "noSpriteLibContainer" GUIContent
Style o-> "categoryLabel" GUIContent
Style o-> "labelLabel" GUIContent
Style o-> "categoryIsEmptyLabel" GUIContent
SpriteResolverInspector +-- SpriteCategorySelectionList
class SpriteSelectorWidget {
    <<const>> kTargetPreviewSize : int = 64
    + SpriteSelectorWidget()
    + UpdateContents(sprites:Sprite[]) : void
    + ShowGUI(selectedIndex:int) : int
    {static} GetRowColumnCount(drawWidth:float, size:int, contentCount:int, column:int, row:int, columnf:float) : void
    ContentSelectionGrid(selected:int, contents:Sprite[], style:GUIStyle, columnCount:int) : int
    + NeedUpdatePreview() : bool
    UpdateSpritePreviews() : void
}
class Styles {
    + Styles()
}
class "List`1"<T> {
}
SpriteSelectorWidget o-> "m_SpritePreviewNeedFetching<int>" "List`1"
SpriteSelectorWidget --> "m_ScrollPos" Vector2
SpriteSelectorWidget --> "m_Style" Styles
SpriteSelectorWidget +-- Styles
Styles --> "gridListStyle" GUIStyle
class SpriteOutlineRenderer {
    + SpriteOutlineRenderer(spriteEditor:ISpriteEditor, eventSystem:SkinningEvents)
    + Dispose() : void
    <<internal>> RenderSpriteOutline(spriteEditor:ISpriteEditor, sprite:SpriteCache) : void
}
class OutlineRenderTexture {
    + dirty : bool
}
class "Dictionary`2"<T1,T2> {
}
SpriteOutlineRenderer --> "m_OutlineMaterial" Material
SpriteOutlineRenderer --> "m_BitMaskMaterial" Material
SpriteOutlineRenderer o-> "m_OutlineTextureCache<string,OutlineRenderTexture>" "Dictionary`2"
SpriteOutlineRenderer --> "m_CurrentDataProvider" ISpriteEditorDataProvider
SpriteOutlineRenderer --> "m_EventSystem" SkinningEvents
SpriteOutlineRenderer --> "m_SpriteEditor" ISpriteEditor
SpriteOutlineRenderer +-- OutlineRenderTexture
OutlineRenderTexture --> "outlineTexture" Texture
class BoneGizmoInitializer {
    {static} BoneGizmoInitializer()
}
class BoneGizmo {
    <<internal>> Initialize() : void
    <<internal>> ClearSpriteBoneCache() : void
}
class BoneGizmoController {
    + BoneGizmoController(view:ISkeletonView, undo:IUndo, toggle:IBoneGizmoToggle)
    <<internal>> OnSelectionChanged() : void
    <<internal>> OnGUI() : void
    <<internal>> FindSkinComponents() : void
    <<internal>> ClearSpriteBoneCache() : void
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<BoneGizmo>" <|-- BoneGizmo
BoneGizmo --> "boneGizmoController" BoneGizmoController
BoneGizmoController --> "boneGizmoToggle" IBoneGizmoToggle
BoneGizmoController --> "hoveredBone" Transform
BoneGizmoController --> "hoveredTail" Transform
BoneGizmoController --> "hoveredBody" Transform
BoneGizmoController --> "hoveredJoint" Transform
BoneGizmoController --> "hotBone" Transform
interface IBoneGizmoToggle {
    enableGizmos : bool <<get>>
    OnGUI() : void
}
class BoneGizmoToggle {
    + enableGizmos : bool <<get>>
    + BoneGizmoToggle()
    + OnGUI() : void
}
IBoneGizmoToggle <|-- BoneGizmoToggle
class SpriteSkinEditor {
    + <<override>> OnInspectorGUI() : void
}
class Contents <<static>> {
    + {static} <<readonly>> listHeaderLabel : string = "Bones"
}
Editor <|-- SpriteSkinEditor
SpriteSkinEditor +-- Contents
Contents o-> "spriteNotFound" GUIContent
Contents o-> "spriteHasNoSkinningInformation" GUIContent
Contents o-> "spriteHasNoWeights" GUIContent
Contents o-> "rootTransformNotFound" GUIContent
Contents o-> "rootTransformNotFoundInArray" GUIContent
Contents o-> "InvalidTransformArray" GUIContent
Contents o-> "transformArrayContainsNull" GUIContent
Contents o-> "InvalidTransformArrayLength" GUIContent
Contents o-> "useManager" GUIContent
Contents o-> "alwaysUpdate" GUIContent
Contents o-> "experimental" GUIContent
class TransformExtensions <<static>> {
    + {static} GetScaledRight(transform:Transform) : Vector3
    + {static} GetScaledUp(transform:Transform) : Vector3
    + {static} IsDescendentOf(transform:Transform, ancestor:Transform) : bool
}
class SpriteLibrary {
    + GetSprite(category:string, label:string) : Sprite
    <<internal>> GetSprite(categoryHash:int, labelHash:int) : Sprite
    <<internal>> GetSprite(categoryHash:int, labelHash:int, validEntry:bool) : Sprite
    <<internal>> GetCategoryNameFromHash(categoryHash:int) : string
    <<internal>> GetLabelNameFromHash(categoryHash:int, labelHash:int) : string
    + AddOverride(spriteLib:SpriteLibraryAsset, category:string, label:string) : void
    + AddOverride(spriteLib:SpriteLibraryAsset, category:string) : void
    + AddOverride(sprite:Sprite, category:string, label:string) : void
    + RemoveOverride(category:string) : void
    + RemoveOverride(category:string, label:string) : void
    + HasOverride(category:string, label:string) : bool
    + RefreshSpriteResolvers() : void
}
class StringAndHash {
    + name : string
    + hash : int
    + StringAndHash(name:string)
    + StringAndHash(hash:int)
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
MonoBehaviour <|-- SpriteLibrary
SpriteLibrary o-> "m_Overrides<StringAndHash,Dictionary<StringAndHash, Sprite>>" "Dictionary`2"
SpriteLibrary --> "spriteLibraryAsset" SpriteLibraryAsset
SpriteLibrary --> "labels<SpriteLibCategory>" "List`1"
SpriteLibrary +-- StringAndHash
interface INameHash {
    name : string <<get>> <<set>>
    hash : int <<get>>
}
class Categorylabel {
    m_Name : string
    m_Hash : int
    + name : string <<get>> <<set>>
    + hash : int <<get>>
    + UpdateHash() : void
}
class SpriteLibCategory {
    m_Name : string
    m_Hash : int
    + name : string <<get>> <<set>>
    + hash : int <<get>>
    + UpdateHash() : void
    <<internal>> ValidateLabels() : void
}
class SpriteLibraryAsset {
    <<internal>> GetSprite(categoryHash:int, labelHash:int) : Sprite
    <<internal>> GetSprite(categoryHash:int, labelHash:int, validEntry:bool) : Sprite
    + GetSprite(category:string, label:string) : Sprite
    + GetCategoryNames() : IEnumerable<string>
    + GetCategorylabelNames(category:string) : IEnumerable<string>
    + GetCategoryLabelNames(category:string) : IEnumerable<string>
    <<internal>> GetCategoryNameFromHash(hash:int) : string
    + AddCategoryLabel(sprite:Sprite, category:string, label:string) : void
    + RemoveCategoryLabel(category:string, label:string, deleteCategory:bool) : void
    <<internal>> GetLabelNameFromHash(categoryHas:int, labelHash:int) : string
    <<internal>> UpdateHashes() : void
    <<internal>> ValidateCategories() : void
    <<internal>> {static} RenameDuplicate(nameHashList:IEnumerable<INameHash>, onRename:Action<string, string>) : void
    <<internal>> {static} Default_GetStringHash(value:string) : int
}
class "List`1"<T> {
}
class "Func`2"<T1,T2> {
}
INameHash <|-- Categorylabel
Categorylabel --> "m_Sprite" Sprite
Categorylabel --> "sprite" Sprite
INameHash <|-- SpriteLibCategory
SpriteLibCategory --> "m_CategoryList<Categorylabel>" "List`1"
SpriteLibCategory --> "categoryList<Categorylabel>" "List`1"
ScriptableObject <|-- SpriteLibraryAsset
SpriteLibraryAsset --> "categories<SpriteLibCategory>" "List`1"
SpriteLibraryAsset o-> "GetStringHash<string,int>" "Func`2"
class SpriteResolver {
    OnEnable() : void
    + SetCategoryAndLabel(category:string, label:string) : void
    + GetCategory() : string
    + GetLabel() : string
    LateUpdate() : void
    <<internal>> GetSprite(validEntry:bool) : Sprite
    + ResolveSpriteToSpriteRenderer() : void
    OnTransformParentChanged() : void
    categoryHashInt : int <<get>> <<set>>
    labelHashInt : int <<get>> <<set>>
    <<internal>> <<unsafe>> {static} ConvertFloatToInt(f:float) : int
    <<internal>> <<unsafe>> {static} ConvertIntToFloat(f:int) : float
}
MonoBehaviour <|-- SpriteResolver
SpriteResolver --> "spriteRenderer" SpriteRenderer
SpriteResolver --> "spriteLibrary" SpriteLibrary
class Behavior {
    poly : bool = false
    quality : bool = false
    varArea : bool = false
    convex : bool = false
    jettison : bool = false
    boundaryMarkers : bool = true
    noHoles : bool = false
    conformDel : bool = false
    noBisect : int = 0
    minAngle : double = 0.0
    maxAngle : double = 0.0
    maxArea : double
    <<internal>> fixedArea : bool = false
    <<internal>> useSegments : bool = true
    <<internal>> useRegions : bool = false
    <<internal>> goodAngle : double = 0.0
    <<internal>> maxGoodAngle : double = 0.0
    <<internal>> offconstant : double = 0.0
    + Behavior(quality:bool, minAngle:double)
    <<internal>> {static} NoExact : bool <<get>> <<set>>
    + Quality : bool <<get>> <<set>>
    + MinAngle : double <<get>> <<set>>
    + MaxAngle : double <<get>> <<set>>
    + MaxArea : double <<get>> <<set>>
    + VarArea : bool <<get>> <<set>>
    + Poly : bool <<get>> <<set>>
    + Convex : bool <<get>> <<set>>
    + ConformingDelaunay : bool <<get>> <<set>>
    + NoBisect : int <<get>> <<set>>
    + UseBoundaryMarkers : bool <<get>> <<set>>
    + NoHoles : bool <<get>> <<set>>
    + Jettison : bool <<get>> <<set>>
}
class "Func`3"<T1,T2,T3> {
}
Behavior --> "usertest<ITriangle,double,bool>" "Func`3"
Behavior --> "UserTest<ITriangle,double,bool>" "Func`3"
class Configuration {
    + Configuration()
    + Configuration(predicates:Func<IPredicates>)
    + Configuration(predicates:Func<IPredicates>, trianglePool:Func<TrianglePool>)
}
class "Func`1"<T> {
}
Configuration --> "Predicates<IPredicates>" "Func`1"
Configuration --> "TrianglePool<TrianglePool>" "Func`1"
enum VertexType {
    InputVertex,
    SegmentVertex,
    FreeVertex,
    DeadVertex,
    UndeadVertex,
}
enum NodeNumbering {
    None,
    Linear,
    CuthillMcKee,
}
enum LocateResult {
    InTriangle,
    OnEdge,
    OnVertex,
    Outside,
}
enum InsertVertexResult {
    Successful,
    Encroaching,
    Violating,
    Duplicate,
}
enum FindDirectionResult {
    Within,
    Leftcollinear,
    Rightcollinear,
}
interface IPredicates {
    CounterClockwise(a:Point, b:Point, c:Point) : double
    InCircle(a:Point, b:Point, c:Point, p:Point) : double
    FindCircumcenter(org:Point, dest:Point, apex:Point, xi:double, eta:double) : Point
    FindCircumcenter(org:Point, dest:Point, apex:Point, xi:double, eta:double, offconstant:double) : Point
}
class Log <<sealed>> {
    <<internal>> {static} Verbose : bool <<get>> <<set>>
    {static} Log()
    + Add(item:LogItem) : void
    + Clear() : void
    + Info(message:string) : void
    + Warning(message:string, location:string) : void
    + Error(message:string, location:string) : void
}
class "ILog`1"<T> {
}
class "IList`1"<T> {
}
"ILog`1" "<LogItem>" <|-- Log
Log --> "Instance<LogItem>" "ILog`1"
Log --> "Data<LogItem>" "IList`1"
Log --> "Level" LogLevel
class Mesh {
    <<internal>> hash_vtx : int = 0
    <<internal>> hash_seg : int = 0
    <<internal>> hash_tri : int = 0
    <<internal>> invertices : int
    <<internal>> insegments : int
    <<internal>> undeads : int
    <<internal>> mesh_dim : int
    <<internal>> nextras : int = 0
    <<internal>> hullsize : int
    <<internal>> steinerleft : int
    <<internal>> checksegments : bool
    <<internal>> checkquality : bool
    + NumberOfInputPoints : int <<get>>
    + NumberOfEdges : int <<get>>
    + IsPolygon : bool <<get>>
    <<internal>> <<const>> DUMMY : int
    + Mesh(config:Configuration)
    + Refine(quality:QualityOptions, delaunay:bool) : void
    + Renumber() : void
    + Renumber(num:NodeNumbering) : void
    <<internal>> SetQualityMesher(qmesher:QualityMesher) : void
    <<internal>> CopyTo(target:Mesh) : void
    <<internal>> TransferNodes(points:IList<Vertex>) : void
    <<internal>> MakeVertexMap() : void
    <<internal>> MakeTriangle(newotri:Otri) : void
    <<internal>> MakeSegment(newsubseg:Osub) : void
    <<internal>> InsertVertex(newvertex:Vertex, searchtri:Otri, splitseg:Osub, segmentflaws:bool, triflaws:bool) : InsertVertexResult
    <<internal>> InsertSubseg(tri:Otri, subsegmark:int) : void
    <<internal>> Flip(flipedge:Otri) : void
    <<internal>> Unflip(flipedge:Otri) : void
    <<internal>> DeleteVertex(deltri:Otri) : void
    <<internal>> UndoVertex() : void
    <<internal>> TriangleDealloc(dyingtriangle:Triangle) : void
    <<internal>> VertexDealloc(dyingvertex:Vertex) : void
    <<internal>> SubsegDealloc(dyingsubseg:SubSegment) : void
}
class "ILog`1"<T> {
}
class "Stack`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
class "ICollection`1"<T> {
}
class "IList`1"<T> {
}
class "IEnumerable`1"<T> {
}
IMesh <|-- Mesh
Mesh --> "predicates" IPredicates
Mesh --> "logger<LogItem>" "ILog`1"
Mesh --> "qualityMesher" QualityMesher
Mesh --> "flipstack<Otri>" "Stack`1"
Mesh --> "triangles" TrianglePool
Mesh --> "subsegs<int,SubSegment>" "Dictionary`2"
Mesh --> "vertices<int,Vertex>" "Dictionary`2"
Mesh --> "holes<Point>" "List`1"
Mesh --> "regions<RegionPointer>" "List`1"
Mesh --> "bounds" Rectangle
Mesh --> "infvertex1" Vertex
Mesh --> "infvertex2" Vertex
Mesh --> "infvertex3" Vertex
Mesh --> "locator" TriangleLocator
Mesh --> "behavior" Behavior
Mesh --> "numbering" NodeNumbering
Mesh --> "Bounds" Rectangle
Mesh --> "Vertices<Vertex>" "ICollection`1"
Mesh --> "Holes<Point>" "IList`1"
Mesh --> "Triangles<Triangle>" "ICollection`1"
Mesh --> "Segments<SubSegment>" "ICollection`1"
Mesh --> "Edges<Edge>" "IEnumerable`1"
Mesh --> "CurrentNumbering" NodeNumbering
Mesh --> "dummytri" Triangle
Mesh --> "dummysub" SubSegment
class MeshValidator <<static>> {
    <<internal>> {static} IsConsistent(mesh:Mesh) : bool
    <<internal>> {static} IsDelaunay(mesh:Mesh) : bool
    <<internal>> {static} IsConstrainedDelaunay(mesh:Mesh) : bool
}
class NewLocation {
    <<const>> EPS : double = 1e-50
    + NewLocation(mesh:Mesh, predicates:IPredicates)
    + FindLocation(org:Vertex, dest:Vertex, apex:Vertex, xi:double, eta:double, offcenter:bool, badotri:Otri) : Point
}
NewLocation --> "predicates" IPredicates
NewLocation --> "mesh" Mesh
NewLocation --> "behavior" Behavior
class RobustPredicates {
    {static} RobustPredicates()
    + RobustPredicates()
    + CounterClockwise(pa:Point, pb:Point, pc:Point) : double
    + InCircle(pa:Point, pb:Point, pc:Point, pd:Point) : double
    + NonRegular(pa:Point, pb:Point, pc:Point, pd:Point) : double
    + FindCircumcenter(org:Point, dest:Point, apex:Point, xi:double, eta:double, offconstant:double) : Point
    + FindCircumcenter(org:Point, dest:Point, apex:Point, xi:double, eta:double) : Point
}
IPredicates <|-- RobustPredicates
RobustPredicates --> "Default" RobustPredicates
class TriangleLocator {
    + TriangleLocator(mesh:Mesh)
    + TriangleLocator(mesh:Mesh, predicates:IPredicates)
    + Update(otri:Otri) : void
    + Reset() : void
    + PreciseLocate(searchpoint:Point, searchtri:Otri, stopatsubsegment:bool) : LocateResult
    + Locate(searchpoint:Point, searchtri:Otri) : LocateResult
}
TriangleLocator --> "sampler" TriangleSampler
TriangleLocator --> "mesh" Mesh
TriangleLocator --> "predicates" IPredicates
TriangleLocator --> "recenttri" Otri
class TrianglePool {
    size : int
    count : int
    + TrianglePool()
    + Get() : Triangle
    + Release(triangle:Triangle) : void
    + Restart() : TrianglePool
    <<internal>> Sample(k:int, random:Random) : IEnumerable<Triangle>
    + Add(item:Triangle) : void
    + Clear() : void
    + Contains(item:Triangle) : bool
    + CopyTo(array:Triangle[], index:int) : void
    + Count : int <<get>>
    + IsReadOnly : bool <<get>>
    + Remove(item:Triangle) : bool
    + GetEnumerator() : IEnumerator<Triangle>
    GetEnumerator() : System.Collections.IEnumerator
}
class "ICollection`1"<T> {
}
class "Stack`1"<T> {
}
class Enumerator {
    count : int
    index : int
    offset : int
    <<internal>> Enumerator(pool:TrianglePool)
    + Dispose() : void
    Current : object <<get>>
    + MoveNext() : bool
    + Reset() : void
}
class "IEnumerator`1"<T> {
}
"ICollection`1" "<Triangle>" <|-- TrianglePool
TrianglePool --> "stack<Triangle>" "Stack`1"
TrianglePool +-- Enumerator
"IEnumerator`1" "<Triangle>" <|-- Enumerator
Enumerator --> "current" Triangle
Enumerator --> "Current" Triangle
class TriangleSampler {
    + TriangleSampler(mesh:Mesh)
    + TriangleSampler(mesh:Mesh, random:Random)
    + Reset() : void
    + Update() : void
    + GetEnumerator() : IEnumerator<Triangle>
    GetEnumerator() : System.Collections.IEnumerator
}
class "IEnumerable`1"<T> {
}
"IEnumerable`1" "<Triangle>" <|-- TriangleSampler
class Placeholder {
    + PlaceHolderTest() : void
}
class ImagePacker <<static>> {
    + {static} Pack(rects:RectInt[], padding:int, outPackedRects:RectInt[], outPackedWidth:int, outPackedHeight:int) : void
    + {static} Pack(buffers:NativeArray<Color32>[], width:int, height:int, padding:int, outPackedBuffer:NativeArray<Color32>, outPackedBufferWidth:int, outPackedBufferHeight:int, outPackedRect:RectInt[], outUVTransform:Vector2Int[]) : void
    {static} InternalPack(rects:RectInt[], padding:int) : ImagePackNode
    + {static} <<unsafe>> Blit(buffer:NativeArray<Color32>, blitToArea:RectInt[], bufferbytesPerRow:int, originalBuffer:NativeArray<Color32>[], blitFromArea:RectInt[], bytesPerRow:int, padding:int) : void
    <<internal>> {static} NextPowerOfTwo(v:ulong) : ulong
}
class ImagePackRect {
    + index : int
    + CompareTo(obj:ImagePackRect) : int
}
class "IComparable`1"<T> {
}
ImagePacker +-- ImagePackRect
"IComparable`1" "<ImagePackRect>" <|-- ImagePackRect
ImagePackRect --> "rect" RectInt
class ImagePackerDebugEditor {
    {static} Launch() : void
    m_TextureActualWidth : int = 0
    m_TextureActualHeight : int = 0
    m_PackWidth : int = 0
    m_PackHeight : int = 0
    m_Padding : int = 0
    m_Zoom : float = 1
    m_PackStep : int
    OnEnable() : void
    SetupConfigGUI() : void
    DrawListElement(rect:Rect, index:int, isactive:bool, isfocused:bool) : void
    OnConfigGUI() : void
    UpdateSpriteRect() : void
    Pack() : void
    DrawLabel(rect:Rect, label:string) : void
    OnImagePackerGUI() : void
    SetupHandlesMatrix() : void
}
class "List`1"<T> {
}
EditorWindow <|-- ImagePackerDebugEditor
ImagePackerDebugEditor --> "m_ReorderableList" ReorderableList
ImagePackerDebugEditor o-> "m_PackRects<RectInt>" "List`1"
ImagePackerDebugEditor --> "m_Texture" Texture2D
ImagePackerDebugEditor o-> "m_ConfigScroll" Vector2
ImagePackerDebugEditor --> "m_PackArea" IMGUIContainer
interface IImagePackNodeVisitor {
    Visit(node:ImagePackNode) : void
}
class CollectEmptyNodePositionVisitor {
    + Visit(node:ImagePackNode) : void
}
class CollectPackNodePositionVisitor {
    + CollectPackNodePositionVisitor()
    + Visit(node:ImagePackNode) : void
}
class ImagePackNode {
    + imageId : int
    + AcceptVisitor(visitor:IImagePackNodeVisitor) : void
    + AdjustSize(oriWidth:int, oriHeight:int, deltaW:int, deltaH:int, adjustx:int, adjusty:int) : void
    + TryInsert(insert:ImagePacker.ImagePackRect, padding:int, remainingSpace:Vector2Int) : bool
    {static} SplitRects(node:ImagePackNode, insert:ImagePacker.ImagePackRect, padding:int, left:ImagePackNode, right:ImagePackNode) : bool
    + Insert(insert:ImagePacker.ImagePackRect, padding:int) : bool
}
class "List`1"<T> {
}
IImagePackNodeVisitor <|-- CollectEmptyNodePositionVisitor
CollectEmptyNodePositionVisitor o-> "emptyAreas<RectInt>" "List`1"
IImagePackNodeVisitor <|-- CollectPackNodePositionVisitor
ImagePackNode --> "left" ImagePackNode
ImagePackNode --> "right" ImagePackNode
ImagePackNode --> "rect" RectInt
ImagePackNode --> "imageWidth" Vector2Int
class InternalEditorBridge <<static>> {
    + {static} RenderSortingLayerFields(order:SerializedProperty, layer:SerializedProperty) : void
    + {static} RepaintImmediately(window:EditorWindow) : void
    + {static} GetISpriteEditorDataProviderFromPath(importedAsset:string) : ISpriteEditorDataProvider
    + {static} GenerateOutline(texture:Texture2D, rect:Rect, detail:float, alphaTolerance:byte, holeDetection:bool, paths:Vector2[][]) : void
    + {static} DoesHardwareSupportsFullNPOT() : bool
    + {static} CreateTemporaryDuplicate(tex:Texture2D, width:int, height:int) : Texture2D
    + {static} ShowSpriteEditorWindow() : void
    + {static} ApplyWireMaterial() : void
    + {static} ResetSpriteEditorView(spriteEditor:ISpriteEditor) : void
    + {static} RegisterShortcutContext(context:ShortcutContext) : void
    + {static} UnregisterShortcutContext(context:ShortcutContext) : void
    + {static} AddEditorApplicationProjectLoadedCallback(callback:UnityAction) : void
    + {static} RemoveEditorApplicationProjectLoadedCallback(callback:UnityAction) : void
}
class ShortcutContext {
    + active : bool <<get>>
    + context : object <<get>> <<set>>
}
class "Func`1"<T> {
}
InternalEditorBridge +-- ShortcutContext
IShortcutToolContext <|-- ShortcutContext
ShortcutContext --> "isActive<bool>" "Func`1"
interface ITextureSettings {
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureSettings {
    m_ColorTexture : bool
    m_Readable : bool
    m_Aniso : int
    m_EnablePostProcessor : bool
    + TextureSettings()
    + TextureSettings(assetPath:string, enablePostProcessor:bool, colorTexture:bool, readable:bool, npotScale:TextureImporterNPOTScale, filterMode:FilterMode, aniso:int, sourceContainsAlpha:bool, sourceWasHDR:bool)
    + colorTexture : bool <<get>> <<set>>
    + readable : bool <<get>> <<set>>
    + aniso : int <<get>> <<set>>
    + enablePostProcessor : bool <<get>> <<set>>
    + assetPath : string <<get>> <<set>>
    + containsAlpha : bool <<get>> <<set>>
    + hdr : bool <<get>> <<set>>
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureSpriteSettings {
    m_PackingTag : string
    + packingTag : string <<get>> <<set>>
    m_PixelsPerUnit : float
    + pixelsPerUnit : float <<get>> <<set>>
    m_ExtrudeEdges : uint
    + extrudeEdges : uint <<get>> <<set>>
    + qualifyForPacking : bool <<get>> <<set>>
    + TextureSpriteSettings()
    + TextureSpriteSettings(packingTag:string, pixelsPerUnit:int, meshType:SpriteMeshType, extrudeEdges:uint, qualifyForPacking:bool, spriteSheetData:SpriteImportData[])
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureWrapSettings {
    + TextureWrapSettings()
    + TextureWrapSettings(wrapMpde:TextureWrapMode, wrapModeU:TextureWrapMode, wrapModeV:TextureWrapMode, wrapModeW:TextureWrapMode)
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureAlphaSettings {
    m_AlphaTolerance : float
    + alphaTolerance : float <<get>> <<set>>
    + TextureAlphaSettings()
    + TextureAlphaSettings(alphaSource:TextureImporterAlphaSource, alphaTolerance:float)
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureMipmapSettings {
    m_BorderMipmap : bool
    + borderMipmap : bool <<get>> <<set>>
    m_Fadeout : bool
    + fadeout : bool <<get>> <<set>>
    m_PreserveCoverage : bool
    + preserveCoverage : bool <<get>> <<set>>
    m_FadeDistanceStart : int
    + fadeDistanceStart : int <<get>> <<set>>
    m_FadeDistanceEnd : int
    + fadeDistanceEnd : int <<get>> <<set>>
    + TextureMipmapSettings()
    + TextureMipmapSettings(filter:TextureImporterMipFilter, borderMipmap:bool, fadeout:bool, preserveCoverage:bool, fadeDistanceStart:int, fadeDistanceEnd:int)
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureNormalSettings {
    m_GenerateFromGrayScale : bool
    + generateFromGrayScale : bool <<get>> <<set>>
    m_Bumpiness : float
    + bumpiness : float <<get>> <<set>>
    + TextureNormalSettings()
    + TextureNormalSettings(filter:TextureImporterNormalFilter, generateFromGrayScale:bool, bumpiness:float)
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureCubemapSettings {
    m_Seamless : bool
    + seamless : bool <<get>> <<set>>
    + TextureCubemapSettings()
    + TextureCubemapSettings(convolution:TextureImporterCubemapConvolution, mode:TextureImporterGenerateCubemap, seamless:bool)
    FillTextureGenerationSettings(settings:TextureGenerationSettings) : void
}
class TextureGeneratorHelper <<static>> {
    + {static} GenerateTextureSprite(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, spriteSettings:TextureSpriteSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateLightmap(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, mipmapSettings:TextureMipmapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateCookie(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, cubemapSettings:TextureCubemapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateNormalMap(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, normalSettings:TextureNormalSettings, mipmapSettings:TextureMipmapSettings, cubemapSettings:TextureCubemapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateTextureGUI(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateTextureSingleChannel(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, cubemapSettings:TextureCubemapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateTextureCursor(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    + {static} GenerateTextureDefault(buffer:NativeArray<Color32>, bufferWidth:int, bufferHeight:int, settings:TextureSettings, platformSettings:TextureImporterPlatformSettings, alphaSettings:TextureAlphaSettings, mipmapSettings:TextureMipmapSettings, cubemapSettings:TextureCubemapSettings, wrapSettings:TextureWrapSettings) : TextureGenerationOutput
    {static} GenerateTexture(imageBuffer:NativeArray<Color32>, imageBufferWidth:int, imageBufferHeight:int, type:TextureImporterType, platformSettings:TextureImporterPlatformSettings, otherSettings:ITextureSettings[]) : TextureGenerationOutput
    {static} + ExtractTextureSettings(tis:TextureImporterSettings) : TextureSettings
    {static} + ExtractTextureSpriteSettings(tis:TextureImporterSettings) : TextureSpriteSettings
    {static} + ExtractTextureWrapSettings(tis:TextureImporterSettings) : TextureWrapSettings
    {static} + ExtractTextureAlphaSettings(settings:TextureImporterSettings) : TextureAlphaSettings
    {static} + ExtractTextureMipmapSettings(settings:TextureImporterSettings) : TextureMipmapSettings
    {static} + ExtractTextureNormalSettings(settings:TextureImporterSettings) : TextureNormalSettings
    {static} + ExtractTextureCubemapSettings(settings:TextureImporterSettings) : TextureCubemapSettings
}
ITextureSettings <|-- TextureSettings
TextureSettings --> "m_NPOTScale" TextureImporterNPOTScale
TextureSettings --> "m_FilterMode" FilterMode
TextureSettings --> "npotScale" TextureImporterNPOTScale
TextureSettings --> "filterMode" FilterMode
ITextureSettings <|-- TextureSpriteSettings
TextureSpriteSettings --> "m_MeshType" SpriteMeshType
TextureSpriteSettings --> "meshType" SpriteMeshType
ITextureSettings <|-- TextureWrapSettings
TextureWrapSettings --> "m_WrapMode" TextureWrapMode
TextureWrapSettings --> "m_WrapModeU" TextureWrapMode
TextureWrapSettings --> "m_WrapModeV" TextureWrapMode
TextureWrapSettings --> "m_WrapModeW" TextureWrapMode
TextureWrapSettings --> "wrapMode" TextureWrapMode
TextureWrapSettings --> "wrapModeU" TextureWrapMode
TextureWrapSettings --> "wrapModeV" TextureWrapMode
TextureWrapSettings --> "wrapModeW" TextureWrapMode
ITextureSettings <|-- TextureAlphaSettings
TextureAlphaSettings --> "m_AlphaSource" TextureImporterAlphaSource
TextureAlphaSettings --> "alphaSource" TextureImporterAlphaSource
ITextureSettings <|-- TextureMipmapSettings
TextureMipmapSettings --> "m_Filter" TextureImporterMipFilter
TextureMipmapSettings --> "filter" TextureImporterMipFilter
ITextureSettings <|-- TextureNormalSettings
TextureNormalSettings --> "m_Filter" TextureImporterNormalFilter
TextureNormalSettings --> "filter" TextureImporterNormalFilter
ITextureSettings <|-- TextureCubemapSettings
TextureCubemapSettings --> "m_Convolution" TextureImporterCubemapConvolution
TextureCubemapSettings --> "convolution" TextureImporterCubemapConvolution
TextureCubemapSettings --> "m_Mode" TextureImporterGenerateCubemap
TextureCubemapSettings --> "mode" TextureImporterGenerateCubemap
class InternalEngineBridge <<static>> {
    + {static} SetLocalAABB(spriteRenderer:SpriteRenderer, aabb:Bounds) : void
    + {static} SetDeformableBuffer(spriteRenderer:SpriteRenderer, src:NativeArray<byte>) : void
    + {static} GUIUnclip(v:Vector2) : Vector2
    + {static} GetGUIClipTopMostRect() : Rect
    + {static} GetGUIClipTopRect() : Rect
}
class Placeholder {
    + PlaceHolderTest() : void
}
class BezierUtility <<static>> {
    + {static} BezierPoint(startPosition:Vector3, startTangent:Vector3, endTangent:Vector3, endPosition:Vector3, t:float) : Vector3
    + {static} ClosestPointOnCurve(point:Vector3, startPosition:Vector3, endPosition:Vector3, startTangent:Vector3, endTangent:Vector3, t:float) : Vector3
    + {static} ClosestPointOnCurveFast(point:Vector3, startPosition:Vector3, endPosition:Vector3, startTangent:Vector3, endTangent:Vector3, t:float) : Vector3
    + {static} SplitBezier(t:float, startPosition:Vector3, endPosition:Vector3, startRightTangent:Vector3, endLeftTangent:Vector3, leftStartPosition:Vector3, leftEndPosition:Vector3, leftStartTangent:Vector3, leftEndTangent:Vector3, rightStartPosition:Vector3, rightEndPosition:Vector3, rightStartTangent:Vector3, rightEndTangent:Vector3) : void
}
enum TangentMode {
    Linear= 0,
    Continuous= 1,
    Broken= 2,
}
class TangentCache <<struct>> {
}
class ControlPoint <<struct>> {
    + mirrorLeft : bool
    + StoreTangents() : void
    + RestoreTangents() : void
}
TangentCache --> "leftTangent" Vector3
TangentCache --> "rightTangent" Vector3
ControlPoint --> "position" Vector3
ControlPoint --> "localLeftTangent" Vector3
ControlPoint --> "localRightTangent" Vector3
ControlPoint --> "tangentMode" TangentMode
ControlPoint --> "continuousCache" TangentCache
ControlPoint --> "brokenCache" TangentCache
ControlPoint --> "leftTangent" Vector3
ControlPoint --> "rightTangent" Vector3
class EditablePath {
    + isOpenEnded : bool <<get>> <<set>>
    + pointCount : int <<get>>
    + GetPoint(index:int) : ControlPoint
    + SetPoint(index:int, controlPoint:ControlPoint) : void
    + AddPoint(controlPoint:ControlPoint) : void
    + InsertPoint(index:int, controlPoint:ControlPoint) : void
    + RemovePoint(index:int) : void
    + Clear() : void
    + Select(selector:ISelector<Vector3>) : bool
}
class "ISelection`1"<T> {
}
IEditablePath <|-- EditablePath
EditablePath --> "shapeType" ShapeType
EditablePath --> "undoObject" IUndoObject
EditablePath --> "localToWorldMatrix" Matrix4x4
EditablePath --> "forward" Vector3
EditablePath --> "up" Vector3
EditablePath --> "right" Vector3
EditablePath --> "worldToLocalMatrix" Matrix4x4
EditablePath --> "selection<int>" "ISelection`1"
class EditablePathController {
    + enableSnapping : bool <<get>> <<set>>
    + RegisterUndo(name:string) : void
    + ClearSelection() : void
    + SelectPoint(index:int, select:bool) : void
    + CreatePoint(index:int, position:Vector3) : void
    + RemoveSelectedPoints() : void
    + MoveSelectedPoints(delta:Vector3) : void
    + MoveEdge(index:int, delta:Vector3) : void
    + SetLeftTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedRightTangent:Vector3, cachedTangentMode:TangentMode) : void
    + SetRightTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedLeftTangent:Vector3, cachedTangentMode:TangentMode) : void
    + ClearClosestPath() : void
    + AddClosestPath(distance:float) : void
}
class "ISnapping`1"<T> {
}
IEditablePathController <|-- EditablePathController
EditablePathController --> "editablePath" IEditablePath
EditablePathController --> "closestEditablePath" IEditablePath
EditablePathController --> "snapping<Vector3>" "ISnapping`1"
class EditablePathExtensions <<static>> {
    + {static} ToPolygon(path:IEditablePath) : Polygon
    + {static} ToSpline(path:IEditablePath) : Spline
    + {static} CalculateLocalLeftTangent(path:IEditablePath, index:int) : Vector3
    + {static} CalculateLeftTangent(path:IEditablePath, index:int) : Vector3
    + {static} CalculateLocalRightTangent(path:IEditablePath, index:int) : Vector3
    + {static} CalculateRightTangent(path:IEditablePath, index:int) : Vector3
    + {static} GetPrevPoint(path:IEditablePath, index:int) : ControlPoint
    + {static} GetNextPoint(path:IEditablePath, index:int) : ControlPoint
    + {static} UpdateTangentMode(path:IEditablePath, index:int) : void
    + {static} UpdateTangentsFromMode(path:IEditablePath) : void
    + {static} SetTangentMode(path:IEditablePath, index:int, tangentMode:TangentMode) : void
    + {static} MirrorTangent(path:IEditablePath, index:int) : void
}
class EditablePathUtility {
    + {static} Mod(x:int, m:int) : int
}
interface IEditablePath {
    isOpenEnded : bool <<get>> <<set>>
    pointCount : int <<get>>
    GetPoint(index:int) : ControlPoint
    SetPoint(index:int, controlPoint:ControlPoint) : void
    AddPoint(controlPoint:ControlPoint) : void
    InsertPoint(index:int, controlPoint:ControlPoint) : void
    RemovePoint(index:int) : void
    Clear() : void
}
class "ISelectable`1"<T> {
}
class "ISelection`1"<T> {
}
"ISelectable`1" "<Vector3>" <|-- IEditablePath
IEditablePath --> "shapeType" ShapeType
IEditablePath --> "undoObject" IUndoObject
IEditablePath --> "selection<int>" "ISelection`1"
IEditablePath --> "localToWorldMatrix" Matrix4x4
IEditablePath --> "forward" Vector3
IEditablePath --> "up" Vector3
IEditablePath --> "right" Vector3
interface IEditablePathController {
    enableSnapping : bool <<get>> <<set>>
    RegisterUndo(name:string) : void
    ClearSelection() : void
    SelectPoint(index:int, select:bool) : void
    CreatePoint(index:int, position:Vector3) : void
    RemoveSelectedPoints() : void
    MoveSelectedPoints(delta:Vector3) : void
    MoveEdge(index:int, delta:Vector3) : void
    SetLeftTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedRightTangent:Vector3, cachedTangentMode:TangentMode) : void
    SetRightTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedLeftTangent:Vector3, cachedTangentMode:TangentMode) : void
    ClearClosestPath() : void
    AddClosestPath(distance:float) : void
}
class "ISnapping`1"<T> {
}
IEditablePathController --> "editablePath" IEditablePath
IEditablePathController --> "closestEditablePath" IEditablePath
IEditablePathController --> "snapping<Vector3>" "ISnapping`1"
interface "ISnapping`1"<T> {
    Snap(value:T) : T
}
interface IUndoObject {
    RegisterUndo(name:string) : void
}
class MultipleEditablePathController {
    + enableSnapping : bool <<get>> <<set>>
    + ClearPaths() : void
    + AddPath(path:IEditablePath) : void
    + RemovePath(path:IEditablePath) : void
    + RegisterUndo(name:string) : void
    + ClearSelection() : void
    + SelectPoint(index:int, select:bool) : void
    + CreatePoint(index:int, position:Vector3) : void
    + RemoveSelectedPoints() : void
    + MoveSelectedPoints(delta:Vector3) : void
    + MoveEdge(index:int, delta:Vector3) : void
    + SetLeftTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedRightTangent:Vector3, cachedTangentMode:TangentMode) : void
    + SetRightTangent(index:int, position:Vector3, setToLinear:bool, mirror:bool, cachedLeftTangent:Vector3, cachedTangentMode:TangentMode) : void
    + ClearClosestPath() : void
    + AddClosestPath(distance:float) : void
}
class "ISnapping`1"<T> {
}
IEditablePathController <|-- MultipleEditablePathController
MultipleEditablePathController --> "editablePath" IEditablePath
MultipleEditablePathController --> "closestEditablePath" IEditablePath
MultipleEditablePathController --> "snapping<Vector3>" "ISnapping`1"
class Snapping {
    + Snap(position:Vector3) : Vector3
}
class "ISnapping`1"<T> {
}
"ISnapping`1" "<Vector3>" <|-- Snapping
class "GenericScriptablePath`1"<T> {
    + <<override>> Clear() : void
    + <<override>> AddPoint(controlPoint:ControlPoint) : void
    + <<override>> InsertPoint(index:int, controlPoint:ControlPoint) : void
    + <<override>> RemovePoint(index:int) : void
    + GetData(index:int) : T
    + SetData(index:int, data:T) : void
}
ScriptablePath <|-- "GenericScriptablePath`1"
class "GenericScriptablePathInspector`2"<U,T> {
    + <<override>> OnInspectorGUI() : void
}
class "ScriptableData`1"<T> {
}
ScriptablePathInspector <|-- "GenericScriptablePathInspector`2"
abstract class "PathComponentEditor`1"<T> {
    <<internal>> DoEditButtonChecked(icon:GUIContent, label:string) : bool
}
class Contents <<static>> {
}
Editor <|-- "PathComponentEditor`1"
"PathComponentEditor`1" +-- Contents
Contents o-> "snappingLabel" GUIContent
class PathEditorToolContents <<static>> {
    <<internal>> {static} IconContent(name:string, tooltip:string) : GUIContent
}
interface IDuringSceneGuiTool {
    DuringSceneGui(sceneView:SceneView) : void
    IsAvailable() : bool
}
class EditorToolManager {
    {static} EditorToolManager()
    <<internal>> {static} Add(tool:IDuringSceneGuiTool) : void
    <<internal>> {static} Remove(tool:IDuringSceneGuiTool) : void
    <<internal>> {static} IsActiveTool() : bool
    <<internal>> {static} IsAvailable() : bool
    <<internal>> {static} GetEditorTool() : T
}
abstract class "PathEditorTool`1"<T> {
    + enableSnapping : bool <<get>> <<set>>
    + <<override>> IsAvailable() : bool
    + GetPath(targetObject:UnityObject) : T
    + SetPath(target:UnityObject) : void
    DuringSceneGui(sceneView:SceneView) : void
    <<internal>> SetShapes() : void
}
PathEditorToolContents o-> "shapeToolIcon" GUIContent
PathEditorToolContents o-> "shapeToolPro" GUIContent
PathEditorToolContents --> "icon" GUIContent
EditorTool <|-- "PathEditorTool`1"
IDuringSceneGuiTool <|-- "PathEditorTool`1"
"PathEditorTool`1" --> "toolbarIcon" GUIContent
class PathEditorToolExtensions <<static>> {
    + {static} CycleTangentMode(pathEditorTool:PathEditorTool<T>) : void
    + {static} MirrorTangent(pathEditorTool:PathEditorTool<T>) : void
}
class "ScriptableData`1"<T> {
    + index : int <<get>> <<set>>
    + data : T <<get>> <<set>>
}
ScriptableObject <|-- "ScriptableData`1"
"ScriptableData`1" --> "owner" UnityObject
class ScriptablePath {
    <<internal>> modified : bool <<get>>
    + isOpenEnded : bool <<get>> <<set>>
    + pointCount : int <<get>>
    + Select(selector:ISelector<Vector3>) : bool
    + <<virtual>> Clear() : void
    + <<virtual>> GetPoint(index:int) : ControlPoint
    + <<virtual>> SetPoint(index:int, controlPoint:ControlPoint) : void
    + <<virtual>> AddPoint(controlPoint:ControlPoint) : void
    + <<virtual>> InsertPoint(index:int, controlPoint:ControlPoint) : void
    + <<virtual>> RemovePoint(index:int) : void
    RegisterUndo(name:string) : void
}
class "ISelection`1"<T> {
}
ScriptableObject <|-- ScriptablePath
IEditablePath <|-- ScriptablePath
IUndoObject <|-- ScriptablePath
ScriptablePath --> "owner" UnityObject
ScriptablePath --> "shapeType" ShapeType
ScriptablePath --> "undoObject" IUndoObject
ScriptablePath --> "selection<int>" "ISelection`1"
ScriptablePath --> "localToWorldMatrix" Matrix4x4
ScriptablePath --> "forward" Vector3
ScriptablePath --> "up" Vector3
ScriptablePath --> "right" Vector3
class ScriptablePathInspector {
    + <<override>> OnInspectorGUI() : void
}
class Contents <<static>> {
}
Editor <|-- ScriptablePathInspector
ScriptablePathInspector +-- Contents
Contents o-> "linearIcon" GUIContent
Contents o-> "continuousIcon" GUIContent
Contents o-> "brokenIcon" GUIContent
Contents o-> "positionLabel" GUIContent
Contents o-> "enableSnapLabel" GUIContent
Contents o-> "tangentModeLabel" GUIContent
Contents o-> "pointLabel" GUIContent
class CreatePointAction {
    + CreatePointAction(pointControl:Control, edgeControl:Control)
}
class "Func`3"<T1,T2,T3> {
}
class "Action`2"<T1,T2> {
}
ClickAction <|-- CreatePointAction
CreatePointAction --> "guiToWorld<IGUIState,Vector2,Vector3>" "Func`3"
CreatePointAction --> "onCreatePoint<int,Vector3>" "Action`2"
class Drawer {
    + DrawCreatePointPreview(position:Vector3) : void
    + DrawPoint(position:Vector3) : void
    + DrawPointHovered(position:Vector3) : void
    + DrawPointSelected(position:Vector3) : void
    + DrawLine(p1:Vector3, p2:Vector3, width:float, color:Color) : void
    + DrawBezier(p1:Vector3, p2:Vector3, p3:Vector3, p4:Vector3, width:float, color:Color) : void
    + DrawTangent(position:Vector3, tangent:Vector3) : void
}
class Styles {
    + Styles()
}
IDrawer <|-- Drawer
Drawer +-- Styles
Styles --> "pointNormalStyle" GUIStyle
Styles --> "pointHoveredStyle" GUIStyle
Styles --> "pointSelectedStyle" GUIStyle
Styles --> "pointPreviewStyle" GUIStyle
Styles --> "tangentNormalStyle" GUIStyle
Styles --> "tangentHoveredStyle" GUIStyle
interface IDrawer {
    DrawCreatePointPreview(position:Vector3) : void
    DrawPoint(position:Vector3) : void
    DrawPointHovered(position:Vector3) : void
    DrawPointSelected(position:Vector3) : void
    DrawLine(p1:Vector3, p2:Vector3, width:float, color:Color) : void
    DrawBezier(p1:Vector3, p2:Vector3, p3:Vector3, p4:Vector3, width:float, color:Color) : void
    DrawTangent(position:Vector3, tangent:Vector3) : void
}
class PathEditor {
    <<const>> kSnappingDistance : float = 15f
    <<const>> kDeleteCommandName : string = "Delete"
    <<const>> kSoftDeleteCommandName : string = "SoftDelete"
    + linearTangentIsZero : bool <<get>> <<set>>
    + PathEditor()
    + PathEditor(guiSystem:GUISystem)
    + OnGUI() : void
}
PathEditor --> "controller" IEditablePathController
PathEditor --> "drawerOverride" IDrawer
abstract class "RectSelector`1"<T> {
    + RectSelector()
    + RectSelector(guiSystem:GUISystem)
    + OnGUI() : void
    Select(element:T) : bool
}
class "ISelector`1"<T> {
}
class Styles {
    + Styles()
}
class "Action`2"<T1,T2> {
}
class "Action`1"<T> {
}
"ISelector`1" "<T>" <|-- "RectSelector`1"
"RectSelector`1" --> "onSelectionBegin<ISelector<T>,bool>" "Action`2"
"RectSelector`1" --> "onSelectionChanged<ISelector<T>>" "Action`1"
"RectSelector`1" --> "onSelectionEnd<ISelector<T>>" "Action`1"
"RectSelector`1" --> "guiRect" Rect
"RectSelector`1" +-- Styles
Styles --> "selectionRectStyle" GUIStyle
class IndexedSelection {
}
class "SerializableSelection`1"<T> {
}
"SerializableSelection`1" "<int>" <|-- IndexedSelection
interface "ISelectable`1"<T> {
    Select(selector:ISelector<T>) : bool
}
interface "ISelection`1"<T> {
    Count : int <<get>>
    activeElement : T <<get>> <<set>>
    Clear() : void
    BeginSelection() : void
    EndSelection(select:bool) : void
    Select(element:T, select:bool) : bool
    Contains(element:T) : bool
}
interface "ISelector`1"<T> {
    Select(element:T) : bool
}
class PointRectSelector {
}
class "RectSelector`1"<T> {
}
"RectSelector`1" "<Vector3>" <|-- PointRectSelector
abstract class "SerializableSelection`1"<T> {
    <<internal>> <<readonly>> {static} kInvalidID : int
    + Count : int <<get>>
    + activeElement : T <<get>> <<set>>
    + Clear() : void
    + BeginSelection() : void
    + EndSelection(select:bool) : void
    + Select(element:T, select:bool) : bool
    + Contains(element:T) : bool
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
}
class "ISelection`1"<T> {
}
"ISelection`1" "<T>" <|-- "SerializableSelection`1"
ISerializationCallbackReceiver <|-- "SerializableSelection`1"
enum ShapeType {
    Polygon,
    Spline,
}
interface IShape {
    isOpenEnded : bool <<get>>
    ToControlPoints() : ControlPoint[]
}
IShape --> "type" ShapeType
class Polygon <<struct>> {
    + isOpenEnded : bool
    isOpenEnded : bool <<get>>
    ToControlPoints() : ControlPoint[]
}
IShape <|-- Polygon
Polygon --> "type" ShapeType
Polygon o-> "empty" Polygon
class ShapeExtensions <<static>> {
    + {static} ToPolygon(points:Vector3[], isOpenEnded:bool) : Polygon
    + {static} ToSpline(points:Vector3[], isOpenEnded:bool) : Spline
    + {static} IsSpline(points:Vector3[], isOpenEnded:bool) : bool
    + {static} ToSpline(polygon:Polygon) : Spline
}
class Spline <<struct>> {
    + isOpenEnded : bool
    isOpenEnded : bool <<get>>
    ToControlPoints() : ControlPoint[]
}
IShape <|-- Spline
Spline --> "type" ShapeType
Spline o-> "empty" Spline
class PixelPerfectCameraEditorTests {
    + PlaceHolderTest() : void
}
class PixelPerfectCameraTests {
    + CalculateCameraPropertiesProvidesCorrectResultsWithVariousInputs(testComponent:PixelPerfectCameraTestComponent, screenWidth:int, screenHeight:int, expected:CalculateCameraPropertiesResult) : void
    + CalculatePostRenderPixelRectStretchToFitHeightWorks() : void
    + CalculatePostRenderPixelRectStretchToFitWidthWorks() : void
    + CalculatePostRenderPixelRectCenteredWorks() : void
}
class PixelPerfectCameraTestComponent {
    + assetsPPU : int <<get>> <<set>>
    + refResolutionX : int <<get>> <<set>>
    + refResolutionY : int <<get>> <<set>>
    + upscaleRT : bool <<get>> <<set>>
    + pixelSnapping : bool <<get>> <<set>>
    + cropFrameX : bool <<get>> <<set>>
    + cropFrameY : bool <<get>> <<set>>
    + stretchFill : bool <<get>> <<set>>
}
class CalculateCameraPropertiesResult {
    + zoom : int
    + useOffscreenRT : bool
    + offscreenRTWidth : int
    + offscreenRTHeight : int
    + orthoSize : float
    + unitsPerPixel : float
}
PixelPerfectCameraTests +-- PixelPerfectCameraTestComponent
IPixelPerfectCamera <|-- PixelPerfectCameraTestComponent
PixelPerfectCameraTests +-- CalculateCameraPropertiesResult
CalculateCameraPropertiesResult --> "pixelRect" Rect
class ExtractLayerTask {
    + {static} <<unsafe>> Execute(extractedLayer:List<PSDLayer>, layers:List<BitmapLayer>, importHiddenLayer:bool) : void
    {static} ExtractLayer(extractedLayer:List<PSDLayer>, layers:List<BitmapLayer>, importHiddenLayer:bool) : int
}
class ConvertBufferJob <<struct>> {
    + <<unsafe>> Execute(index:int) : void
}
class "NativeArray`1"<T> {
}
ExtractLayerTask +-- ConvertBufferJob
IJobParallelFor <|-- ConvertBufferJob
ConvertBufferJob --> "original<IntPtr>" "NativeArray`1"
ConvertBufferJob --> "width<int>" "NativeArray`1"
ConvertBufferJob --> "height<int>" "NativeArray`1"
ConvertBufferJob --> "output<IntPtr>" "NativeArray`1"
class FlattenImageTask <<static>> {
    {static} <<unsafe>> + Execute(layer:List<BitmapLayer>, importHiddenLayer:bool, width:int, height:int, output:NativeArray<Color32>) : void
    {static} <<unsafe>> GetBuffersToMergeFromLayer(layer:BitmapLayer, importHiddenLayer:bool, buffers:List<IntPtr>) : void
}
class FlattenImageInternalJob <<struct>> {
    + layersPerJob : int
    + width : int
    + height : int
    + flipY : bool
    + <<unsafe>> Execute(index:int) : void
}
class "NativeArray`1"<T> {
}
FlattenImageTask +-- FlattenImageInternalJob
IJobParallelFor <|-- FlattenImageInternalJob
FlattenImageInternalJob --> "buffers<IntPtr>" "NativeArray`1"
FlattenImageInternalJob --> "output<IntPtr>" "NativeArray`1"
class Placeholder {
    + PlaceHolderTest() : void
}
class Bootstrap {
    {static} Bootstrap()
}
class CollabAnalytics <<static>> {
    + {static} SendUserAction(category:string, action:string) : void
    + {static} <<readonly>> historyCategoryString : string = "History"
}
class CollabUserActionAnalyticsEvent <<struct>> {
    + category : string
    + action : string
}
CollabAnalytics +-- CollabUserActionAnalyticsEvent
class CollabHistoryWindow {
    <<const>> kWindowTitle : string = "Collab History"
    <<const>> kServiceUrl : string = "developer.cloud.unity3d.com"
    + {static} ShowHistoryWindow() : void
    + {static} ValidateShowHistoryWindow() : bool
    m_ItemsPerPage : int = 5
    m_InProgressRev : string
    m_RevisionActionsEnabled : bool
    + CollabHistoryWindow()
    + OnEnable() : void
    + OnDisable() : void
    + revisionActionsEnabled : bool <<get>> <<set>>
    + SetupGUI() : void
    + UpdateState(state:HistoryState, force:bool) : void
    + UpdateRevisions(datas:IEnumerable<RevisionData>, tip:string, totalRevisions:int, currentPage:int) : void
    + inProgressRevision : string <<get>> <<set>>
    + itemsPerPage : int <<set>>
    UpdateHistoryView(history:VisualElement) : void
    NoSeatClick() : void
    SignInClick() : void
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
EditorWindow <|-- CollabHistoryWindow
ICollabHistoryWindow <|-- CollabHistoryWindow
CollabHistoryWindow --> "m_Presenter" CollabHistoryPresenter
CollabHistoryWindow --> "m_Views<HistoryState,VisualElement>" "Dictionary`2"
CollabHistoryWindow o-> "m_HistoryItems<CollabHistoryItem>" "List`1"
CollabHistoryWindow --> "m_State" HistoryState
CollabHistoryWindow --> "m_Container" VisualElement
CollabHistoryWindow --> "m_Pager" PagedListView
CollabHistoryWindow --> "m_HistoryView" ScrollView
CollabHistoryWindow --> "OnPageChangeAction" PageChangeAction
CollabHistoryWindow --> "OnGoBackAction" RevisionAction
CollabHistoryWindow --> "OnUpdateAction" RevisionAction
CollabHistoryWindow --> "OnRestoreAction" RevisionAction
CollabHistoryWindow --> "OnShowBuildAction" ShowBuildAction
CollabHistoryWindow --> "OnShowServicesAction" Action
class CollabToolbarButton {
    <<const>> kCollabButtonWidth : float = 78.0f
    m_DynamicTooltip : string
    {static} m_ShowCollabTooltip : bool = false
    + CollabToolbarButton()
    OnUnityConnectUserStateChanged(state:UserInfo) : void
    OnUnityConnectStateChanged(state:ConnectInfo) : void
    + <<override>> OnGUI(rect:Rect) : void
    GUIToScreenRect(guiRect:Rect) : Rect
    ShowPopup(rect:Rect) : void
    DoCollabDropDown(rect:Rect) : void
    + OnCollabStateChanged(info:CollabInfo) : void
    + UpdateCollabToolbarState() : void
    ReserveRight(width:float, pos:Rect) : void
    ReserveBottom(height:float, pos:Rect) : void
    GetCollabButton() : ButtonWithAnimatedIconRotation
    + Dispose() : void
}
enum CollabToolbarState {
    NeedToEnableCollab,
    UpToDate,
    Conflict,
    OperationError,
    ServerHasChanges,
    FilesToPush,
    InProgress,
    Disabled,
    Offline,
}
class CollabToolbarContent {
    <<readonly>> m_iconName : string
    <<readonly>> m_toolTip : string
    + CollabToolbarContent(state:CollabToolbarState, iconName:string, toolTip:string)
}
class "Dictionary`2"<T1,T2> {
}
SubToolbar <|-- CollabToolbarButton
IDisposable <|-- CollabToolbarButton
CollabToolbarButton o-> "m_CollabToolbarState" CollabToolbarState
CollabToolbarButton --> "m_CollabButton" ButtonWithAnimatedIconRotation
CollabToolbarButton +-- CollabToolbarState
CollabToolbarButton +-- CollabToolbarContent
CollabToolbarContent --> "m_state" CollabToolbarState
CollabToolbarContent --> "m_CollabIcons<CollabToolbarContent,GUIContent>" "Dictionary`2"
CollabToolbarContent --> "RegisteredForState" CollabToolbarState
CollabToolbarContent --> "GuiContent" GUIContent
class WebViewStatic {
    {static} + GetWebView() : WebView
    {static} + SetWebView(webView:WebView) : void
}
class CollabToolbarWindow {
    + {static} s_ToolbarIsVisible : bool = false
    <<const>> kWindowWidth : int = 320
    <<const>> kWindowHeight : int = 350
    + {static} CloseToolbar() : void
    + {static} ShowToolbarWindow() : CollabToolbarWindow
    + {static} ValidateShowToolbarWindow() : bool
    + {static} IsVisible() : bool
    + {static} ShowCenteredAtPosition(buttonRect:Rect) : bool
    + OnReceiveTitle(title:string) : void
    + <<new>> OnInitScripting() : void
    + <<override>> OnEnable() : void
    <<internal>> <<new>> OnDisable() : void
    + <<new>> OnDestroy() : void
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<WebViewStatic>" <|-- WebViewStatic
WebViewStatic --> "m_WebView" WebView
WebViewEditorStaticWindow <|-- CollabToolbarWindow
IHasCustomMenu <|-- CollabToolbarWindow
CollabToolbarWindow --> "webView" WebView
class HistoryTests {
    + SetUp() : void
    + TearDown() : void
    + CollabHistoryPresenter_OnUpdatePage__PropagatesRevisionResult() : void
    + CollabHistoryPresenter_OnUpdatePage__RevisionNumberingIsInOrder() : void
    + CollabHistoryPresenter_OnUpdatePage__RevisionNumberingChangesForMorePages() : void
    + CollabHistoryPresenter_OnUpdatePage__ObtainedIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__CurrentIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__InProgressIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__EnabledIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__DisabledIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasNoneWhenNotTip() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateTipHasNoneWhenEnabled() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasConfigureWhenTip() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasConfigureWhenZeroBuildStatus() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasNoneWhenZeroBuildStatuses() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasSuccessWhenCompleteAndSucceeded() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasInProgress() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasFailure() : void
    + CollabHistoryPresenter_OnUpdatePage__BuildStateHasFailureWhenAnyBuildsFail() : void
    + CollabHistoryPresenter_OnUpdatePage__ChangesPropagateThrough() : void
    + CollabHistoryPresenter_OnUpdatePage__ChangesTotalIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__ChangesTruncatedIsCalculated() : void
    + CollabHistoryPresenter_OnUpdatePage__OnlyKeeps10ChangeActions() : void
    + CollabHistoryPresenter_OnUpdatePage__DeduplicatesMetaFiles() : void
    + CollabHistoryPresenter_OnUpdatePage__FolderMetaFilesAreCounted() : void
}
class TestRevisionsService {
    +  <<event>> FetchRevisionsCallback : RevisionsDelegate 
    + tipRevision : string <<get>> <<set>>
    + currentUser : string <<get>> <<set>>
    + GetRevisions(offset:int, count:int) : void
}
class TestHistoryWindow {
    + revisionActionsEnabled : bool <<get>> <<set>>
    + itemsPerPage : int <<get>> <<set>>
    + errMessage : string <<get>> <<set>>
    + inProgressRevision : string <<get>> <<set>>
    + UpdateState(state:HistoryState, force:bool) : void
    + UpdateRevisions(items:IEnumerable<RevisionData>, tip:string, totalRevisions:int, currPage:int) : void
}
class "IEnumerable`1"<T> {
}
IRevisionsService <|-- TestRevisionsService
TestRevisionsService --> "result" RevisionsResult
ICollabHistoryWindow <|-- TestHistoryWindow
TestHistoryWindow --> "items<RevisionData>" "IEnumerable`1"
TestHistoryWindow --> "OnPageChangeAction" PageChangeAction
TestHistoryWindow --> "OnGoBackAction" RevisionAction
TestHistoryWindow --> "OnUpdateAction" RevisionAction
TestHistoryWindow --> "OnRestoreAction" RevisionAction
TestHistoryWindow --> "OnShowBuildAction" ShowBuildAction
TestHistoryWindow --> "OnShowServicesAction" Action
interface IDiscovery {
    PathCallback() : CodeEditor.Installation[]
}
class Discovery {
    + PathCallback() : CodeEditor.Installation[]
}
class RiderPathLocator <<static>> {
    + {static} GetAllRiderPaths() : RiderInfo[]
    <<internal>> {static} GetBuildNumber(path:string) : string
    <<internal>> {static} IsToolbox(path:string) : bool
}
class ToolboxHistory {
    + {static} GetLatestBuildFromJson(json:string) : string
}
class ItemNode {
}
class BuildNode {
    + build : string
}
class ToolboxInstallData {
    + {static} GetLatestBuildFromJson(json:string) : string
}
class ActiveApplication {
}
class RiderInfo <<struct>> {
    + IsToolbox : bool
    + Presentation : string
    + BuildVersion : string
    + Path : string
    + RiderInfo(path:string, isToolbox:bool)
}
class Logger <<static>> {
    <<internal>> {static} Warn(message:string, e:Exception) : void
}
class "List`1"<T> {
}
IDiscovery <|-- Discovery
RiderPathLocator +-- ToolboxHistory
ToolboxHistory --> "history<ItemNode>" "List`1"
RiderPathLocator +-- ItemNode
ItemNode --> "item" BuildNode
RiderPathLocator +-- BuildNode
RiderPathLocator +-- ToolboxInstallData
ToolboxInstallData --> "active_application" ActiveApplication
RiderPathLocator +-- ActiveApplication
ActiveApplication --> "builds<string>" "List`1"
RiderPathLocator +-- RiderInfo
RiderPathLocator +-- Logger
class EditorPluginInterop <<static>> {
    + {static} LogPath : string <<get>>
    + {static} OpenFileDllImplementation(path:string, line:int, column:int) : bool
    + {static} EditorPluginIsLoadedFromAssets(assembly:Assembly) : bool
    <<internal>> {static} InitEntryPoint(assembly:Assembly) : void
}
EditorPluginInterop --> "EditorPluginAssembly" Assembly
enum LoggingLevel {
    OFF,
    FATAL,
    ERROR,
    WARN,
    INFO,
    VERBOSE,
    TRACE,
}
class PluginSettings {
    + {static} LogEventsCollectorEnabled : bool <<get>>
}
PluginSettings --> "SelectedLoggingLevel" LoggingLevel
class RiderInitializer {
    + Initialize(editorPath:string) : void
}
class RiderScriptEditor {
    {static} RiderScriptEditor()
    <<internal>> {static} GetEditorRealPath(path:string) : string
    <<const>> unity_generate_all : string = "unity_generate_all_csproj"
    + RiderScriptEditor(discovery:IDiscovery, projectGeneration:IGenerator)
    + OnGUI() : void
    + SyncIfNeeded(addedFiles:string[], deletedFiles:string[], movedFiles:string[], movedFromFiles:string[], importedFiles:string[]) : void
    + SyncAll() : void
    + Initialize(editorInstallationPath:string) : void
    + OpenProject(path:string, line:int, column:int) : bool
    {static} IsUnityScript(path:string) : bool
    {static} GetBaseUnityDeveloperFolder() : string
    + TryGetInstallationForPath(editorPath:string, installation:CodeEditor.Installation) : bool
    + {static} IsRiderInstallation(path:string) : bool
    + {static} CurrentEditor : string <<get>>
    + CreateSolutionIfDoesntExist() : void
}
IExternalCodeEditor <|-- RiderScriptEditor
RiderScriptEditor --> "m_Discoverability" IDiscovery
RiderScriptEditor --> "m_ProjectGeneration" IGenerator
RiderScriptEditor o-> "m_Initiliazer" RiderInitializer
class RiderScriptEditorData {
    <<internal>> HasChanges : bool = true
    <<internal>> shouldLoadEditorPlugin : bool
    <<internal>> InitializedOnce : bool
    <<internal>> currentEditorVersion : string
    + Init() : void
    + Invalidate(editorInstallationPath:string) : void
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<RiderScriptEditorData>" <|-- RiderScriptEditorData
interface IAssemblyNameProvider {
    GetAssemblyNameFromScriptPath(path:string) : string
    GetAssemblies(shouldFileBePartOfSolution:Func<string, bool>) : IEnumerable<Assembly>
    GetAllAssetPaths() : IEnumerable<string>
    GetRoslynAnalyzerPaths() : IEnumerable<string>
    FindForAssetPath(assetPath:string) : UnityEditor.PackageManager.PackageInfo
    ParseResponseFile(responseFilePath:string, projectDirectory:string, systemReferenceDirectories:string[]) : ResponseFileData
    IsInternalizedPackagePath(path:string) : bool
    ToggleProjectGeneration(preference:ProjectGenerationFlag) : void
}
class AssemblyNameProvider {
    + GetAssemblyNameFromScriptPath(path:string) : string
    + GetAssemblies(shouldFileBePartOfSolution:Func<string, bool>) : IEnumerable<Assembly>
    + GetAllAssetPaths() : IEnumerable<string>
    + FindForAssetPath(assetPath:string) : UnityEditor.PackageManager.PackageInfo
    + ParseResponseFile(responseFilePath:string, projectDirectory:string, systemReferenceDirectories:string[]) : ResponseFileData
    + IsInternalizedPackagePath(path:string) : bool
    + ToggleProjectGeneration(preference:ProjectGenerationFlag) : void
    + GetRoslynAnalyzerPaths() : IEnumerable<string>
}
IAssemblyNameProvider --> "ProjectGenerationFlag" ProjectGenerationFlag
IAssemblyNameProvider <|-- AssemblyNameProvider
AssemblyNameProvider o-> "m_ProjectGenerationFlag" ProjectGenerationFlag
AssemblyNameProvider --> "ProjectGenerationFlag" ProjectGenerationFlag
interface IFileIO {
    Exists(fileName:string) : bool
    ReadAllText(fileName:string) : string
    WriteAllText(fileName:string, content:string) : void
    CreateDirectory(pathName:string) : void
}
class FileIOProvider {
    + Exists(fileName:string) : bool
    + ReadAllText(fileName:string) : string
    + WriteAllText(fileName:string, content:string) : void
    + CreateDirectory(pathName:string) : void
}
IFileIO <|-- FileIOProvider
interface IGUIDGenerator {
    ProjectGuid(projectName:string, assemblyName:string) : string
    SolutionGuid(projectName:string, extension:string) : string
}
class GUIDProvider {
    + ProjectGuid(projectName:string, assemblyName:string) : string
    + SolutionGuid(projectName:string, extension:string) : string
}
IGUIDGenerator <|-- GUIDProvider
interface IGenerator {
    SyncIfNeeded(affectedFiles:List<string>, reimportedFiles:string[]) : bool
    Sync() : void
    SolutionFile() : string
    ProjectDirectory : string <<get>>
    GenerateAll(generateAll:bool) : void
    SolutionExists() : bool
}
class ProjectGeneration {
    + {static} <<readonly>> MSBuildNamespaceUri : string = "http://schemas.microsoft.com/developer/msbuild/2003"
    <<const>> k_WindowsNewline : string = "\r\n"
    <<const>> k_SettingsJson : string = @"{
    ""files.exclude"":
    {
        ""**/.DS_Store"":true,
        ""**/.git"":true,
        ""**/.gitignore"":true,
        ""**/.gitmodules"":true,
        ""**/*.booproj"":true,
        ""**/*.pidb"":true,
        ""**/*.suo"":true,
        ""**/*.user"":true,
        ""**/*.userprefs"":true,
        ""**/*.unityproj"":true,
        ""**/*.dll"":true,
        ""**/*.exe"":true,
        ""**/*.pdf"":true,
        ""**/*.mid"":true,
        ""**/*.midi"":true,
        ""**/*.wav"":true,
        ""**/*.gif"":true,
        ""**/*.ico"":true,
        ""**/*.jpg"":true,
        ""**/*.jpeg"":true,
        ""**/*.png"":true,
        ""**/*.psd"":true,
        ""**/*.tga"":true,
        ""**/*.tif"":true,
        ""**/*.tiff"":true,
        ""**/*.3ds"":true,
        ""**/*.3DS"":true,
        ""**/*.fbx"":true,
        ""**/*.FBX"":true,
        ""**/*.lxo"":true,
        ""**/*.LXO"":true,
        ""**/*.ma"":true,
        ""**/*.MA"":true,
        ""**/*.obj"":true,
        ""**/*.OBJ"":true,
        ""**/*.asset"":true,
        ""**/*.cubemap"":true,
        ""**/*.flare"":true,
        ""**/*.mat"":true,
        ""**/*.meta"":true,
        ""**/*.prefab"":true,
        ""**/*.unity"":true,
        ""build/"":true,
        ""Build/"":true,
        ""Library/"":true,
        ""library/"":true,
        ""obj/"":true,
        ""Obj/"":true,
        ""ProjectSettings/"":true,
        ""temp/"":true,
        ""Temp/"":true
    &#125;
}"
    m_SolutionProjectEntryTemplate : string
    m_SolutionProjectConfigurationTemplate : string
    + ProjectDirectory : string <<get>>
    + GenerateAll(generateAll:bool) : void
    <<readonly>> m_ProjectName : string
    <<const>> k_ToolsVersion : string = "4.0"
    <<const>> k_ProductVersion : string = "10.0.20506"
    <<const>> k_BaseDirectory : string = "."
    <<const>> k_TargetFrameworkVersion : string = "v4.7.1"
    <<const>> k_TargetLanguageVersion : string = "latest"
    + ProjectGeneration(tempDirectory:string)
    + ProjectGeneration(tempDirectory:string, assemblyNameProvider:IAssemblyNameProvider, fileIO:IFileIO, guidGenerator:IGUIDGenerator)
    + SyncIfNeeded(affectedFiles:List<string>, reimportedFiles:string[]) : bool
    HasFilesBeenModified(affectedFiles:List<string>, reimportedFiles:string[]) : bool
    {static} ShouldSyncOnReimportedAsset(asset:string) : bool
    + Sync() : void
    + SolutionExists() : bool
    SetupProjectSupportedExtensions() : void
    ShouldFileBePartOfSolution(file:string) : bool
    HasValidExtension(file:string) : bool
    IsSupportedExtension(extension:string) : bool
    {static} ScriptingLanguageFor(assembly:Assembly) : ScriptingLanguage
    {static} GetExtensionOfSourceFiles(files:string[]) : string
    {static} GetExtensionOfSourceFile(file:string) : string
    {static} ScriptingLanguageFor(extension:string) : ScriptingLanguage
    + GenerateAndWriteSolutionAndProjects() : void
    ParseResponseFileData(assembly:Assembly) : List<ResponseFileData>
    GenerateAllAssetProjectParts() : Dictionary<string, string>
    SyncProject(assembly:Assembly, allAssetsProjectParts:Dictionary<string, string>, responseFilesData:List<ResponseFileData>, assemblyNames:HashSet<string>) : void
    SyncProjectFileIfNotChanged(path:string, newContents:string) : void
    SyncSolutionFileIfNotChanged(path:string, newContents:string) : void
    SyncFileIfNotChanged(filename:string, newContents:string) : void
    ProjectText(assembly:Assembly, allAssetsProjectParts:Dictionary<string, string>, responseFilesData:List<ResponseFileData>, assemblyNames:HashSet<string>, roslynAnalyzerDllPaths:string[]) : string
    {static} AppendReference(fullReference:string, projectBuilder:StringBuilder) : void
    + ProjectFile(assembly:Assembly) : string
    + SolutionFile() : string
    ProjectHeader(assembly:Assembly, responseFilesData:List<ResponseFileData>, roslynAnalyzerDllPaths:string[], builder:StringBuilder) : void
    {static} GetSolutionText() : string
    {static} GetProjectFooterTemplate() : string
    {static} GetProjectHeaderTemplate(builder:StringBuilder, assemblyGUID:string, assemblyName:string, defines:string, allowUnsafe:bool, analyzerBlock:string) : void
    SyncSolution(assemblies:IEnumerable<Assembly>) : void
    SolutionText(assemblies:IEnumerable<Assembly>) : string
    {static} RelevantAssembliesForMode(assemblies:IEnumerable<Assembly>) : IEnumerable<Assembly>
    GetProjectEntries(assemblies:IEnumerable<Assembly>) : string
    GetProjectActiveConfigurations(projectGuid:string) : string
    EscapedRelativePathFor(file:string) : string
    {static} SkipPathPrefix(path:string, prefix:string) : string
    {static} NormalizePath(path:string) : string
    ProjectGuid(assembly:string) : string
    SolutionGuid(assembly:Assembly) : string
    {static} ProjectFooter() : string
    {static} GetProjectExtension() : string
    WriteVSCodeSettingsFiles() : void
}
class SolutionGuidGenerator <<static>> {
    + {static} GuidForProject(projectName:string) : string
    + {static} GuidForSolution(projectName:string, sourceFileExtension:string) : string
    {static} ComputeGuidHashFor(input:string) : string
}
enum ScriptingLanguage {
    None,
    CSharp,
}
class "Dictionary`2"<T1,T2> {
}
IGenerator --> "AssemblyNameProvider" IAssemblyNameProvider
IGenerator <|-- ProjectGeneration
ProjectGeneration o-> "k_BuiltinSupportedExtensions<string,ScriptingLanguage>" "Dictionary`2"
ProjectGeneration --> "AssemblyNameProvider" IAssemblyNameProvider
ProjectGeneration --> "m_AssemblyNameProvider" IAssemblyNameProvider
ProjectGeneration --> "m_FileIOProvider" IFileIO
ProjectGeneration --> "m_GUIDProvider" IGUIDGenerator
SolutionGuidGenerator o-> "mD5" MD5
ProjectGeneration +-- ScriptingLanguage
enum ProjectGenerationFlag {
    None= 0,
    Embedded= 1,
    Local= 2,
    Registry= 4,
    Git= 8,
    BuiltIn= 16,
    Unknown= 32,
    PlayerAssemblies= 64,
    LocalTarBall= 128,
}
class TestMath <<partial>> {
    + <<unsafe>> hash_blob() : void
}
class TestRandom {
    + {static} bool_uniform() : void
    + {static} bool2_uniform() : void
    + {static} bool2_independent() : void
    + {static} bool3_uniform() : void
    + {static} bool3_independent() : void
    + {static} bool4_uniform() : void
    + {static} bool4_independent() : void
    + {static} int_uniform_low_bits() : void
    + {static} int_uniform_high_bits() : void
    + {static} int_uniform_max() : void
    + {static} int_uniform_max_limit() : void
    + {static} int_uniform_min_max() : void
    + {static} int_uniform_min_max_limit() : void
    + {static} int2_uniform_low_bits() : void
    + {static} int2_uniform_high_bits() : void
    + {static} int2_uniform_max() : void
    + {static} int2_uniform_min_max() : void
    + {static} int2_uniform_min_max_limit() : void
    + {static} int2_independent_low_bits() : void
    + {static} int2_independent_high_bits() : void
    + {static} int3_uniform_low_bits() : void
    + {static} int3_uniform_high_bits() : void
    + {static} int3_uniform_max() : void
    + {static} int3_uniform_max_limit() : void
    + {static} int3_uniform_min_max() : void
    + {static} int3_uniform_min_max_limit() : void
    + {static} int3_independent_low_bits() : void
    + {static} int3_independent_high_bits() : void
    + {static} int4_uniform_low_bits() : void
    + {static} int4_uniform_high_bits() : void
    + {static} int4_uniform_max() : void
    + {static} int4_uniform_max_limit() : void
    + {static} int4_uniform_min_max() : void
    + {static} int4_uniform_min_max_limit() : void
    + {static} int4_independent_low_bits() : void
    + {static} int4_independent_high_bits() : void
    + {static} uint_uniform_low_bits() : void
    + {static} uint_uniform_high_bits() : void
    + {static} uint_uniform_max() : void
    + {static} uint_uniform_max_limit() : void
    + {static} uint_uniform_min_max() : void
    + {static} uint_uniform_min_max_limit() : void
    + {static} uint2_uniform_low_bits() : void
    + {static} uint2_uniform_high_bits() : void
    + {static} uint2_uniform_max() : void
    + {static} uint2_uniform_max_limit() : void
    + {static} uint2_uniform_min_max() : void
    + {static} uint2_uniform_min_max_limit() : void
    + {static} uint2_independent_low_bits() : void
    + {static} uint2_independent_high_bits() : void
    + {static} uint3_uniform_low_bits() : void
    + {static} uint3_uniform_high_bits() : void
    + {static} uint3_uniform_max() : void
    + {static} uint3_uniform_max_limit() : void
    + {static} uint3_uniform_min_max() : void
    + {static} uint3_uniform_min_max_limit() : void
    + {static} uint3_independent_low_bits() : void
    + {static} uint3_independent_high_bits() : void
    + {static} uint4_uniform_low_bits() : void
    + {static} uint4_uniform_high_bits() : void
    + {static} uint4_uniform_max() : void
    + {static} uint4_uniform_max_limit() : void
    + {static} uint4_uniform_min_max() : void
    + {static} uint4_uniform_min_max_limit() : void
    + {static} uint4_independent_low_bits() : void
    + {static} uint4_independent_high_bits() : void
    + {static} float_uniform() : void
    + {static} float_uniform_low_bits() : void
    + {static} float_uniform_max() : void
    + {static} float_uniform_min_max() : void
    + {static} float2_uniform() : void
    + {static} float2_uniform_low_bits() : void
    + {static} float2_uniform_max() : void
    + {static} float2_uniform_min_max() : void
    + {static} float2_independent() : void
    + {static} float3_uniform() : void
    + {static} float3_uniform_low_bits() : void
    + {static} float3_uniform_max() : void
    + {static} float3_uniform_min_max() : void
    + {static} float3_independent() : void
    + {static} float4_uniform() : void
    + {static} float4_uniform_low_bits() : void
    + {static} float4_uniform_max() : void
    + {static} float4_uniform_min_max() : void
    + {static} float4_independent() : void
    + {static} double_uniform() : void
    + {static} double_uniform_low_bits() : void
    + {static} double_uniform_max() : void
    + {static} double_uniform_min_max() : void
    + {static} double2_uniform() : void
    + {static} double2_uniform_low_bits() : void
    + {static} double2_uniform_max() : void
    + {static} double2_uniform_min_max() : void
    + {static} double2_independent() : void
    + {static} double3_uniform() : void
    + {static} double3_uniform_low_bits() : void
    + {static} double3_uniform_max() : void
    + {static} double3_uniform_min_max() : void
    + {static} double3_independent() : void
    + {static} double4_uniform() : void
    + {static} double4_uniform_low_bits() : void
    + {static} double4_uniform_max() : void
    + {static} double4_uniform_min_max() : void
    + {static} double4_independent() : void
    + {static} float2_direction() : void
    + {static} double2_direction() : void
    + {static} float3_direction() : void
    + {static} double3_direction() : void
    + {static} quaternion_rotation() : void
}
class noise <<static>> <<partial>> {
    + {static} cellular(P:float2) : float2
}
class noise <<static>> <<partial>> {
    + {static} cellular2x2(P:float2) : float2
}
class noise <<static>> <<partial>> {
    + {static} cellular2x2x2(P:float3) : float2
}
class noise <<static>> <<partial>> {
    + {static} cellular(P:float3) : float2
}
class noise <<static>> <<partial>> {
    + {static} cnoise(P:float2) : float
    + {static} pnoise(P:float2, rep:float2) : float
}
class noise <<static>> <<partial>> {
    + {static} cnoise(P:float3) : float
    + {static} pnoise(P:float3, rep:float3) : float
}
class noise <<static>> <<partial>> {
    + {static} cnoise(P:float4) : float
    + {static} pnoise(P:float4, rep:float4) : float
}
class noise <<static>> <<partial>> {
    {static} mod289(x:float) : float
    {static} mod289(x:float2) : float2
    {static} mod289(x:float3) : float3
    {static} mod289(x:float4) : float4
    {static} mod7(x:float3) : float3
    {static} mod7(x:float4) : float4
    {static} permute(x:float) : float
    {static} permute(x:float3) : float3
    {static} permute(x:float4) : float4
    {static} taylorInvSqrt(r:float) : float
    {static} taylorInvSqrt(r:float4) : float4
    {static} fade(t:float2) : float2
    {static} fade(t:float3) : float3
    {static} fade(t:float4) : float4
    {static} grad4(j:float, ip:float4) : float4
    {static} rgrad2(p:float2, rot:float) : float2
}
class noise <<static>> <<partial>> {
    + {static} snoise(v:float2) : float
}
class noise <<static>> <<partial>> {
    + {static} snoise(v:float3) : float
}
class noise <<static>> <<partial>> {
    + {static} snoise(v:float3, gradient:float3) : float
}
class noise <<static>> <<partial>> {
    + {static} snoise(v:float4) : float
}
class noise <<static>> <<partial>> {
    + {static} psrdnoise(pos:float2, per:float2, rot:float) : float3
    + {static} psrdnoise(pos:float2, per:float2) : float3
    + {static} psrnoise(pos:float2, per:float2, rot:float) : float
    + {static} psrnoise(pos:float2, per:float2) : float
    + {static} srdnoise(pos:float2, rot:float) : float3
    + {static} srdnoise(pos:float2) : float3
    + {static} srnoise(pos:float2, rot:float) : float
    + {static} srnoise(pos:float2) : float
}
class CallbacksDelegator {
    + CallbacksDelegator(callbacksProvider:Func<ICallbacks[]>, adaptorFactory:ITestAdaptorFactory)
    + RunStarted(testsToRun:ITest) : void
    + RunStartedRemotely(testsToRunData:byte[]) : void
    + RunFinished(testResults:ITestResult) : void
    + RunFinishedRemotely(testResultsData:byte[]) : void
    + RunFailed(failureMessage:string) : void
    + TestStarted(test:ITest) : void
    + TestStartedRemotely(testStartedData:byte[]) : void
    + TestFinished(result:ITestResult) : void
    + TestFinishedRemotely(testResultsData:byte[]) : void
    + TestTreeRebuild(test:ITest) : void
}
ICallbacksDelegator <|-- CallbacksDelegator
CallbacksDelegator --> "instance" CallbacksDelegator
class CallbacksDelegatorListener {
    + RunStarted(testsToRun:NUnit.Framework.Interfaces.ITest) : void
    + RunFinished(testResults:NUnit.Framework.Interfaces.ITestResult) : void
    + TestStarted(test:NUnit.Framework.Interfaces.ITest) : void
    + TestFinished(result:NUnit.Framework.Interfaces.ITestResult) : void
}
ScriptableObject <|-- CallbacksDelegatorListener
ITestRunnerListener <|-- CallbacksDelegatorListener
class CallbacksHolder {
    + Add(callback:ICallbacks, priority:int) : void
    + Remove(callback:ICallbacks) : void
    + GetAll() : ICallbacks[]
    + Clear() : void
    + TemporarilySuppressCallbacks() : IDisposable
}
class "ScriptableSingleton`1"<T> {
}
class CallbackWithPriority <<struct>> {
    + Priority : int
    + CallbackWithPriority(callback:ICallbacks, priority:int)
}
class Suppressor <<sealed>> {
    + Suppressor(instance:CallbacksHolder)
    + Dispose() : void
}
"ScriptableSingleton`1" "<CallbacksHolder>" <|-- CallbacksHolder
ICallbacksHolder <|-- CallbacksHolder
CallbacksHolder +-- CallbackWithPriority
CallbackWithPriority --> "Callback" ICallbacks
CallbacksHolder +-- Suppressor
IDisposable <|-- Suppressor
class ExecutionSettings {
    + ExecutionSettings(filtersToExecute:Filter[])
    <<internal>> targetPlatform : BuildTarget?
    + runSynchronously : bool
    + playerHeartbeatTimeout : int
    <<internal>> EditModeIncluded() : bool
    <<internal>> PlayModeInEditorIncluded() : bool
    <<internal>> PlayerIncluded() : bool
    <<internal>> BuildNUnitFilter() : ITestFilter
}
ExecutionSettings --> "overloadTestRunSettings" ITestRunSettings
ExecutionSettings --> "filter" Filter
class Filter {
    + targetPlatform : BuildTarget?
    <<internal>> ToRuntimeTestRunnerFilter(synchronousOnly:bool) : RuntimeTestRunnerFilter
}
Filter --> "testMode" TestMode
interface ICallbacks {
    RunStarted(testsToRun:ITestAdaptor) : void
    RunFinished(result:ITestResultAdaptor) : void
    TestStarted(test:ITestAdaptor) : void
    TestFinished(result:ITestResultAdaptor) : void
}
interface ICallbacksDelegator {
    RunStarted(testsToRun:ITest) : void
    RunStartedRemotely(testsToRunData:byte[]) : void
    RunFinished(testResults:ITestResult) : void
    RunFinishedRemotely(testResultsData:byte[]) : void
    RunFailed(failureMessage:string) : void
    TestStarted(test:ITest) : void
    TestStartedRemotely(testStartedData:byte[]) : void
    TestFinished(result:ITestResult) : void
    TestFinishedRemotely(testResultsData:byte[]) : void
    TestTreeRebuild(test:ITest) : void
}
interface ICallbacksHolder {
    Add(callback:ICallbacks, priority:int) : void
    Remove(callback:ICallbacks) : void
    GetAll() : ICallbacks[]
    Clear() : void
}
interface IErrorCallbacks {
    OnError(message:string) : void
}
ICallbacks <|-- IErrorCallbacks
interface ITestAdaptor {
    Id : string <<get>>
    Name : string <<get>>
    FullName : string <<get>>
    TestCaseCount : int <<get>>
    HasChildren : bool <<get>>
    IsSuite : bool <<get>>
    TestCaseTimeout : int <<get>>
    IsTestAssembly : bool <<get>>
    Description : string <<get>>
    SkipReason : string <<get>>
    ParentId : string <<get>>
    ParentFullName : string <<get>>
    UniqueName : string <<get>>
    ParentUniqueName : string <<get>>
    ChildIndex : int <<get>>
}
class "IEnumerable`1"<T> {
}
ITestAdaptor --> "Children<ITestAdaptor>" "IEnumerable`1"
ITestAdaptor --> "Parent" ITestAdaptor
ITestAdaptor --> "TypeInfo" ITypeInfo
ITestAdaptor --> "Method" IMethodInfo
ITestAdaptor --> "RunState" RunState
ITestAdaptor --> "TestMode" TestMode
interface ITestAdaptorFactory {
    Create(test:ITest) : ITestAdaptor
    Create(testData:RemoteTestData) : ITestAdaptor
    Create(testResult:ITestResult) : ITestResultAdaptor
    Create(testResult:RemoteTestResultData, allData:RemoteTestResultDataWithTestData) : ITestResultAdaptor
    BuildTree(data:RemoteTestResultDataWithTestData) : ITestAdaptor
    BuildTreeAsync(data:RemoteTestResultDataWithTestData) : IEnumerator<ITestAdaptor>
    ClearResultsCache() : void
    ClearTestsCache() : void
}
interface ITestResultAdaptor {
    Name : string <<get>>
    FullName : string <<get>>
    ResultState : string <<get>>
    Duration : double <<get>>
    Message : string <<get>>
    StackTrace : string <<get>>
    AssertCount : int <<get>>
    FailCount : int <<get>>
    PassCount : int <<get>>
    SkipCount : int <<get>>
    InconclusiveCount : int <<get>>
    HasChildren : bool <<get>>
    Output : string <<get>>
    ToXml() : TNode
}
class "IEnumerable`1"<T> {
}
ITestResultAdaptor --> "Test" ITestAdaptor
ITestResultAdaptor --> "TestStatus" TestStatus
ITestResultAdaptor --> "StartTime" DateTime
ITestResultAdaptor --> "EndTime" DateTime
ITestResultAdaptor --> "Children<ITestResultAdaptor>" "IEnumerable`1"
interface ITestRunnerApi {
    Execute(executionSettings:ExecutionSettings) : string
    RegisterCallbacks(testCallbacks:T, priority:int) : void
    UnregisterCallbacks(testCallbacks:T) : void
    RetrieveTestList(testMode:TestMode, callback:Action<ITestAdaptor>) : void
}
interface ITestRunSettings {
    Apply() : void
}
IDisposable <|-- ITestRunSettings
interface ITestTreeRebuildCallbacks {
    TestTreeRebuild(test:ITestAdaptor) : void
}
ICallbacks <|-- ITestTreeRebuildCallbacks
enum RunState {
    NotRunnable,
    Runnable,
    Explicit,
    Skipped,
    Ignored,
}
class TestAdaptor {
    <<internal>> TestAdaptor(test:ITest, children:ITestAdaptor[])
    + SetParent(parent:ITestAdaptor) : void
    <<internal>> TestAdaptor(test:RemoteTestData)
    <<internal>> ApplyChildren(allTests:IEnumerable<TestAdaptor>) : void
    + Id : string <<get>>
    + Name : string <<get>>
    + FullName : string <<get>>
    + TestCaseCount : int <<get>>
    + HasChildren : bool <<get>>
    + IsSuite : bool <<get>>
    + TestCaseTimeout : int <<get>>
    + IsTestAssembly : bool <<get>>
    + Description : string <<get>>
    + SkipReason : string <<get>>
    + ParentId : string <<get>>
    + ParentFullName : string <<get>>
    + UniqueName : string <<get>>
    + ParentUniqueName : string <<get>>
    + ChildIndex : int <<get>>
}
class "IEnumerable`1"<T> {
}
ITestAdaptor <|-- TestAdaptor
TestAdaptor --> "Children<ITestAdaptor>" "IEnumerable`1"
TestAdaptor --> "Parent" ITestAdaptor
TestAdaptor --> "TypeInfo" ITypeInfo
TestAdaptor --> "Method" IMethodInfo
TestAdaptor --> "RunState" RunState
TestAdaptor --> "TestMode" TestMode
class TestAdaptorFactory {
    + Create(test:ITest) : ITestAdaptor
    + Create(testData:RemoteTestData) : ITestAdaptor
    + Create(testResult:ITestResult) : ITestResultAdaptor
    + Create(testResult:RemoteTestResultData, allData:RemoteTestResultDataWithTestData) : ITestResultAdaptor
    + BuildTree(data:RemoteTestResultDataWithTestData) : ITestAdaptor
    + BuildTreeAsync(data:RemoteTestResultDataWithTestData) : IEnumerator<ITestAdaptor>
    + ClearResultsCache() : void
    + ClearTestsCache() : void
}
ITestAdaptorFactory <|-- TestAdaptorFactory
enum TestMode {
    EditMode= 1 << 0,
    PlayMode= 1 << 1,
}
class TestResultAdaptor {
    <<internal>> TestResultAdaptor(result:ITestResult, test:ITestAdaptor, children:ITestResultAdaptor[])
    <<internal>> TestResultAdaptor(result:RemoteTestResultData, allData:RemoteTestResultDataWithTestData)
    + Name : string <<get>>
    + FullName : string <<get>>
    + ResultState : string <<get>>
    + Duration : double <<get>>
    + Message : string <<get>>
    + StackTrace : string <<get>>
    + AssertCount : int <<get>>
    + FailCount : int <<get>>
    + PassCount : int <<get>>
    + SkipCount : int <<get>>
    + InconclusiveCount : int <<get>>
    + HasChildren : bool <<get>>
    + Output : string <<get>>
    + ToXml() : TNode
}
class "IEnumerable`1"<T> {
}
ITestResultAdaptor <|-- TestResultAdaptor
TestResultAdaptor --> "Test" ITestAdaptor
TestResultAdaptor --> "TestStatus" TestStatus
TestResultAdaptor --> "StartTime" DateTime
TestResultAdaptor --> "EndTime" DateTime
TestResultAdaptor --> "Children<ITestResultAdaptor>" "IEnumerable`1"
class TestRunnerApi {
    + Execute(executionSettings:ExecutionSettings) : string
    + RegisterCallbacks(testCallbacks:T, priority:int) : void
    + UnregisterCallbacks(testCallbacks:T) : void
    <<internal>> RetrieveTestList(executionSettings:ExecutionSettings, callback:Action<ITestAdaptor>) : void
    + RetrieveTestList(testMode:TestMode, callback:Action<ITestAdaptor>) : void
    <<internal>> {static} IsRunActive() : bool
}
class "Func`2"<T1,T2> {
}
ScriptableObject <|-- TestRunnerApi
ITestRunnerApi <|-- TestRunnerApi
TestRunnerApi --> "callbacksHolder" ICallbacksHolder
TestRunnerApi o-> "ScheduleJob<ExecutionSettings,string>" "Func`2"
enum TestStatus {
    Inconclusive,
    Skipped,
    Passed,
    Failed,
}
class CommandLineOption {
    + CommandLineOption(argName:string, action:Action)
    + CommandLineOption(argName:string, action:Action<string>)
    + CommandLineOption(argName:string, action:Action<string[]>)
    + ArgName : string <<get>>
    + ApplyValue(value:string) : void
    {static} SplitStringToArray(value:string) : string[]
}
class "Action`1"<T> {
}
ICommandLineOption <|-- CommandLineOption
CommandLineOption --> "m_ArgAction<string>" "Action`1"
class CommandLineOptionSet {
    + CommandLineOptionSet(options:ICommandLineOption[])
    + Parse(args:string[]) : void
}
interface ICommandLineOption {
    ArgName : string <<get>>
    ApplyValue(value:string) : void
}
class Executer {
    + Executer(testRunnerApi:ITestRunnerApi, settingsBuilder:ISettingsBuilder, logErrorFormat:Action<string, object[]>, logException:Action<Exception>, exitEditorApplication:Action<int>, scriptCompilationFailedCheck:Func<bool>)
    <<internal>> InitializeAndExecuteRun(commandLineArgs:string[]) : void
    <<internal>> BuildExecutionSettings(commandLineArgs:string[]) : ExecutionSettings
    <<internal>> SetUpCallbacks(executionSettings:ExecutionSettings) : void
    <<internal>> ExitOnCompileErrors() : void
    HandleSetupException(exception:SetupException) : void
}
enum ReturnCodes {
    Ok= 0,
    Failed= 2,
    RunError= 3,
    PlatformNotFoundReturnCode= 4,
}
class ExceptionHandling {
    <<internal>> m_Message : string
    <<internal>> m_ReturnCode : int
    + ExceptionHandling(exceptionType:SetupException.ExceptionType, message:string, returnCode:ReturnCodes)
}
Executer +-- ReturnCodes
Executer +-- ExceptionHandling
class ExecutionSettings {
    + TestResultsFile : string
    + DeviceLogsDirectory : string
}
class ExitCallbacks {
    <<internal>> {static} preventExit : bool
    + RunFinished(testResults:ITestResultAdaptor) : void
    + TestStarted(test:ITestAdaptor) : void
    + TestFinished(result:ITestResultAdaptor) : void
    + RunStarted(testsToRun:ITestAdaptor) : void
    + OnError(message:string) : void
}
ScriptableObject <|-- ExitCallbacks
IErrorCallbacks <|-- ExitCallbacks
interface ISettingsBuilder {
    BuildApiExecutionSettings(commandLineArgs:string[]) : Api.ExecutionSettings
    BuildExecutionSettings(commandLineArgs:string[]) : ExecutionSettings
}
class LogSavingCallbacks {
    + RunStarted(testsToRun:ITestAdaptor) : void
    + <<virtual>> RunFinished(testResults:ITestResultAdaptor) : void
    + TestStarted(test:ITestAdaptor) : void
    + TestFinished(result:ITestResultAdaptor) : void
}
ScriptableObject <|-- LogSavingCallbacks
ICallbacks <|-- LogSavingCallbacks
class LogWriter {
    <<internal>> LogWriter(logsDirectory:string, deviceID:string, logger:DeploymentTargetLogger)
    + Stop() : void
    + Dispose() : void
}
IDisposable <|-- LogWriter
class ResultsSavingCallbacks {
    + m_ResultFilePath : string
    + ResultsSavingCallbacks()
    + RunStarted(testsToRun:ITestAdaptor) : void
    + <<virtual>> RunFinished(testResults:ITestResultAdaptor) : void
    + TestStarted(test:ITestAdaptor) : void
    + TestFinished(result:ITestResultAdaptor) : void
}
ScriptableObject <|-- ResultsSavingCallbacks
ICallbacks <|-- ResultsSavingCallbacks
class ResultsWriter {
    + WriteResultToFile(result:ITestResultAdaptor, filePath:string) : void
    CreateDirectory(filePath:string) : void
    + WriteResultToStream(result:ITestResultAdaptor, streamWriter:StreamWriter, settings:XmlWriterSettings) : void
    WriteResultsToXml(result:ITestResultAdaptor, xmlWriter:XmlWriter) : void
}
class RunData {
    + isRunning : bool
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<RunData>" <|-- RunData
RunData --> "executionSettings" ExecutionSettings
class RunSettings {
    + RunSettings(testSettings:ITestSettings)
    + Apply() : void
    + Dispose() : void
}
ITestRunSettings <|-- RunSettings
class SettingsBuilder {
    + SettingsBuilder(testSettingsDeserializer:ITestSettingsDeserializer, logAction:Action<string>, logWarningAction:Action<string>, fileExistsCheck:Func<string, bool>, scriptCompilationFailedCheck:Func<bool>)
    + BuildApiExecutionSettings(commandLineArgs:string[]) : Api.ExecutionSettings
    + BuildExecutionSettings(commandLineArgs:string[]) : ExecutionSettings
    DisplayQuitWarningIfQuitIsGiven(quitIsGiven:bool) : void
    CheckForScriptCompilationErrors() : void
    LogParametersForRun(testPlatform:string, testFilters:string[], testCategories:string[], testSettingsFilePath:string) : void
    GetTestSettings(testSettingsFilePath:string) : ITestSettings
    {static} SetFilterAndGetBuildTarget(testPlatform:string, filter:Filter) : BuildTarget?
}
ISettingsBuilder <|-- SettingsBuilder
class SetupException {
    + SetupException(type:ExceptionType, details:object[])
}
enum ExceptionType {
    ScriptCompilationFailed,
    PlatformNotFound,
    TestSettingsFileNotFound,
}
Exception <|-- SetupException
SetupException --> "Type" ExceptionType
SetupException +-- ExceptionType
class TestStarter <<static>> {
    {static} TestStarter()
    {static} UpdateWatch() : void
    {static} ShouldRunTests() : bool
}
TestStarter --> "s_Executer" Executer
TestStarter --> "executer" Executer
class AssetsDatabaseHelper {
    + OpenAssetInItsDefaultExternalEditor(assetPath:string, line:int) : void
}
IAssetsDatabaseHelper <|-- AssetsDatabaseHelper
class GuiHelper {
    + GuiHelper(monoCecilHelper:IMonoCecilHelper, assetsDatabaseHelper:IAssetsDatabaseHelper)
    + OpenScriptInExternalEditor(type:Type, method:MethodInfo) : void
    + GetFileOpenInfo(type:Type, method:MethodInfo) : IFileOpenInfo
    + FilePathToAssetsRelativeAndUnified(filePath:string) : string
    + OpenScriptInExternalEditor(stacktrace:string) : bool
}
IGuiHelper <|-- GuiHelper
GuiHelper --> "AssetsDatabaseHelper" IAssetsDatabaseHelper
interface IAssetsDatabaseHelper {
    OpenAssetInItsDefaultExternalEditor(assetPath:string, line:int) : void
}
interface IGuiHelper {
    OpenScriptInExternalEditor(stacktrace:string) : bool
    OpenScriptInExternalEditor(type:Type, method:MethodInfo) : void
    GetFileOpenInfo(type:Type, method:MethodInfo) : IFileOpenInfo
    FilePathToAssetsRelativeAndUnified(filePath:string) : string
}
class TestListGUIHelper {
    + {static} MenuItemAddFolderAndAsmDefForTesting() : void
    + {static} MenuItemAddFolderAndAsmDefForTestingWithValidation() : bool
    + {static} AddFolderAndAsmDefForTesting(isEditorOnly:bool) : void
    + {static} SelectedFolderContainsTestAssembly() : bool
    + {static} AddTest() : void
    + {static} CanAddScriptAndItWillCompile() : bool
    + {static} CanAddEditModeTestScriptAndItWillCompile() : bool
    + {static} CanAddPlayModeTestScriptAndItWillCompile() : bool
    + {static} GetActiveFolderPath() : string
}
class TestRunnerResult {
    + id : string
    + uniqueId : string
    + name : string
    + fullName : string
    + duration : float
    + messages : string
    + output : string
    + stacktrace : string
    + notRunnable : bool
    + ignoredOrSkipped : bool
    + description : string
    + isSuite : bool
    + parentId : string
    + parentUniqueId : string
    + notOutdated : bool
    <<internal>> TestRunnerResult(test:ITestAdaptor)
    <<internal>> TestRunnerResult(testResult:ITestResultAdaptor)
    + Update(result:TestRunnerResult) : void
    + SetResultChangedCallback(resultUpdated:Action<TestRunnerResult>) : void
    + <<override>> ToString() : string
    + Id : string <<get>>
    + FullName : string <<get>>
    + ParentId : string <<get>>
    + IsSuite : bool <<get>>
    + Clear() : void
}
class "List`1"<T> {
}
enum ResultStatus {
    NotRun,
    Passed,
    Failed,
    Inconclusive,
    Skipped,
}
TestRunnerResult o-> "resultStatus" ResultStatus
TestRunnerResult --> "categories<string>" "List`1"
TestRunnerResult --> "Categories<string>" "List`1"
TestRunnerResult +-- ResultStatus
class TestRunnerUIFilter {
    + PassedCount : int <<get>>
    + FailedCount : int <<get>>
    + NotRunCount : int <<get>>
    + PassedHidden : bool
    + FailedHidden : bool
    + NotRunHidden : bool
    + IsFiltering : bool <<get>>
    + UpdateCounters(resultList:List<TestRunnerResult>) : void
    + Draw() : void
    + Clear() : void
}
class "Action`1"<T> {
}
TestRunnerUIFilter --> "RebuildTestList" Action
TestRunnerUIFilter --> "SearchStringChanged<string>" "Action`1"
TestRunnerUIFilter --> "SearchStringCleared" Action
class UITestRunnerFilter {
    + testRepetitions : int = 1
    + synchronousOnly : bool = false
    + {static} AssemblyNameFromPath(path:string) : string
    + ClearResults(newResultList:List<IClearableResult>) : void
}
interface IClearableResult {
    Id : string <<get>>
    FullName : string <<get>>
    ParentId : string <<get>>
    IsSuite : bool <<get>>
    Clear() : void
}
class "List`1"<T> {
}
UITestRunnerFilter +-- IClearableResult
IClearableResult --> "Categories<string>" "List`1"
class TestRunnerStateSerializer {
    + ShouldRestore() : bool
    + SaveContext() : void
    + RestoreContext() : void
    + CanRestoreFromScriptableObject(requestedType:Type) : bool
    + RestoreScriptableObjectInstance() : ScriptableObject
    + CanRestoreFromJson(requestedType:Type) : bool
    + RestoreClassFromJson(instance:object) : void
}
IStateSerializer <|-- TestRunnerStateSerializer
abstract class AttributeFinderBase {
    + {abstract} Search(tests:ITest, filter:ITestFilter, testTargetPlatform:RuntimePlatform) : IEnumerable<Type>
}
interface IAttributeFinder {
    Search(tests:ITest, filter:ITestFilter, testTargetPlatform:RuntimePlatform) : IEnumerable<Type>
}
abstract class "AttributeFinderBase`2"<T1,T2> {
    + <<override>> Search(tests:ITest, filter:ITestFilter, testTargetPlatform:RuntimePlatform) : IEnumerable<Type>
}
IAttributeFinder <|-- AttributeFinderBase
AttributeFinderBase <|-- "AttributeFinderBase`2"
class DelayedCallback {
    + DelayedCallback(function:System.Action, timeFromNow:double)
    + Clear() : void
    + Reset() : void
}
class EditModeLauncher {
    + {static} IsRunning : bool
    + launchedOutsideApi : bool
    + EditModeLauncher(filter:UITestRunnerFilter, platform:TestPlatform)
    + EditModeLauncher(filters:Filter[], platform:TestPlatform, runSynchronously:bool)
    + <<override>> Run() : void
    + AddEventHandler() : T
}
class BackgroundListener {
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
}
TestLauncherBase <|-- EditModeLauncher
EditModeLauncher --> "m_EditModeRunner" EditModeRunner
EditModeLauncher +-- BackgroundListener
ScriptableObject <|-- BackgroundListener
ITestRunnerListener <|-- BackgroundListener
class EditModeLauncherContextSettings {
    + EditModeLauncherContextSettings()
    + Dispose() : void
}
IDisposable <|-- EditModeLauncherContextSettings
class TestLaunchFailedException {
    + TestLaunchFailedException()
    + TestLaunchFailedException(message:string)
}
class PlayerLauncher {
    + PlayerLauncher(settings:PlaymodeTestsControllerSettings, targetPlatform:BuildTarget?, overloadTestRunSettings:ITestRunSettings, heartbeatTimeout:int)
    + <<override>> Run() : void
    + PrepareScene(sceneName:string) : Scene
    <<internal>> GetBuildOptions(scenePath:string) : PlayerLauncherBuildOptions
}
Exception <|-- TestLaunchFailedException
RuntimeTestLauncherBase <|-- PlayerLauncher
class PlayerLauncherBuildOptions {
    + PlayerDirectory : string
    + <<override>> ToString() : string
}
PlayerLauncherBuildOptions --> "BuildPlayerOptions" BuildPlayerOptions
class PlayerLauncherContextSettings {
    + PlayerLauncherContextSettings(overloadSettings:ITestRunSettings)
    + Dispose() : void
}
IDisposable <|-- PlayerLauncherContextSettings
class PlayerLauncherTestRunSettings {
    + buildOnly : bool <<set>> <<get>>
    + buildOnlyLocationPath : string <<set>> <<get>>
    + Dispose() : void
    Apply() : void
}
ITestRunSettings <|-- PlayerLauncherTestRunSettings
class PlaymodeLauncher {
    + {static} IsRunning : bool
    + PlaymodeLauncher(settings:PlaymodeTestsControllerSettings)
    + <<override>> Run() : void
    + UpdateCallback() : void
    + AddEventHandler() : void
}
class BackgroundWatcher {
    {static} BackgroundWatcher()
}
RuntimeTestLauncherBase <|-- PlaymodeLauncher
PlaymodeLauncher +-- BackgroundWatcher
class PostbuildCleanupAttributeFinder {
    + PostbuildCleanupAttributeFinder()
}
class "AttributeFinderBase`2"<T1,T2> {
}
"AttributeFinderBase`2" "<IPostBuildCleanup,PostBuildCleanupAttribute>" <|-- PostbuildCleanupAttributeFinder
class PrebuildSetupAttributeFinder {
    + PrebuildSetupAttributeFinder()
}
class "AttributeFinderBase`2"<T1,T2> {
}
"AttributeFinderBase`2" "<IPrebuildSetup,PrebuildSetupAttribute>" <|-- PrebuildSetupAttributeFinder
class RemotePlayerLogController {
    + SetBuildTarget(buildTarget:BuildTarget) : void
    + SetLogsDirectory(dir:string) : void
    + StartLogWriters() : void
    + StopLogWriters() : void
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<RemotePlayerLogController>" <|-- RemotePlayerLogController
class RemoteTestRunController {
    <<internal>> <<const>> k_HeartbeatTimeout : int
    + Init(buildTarget:BuildTarget, heartbeatTimeout:int) : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<RemoteTestRunController>" <|-- RemoteTestRunController
class RemoteTestResultReciever {
    + RunStarted(messageEventArgs:MessageEventArgs) : void
    + RunFinished(messageEventArgs:MessageEventArgs) : void
}
abstract class RuntimeTestLauncherBase {
    + CreateSceneName() : string
}
class PlaymodeTestsControllerExtensions <<static>> {
    <<internal>> {static} AddEventHandlerMonoBehaviour(controller:PlaymodeTestsController) : T
    <<internal>> {static} AddEventHandlerScriptableObject(controller:PlaymodeTestsController) : T
    <<internal>> {static} AddEventHandlerScriptableObject(controller:PlaymodeTestsController, obj:ITestRunnerListener) : void
}
TestLauncherBase <|-- RuntimeTestLauncherBase
abstract class TestLauncherBase {
    + {abstract} Run() : void
    + ExecutePostBuildCleanupMethods(tests:ITest, testRunnerFilter:ITestFilter) : void
    + {static} ExecutePostBuildCleanupMethods(tests:ITest, testRunnerFilter:ITestFilter, testTargetPlatform:RuntimePlatform?) : void
}
class TestJobData {
    + guid : string
    + taskIndex : int
    + taskPC : int
    + isRunning : bool
    + undoGroup : int
    + isHandledByRunner : bool
    + TestJobData(settings:ExecutionSettings)
}
TestJobData --> "executionSettings" ExecutionSettings
TestJobData --> "editModeRunner" EditModeRunner
TestJobData --> "testTree" ITest
class TestJobDataHolder {
}
class "ScriptableSingleton`1"<T> {
}
class "List`1"<T> {
}
"ScriptableSingleton`1" "<TestJobDataHolder>" <|-- TestJobDataHolder
TestJobDataHolder o-> "TestRuns<TestJobData>" "List`1"
class TestJobRunner {
    + RunJob(data:TestJobData) : string
}
class "List`1"<T> {
}
class "Action`1"<T> {
}
class "Func`2"<T1,T2> {
}
TestJobRunner o-> "SavedTestJobData<TestJobData>" "List`1"
TestJobRunner o-> "SubscribeCallback<EditorApplication.CallbackFunction>" "Action`1"
TestJobRunner o-> "UnsubscribeCallback<EditorApplication.CallbackFunction>" "Action`1"
TestJobRunner o-> "PcHelper" TestCommandPcHelper
TestJobRunner o-> "GetTasks<ExecutionSettings,IEnumerable<TestTaskBase>>" "Func`2"
TestJobRunner o-> "LogException<Exception>" "Action`1"
TestJobRunner o-> "LogError<string>" "Action`1"
TestJobRunner o-> "ReportRunFailed<string>" "Action`1"
class TestRunCanceledException {
}
Exception <|-- TestRunCanceledException
class EditModePcHelper {
    + <<override>> SetEnumeratorPC(enumerator:IEnumerator, pc:int) : void
    + <<override>> GetEnumeratorPC(enumerator:IEnumerator) : int
}
TestCommandPcHelper <|-- EditModePcHelper
interface IUnityTestAssemblyRunnerFactory {
    Create(testPlatform:TestPlatform, factory:WorkItemFactory) : IUnityTestAssemblyRunner
}
class UnityTestAssemblyRunnerFactory {
    + Create(testPlatform:TestPlatform, factory:WorkItemFactory) : IUnityTestAssemblyRunner
}
class EditModeRunner {
    + RunFinished : bool = false
    + RunningSynchronously : bool <<get>>
    + Init(filters:Filter[], platform:TestPlatform, runningSynchronously:bool) : void
    + OnEnable() : void
    + TestStartedEvent(test:ITest) : void
    + TestFinishedEvent(testResult:ITestResult) : void
    + Run() : void
    + CompleteSynchronously() : void
    + AddEventHandler() : T
    + Dispose() : void
    + OnRunCancel() : void
    + GetLoadedTests() : ITest
    + GetFilter() : ITestFilter
}
IUnityTestAssemblyRunnerFactory <|-- UnityTestAssemblyRunnerFactory
ScriptableObject <|-- EditModeRunner
IDisposable <|-- EditModeRunner
EditModeRunner --> "m_Runner" IUnityTestAssemblyRunner
EditModeRunner --> "UnityTestAssemblyRunnerFactory" IUnityTestAssemblyRunnerFactory
class EditmodeWorkItemFactory {
}
WorkItemFactory <|-- EditmodeWorkItemFactory
class EditorEnumeratorTestWorkItem {
    + EditorEnumeratorTestWorkItem(test:TestMethod, filter:ITestFilter)
}
UnityWorkItem <|-- EditorEnumeratorTestWorkItem
class EnumeratorStepHelper {
    + {static} SetEnumeratorPC(pc:int) : void
    + {static} GetEnumeratorPC(enumerator:IEnumerator) : int
    + {static} UpdateEnumeratorPcIfNeeded(enumerator:IEnumerator) : bool
}
interface ITestSettings {
    scriptingBackend : ScriptingImplementation? <<get>> <<set>>
    Architecture : string <<get>> <<set>>
    apiProfile : ApiCompatibilityLevel? <<get>> <<set>>
    appleEnableAutomaticSigning : bool? <<get>> <<set>>
    appleDeveloperTeamID : string <<get>> <<set>>
    iOSManualProvisioningProfileType : ProvisioningProfileType? <<get>> <<set>>
    iOSManualProvisioningProfileID : string <<get>> <<set>>
    tvOSManualProvisioningProfileType : ProvisioningProfileType? <<get>> <<set>>
    tvOSManualProvisioningProfileID : string <<get>> <<set>>
    SetupProjectParameters() : void
}
IDisposable <|-- ITestSettings
interface ITestSettingsDeserializer {
    GetSettingsFromJsonFile(jsonFilePath:string) : ITestSettings
}
class TestSettings {
    + scriptingBackend : ScriptingImplementation? <<get>> <<set>>
    + Architecture : string <<get>> <<set>>
    + apiProfile : ApiCompatibilityLevel? <<get>> <<set>>
    + appleEnableAutomaticSigning : bool? <<get>> <<set>>
    + appleDeveloperTeamID : string <<get>> <<set>>
    + iOSManualProvisioningProfileType : ProvisioningProfileType? <<get>> <<set>>
    + iOSManualProvisioningProfileID : string <<get>> <<set>>
    + tvOSManualProvisioningProfileType : ProvisioningProfileType? <<get>> <<set>>
    + tvOSManualProvisioningProfileID : string <<get>> <<set>>
    + Dispose() : void
    + SetupProjectParameters() : void
}
abstract class TestSetting {
    + {abstract} Setup(settings:TestSettings) : void
    + {abstract} Cleanup() : void
}
class "TestSetting`1"<T> {
    + TestSetting(getFromSettings:Func<TestSettings, T>, getCurrentValue:Func<T>, setValue:Action<T>)
    + <<override>> Setup(settings:TestSettings) : void
    + <<override>> Cleanup() : void
}
ITestSettings <|-- TestSettings
TestSettings +-- TestSetting
TestSettings +-- "TestSetting`1"
TestSetting <|-- "TestSetting`1"
class TestSettingsDeserializer {
    + TestSettingsDeserializer(testSettingsFactory:Func<ITestSettings>)
    + GetSettingsFromJsonFile(jsonFilePath:string) : ITestSettings
}
abstract class SettingsMap {
    + Key : string <<get>>
    + {abstract} ApplyToSettings(settings:ITestSettings, value:object) : void
}
class "SettingsMap`1"<T> {
    + SettingsMap(key:string, setter:Action<ITestSettings, T>)
    + <<override>> ApplyToSettings(settings:ITestSettings, value:object) : void
}
ITestSettingsDeserializer <|-- TestSettingsDeserializer
TestSettingsDeserializer +-- SettingsMap
SettingsMap --> "Type" Type
TestSettingsDeserializer +-- "SettingsMap`1"
SettingsMap <|-- "SettingsMap`1"
class AssemblyCompilationErrorsMessage {
    + assembly : string
    + AssemblyCompilationErrorsMessage()
}
Message <|-- AssemblyCompilationErrorsMessage
interface ITestRunnerApiMapper {
    GetRunStateFromResultNunitXml(result:ITestResultAdaptor) : string
    GetTestStateFromResult(result:ITestResultAdaptor) : TestState
    FlattenTestNames(testsToRun:ITestAdaptor) : List<string>
    MapTestToTestPlanMessage(testsToRun:ITestAdaptor) : TestPlanMessage
    MapTestToTestStartedMessage(test:ITestAdaptor) : TestStartedMessage
    TestResultToTestFinishedMessage(result:ITestResultAdaptor) : TestFinishedMessage
}
interface IUtpLogger {
    Log(msg:Message) : void
}
interface IUtpMessageReporter {
    ReportAssemblyCompilationErrors(assembly:string, errorCompilerMessages:IEnumerable<CompilerMessage>) : void
    ReportTestFinished(result:ITestResultAdaptor) : void
    ReportTestRunStarted(testsToRun:ITestAdaptor) : void
    ReportTestStarted(test:ITestAdaptor) : void
}
abstract class Message {
    + type : string
    + time : ulong
    + version : int
    + phase : string
    + processId : int
    + AddTimeStamp() : void
}
class TestFinishedMessage {
    + name : string
    + message : string
    + duration : ulong
    + durationMicroseconds : ulong
    + stackTrace : string
    + TestFinishedMessage()
}
Message <|-- TestFinishedMessage
TestFinishedMessage --> "state" TestState
class TestPlanMessage {
    + TestPlanMessage()
}
class "List`1"<T> {
}
Message <|-- TestPlanMessage
TestPlanMessage --> "tests<string>" "List`1"
class TestRunnerApiMapper {
    + MapTestToTestPlanMessage(testsToRun:ITestAdaptor) : TestPlanMessage
    + MapTestToTestStartedMessage(test:ITestAdaptor) : TestStartedMessage
    + TestResultToTestFinishedMessage(result:ITestResultAdaptor) : TestFinishedMessage
    + GetRunStateFromResultNunitXml(result:ITestResultAdaptor) : string
    + GetTestStateFromResult(result:ITestResultAdaptor) : TestState
    + FlattenTestNames(test:ITestAdaptor) : List<string>
}
ITestRunnerApiMapper <|-- TestRunnerApiMapper
class TestStartedMessage {
    + name : string
    + TestStartedMessage()
}
Message <|-- TestStartedMessage
TestStartedMessage --> "state" TestState
enum TestState {
    Inconclusive= 0,
    Skipped= 2,
    Ignored= 3,
    Success= 4,
    Failure= 5,
    Error= 6,
}
class UnityTestProtocolListener {
    + UnityTestProtocolListener()
    + RunStarted(testsToRun:ITestAdaptor) : void
    + RunFinished(testResults:ITestResultAdaptor) : void
    + TestStarted(test:ITestAdaptor) : void
    + TestFinished(result:ITestResultAdaptor) : void
}
ScriptableObject <|-- UnityTestProtocolListener
ICallbacks <|-- UnityTestProtocolListener
class UnityTestProtocolStarter <<static>> {
    {static} UnityTestProtocolStarter()
    + {static} OnAssemblyCompilationFinished(assembly:string, messages:CompilerMessage[]) : void
}
class UtpDebugLogger {
    + Log(msg:Message) : void
}
IUtpLogger <|-- UtpDebugLogger
class UtpMessageReporter {
    + UtpMessageReporter(utpLogger:IUtpLogger)
    + ReportAssemblyCompilationErrors(assembly:string, errorCompilerMessages:IEnumerable<CompilerMessage>) : void
    + ReportTestRunStarted(testsToRun:ITestAdaptor) : void
    + ReportTestStarted(test:ITestAdaptor) : void
    + ReportTestFinished(result:ITestResultAdaptor) : void
}
IUtpMessageReporter <|-- UtpMessageReporter
UtpMessageReporter --> "TestRunnerApiMapper" ITestRunnerApiMapper
UtpMessageReporter --> "Logger" IUtpLogger
class AllocatingGCMemoryConstraint {
    + <<override>> ApplyTo(obj:object) : ConstraintResult
    + <<override>> ApplyTo(del:ActualValueDelegate<TActual>) : ConstraintResult
    + <<override>> Description : string <<get>>
}
class AllocatingGCMemoryResult {
    + AllocatingGCMemoryResult(constraint:IConstraint, actualValue:object, diff:int)
    + <<override>> WriteMessageTo(writer:MessageWriter) : void
}
Constraint <|-- AllocatingGCMemoryConstraint
AllocatingGCMemoryConstraint +-- AllocatingGCMemoryResult
ConstraintResult <|-- AllocatingGCMemoryResult
class ConstraintExtensions <<static>> {
    + {static} AllocatingGCMemory(chain:ConstraintExpression) : AllocatingGCMemoryConstraint
}
class InvalidSignatureException {
    + InvalidSignatureException(message:string)
}
ResultStateException <|-- InvalidSignatureException
InvalidSignatureException --> "ResultState" ResultState
class Is {
    + {static} AllocatingGCMemory() : AllocatingGCMemoryConstraint
}
class LogAssert <<static>> {
    + {static} Expect(type:LogType, message:string) : void
    + {static} Expect(type:LogType, message:Regex) : void
    + {static} NoUnexpectedReceived() : void
    + {static} ignoreFailingMessages : bool <<get>> <<set>>
}
class UnexpectedLogMessageException {
    + UnexpectedLogMessageException(log:LogMatch)
    + <<override>> StackTrace : string <<get>>
}
ResultStateException <|-- UnexpectedLogMessageException
UnexpectedLogMessageException --> "LogEvent" LogMatch
UnexpectedLogMessageException --> "ResultState" ResultState
class UnhandledLogMessageException {
    + UnhandledLogMessageException(log:LogEvent)
    + <<override>> StackTrace : string <<get>>
}
ResultStateException <|-- UnhandledLogMessageException
UnhandledLogMessageException --> "LogEvent" LogEvent
UnhandledLogMessageException --> "ResultState" ResultState
class UnityTestTimeoutException {
    + UnityTestTimeoutException(timeout:int)
    + <<override>> StackTrace : string <<get>>
}
ResultStateException <|-- UnityTestTimeoutException
UnityTestTimeoutException --> "ResultState" ResultState
class ActionDelegator {
    + Delegate(action:Action) : object
    + Delegate(action:Func<object>) : object
    + HasAction() : bool
    + Execute(logScope:LogScope) : void
}
BaseDelegator <|-- ActionDelegator
abstract class BaseDelegator {
    + Abort() : void
}
class ConstructDelegator {
    + ConstructDelegator(stateSerializer:IStateSerializer)
    + Delegate(type:Type, arguments:object[]) : object
    + HasAction() : bool
    + Execute(logScope:LogScope) : void
    + DestroyCurrentTestObjectIfExists() : void
}
interface IAsyncTestAssemblyBuilder {
    BuildAsync(assemblies:Assembly[], testPlatforms:TestPlatform[], options:IDictionary<string, object>) : IEnumerator<ITest>
}
ITestAssemblyBuilder <|-- IAsyncTestAssemblyBuilder
interface IStateSerializer {
    RestoreScriptableObjectInstance() : ScriptableObject
    RestoreClassFromJson(instance:object) : void
    CanRestoreFromJson(requestedType:Type) : bool
    CanRestoreFromScriptableObject(requestedType:Type) : bool
}
class TestExtensions <<static>> {
    + {static} HasCategory(test:ITest, categoryFilter:string[]) : bool
    + {static} GetAllCategoriesFromTest(test:ITest) : List<string>
    + {static} ParseForNameDuplicates(test:ITest) : void
    + {static} GetChildIndex(test:ITest) : int
    + {static} HasChildIndex(test:ITest) : bool
    {static} GetAncestorPath(test:ITest) : string
    + {static} GetUniqueName(test:ITest) : string
    + {static} GetFullName(test:ITest) : string
    + {static} GetSkipReason(test:ITest) : string
    + {static} GetParentId(test:ITest) : string
    + {static} GetParentFullName(test:ITest) : string
    + {static} GetParentUniqueName(test:ITest) : string
}
class TestResultExtensions <<static>> {
    + {static} RecordPrefixedException(testResult:TestResult, prefix:string, ex:Exception, resultState:ResultState) : void
    + {static} RecordPrefixedError(testResult:TestResult, prefix:string, error:string, resultState:ResultState) : void
}
class UnityTestAssemblyBuilder {
    + UnityTestAssemblyBuilder()
    + Build(assemblies:Assembly[], testPlatforms:TestPlatform[], options:IDictionary<string, object>) : ITest
    + BuildAsync(assemblies:Assembly[], testPlatforms:TestPlatform[], options:IDictionary<string, object>) : IEnumerator<ITest>
    + {static} GetNUnitTestBuilderSettings(testPlatform:TestPlatform) : Dictionary<string, object>
}
DefaultTestAssemblyBuilder <|-- UnityTestAssemblyBuilder
IAsyncTestAssemblyBuilder <|-- UnityTestAssemblyBuilder
interface ITestRunnerListener {
    RunStarted(testsToRun:ITest) : void
    RunFinished(testResults:ITestResult) : void
    TestStarted(test:ITest) : void
    TestFinished(result:ITestResult) : void
}
class TestFinishedEvent {
}
class TestStartedEvent {
}
class RunFinishedEvent {
}
class RunStartedEvent {
}
class "UnityEvent`1"<T> {
}
"UnityEvent`1" "<ITestResult>" <|-- TestFinishedEvent
"UnityEvent`1" "<ITest>" <|-- TestStartedEvent
"UnityEvent`1" "<ITestResult>" <|-- RunFinishedEvent
"UnityEvent`1" "<ITest>" <|-- RunStartedEvent
class PlaymodeTestsController {
    <<internal>> <<const>> kPlaymodeTestControllerName : string = "Code-based tests runner"
    + Start() : IEnumerator
    <<internal>> {static} IsControllerOnScene() : bool
    <<internal>> {static} GetController() : PlaymodeTestsController
    + TestRunnerCoroutine() : IEnumerator
    + Run() : IEnumerator
    + Cleanup() : void
    + {static} TryCleanup() : void
}
class "List`1"<T> {
}
MonoBehaviour <|-- PlaymodeTestsController
PlaymodeTestsController --> "AssembliesWithTests<string>" "List`1"
PlaymodeTestsController o-> "testStartedEvent" TestStartedEvent
PlaymodeTestsController o-> "testFinishedEvent" TestFinishedEvent
PlaymodeTestsController o-> "runStartedEvent" RunStartedEvent
PlaymodeTestsController o-> "runFinishedEvent" RunFinishedEvent
PlaymodeTestsController o-> "settings" PlaymodeTestsControllerSettings
PlaymodeTestsController --> "m_Runner" UnityTestAssemblyRunner
class PlaymodeTestsControllerSettings {
    + sceneBased : bool
    + originalScene : string
    + bootstrapScene : string
    + {static} CreateRunnerSettings(filters:RuntimeTestRunnerFilter[]) : PlaymodeTestsControllerSettings
    <<internal>> BuildNUnitFilter() : ITestFilter
}
class RuntimeTestRunnerFilter {
    + synchronousOnly : bool = false
    + BuildNUnitFilter() : ITestFilter
}
class SynchronousFilter {
    + ToXml(recursive:bool) : TNode
    + AddToXml(parentNode:TNode, recursive:bool) : TNode
    + Pass(test:ITest) : bool
    + IsExplicitMatch(test:ITest) : bool
}
ITestFilter <|-- SynchronousFilter
class TestEnumeratorWrapper {
    + TestEnumeratorWrapper(testMethod:TestMethod)
    + GetEnumerator(context:ITestExecutionContext) : IEnumerator
}
class TestListenerWrapper {
    + TestListenerWrapper(testStartedEvent:TestStartedEvent, testFinishedEvent:TestFinishedEvent)
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
    + TestOutput(output:TestOutput) : void
}
ITestListener <|-- TestListenerWrapper
enum TestPlatform {
    All= 0xFF,
    EditMode= 1 << 1,
    PlayMode= 1 << 2,
}
class TestPlatformEnumExtensions <<static>> {
    + {static} IsFlagIncluded(flags:TestPlatform, flag:TestPlatform) : bool
}
class AttributeHelper <<static>> {
    <<internal>> {static} GetTargetClassFromName(targetClassName:string, attributeInterface:Type) : Type
}
class ColorEqualityComparer {
    + ColorEqualityComparer(error:float)
    + Equals(expected:Color, actual:Color) : bool
    + GetHashCode(color:Color) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Color>" <|-- ColorEqualityComparer
ColorEqualityComparer --> "Instance" ColorEqualityComparer
class CoroutineRunner {
    <<internal>> <<const>> k_DefaultTimeout : int
    + CoroutineRunner(playmodeTestsController:MonoBehaviour, context:UnityTestExecutionContext)
    + HandleEnumerableTest(testEnumerator:IEnumerator) : IEnumerator
    + HasFailedWithTimeout() : bool
    + GetDefaultTimeout() : int
}
class FloatEqualityComparer {
    + FloatEqualityComparer(allowedError:float)
    + Equals(expected:float, actual:float) : bool
    + GetHashCode(value:float) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<float>" <|-- FloatEqualityComparer
FloatEqualityComparer --> "Instance" FloatEqualityComparer
interface IOuterUnityTestAction {
    BeforeTest(test:ITest) : IEnumerator
    AfterTest(test:ITest) : IEnumerator
}
interface IPostBuildCleanup {
    Cleanup() : void
}
interface IPrebuildSetup {
    Setup() : void
}
interface ITestRunCallback {
    RunStarted(testsToRun:ITest) : void
    RunFinished(testResults:ITestResult) : void
    TestStarted(test:ITest) : void
    TestFinished(result:ITestResult) : void
}
class PostBuildCleanupAttribute {
    + PostBuildCleanupAttribute(targetClass:Type)
    + PostBuildCleanupAttribute(targetClassName:string)
}
Attribute <|-- PostBuildCleanupAttribute
PostBuildCleanupAttribute --> "TargetClass" Type
class PrebuildSetupAttribute {
    + PrebuildSetupAttribute(targetClass:Type)
    + PrebuildSetupAttribute(targetClassName:string)
}
Attribute <|-- PrebuildSetupAttribute
PrebuildSetupAttribute --> "TargetClass" Type
class QuaternionEqualityComparer {
    + QuaternionEqualityComparer(allowedError:float)
    + Equals(expected:Quaternion, actual:Quaternion) : bool
    + GetHashCode(quaternion:Quaternion) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Quaternion>" <|-- QuaternionEqualityComparer
QuaternionEqualityComparer --> "Instance" QuaternionEqualityComparer
class StackTraceFilter <<static>> {
    + {static} Filter(inputStackTrace:string) : string
}
class TestRunCallbackAttribute {
    + TestRunCallbackAttribute(type:Type)
    <<internal>> ConstructCallback() : ITestRunCallback
}
Attribute <|-- TestRunCallbackAttribute
class TestRunCallbackListener {
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
}
ScriptableObject <|-- TestRunCallbackListener
ITestRunnerListener <|-- TestRunCallbackListener
class Utils <<static>> {
    + {static} AreFloatsEqual(expected:float, actual:float, epsilon:float) : bool
    + {static} AreFloatsEqualAbsoluteError(expected:float, actual:float, allowedAbsoluteError:float) : bool
    + {static} CreatePrimitive(type:PrimitiveType) : GameObject
}
class Vector2ComparerWithEqualsOperator {
    + Equals(expected:Vector2, actual:Vector2) : bool
    + GetHashCode(vec2:Vector2) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector2>" <|-- Vector2ComparerWithEqualsOperator
Vector2ComparerWithEqualsOperator --> "Instance" Vector2ComparerWithEqualsOperator
class Vector2EqualityComparer {
    + Vector2EqualityComparer(error:float)
    + Equals(expected:Vector2, actual:Vector2) : bool
    + GetHashCode(vec2:Vector2) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector2>" <|-- Vector2EqualityComparer
Vector2EqualityComparer --> "Instance" Vector2EqualityComparer
class Vector3ComparerWithEqualsOperator {
    + Equals(expected:Vector3, actual:Vector3) : bool
    + GetHashCode(vec3:Vector3) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector3>" <|-- Vector3ComparerWithEqualsOperator
Vector3ComparerWithEqualsOperator --> "Instance" Vector3ComparerWithEqualsOperator
class Vector3EqualityComparer {
    + Vector3EqualityComparer(allowedError:float)
    + Equals(expected:Vector3, actual:Vector3) : bool
    + GetHashCode(vec3:Vector3) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector3>" <|-- Vector3EqualityComparer
Vector3EqualityComparer --> "Instance" Vector3EqualityComparer
class Vector4ComparerWithEqualsOperator {
    + Equals(expected:Vector4, actual:Vector4) : bool
    + GetHashCode(vec4:Vector4) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector4>" <|-- Vector4ComparerWithEqualsOperator
Vector4ComparerWithEqualsOperator --> "Instance" Vector4ComparerWithEqualsOperator
class Vector4EqualityComparer {
    + Vector4EqualityComparer(allowedError:float)
    + Equals(expected:Vector4, actual:Vector4) : bool
    + GetHashCode(vec4:Vector4) : int
}
class "IEqualityComparer`1"<T> {
}
"IEqualityComparer`1" "<Vector4>" <|-- Vector4EqualityComparer
Vector4EqualityComparer --> "Instance" Vector4EqualityComparer
class DropdownOptionListDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
}
PropertyDrawer <|-- DropdownOptionListDrawer
class GlyphMetricsPropertyDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
}
PropertyDrawer <|-- GlyphMetricsPropertyDrawer
class GlyphRectPropertyDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
}
PropertyDrawer <|-- GlyphRectPropertyDrawer
class TMP_ContextMenus {
    {static} CopyTexture(command:MenuCommand) : void
    {static} SelectMaterial(command:MenuCommand) : void
    {static} DuplicateMaterial(command:MenuCommand) : void
    {static} CopyMaterialProperties(command:MenuCommand) : void
    {static} PasteMaterialProperties(command:MenuCommand) : void
    {static} ResetSettings(command:MenuCommand) : void
    {static} CopyAtlas(command:MenuCommand) : void
    {static} PasteAtlas(command:MenuCommand) : void
    {static} ExtractAtlas(command:MenuCommand) : void
    {static} RegenerateFontAsset(command:MenuCommand) : void
    {static} ForceFontAssetUpgrade(command:MenuCommand) : void
    {static} ClearFontAssetData(command:MenuCommand) : void
    {static} CreateFontAsset(command:MenuCommand) : void
}
Editor <|-- TMP_ContextMenus
class TMPro_CreateObjectMenu <<static>> {
    {static} CreateTextMeshProObjectPerform(command:MenuCommand) : void
    {static} CreateTextMeshProGuiObjectPerform(menuCommand:MenuCommand) : void
    + {static} AddButton(menuCommand:MenuCommand) : void
    {static} AddTextMeshProInputField(menuCommand:MenuCommand) : void
    + {static} AddDropdown(menuCommand:MenuCommand) : void
    + {static} CreateNewUI() : GameObject
    + {static} GetOrCreateCanvasGameObject() : GameObject
    {static} IsValidCanvas(canvas:Canvas) : bool
}
class EditorShaderUtilities <<static>> {
    + {static} CopyMaterialProperties(source:Material, destination:Material) : void
}
class TMPro_FontAssetCreatorWindow {
    + {static} ShowFontAtlasCreatorWindow() : void
    + {static} ShowFontAtlasCreatorWindow(sourceFontFile:Font) : void
    + {static} ShowFontAtlasCreatorWindow(fontAsset:TMP_FontAsset) : void
    m_FontAssetCreationSettingsCurrentIndex : int = 0
    <<const>> k_FontAssetCreationSettingsContainerKey : string = "TextMeshPro.FontAssetCreator.RecentFontAssetCreationSettings.Container"
    <<const>> k_FontAssetCreationSettingsCurrentIndexKey : string = "TextMeshPro.FontAssetCreator.RecentFontAssetCreationSettings.CurrentIndex"
    <<const>> k_TwoColumnControlsWidth : float = 335f
    m_GlyphPackingGenerationTime : double
    m_GlyphRenderingGenerationTime : double
    m_PointSizeSamplingMode : int
    m_CharacterSetSelectionMode : int
    m_CharacterSequence : string = ""
    m_OutputFeedback : string = ""
    m_WarningMessage : string
    m_CharacterCount : int
    m_IsRepaintNeeded : bool
    m_AtlasGenerationProgress : float
    m_AtlasGenerationProgressLabel : string
    m_RenderingProgress : float
    m_IsGlyphPackingDone : bool
    m_IsGlyphRenderingDone : bool
    m_IsRenderingDone : bool
    m_IsProcessing : bool
    m_IsGenerationDisabled : bool
    m_IsGenerationCancelled : bool
    m_IsFontAtlasInvalid : bool
    m_PointSize : int
    m_Padding : int = 5
    m_AtlasWidth : int = 512
    m_AtlasHeight : int = 512
    m_IncludeFontFeatures : bool
    + OnEnable() : void
    + OnDisable() : void
    ON_RESOURCES_LOADED() : void
    CheckEssentialResources() : void
    + OnGUI() : void
    + Update() : void
    {static} ParseNumberSequence(sequence:string) : uint[]
    {static} ParseHexNumberSequence(sequence:string) : uint[]
    DrawControls() : void
    ClearGeneratedData() : void
    UpdateRenderFeedbackWindow() : void
    CreateFontAtlasTexture() : void
    SaveNewFontAsset(sourceObject:Object) : void
    SaveNewFontAssetWithSameName(sourceObject:Object) : void
    Save_Bitmap_FontAsset(filePath:string) : void
    Save_SDF_FontAsset(filePath:string) : void
    SaveFontCreationSettings() : FontAssetCreationSettings
    LoadFontCreationSettings(settings:FontAssetCreationSettings) : void
    SaveCreationSettingsToEditorPrefs(settings:FontAssetCreationSettings) : void
    DrawPreview() : void
    CheckForLegacyGlyphRenderMode() : void
    + GetKerningTable() : TMP_FontFeatureTable
}
class FontAssetCreationSettingsContainer {
}
enum FontPackingModes {
    Fast= 0,
    Optimum= 4,
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
EditorWindow <|-- TMPro_FontAssetCreatorWindow
TMPro_FontAssetCreatorWindow --> "m_FontAssetCreationSettingsContainer" FontAssetCreationSettingsContainer
TMPro_FontAssetCreatorWindow o-> "m_PackingMode" FontPackingModes
TMPro_FontAssetCreatorWindow --> "m_ScrollPosition" Vector2
TMPro_FontAssetCreatorWindow --> "m_OutputScrollPosition" Vector2
TMPro_FontAssetCreatorWindow --> "m_SourceFontFile" Object
TMPro_FontAssetCreatorWindow --> "m_SelectedFontAsset" TMP_FontAsset
TMPro_FontAssetCreatorWindow --> "m_LegacyFontAsset" TMP_FontAsset
TMPro_FontAssetCreatorWindow --> "m_ReferencedFontAsset" TMP_FontAsset
TMPro_FontAssetCreatorWindow --> "m_CharactersFromFile" TextAsset
TMPro_FontAssetCreatorWindow o-> "m_GlyphRenderMode" GlyphRenderMode
TMPro_FontAssetCreatorWindow --> "m_FontAtlasTexture" Texture2D
TMPro_FontAssetCreatorWindow --> "m_SavedFontAtlas" Texture2D
TMPro_FontAssetCreatorWindow o-> "m_FontGlyphTable<Glyph>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_FontCharacterTable<TMP_Character>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_CharacterLookupMap<uint,uint>" "Dictionary`2"
TMPro_FontAssetCreatorWindow o-> "m_GlyphLookupMap<uint,List<uint>>" "Dictionary`2"
TMPro_FontAssetCreatorWindow o-> "m_GlyphsToPack<Glyph>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_GlyphsPacked<Glyph>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_FreeGlyphRects<GlyphRect>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_UsedGlyphRects<GlyphRect>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_GlyphsToRender<Glyph>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_AvailableGlyphsToAdd<uint>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_MissingCharacters<uint>" "List`1"
TMPro_FontAssetCreatorWindow o-> "m_ExcludedCharacters<uint>" "List`1"
TMPro_FontAssetCreatorWindow +-- FontAssetCreationSettingsContainer
FontAssetCreationSettingsContainer --> "fontAssetCreationSettings<FontAssetCreationSettings>" "List`1"
TMPro_FontAssetCreatorWindow +-- FontPackingModes
class SortingLayerHelper <<static>> {
    {static} GetSortingLayerNames() : string[]
}
class TMPro_TextContainerEditor {
    OnEnable() : void
    OnDisable() : void
    + <<override>> OnInspectorGUI() : void
    GetAnchorPosition(index:int) : Vector2
}
Editor <|-- TMPro_TextContainerEditor
class TMPro_TexturePostProcessor {
    OnPostprocessTexture(texture:Texture2D) : void
}
class FontAssetPostProcessor {
}
AssetPostprocessor <|-- TMPro_TexturePostProcessor
AssetPostprocessor <|-- FontAssetPostProcessor
abstract class TMP_BaseEditorPanel {
    + selAlignGridA : int
    + selAlignGridB : int
    ON_TEXT_STYLE_CHANGED(isChanged:bool) : void
    + <<override>> OnInspectorGUI() : void
    + OnSceneGUI() : void
    DrawFont() : void
    DrawColor() : void
    DrawSpacing() : void
    DrawAlignment() : void
    DrawWrappingOverflow() : void
    DrawMarginField(position:Rect, label:string, value:float) : float
}
class "Dictionary`2"<T1,T2> {
}
class Foldout <<struct>> {
    + {static} extraSettings : bool = false
    + {static} materialInspector : bool = true
}
Editor <|-- TMP_BaseEditorPanel
TMP_BaseEditorPanel o-> "k_RtlToggleLabel" GUIContent
TMP_BaseEditorPanel o-> "k_FontAssetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_MaterialPresetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_StyleLabel" GUIContent
TMP_BaseEditorPanel o-> "k_AutoSizeLabel" GUIContent
TMP_BaseEditorPanel o-> "k_FontSizeLabel" GUIContent
TMP_BaseEditorPanel o-> "k_AutoSizeOptionsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_MinLabel" GUIContent
TMP_BaseEditorPanel o-> "k_MaxLabel" GUIContent
TMP_BaseEditorPanel o-> "k_WdLabel" GUIContent
TMP_BaseEditorPanel o-> "k_LineLabel" GUIContent
TMP_BaseEditorPanel o-> "k_FontStyleLabel" GUIContent
TMP_BaseEditorPanel o-> "k_BoldLabel" GUIContent
TMP_BaseEditorPanel o-> "k_ItalicLabel" GUIContent
TMP_BaseEditorPanel o-> "k_UnderlineLabel" GUIContent
TMP_BaseEditorPanel o-> "k_StrikethroughLabel" GUIContent
TMP_BaseEditorPanel o-> "k_LowercaseLabel" GUIContent
TMP_BaseEditorPanel o-> "k_UppercaseLabel" GUIContent
TMP_BaseEditorPanel o-> "k_SmallcapsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_ColorModeLabel" GUIContent
TMP_BaseEditorPanel o-> "k_BaseColorLabel" GUIContent
TMP_BaseEditorPanel o-> "k_ColorPresetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_ColorGradientLabel" GUIContent
TMP_BaseEditorPanel o-> "k_CorenerColorsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_OverrideTagsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_SpacingOptionsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_CharacterSpacingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_WordSpacingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_LineSpacingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_ParagraphSpacingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_AlignmentLabel" GUIContent
TMP_BaseEditorPanel o-> "k_WrapMixLabel" GUIContent
TMP_BaseEditorPanel o-> "k_WrappingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_OverflowLabel" GUIContent
TMP_BaseEditorPanel o-> "k_MarginsLabel" GUIContent
TMP_BaseEditorPanel o-> "k_GeometrySortingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_IsTextObjectScaleStatic" GUIContent
TMP_BaseEditorPanel o-> "k_RichTextLabel" GUIContent
TMP_BaseEditorPanel o-> "k_EscapeCharactersLabel" GUIContent
TMP_BaseEditorPanel o-> "k_VisibleDescenderLabel" GUIContent
TMP_BaseEditorPanel o-> "k_SpriteAssetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_StyleSheetAssetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_HorizontalMappingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_VerticalMappingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_LineOffsetLabel" GUIContent
TMP_BaseEditorPanel o-> "k_KerningLabel" GUIContent
TMP_BaseEditorPanel o-> "k_PaddingLabel" GUIContent
TMP_BaseEditorPanel o-> "k_LeftLabel" GUIContent
TMP_BaseEditorPanel o-> "k_TopLabel" GUIContent
TMP_BaseEditorPanel o-> "k_RightLabel" GUIContent
TMP_BaseEditorPanel o-> "k_BottomLabel" GUIContent
TMP_BaseEditorPanel o-> "k_AvailableStyles<int,TMP_Style>" "Dictionary`2"
TMP_BaseEditorPanel +-- Foldout
abstract class TMP_BaseShaderGUI {
    {static} s_UndoRedoCount : int
    {static} s_LastSeenUndoRedoCount : int
    {static} TMP_BaseShaderGUI()
    m_IsNewGUI : bool = true
    m_DragAndDropMinY : float
    PrepareGUI() : void
    + <<override>> OnGUI(materialEditor:MaterialEditor, properties:MaterialProperty[]) : void
    + EndPanel() : void
    BeginProperty(name:string) : MaterialProperty
    EndProperty() : bool
    DoTexture(name:string, label:string, type:System.Type, withTilingOffset:bool, speedNames:string[]) : void
    DoTilingOffset(rect:Rect, property:MaterialProperty) : void
    DoFloat(rect:Rect, name:string, label:string) : void
    DoDragAndDropBegin() : void
    DoDragAndDropEnd() : void
    PerformDrop(droppedMaterial:Material) : void
}
class ShaderFeature {
    + undoLabel : string
    m_State : int
    + Active : bool <<get>>
    + State : int <<get>>
    + ReadState(material:Material) : void
    + SetActive(active:bool, material:Material) : void
    + DoPopup(editor:MaterialEditor, material:Material) : void
    SetStateKeywords(material:Material) : void
}
ShaderGUI <|-- TMP_BaseShaderGUI
TMP_BaseShaderGUI o-> "s_TempLabel" GUIContent
TMP_BaseShaderGUI +-- ShaderFeature
ShaderFeature --> "label" GUIContent
class TMP_BitmapShaderGUI {
    {static} s_Face : bool = true
    DoFacePanel() : void
    DoDebugPanel() : void
}
TMP_BaseShaderGUI <|-- TMP_BitmapShaderGUI
class TMP_CharacterPropertyDrawer {
    m_GlyphSelectedForEditing : int
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    DrawGlyph(position:Rect, property:SerializedProperty) : void
}
PropertyDrawer <|-- TMP_CharacterPropertyDrawer
class TMP_ColorGradientAssetMenu <<static>> {
    + {static} CreateColorGradient(context:MenuCommand) : void
}
class TMP_ColorGradientEditor {
    OnEnable() : void
    + <<override>> OnInspectorGUI() : void
}
Editor <|-- TMP_ColorGradientEditor
TMP_ColorGradientEditor --> "m_ColorMode" SerializedProperty
TMP_ColorGradientEditor --> "m_TopLeftColor" SerializedProperty
TMP_ColorGradientEditor --> "m_TopRightColor" SerializedProperty
TMP_ColorGradientEditor --> "m_BottomLeftColor" SerializedProperty
TMP_ColorGradientEditor --> "m_BottomRightColor" SerializedProperty
class DropdownEditor {
    + <<override>> OnInspectorGUI() : void
}
SelectableEditor <|-- DropdownEditor
DropdownEditor --> "m_Template" SerializedProperty
DropdownEditor --> "m_CaptionText" SerializedProperty
DropdownEditor --> "m_CaptionImage" SerializedProperty
DropdownEditor --> "m_Placeholder" SerializedProperty
DropdownEditor --> "m_ItemText" SerializedProperty
DropdownEditor --> "m_ItemImage" SerializedProperty
DropdownEditor --> "m_OnSelectionChanged" SerializedProperty
DropdownEditor --> "m_Value" SerializedProperty
DropdownEditor --> "m_AlphaFadeSpeed" SerializedProperty
DropdownEditor --> "m_Options" SerializedProperty
class TMP_EditorCoroutine {
    TMP_EditorCoroutine(routine:IEnumerator)
    + {static} StartCoroutine(routine:IEnumerator) : TMP_EditorCoroutine
    Start() : void
    + Stop() : void
    EditorUpdate() : void
}
TMP_EditorCoroutine --> "coroutine" IEnumerator
class TMP_EditorPanel {
    IsPreset : bool
    UpdateTargetsSortingLayerID(sortingLayerID:int) : void
    UpdateTargetsSortingOrder(sortingOrder:int) : void
}
TMP_BaseEditorPanel <|-- TMP_EditorPanel
TMP_EditorPanel o-> "k_SortingLayerLabel" GUIContent
TMP_EditorPanel o-> "k_OrderInLayerLabel" GUIContent
TMP_EditorPanel o-> "k_OrthographicLabel" GUIContent
TMP_EditorPanel o-> "k_VolumetricLabel" GUIContent
TMP_EditorPanel --> "m_IsVolumetricTextProp" SerializedProperty
TMP_EditorPanel --> "m_IsOrthographicProp" SerializedProperty
TMP_EditorPanel --> "m_Renderer" Renderer
class TMP_EditorPanelUI {
}
TMP_BaseEditorPanel <|-- TMP_EditorPanelUI
TMP_EditorPanelUI o-> "k_RaycastTargetLabel" GUIContent
TMP_EditorPanelUI o-> "k_MaskableLabel" GUIContent
TMP_EditorPanelUI --> "m_RaycastTargetProp" SerializedProperty
class TMP_EditorUtility <<static>> {
    + {static} packageRelativePath : string <<get>>
    + {static} packageFullPath : string <<get>>
    + {static} RepaintAll() : void
    + {static} CreateAsset(name:string) : T
    + {static} FindMaterialReferences(fontAsset:TMP_FontAsset) : Material[]
    + {static} FindMatchingFontAsset(mat:Material) : TMP_FontAsset
    + {static} GetDecimalCharacterSequence(characterSet:int[]) : string
    + {static} GetUnicodeCharacterSequence(characterSet:int[]) : string
    + {static} DrawBox(rect:Rect, thickness:float, color:Color) : void
    + {static} GetHorizontalAlignmentGridValue(value:int) : int
    + {static} GetVerticalAlignmentGridValue(value:int) : int
    + {static} DrawColorProperty(rect:Rect, property:SerializedProperty) : void
    + {static} EditorToggle(position:Rect, value:bool, content:GUIContent, style:GUIStyle) : bool
}
class FontWeightDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
}
class TMP_FontAssetEditor {
    + OnEnable() : void
    + OnDisable() : void
    + <<override>> OnInspectorGUI() : void
    CleanFallbackFontAssetTable() : void
    SavedAtlasGenerationSettings() : void
    RestoreAtlasGenerationSettings() : void
    UpdateFontAssetCreationSettings() : void
    UpdateCharacterData(property:SerializedProperty, index:int) : void
    UpdateGlyphData(property:SerializedProperty, index:int) : void
    DisplayPageNavigation(currentPage:int, arraySize:int, itemsPerPage:int) : void
    AddNewGlyph(srcIndex:int, dstGlyphID:int) : bool
    RemoveGlyphFromList(index:int) : void
    AddNewCharacter(srcIndex:int, dstGlyphID:int) : bool
    RemoveCharacterFromList(index:int) : void
    GetValueRecord(property:SerializedProperty) : TMP_GlyphValueRecord
    RemoveAdjustmentPairFromList(index:int) : void
    CopyGlyphSerializedProperty(srcGlyph:SerializedProperty, dstGlyph:SerializedProperty) : void
    CopyCharacterSerializedProperty(source:SerializedProperty, target:SerializedProperty) : void
    SearchGlyphTable(searchPattern:string, searchResults:List<int>) : void
    SearchCharacterTable(searchPattern:string, searchResults:List<int>) : void
    SearchKerningTable(searchPattern:string, searchResults:List<int>) : void
}
class UI_PanelState <<struct>> {
    + {static} faceInfoPanel : bool = true
    + {static} generationSettingsPanel : bool = true
    + {static} fontAtlasInfoPanel : bool = true
    + {static} fontWeightPanel : bool = true
    + {static} fallbackFontAssetPanel : bool = true
    + {static} glyphTablePanel : bool = false
    + {static} characterTablePanel : bool = false
    + {static} fontFeatureTablePanel : bool = false
}
class AtlasSettings <<struct>> {
    + pointSize : int
    + padding : int
    + atlasWidth : int
    + atlasHeight : int
}
class Warning <<struct>> {
    + isEnabled : bool
    + expirationTime : double
}
PropertyDrawer <|-- FontWeightDrawer
Editor <|-- TMP_FontAssetEditor
TMP_FontAssetEditor --> "internalSDFMaterial" Material
TMP_FontAssetEditor --> "s_InternalSDFMaterial" Material
TMP_FontAssetEditor --> "internalBitmapMaterial" Material
TMP_FontAssetEditor --> "s_InternalBitmapMaterial" Material
TMP_FontAssetEditor +-- UI_PanelState
TMP_FontAssetEditor +-- AtlasSettings
AtlasSettings --> "glyphRenderMode" GlyphRenderMode
TMP_FontAssetEditor +-- Warning
class TMP_FontAsset_CreationMenu <<static>> {
    + {static} CreateFontAssetVariant() : void
    + {static} CreateFontAsset() : void
}
class TMP_GlyphPairAdjustmentRecordPropertyDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    ValidateInput(source:string) : bool
    GetUnicodeCharacter(source:string) : uint
    DrawGlyph(glyphIndex:uint, position:Rect, property:SerializedProperty) : void
}
PropertyDrawer <|-- TMP_GlyphPairAdjustmentRecordPropertyDrawer
TMP_GlyphPairAdjustmentRecordPropertyDrawer o-> "s_CharacterTextFieldLabel" GUIContent
class TMP_GlyphPropertyDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    DrawGlyph(position:Rect, property:SerializedProperty) : void
}
PropertyDrawer <|-- TMP_GlyphPropertyDrawer
class TMP_InputFieldEditor {
    + <<override>> OnInspectorGUI() : void
}
class m_foldout <<struct>> {
    + {static} textInput : bool = true
    + {static} fontSettings : bool = true
    + {static} extraSettings : bool = true
}
SelectableEditor <|-- TMP_InputFieldEditor
TMP_InputFieldEditor --> "m_TextViewport" SerializedProperty
TMP_InputFieldEditor --> "m_TextComponent" SerializedProperty
TMP_InputFieldEditor --> "m_Text" SerializedProperty
TMP_InputFieldEditor --> "m_ContentType" SerializedProperty
TMP_InputFieldEditor --> "m_LineType" SerializedProperty
TMP_InputFieldEditor --> "m_LineLimit" SerializedProperty
TMP_InputFieldEditor --> "m_InputType" SerializedProperty
TMP_InputFieldEditor --> "m_CharacterValidation" SerializedProperty
TMP_InputFieldEditor --> "m_InputValidator" SerializedProperty
TMP_InputFieldEditor --> "m_RegexValue" SerializedProperty
TMP_InputFieldEditor --> "m_KeyboardType" SerializedProperty
TMP_InputFieldEditor --> "m_CharacterLimit" SerializedProperty
TMP_InputFieldEditor --> "m_CaretBlinkRate" SerializedProperty
TMP_InputFieldEditor --> "m_CaretWidth" SerializedProperty
TMP_InputFieldEditor --> "m_CaretColor" SerializedProperty
TMP_InputFieldEditor --> "m_CustomCaretColor" SerializedProperty
TMP_InputFieldEditor --> "m_SelectionColor" SerializedProperty
TMP_InputFieldEditor --> "m_HideMobileKeyboard" SerializedProperty
TMP_InputFieldEditor --> "m_HideMobileInput" SerializedProperty
TMP_InputFieldEditor --> "m_Placeholder" SerializedProperty
TMP_InputFieldEditor --> "m_VerticalScrollbar" SerializedProperty
TMP_InputFieldEditor --> "m_ScrollbarScrollSensitivity" SerializedProperty
TMP_InputFieldEditor --> "m_OnValueChanged" SerializedProperty
TMP_InputFieldEditor --> "m_OnEndEdit" SerializedProperty
TMP_InputFieldEditor --> "m_OnSelect" SerializedProperty
TMP_InputFieldEditor --> "m_OnDeselect" SerializedProperty
TMP_InputFieldEditor --> "m_ReadOnly" SerializedProperty
TMP_InputFieldEditor --> "m_RichText" SerializedProperty
TMP_InputFieldEditor --> "m_RichTextEditingAllowed" SerializedProperty
TMP_InputFieldEditor --> "m_ResetOnDeActivation" SerializedProperty
TMP_InputFieldEditor --> "m_RestoreOriginalTextOnEscape" SerializedProperty
TMP_InputFieldEditor --> "m_OnFocusSelectAll" SerializedProperty
TMP_InputFieldEditor --> "m_GlobalPointSize" SerializedProperty
TMP_InputFieldEditor --> "m_GlobalFontAsset" SerializedProperty
TMP_InputFieldEditor --> "m_CustomColor" AnimBool
TMP_InputFieldEditor +-- m_foldout
class AssetConversionRecord <<struct>> {
    + referencedResource : string
    + target : string
    + replacement : string
}
class AssetConversionData {
}
class TMP_ProjectConversionUtility {
    {static} ShowConverterWindow() : void
    OnEnable() : void
    OnGUI() : void
    OnInspectorUpdate() : void
    SetEditorWindowSize() : void
    {static} ScanProjectFileAsync(fileRecord:AssetFileRecord) : void
}
class TMP_PackageUtilities {
    + {static} ImportProjectResourcesMenu() : void
    + {static} ImportExamplesContentMenu() : void
}
class "List`1"<T> {
}
class AssetModificationRecord <<struct>> {
    + assetFilePath : string
    + assetDataFile : string
}
class AssetFileRecord <<struct>> {
    + assetFilePath : string
    + assetMetaFilePath : string
    + AssetFileRecord(filePath:string, metaFilePath:string)
}
enum SaveAssetDialogueOptions {
    Unset= 0,
    Save= 1,
    SaveAll= 2,
    DoNotSave= 3,
}
class AssetRemappingRecord <<struct>> {
    + oldGuid : string
    + newGuid : string
    + assetPath : string
}
class AssetModificationRecord <<struct>> {
    + assetFilePath : string
    + assetDataFile : string
}
AssetConversionData --> "assetRecords<AssetConversionRecord>" "List`1"
EditorWindow <|-- TMP_ProjectConversionUtility
Editor <|-- TMP_PackageUtilities
TMP_ProjectConversionUtility +-- AssetModificationRecord
TMP_ProjectConversionUtility +-- AssetFileRecord
TMP_PackageUtilities +-- SaveAssetDialogueOptions
TMP_PackageUtilities +-- AssetRemappingRecord
TMP_PackageUtilities +-- AssetModificationRecord
class TMP_PostBuildProcessHandler {
    + {static} OnPostprocessBuild(target:BuildTarget, pathToBuiltProject:string) : void
}
class TMP_ProjectTextSettings <<static>> {
    + {static} SelectProjectTextSettings() : void
    {static} ON_RESOURCES_LOADED() : void
}
class TMP_ResourcesLoader {
    + {static} LoadTextMeshProResources() : void
    {static} TMP_ResourcesLoader()
}
class TMP_SDFShaderGUI {
    {static} s_Face : bool = true
    {static} s_Outline : bool = true
    {static} s_Outline2 : bool
    {static} s_Underlay : bool
    {static} s_Lighting : bool
    {static} s_Glow : bool
    {static} s_Bevel : bool
    {static} s_Light : bool
    {static} s_Bump : bool
    {static} s_Env : bool
    {static} TMP_SDFShaderGUI()
    DoFacePanel() : void
    DoOutlinePanel() : void
    DoOutline2Panel() : void
    DoUnderlayPanel() : void
    DoBevelPanel() : void
    DoLocalLightingPanel() : void
    DoSurfaceLightingPanel() : void
    DoBumpMapPanel() : void
    DoEnvMapPanel() : void
    DoGlowPanel() : void
    DoDebugPanel() : void
    DoMaskSubgroup() : void
    DoMaskTexSubgroup() : void
}
TMP_BaseShaderGUI <|-- TMP_SDFShaderGUI
TMP_SDFShaderGUI --> "s_OutlineFeature" ShaderFeature
TMP_SDFShaderGUI --> "s_UnderlayFeature" ShaderFeature
TMP_SDFShaderGUI --> "s_BevelFeature" ShaderFeature
TMP_SDFShaderGUI --> "s_GlowFeature" ShaderFeature
TMP_SDFShaderGUI --> "s_MaskFeature" ShaderFeature
class TMP_SerializedPropertyHolder {
    + firstCharacter : uint
    + secondCharacter : uint
}
ScriptableObject <|-- TMP_SerializedPropertyHolder
TMP_SerializedPropertyHolder --> "fontAsset" TMP_FontAsset
TMP_SerializedPropertyHolder o-> "glyphPairAdjustmentRecord" TMP_GlyphPairAdjustmentRecord
class TMP_SettingsEditor {
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
}
class Styles {
}
Editor <|-- TMP_SettingsEditor
TMP_SettingsEditor --> "m_PropFontAsset" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultFontAssetPath" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultFontSize" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultAutoSizeMinRatio" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultAutoSizeMaxRatio" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultTextMeshProTextContainerSize" SerializedProperty
TMP_SettingsEditor --> "m_PropDefaultTextMeshProUITextContainerSize" SerializedProperty
TMP_SettingsEditor --> "m_PropAutoSizeTextContainer" SerializedProperty
TMP_SettingsEditor --> "m_PropEnableRaycastTarget" SerializedProperty
TMP_SettingsEditor --> "m_PropIsTextObjectScaleStatic" SerializedProperty
TMP_SettingsEditor --> "m_PropSpriteAsset" SerializedProperty
TMP_SettingsEditor --> "m_PropMissingSpriteCharacterUnicode" SerializedProperty
TMP_SettingsEditor --> "m_PropEnableEmojiSupport" SerializedProperty
TMP_SettingsEditor --> "m_PropSpriteAssetPath" SerializedProperty
TMP_SettingsEditor --> "m_PropStyleSheet" SerializedProperty
TMP_SettingsEditor --> "m_PropStyleSheetsResourcePath" SerializedProperty
TMP_SettingsEditor --> "m_List" ReorderableList
TMP_SettingsEditor --> "m_PropColorGradientPresetsPath" SerializedProperty
TMP_SettingsEditor --> "m_PropMatchMaterialPreset" SerializedProperty
TMP_SettingsEditor --> "m_PropWordWrapping" SerializedProperty
TMP_SettingsEditor --> "m_PropKerning" SerializedProperty
TMP_SettingsEditor --> "m_PropExtraPadding" SerializedProperty
TMP_SettingsEditor --> "m_PropTintAllSprites" SerializedProperty
TMP_SettingsEditor --> "m_PropParseEscapeCharacters" SerializedProperty
TMP_SettingsEditor --> "m_PropMissingGlyphCharacter" SerializedProperty
TMP_SettingsEditor --> "m_GetFontFeaturesAtRuntime" SerializedProperty
TMP_SettingsEditor --> "m_PropWarningsDisabled" SerializedProperty
TMP_SettingsEditor --> "m_PropLeadingCharacters" SerializedProperty
TMP_SettingsEditor --> "m_PropFollowingCharacters" SerializedProperty
TMP_SettingsEditor --> "m_PropUseModernHangulLineBreakingRules" SerializedProperty
TMP_SettingsEditor +-- Styles
Styles o-> "defaultFontAssetLabel" GUIContent
Styles o-> "defaultFontAssetPathLabel" GUIContent
Styles o-> "fallbackFontAssetsLabel" GUIContent
Styles o-> "fallbackFontAssetsListLabel" GUIContent
Styles o-> "fallbackMaterialSettingsLabel" GUIContent
Styles o-> "matchMaterialPresetLabel" GUIContent
Styles o-> "containerDefaultSettingsLabel" GUIContent
Styles o-> "textMeshProLabel" GUIContent
Styles o-> "textMeshProUiLabel" GUIContent
Styles o-> "enableRaycastTarget" GUIContent
Styles o-> "autoSizeContainerLabel" GUIContent
Styles o-> "isTextObjectScaleStaticLabel" GUIContent
Styles o-> "textComponentDefaultSettingsLabel" GUIContent
Styles o-> "defaultFontSize" GUIContent
Styles o-> "autoSizeRatioLabel" GUIContent
Styles o-> "minLabel" GUIContent
Styles o-> "maxLabel" GUIContent
Styles o-> "wordWrappingLabel" GUIContent
Styles o-> "kerningLabel" GUIContent
Styles o-> "extraPaddingLabel" GUIContent
Styles o-> "tintAllSpritesLabel" GUIContent
Styles o-> "parseEscapeCharactersLabel" GUIContent
Styles o-> "dynamicFontSystemSettingsLabel" GUIContent
Styles o-> "getFontFeaturesAtRuntime" GUIContent
Styles o-> "dynamicAtlasTextureGroup" GUIContent
Styles o-> "missingGlyphLabel" GUIContent
Styles o-> "disableWarningsLabel" GUIContent
Styles o-> "defaultSpriteAssetLabel" GUIContent
Styles o-> "missingSpriteCharacterUnicodeLabel" GUIContent
Styles o-> "enableEmojiSupportLabel" GUIContent
Styles o-> "spriteAssetsPathLabel" GUIContent
Styles o-> "defaultStyleSheetLabel" GUIContent
Styles o-> "styleSheetResourcePathLabel" GUIContent
Styles o-> "colorGradientPresetsLabel" GUIContent
Styles o-> "colorGradientsPathLabel" GUIContent
Styles o-> "lineBreakingLabel" GUIContent
Styles o-> "koreanSpecificRules" GUIContent
class TMP_SpriteAssetEditor {
    m_moveToIndex : int
    m_selectedElement : int
    m_CurrentCharacterPage : int
    m_CurrentGlyphPage : int
    <<const>> k_UndoRedo : string = "UndoRedoPerformed"
    m_CharacterSearchPattern : string
    m_IsCharacterSearchDirty : bool
    m_GlyphSearchPattern : string
    m_IsGlyphSearchDirty : bool
    isAssetDirty : bool
    m_xOffset : float
    m_yOffset : float
    m_xAdvance : float
    m_scale : float
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
    DisplayPageNavigation(currentPage:int, arraySize:int, itemsPerPage:int) : void
    UpdateGlobalProperty(property:string, value:float) : void
    SwapCharacterElements(selectedIndex:int, newIndex:int) : void
    MoveCharacterToIndex(selectedIndex:int, newIndex:int) : void
    SwapGlyphElements(selectedIndex:int, newIndex:int) : void
    MoveGlyphToIndex(selectedIndex:int, newIndex:int) : void
    CopyCharacterSerializedProperty(source:SerializedProperty, target:SerializedProperty) : void
    CopyGlyphSerializedProperty(srcGlyph:SerializedProperty, dstGlyph:SerializedProperty) : void
    SearchCharacterTable(searchPattern:string, searchResults:List<int>) : void
    SearchGlyphTable(searchPattern:string, searchResults:List<int>) : void
}
class UI_PanelState <<struct>> {
    + {static} spriteAssetFaceInfoPanel : bool = true
    + {static} spriteAtlasInfoPanel : bool = true
    + {static} fallbackSpriteAssetPanel : bool = true
    + {static} spriteCharacterTablePanel : bool
    + {static} spriteGlyphTablePanel : bool
}
class "List`1"<T> {
}
Editor <|-- TMP_SpriteAssetEditor
TMP_SpriteAssetEditor --> "m_CharacterSearchList<int>" "List`1"
TMP_SpriteAssetEditor --> "m_GlyphSearchList<int>" "List`1"
TMP_SpriteAssetEditor --> "m_FaceInfoProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_PointSizeProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_ScaleProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_LineHeightProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_AscentLineProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_BaselineProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_DescentLineProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_spriteAtlas_prop" SerializedProperty
TMP_SpriteAssetEditor --> "m_material_prop" SerializedProperty
TMP_SpriteAssetEditor --> "m_SpriteCharacterTableProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_SpriteGlyphTableProperty" SerializedProperty
TMP_SpriteAssetEditor --> "m_fallbackSpriteAssetList" ReorderableList
TMP_SpriteAssetEditor --> "m_SpriteAsset" TMP_SpriteAsset
TMP_SpriteAssetEditor +-- UI_PanelState
class TMP_SpriteAssetImporter {
    + {static} ShowFontAtlasCreatorWindow() : void
    m_CreationFeedback : string
    OnEnable() : void
    + OnGUI() : void
    DrawEditorPanel() : void
    SaveSpriteAsset(filePath:string) : void
    {static} AddDefaultMaterial(spriteAsset:TMP_SpriteAsset) : void
    SetEditorWindowSize() : void
}
class "List`1"<T> {
}
EditorWindow <|-- TMP_SpriteAssetImporter
TMP_SpriteAssetImporter --> "m_SpriteAtlas" Texture2D
TMP_SpriteAssetImporter o-> "m_SpriteDataFormat" SpriteAssetImportFormats
TMP_SpriteAssetImporter --> "m_JsonFile" TextAsset
TMP_SpriteAssetImporter --> "m_SpriteAsset" TMP_SpriteAsset
TMP_SpriteAssetImporter o-> "m_SpriteInfoList<TMP_Sprite>" "List`1"
class TMP_SpriteAssetMenu <<static>> {
    {static} CopyTexture(command:MenuCommand) : void
    {static} UpdateSpriteAsset(command:MenuCommand) : void
    <<internal>> {static} UpdateSpriteAsset(spriteAsset:TMP_SpriteAsset) : void
    + {static} CreateSpriteAsset() : void
}
class TMP_SpriteCharacterPropertyDrawer {
    m_GlyphSelectedForEditing : int
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    DrawSpriteGlyph(position:Rect, property:SerializedProperty) : void
}
PropertyDrawer <|-- TMP_SpriteCharacterPropertyDrawer
class TMP_SpriteGlyphPropertyDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    DrawGlyph(position:Rect, property:SerializedProperty) : void
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
}
PropertyDrawer <|-- TMP_SpriteGlyphPropertyDrawer
class TMP_StyleAssetMenu <<static>> {
    + {static} CreateTextMeshProObjectPerform() : void
}
class StyleDrawer {
    + {static} <<readonly>> height : float = 95f
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
}
class TMP_StyleEditor {
    m_SelectedElement : int
    m_Page : int
    m_IsStyleSheetDirty : bool
    OnEnable() : void
    + <<override>> OnInspectorGUI() : void
    {static} DoSelectionCheck(selectionArea:Rect) : bool
    SwapStyleElements(selectedIndex:int, newIndex:int) : void
}
PropertyDrawer <|-- StyleDrawer
Editor <|-- TMP_StyleEditor
TMP_StyleEditor --> "m_StyleSheet" TMP_StyleSheet
TMP_StyleEditor --> "m_StyleListProp" SerializedProperty
class TMP_SubMeshUI_Editor {
    + OnEnable() : void
    + OnDisable() : void
    + <<override>> OnInspectorGUI() : void
}
class m_foldout <<struct>> {
    + {static} fontSettings : bool = true
}
Editor <|-- TMP_SubMeshUI_Editor
TMP_SubMeshUI_Editor +-- m_foldout
class TMP_SubMesh_Editor {
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
}
class m_foldout <<struct>> {
    + {static} fontSettings : bool = true
}
Editor <|-- TMP_SubMesh_Editor
TMP_SubMesh_Editor +-- m_foldout
class TMP_TextAlignmentDrawer {
    <<const>> k_AlignmentButtonWidth : int = 24
    <<const>> k_AlignmentButtonHeight : int = 20
    <<const>> k_WideViewWidth : int = 504
    <<const>> k_ControlsSpacing : int = 6
    <<const>> k_GroupWidth : int
    {static} <<readonly>> k_TextAlignmentHash : int
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    {static} DoHorizontalAligmentControl(position:Rect, alignment:SerializedProperty) : int
    {static} DoVerticalAligmentControl(position:Rect, alignment:SerializedProperty) : int
}
class TMP_HorizontalAlignmentDrawer {
    <<const>> k_AlignmentButtonWidth : int = 24
    <<const>> k_AlignmentButtonHeight : int = 20
    <<const>> k_WideViewWidth : int = 504
    <<const>> k_ControlsSpacing : int = 6
    <<const>> k_GroupWidth : int
    {static} <<readonly>> k_TextAlignmentHash : int
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    {static} DoHorizontalAligmentControl(position:Rect, alignment:SerializedProperty) : int
}
class TMP_VerticalAlignmentDrawer {
    <<const>> k_AlignmentButtonWidth : int = 24
    <<const>> k_AlignmentButtonHeight : int = 20
    <<const>> k_WideViewWidth : int = 504
    <<const>> k_ControlsSpacing : int = 6
    <<const>> k_GroupWidth : int
    {static} <<readonly>> k_TextAlignmentHash : int
    + <<override>> GetPropertyHeight(property:SerializedProperty, label:GUIContent) : float
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    {static} DoVerticalAligmentControl(position:Rect, alignment:SerializedProperty) : int
}
PropertyDrawer <|-- TMP_TextAlignmentDrawer
PropertyDrawer <|-- TMP_HorizontalAlignmentDrawer
PropertyDrawer <|-- TMP_VerticalAlignmentDrawer
class TMP_UIStyleManager <<static>> {
    {static} TMP_UIStyleManager()
}
TMP_UIStyleManager --> "label" GUIStyle
TMP_UIStyleManager --> "textAreaBoxWindow" GUIStyle
TMP_UIStyleManager --> "boldFoldout" GUIStyle
TMP_UIStyleManager --> "panelTitle" GUIStyle
TMP_UIStyleManager --> "sectionHeader" GUIStyle
TMP_UIStyleManager --> "centeredLabel" GUIStyle
TMP_UIStyleManager --> "rightLabel" GUIStyle
TMP_UIStyleManager --> "wrappingTextArea" GUIStyle
TMP_UIStyleManager --> "alignmentButtonLeft" GUIStyle
TMP_UIStyleManager --> "alignmentButtonMid" GUIStyle
TMP_UIStyleManager --> "alignmentButtonRight" GUIStyle
TMP_UIStyleManager --> "alignLeft" Texture2D
TMP_UIStyleManager --> "alignCenter" Texture2D
TMP_UIStyleManager --> "alignRight" Texture2D
TMP_UIStyleManager --> "alignJustified" Texture2D
TMP_UIStyleManager --> "alignFlush" Texture2D
TMP_UIStyleManager --> "alignGeoCenter" Texture2D
TMP_UIStyleManager --> "alignTop" Texture2D
TMP_UIStyleManager --> "alignMiddle" Texture2D
TMP_UIStyleManager --> "alignBottom" Texture2D
TMP_UIStyleManager --> "alignBaseline" Texture2D
TMP_UIStyleManager --> "alignMidline" Texture2D
TMP_UIStyleManager --> "alignCapline" Texture2D
TMP_UIStyleManager --> "sectionHeaderTexture" Texture2D
class FastAction {
    + Add(rhs:System.Action) : void
    + Remove(rhs:System.Action) : void
    + Call() : void
}
class "FastAction`1"<A> {
    + Add(rhs:System.Action<A>) : void
    + Remove(rhs:System.Action<A>) : void
    + Call(a:A) : void
}
class "FastAction`2"<A,B> {
    + Add(rhs:System.Action<A, B>) : void
    + Remove(rhs:System.Action<A, B>) : void
    + Call(a:A, b:B) : void
}
class "FastAction`3"<A,B,C> {
    + Add(rhs:System.Action<A, B, C>) : void
    + Remove(rhs:System.Action<A, B, C>) : void
    + Call(a:A, b:B, c:C) : void
}
class "LinkedList`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
FastAction o-> "delegates<System.Action>" "LinkedList`1"
FastAction o-> "lookup<System.Action,LinkedListNode<System.Action>>" "Dictionary`2"
"FastAction`1" o-> "delegates<System.Action<A>>" "LinkedList`1"
"FastAction`1" o-> "lookup<System.Action<A>,LinkedListNode<System.Action<A>>>" "Dictionary`2"
"FastAction`2" o-> "delegates<System.Action<A, B>>" "LinkedList`1"
"FastAction`2" o-> "lookup<System.Action<A, B>,LinkedListNode<System.Action<A, B>>>" "Dictionary`2"
"FastAction`3" o-> "delegates<System.Action<A, B, C>>" "LinkedList`1"
"FastAction`3" o-> "lookup<System.Action<A, B, C>,LinkedListNode<System.Action<A, B, C>>>" "Dictionary`2"
interface ITextPreprocessor {
    PreprocessText(text:string) : string
}
class MaterialReferenceManager {
    + {static} AddFontAsset(fontAsset:TMP_FontAsset) : void
    + {static} AddSpriteAsset(spriteAsset:TMP_SpriteAsset) : void
    + {static} AddSpriteAsset(hashCode:int, spriteAsset:TMP_SpriteAsset) : void
    + {static} AddFontMaterial(hashCode:int, material:Material) : void
    + {static} AddColorGradientPreset(hashCode:int, spriteAsset:TMP_ColorGradient) : void
    + Contains(font:TMP_FontAsset) : bool
    + Contains(sprite:TMP_SpriteAsset) : bool
    + {static} TryGetFontAsset(hashCode:int, fontAsset:TMP_FontAsset) : bool
    + {static} TryGetSpriteAsset(hashCode:int, spriteAsset:TMP_SpriteAsset) : bool
    + {static} TryGetColorGradientPreset(hashCode:int, gradientPreset:TMP_ColorGradient) : bool
    + {static} TryGetMaterial(hashCode:int, material:Material) : bool
}
class TMP_MaterialReference <<struct>> {
    + referenceCount : int
}
class MaterialReference <<struct>> {
    + index : int
    + isDefaultMaterial : bool
    + isFallbackMaterial : bool
    + padding : float
    + referenceCount : int
    + MaterialReference(index:int, fontAsset:TMP_FontAsset, spriteAsset:TMP_SpriteAsset, material:Material, padding:float)
    + {static} Contains(materialReferences:MaterialReference[], fontAsset:TMP_FontAsset) : bool
    + {static} AddMaterialReference(material:Material, fontAsset:TMP_FontAsset, materialReferences:MaterialReference[], materialReferenceIndexLookup:Dictionary<int, int>) : int
    + {static} AddMaterialReference(material:Material, spriteAsset:TMP_SpriteAsset, materialReferences:MaterialReference[], materialReferenceIndexLookup:Dictionary<int, int>) : int
}
MaterialReferenceManager --> "instance" MaterialReferenceManager
TMP_MaterialReference --> "material" Material
MaterialReference --> "fontAsset" TMP_FontAsset
MaterialReference --> "spriteAsset" TMP_SpriteAsset
MaterialReference --> "material" Material
MaterialReference --> "fallbackMaterial" Material
enum TextContainerAnchors {
    TopLeft= 0,
    Top= 1,
    TopRight= 2,
    Left= 3,
    Middle= 4,
    Right= 5,
    BottomLeft= 6,
    Bottom= 7,
    BottomRight= 8,
    Custom= 9,
}
class TextContainer {
    + hasChanged : bool <<get>> <<set>>
    + width : float <<get>> <<set>>
    + height : float <<get>> <<set>>
    + isDefaultWidth : bool <<get>>
    + isDefaultHeight : bool <<get>>
    + isAutoFitting : bool <<get>> <<set>>
    OnContainerChanged() : void
    GetPivot(anchor:TextContainerAnchors) : Vector2
    GetAnchorPosition(pivot:Vector2) : TextContainerAnchors
}
UIBehaviour <|-- TextContainer
TextContainer --> "pivot" Vector2
TextContainer --> "anchorPosition" TextContainerAnchors
TextContainer --> "rect" Rect
TextContainer --> "size" Vector2
TextContainer --> "margins" Vector4
TextContainer --> "rectTransform" RectTransform
TextContainer --> "textMeshPro" TextMeshPro
class TextMeshPro <<partial>> {
    + sortingLayerID : int <<get>> <<set>>
    <<internal>> _SortingLayerID : int
    + sortingOrder : int <<get>> <<set>>
    <<internal>> _SortingOrder : int
    + <<override>> autoSizeTextContainer : bool <<get>> <<set>>
    + SetMask(type:MaskingTypes, maskCoords:Vector4) : void
    + SetMask(type:MaskingTypes, maskCoords:Vector4, softnessX:float, softnessY:float) : void
    + <<override>> SetVerticesDirty() : void
    + <<override>> SetLayoutDirty() : void
    + <<override>> SetMaterialDirty() : void
    + <<override>> SetAllDirty() : void
    + <<override>> Rebuild(update:CanvasUpdate) : void
    + <<override>> UpdateMeshPadding() : void
    + <<override>> ForceMeshUpdate(ignoreActiveState:bool, forceTextReparsing:bool) : void
    + <<override>> GetTextInfo(text:string) : TMP_TextInfo
    + <<override>> ClearMesh(updateMesh:bool) : void
    + <<override>>  <<event>> OnPreRenderText : Action<TMP_TextInfo> 
    + <<override>> UpdateGeometry(mesh:Mesh, index:int) : void
    + <<override>> UpdateVertexData(flags:TMP_VertexDataUpdateFlags) : void
    + <<override>> UpdateVertexData() : void
    + UpdateFontAsset() : void
    + CalculateLayoutInputHorizontal() : void
    + CalculateLayoutInputVertical() : void
}
TMP_Text <|-- TextMeshPro
ILayoutElement <|-- TextMeshPro
TextMeshPro --> "textContainer" TextContainer
TextMeshPro --> "transform" Transform
TextMeshPro --> "renderer" Renderer
TextMeshPro --> "mesh" Mesh
TextMeshPro --> "meshFilter" MeshFilter
TextMeshPro --> "maskType" MaskingTypes
class TextMeshProUGUI <<partial>> {
    + <<override>> autoSizeTextContainer : bool <<get>> <<set>>
    + CalculateLayoutInputHorizontal() : void
    + CalculateLayoutInputVertical() : void
    + <<override>> SetVerticesDirty() : void
    + <<override>> SetLayoutDirty() : void
    + <<override>> SetMaterialDirty() : void
    + <<override>> SetAllDirty() : void
    DelayedGraphicRebuild() : IEnumerator
    DelayedMaterialRebuild() : IEnumerator
    + <<override>> Rebuild(update:CanvasUpdate) : void
    + <<override>> GetModifiedMaterial(baseMaterial:Material) : Material
    + <<override>> RecalculateClipping() : void
    + <<override>> Cull(clipRect:Rect, validRect:bool) : void
    <<internal>> <<override>> UpdateCulling() : void
    + <<override>> UpdateMeshPadding() : void
    + <<override>> ForceMeshUpdate(ignoreActiveState:bool, forceTextReparsing:bool) : void
    + <<override>> GetTextInfo(text:string) : TMP_TextInfo
    + <<override>> ClearMesh() : void
    + <<override>>  <<event>> OnPreRenderText : Action<TMP_TextInfo> 
    + <<override>> UpdateGeometry(mesh:Mesh, index:int) : void
    + <<override>> UpdateVertexData(flags:TMP_VertexDataUpdateFlags) : void
    + <<override>> UpdateVertexData() : void
    + UpdateFontAsset() : void
}
TMP_Text <|-- TextMeshProUGUI
ILayoutElement <|-- TextMeshProUGUI
TextMeshProUGUI --> "materialForRendering" Material
TextMeshProUGUI --> "mesh" Mesh
TextMeshProUGUI --> "canvasRenderer" CanvasRenderer
TextMeshProUGUI --> "maskOffset" Vector4
enum Compute_DistanceTransform_EventTypes {
    Processing,
    Completed,
}
class TMPro_EventManager <<static>> {
    + {static} ON_MATERIAL_PROPERTY_CHANGED(isChanged:bool, mat:Material) : void
    + {static} ON_FONT_PROPERTY_CHANGED(isChanged:bool, obj:Object) : void
    + {static} ON_SPRITE_ASSET_PROPERTY_CHANGED(isChanged:bool, obj:Object) : void
    + {static} ON_TEXTMESHPRO_PROPERTY_CHANGED(isChanged:bool, obj:Object) : void
    + {static} ON_DRAG_AND_DROP_MATERIAL_CHANGED(sender:GameObject, currentMaterial:Material, newMaterial:Material) : void
    + {static} ON_TEXT_STYLE_PROPERTY_CHANGED(isChanged:bool) : void
    + {static} ON_COLOR_GRADIENT_PROPERTY_CHANGED(obj:Object) : void
    + {static} ON_TEXT_CHANGED(obj:Object) : void
    + {static} ON_TMP_SETTINGS_CHANGED() : void
    + {static} ON_RESOURCES_LOADED() : void
    + {static} ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED(isChanged:bool, obj:Object) : void
    + {static} ON_COMPUTE_DT_EVENT(Sender:object, e:Compute_DT_EventArgs) : void
}
class Compute_DT_EventArgs {
    + ProgressPercentage : float
    + Compute_DT_EventArgs(type:Compute_DistanceTransform_EventTypes, progress:float)
    + Compute_DT_EventArgs(type:Compute_DistanceTransform_EventTypes, colors:Color[])
}
class "FastAction`2"<T1,T2> {
}
class "FastAction`3"<T1,T2,T3> {
}
class "FastAction`1"<T> {
}
TMPro_EventManager o-> "COMPUTE_DT_EVENT<object,Compute_DT_EventArgs>" "FastAction`2"
TMPro_EventManager o-> "MATERIAL_PROPERTY_EVENT<bool,Material>" "FastAction`2"
TMPro_EventManager o-> "FONT_PROPERTY_EVENT<bool,Object>" "FastAction`2"
TMPro_EventManager o-> "SPRITE_ASSET_PROPERTY_EVENT<bool,Object>" "FastAction`2"
TMPro_EventManager o-> "TEXTMESHPRO_PROPERTY_EVENT<bool,Object>" "FastAction`2"
TMPro_EventManager o-> "DRAG_AND_DROP_MATERIAL_EVENT<GameObject,Material,Material>" "FastAction`3"
TMPro_EventManager o-> "TEXT_STYLE_PROPERTY_EVENT<bool>" "FastAction`1"
TMPro_EventManager o-> "COLOR_GRADIENT_PROPERTY_EVENT<Object>" "FastAction`1"
TMPro_EventManager o-> "TMP_SETTINGS_PROPERTY_EVENT" FastAction
TMPro_EventManager o-> "RESOURCE_LOAD_EVENT" FastAction
TMPro_EventManager o-> "TEXTMESHPRO_UGUI_PROPERTY_EVENT<bool,Object>" "FastAction`2"
TMPro_EventManager o-> "TEXT_CHANGED_EVENT<Object>" "FastAction`1"
Compute_DT_EventArgs --> "EventType" Compute_DistanceTransform_EventTypes
class TMPro_ExtensionMethods <<static>> {
    + {static} ArrayToString(chars:char[]) : string
    + {static} IntToString(unicodes:int[]) : string
    <<internal>> {static} UintToString(unicodes:List<uint>) : string
    + {static} IntToString(unicodes:int[], start:int, length:int) : string
    + {static} FindInstanceID(list:List<T>, target:T) : int
    + {static} Compare(a:Color32, b:Color32) : bool
    + {static} CompareRGB(a:Color32, b:Color32) : bool
    + {static} Compare(a:Color, b:Color) : bool
    + {static} CompareRGB(a:Color, b:Color) : bool
    + {static} Multiply(c1:Color32, c2:Color32) : Color32
    + {static} Tint(c1:Color32, c2:Color32) : Color32
    + {static} Tint(c1:Color32, tint:float) : Color32
    + {static} MinAlpha(c1:Color, c2:Color) : Color
    + {static} Compare(v1:Vector3, v2:Vector3, accuracy:int) : bool
    + {static} Compare(q1:Quaternion, q2:Quaternion, accuracy:int) : bool
}
class TMP_Math <<static>> {
    + <<const>> FLOAT_MAX : float = 32767
    + <<const>> FLOAT_MIN : float
    + <<const>> INT_MAX : int = 2147483647
    + <<const>> INT_MIN : int
    + <<const>> FLOAT_UNSET : float
    + <<const>> INT_UNSET : int
    + {static} Approximately(a:float, b:float) : bool
    + {static} Mod(a:int, b:int) : int
}
TMP_Math o-> "MAX_16BIT" Vector2
TMP_Math o-> "MIN_16BIT" Vector2
enum TMP_VertexDataUpdateFlags {
    None= 0x0,
    Vertices= 0x1,
    Uv0= 0x2,
    Uv2= 0x4,
    Uv4= 0x8,
    Colors32= 0x10,
    All= 0xFF,
}
class VertexGradient <<struct>> {
    + VertexGradient(color:Color)
    + VertexGradient(color0:Color, color1:Color, color2:Color, color3:Color)
}
class TMP_PageInfo <<struct>> {
    + firstCharacterIndex : int
    + lastCharacterIndex : int
    + ascender : float
    + baseLine : float
    + descender : float
}
class TMP_LinkInfo <<struct>> {
    + hashCode : int
    + linkIdFirstCharacterIndex : int
    + linkIdLength : int
    + linkTextfirstCharacterIndex : int
    + linkTextLength : int
    <<internal>> SetLinkID(text:char[], startIndex:int, length:int) : void
    + GetLinkText() : string
    + GetLinkID() : string
}
class TMP_WordInfo <<struct>> {
    + firstCharacterIndex : int
    + lastCharacterIndex : int
    + characterCount : int
    + GetWord() : string
}
class TMP_SpriteInfo <<struct>> {
    + spriteIndex : int
    + characterIndex : int
    + vertexIndex : int
}
class Extents <<struct>> {
    + Extents(min:Vector2, max:Vector2)
    + <<override>> ToString() : string
}
class Mesh_Extents <<struct>> {
    + Mesh_Extents(min:Vector2, max:Vector2)
    + <<override>> ToString() : string
}
class WordWrapState <<struct>> {
    + previous_WordBreak : int
    + total_CharacterCount : int
    + visible_CharacterCount : int
    + visible_SpriteCount : int
    + visible_LinkCount : int
    + firstCharacterIndex : int
    + firstVisibleCharacterIndex : int
    + lastCharacterIndex : int
    + lastVisibleCharIndex : int
    + lineNumber : int
    + maxCapHeight : float
    + maxAscender : float
    + maxDescender : float
    + startOfLineAscender : float
    + maxLineAscender : float
    + maxLineDescender : float
    + pageAscender : float
    + marginLeft : float
    + marginRight : float
    + xAdvance : float
    + preferredWidth : float
    + preferredHeight : float
    + previousLineScale : float
    + wordCount : int
    + italicAngle : int
    + fontScale : float
    + fontScaleMultiplier : float
    + currentFontSize : float
    + baselineOffset : float
    + lineOffset : float
    + isDrivenLineSpacing : bool
    + glyphHorizontalAdvanceAdjustment : float
    + cSpace : float
    + mSpace : float
    + spriteAnimationID : int
    + currentMaterialIndex : int
    + tagNoParsing : bool
    + isNonBreakingSpace : bool
}
class TagAttribute <<struct>> {
    + startIndex : int
    + length : int
    + hashCode : int
}
class RichTextTagAttribute <<struct>> {
    + nameHashCode : int
    + valueHashCode : int
    + valueStartIndex : int
    + valueLength : int
}
class "TMP_TextProcessingStack`1"<T> {
}
VertexGradient --> "topLeft" Color
VertexGradient --> "topRight" Color
VertexGradient --> "bottomLeft" Color
VertexGradient --> "bottomRight" Color
TMP_LinkInfo --> "textComponent" TMP_Text
TMP_WordInfo --> "textComponent" TMP_Text
Extents o-> "zero" Extents
Extents o-> "uninitialized" Extents
Extents --> "min" Vector2
Extents --> "max" Vector2
Mesh_Extents --> "min" Vector2
Mesh_Extents --> "max" Vector2
WordWrapState --> "horizontalAlignment" HorizontalAlignmentOptions
WordWrapState --> "fontStyle" FontStyles
WordWrapState --> "textInfo" TMP_TextInfo
WordWrapState --> "lineInfo" TMP_LineInfo
WordWrapState --> "vertexColor" Color32
WordWrapState --> "underlineColor" Color32
WordWrapState --> "strikethroughColor" Color32
WordWrapState --> "highlightColor" Color32
WordWrapState --> "basicStyleStack" TMP_FontStyleStack
WordWrapState --> "italicAngleStack<int>" "TMP_TextProcessingStack`1"
WordWrapState --> "colorStack<Color32>" "TMP_TextProcessingStack`1"
WordWrapState --> "underlineColorStack<Color32>" "TMP_TextProcessingStack`1"
WordWrapState --> "strikethroughColorStack<Color32>" "TMP_TextProcessingStack`1"
WordWrapState --> "highlightColorStack<Color32>" "TMP_TextProcessingStack`1"
WordWrapState --> "highlightStateStack<HighlightState>" "TMP_TextProcessingStack`1"
WordWrapState --> "colorGradientStack<TMP_ColorGradient>" "TMP_TextProcessingStack`1"
WordWrapState --> "sizeStack<float>" "TMP_TextProcessingStack`1"
WordWrapState --> "indentStack<float>" "TMP_TextProcessingStack`1"
WordWrapState --> "fontWeightStack<FontWeight>" "TMP_TextProcessingStack`1"
WordWrapState --> "styleStack<int>" "TMP_TextProcessingStack`1"
WordWrapState --> "baselineStack<float>" "TMP_TextProcessingStack`1"
WordWrapState --> "actionStack<int>" "TMP_TextProcessingStack`1"
WordWrapState --> "materialReferenceStack<MaterialReference>" "TMP_TextProcessingStack`1"
WordWrapState --> "lineJustificationStack<HorizontalAlignmentOptions>" "TMP_TextProcessingStack`1"
WordWrapState --> "currentFontAsset" TMP_FontAsset
WordWrapState --> "currentSpriteAsset" TMP_SpriteAsset
WordWrapState --> "currentMaterial" Material
WordWrapState --> "meshExtents" Extents
RichTextTagAttribute --> "valueType" TagValueType
RichTextTagAttribute --> "unitType" TagUnitType
class TextMeshPro <<partial>> {
    m_previousLossyScaleY : float
    UpdateEnvMapMatrix() : void
    SetMask(maskType:MaskingTypes) : void
    SetMaskCoordinates(coords:Vector4) : void
    SetMaskCoordinates(coords:Vector4, softX:float, softY:float) : void
    EnableMasking() : void
    DisableMasking() : void
    UpdateMask() : void
    CreateMaterialInstance() : void
    SetPerspectiveCorrection() : void
    + <<override>> ComputeMarginSize() : void
    <<internal>> <<override>> InternalUpdate() : void
    OnPreRenderObject() : void
    SetMeshFilters(state:bool) : void
    UpdateSDFScale(scaleDelta:float) : void
}
class TextMeshProUGUI <<partial>> {
    UpdateEnvMapMatrix() : void
    EnableMasking() : void
    DisableMasking() : void
    UpdateMask() : void
    SetPerspectiveCorrection() : void
    SetMeshArrays(size:int) : void
    + <<override>> ComputeMarginSize() : void
    <<internal>> <<override>> InternalUpdate() : void
    OnPreRenderCanvas() : void
    <<internal>> <<override>> GetCanvasSpaceClippingRect() : Rect
    UpdateSDFScale(scaleDelta:float) : void
}
abstract class TMP_Asset {
    + instanceID : int <<get>>
    + hashCode : int
    + materialHashCode : int
}
ScriptableObject <|-- TMP_Asset
TMP_Asset --> "material" Material
class TMP_Character {
    + TMP_Character()
    + TMP_Character(unicode:uint, glyph:Glyph)
    + TMP_Character(unicode:uint, fontAsset:TMP_FontAsset, glyph:Glyph)
    <<internal>> TMP_Character(unicode:uint, glyphIndex:uint)
}
TMP_TextElement <|-- TMP_Character
class TMP_Vertex <<struct>> {
}
class TMP_Offset <<struct>> {
    + left : float <<get>> <<set>>
    + right : float <<get>> <<set>>
    + top : float <<get>> <<set>>
    + bottom : float <<get>> <<set>>
    + horizontal : float <<get>> <<set>>
    + vertical : float <<get>> <<set>>
    m_Left : float
    m_Right : float
    m_Top : float
    m_Bottom : float
    + TMP_Offset(left:float, right:float, top:float, bottom:float)
    + TMP_Offset(horizontal:float, vertical:float)
    + <<override>> GetHashCode() : int
    + <<override>> Equals(obj:object) : bool
    + Equals(other:TMP_Offset) : bool
}
class HighlightState <<struct>> {
    + HighlightState(color:Color32, padding:TMP_Offset)
    + <<override>> GetHashCode() : int
    + <<override>> Equals(obj:object) : bool
    + Equals(other:HighlightState) : bool
}
class TMP_CharacterInfo <<struct>> {
    + character : char
    + index : int
    + stringLength : int
    + spriteIndex : int
    + materialReferenceIndex : int
    + isUsingAlternateTypeface : bool
    + pointSize : float
    + lineNumber : int
    + pageNumber : int
    + vertexIndex : int
    + origin : float
    + xAdvance : float
    + ascender : float
    + baseLine : float
    + descender : float
    <<internal>> adjustedAscender : float
    <<internal>> adjustedDescender : float
    + aspectRatio : float
    + scale : float
    + underlineVertexIndex : int
    + strikethroughVertexIndex : int
    + isVisible : bool
}
TMP_Vertex --> "position" Vector3
TMP_Vertex --> "uv" Vector2
TMP_Vertex --> "uv2" Vector2
TMP_Vertex --> "uv4" Vector2
TMP_Vertex --> "color" Color32
TMP_Vertex --> "zero" TMP_Vertex
TMP_Vertex o-> "k_Zero" TMP_Vertex
TMP_Offset --> "zero" TMP_Offset
TMP_Offset o-> "k_ZeroOffset" TMP_Offset
HighlightState --> "color" Color32
HighlightState --> "padding" TMP_Offset
TMP_CharacterInfo --> "elementType" TMP_TextElementType
TMP_CharacterInfo --> "textElement" TMP_TextElement
TMP_CharacterInfo --> "fontAsset" TMP_FontAsset
TMP_CharacterInfo --> "spriteAsset" TMP_SpriteAsset
TMP_CharacterInfo --> "material" Material
TMP_CharacterInfo --> "vertex_BL" TMP_Vertex
TMP_CharacterInfo --> "vertex_TL" TMP_Vertex
TMP_CharacterInfo --> "vertex_TR" TMP_Vertex
TMP_CharacterInfo --> "vertex_BR" TMP_Vertex
TMP_CharacterInfo --> "topLeft" Vector3
TMP_CharacterInfo --> "bottomLeft" Vector3
TMP_CharacterInfo --> "topRight" Vector3
TMP_CharacterInfo --> "bottomRight" Vector3
TMP_CharacterInfo --> "color" Color32
TMP_CharacterInfo --> "underlineColor" Color32
TMP_CharacterInfo --> "strikethroughColor" Color32
TMP_CharacterInfo --> "highlightColor" Color32
TMP_CharacterInfo --> "highlightState" HighlightState
TMP_CharacterInfo --> "style" FontStyles
enum ColorMode {
    Single,
    HorizontalGradient,
    VerticalGradient,
    FourCornersGradient,
}
class TMP_ColorGradient {
    + TMP_ColorGradient()
    + TMP_ColorGradient(color:Color)
    + TMP_ColorGradient(color0:Color, color1:Color, color2:Color, color3:Color)
}
ScriptableObject <|-- TMP_ColorGradient
TMP_ColorGradient o-> "colorMode" ColorMode
TMP_ColorGradient --> "topLeft" Color
TMP_ColorGradient --> "topRight" Color
TMP_ColorGradient --> "bottomLeft" Color
TMP_ColorGradient --> "bottomRight" Color
TMP_ColorGradient o-> "k_DefaultColorMode" ColorMode
TMP_ColorGradient o-> "k_DefaultColor" Color
class TMP_Compatibility <<static>> {
    + {static} ConvertTextAlignmentEnumValues(oldValue:TextAlignmentOptions) : TextAlignmentOptions
}
enum AnchorPositions {
    TopLeft,
    Top,
    TopRight,
    Left,
    Center,
    Right,
    BottomLeft,
    Bottom,
    BottomRight,
    BaseLine,
    None,
}
TMP_Compatibility +-- AnchorPositions
interface ITweenValue {
    TweenValue(floatPercentage:float) : void
    ignoreTimeScale : bool <<get>>
    duration : float <<get>>
    ValidTarget() : bool
}
class ColorTween <<struct>> {
    + duration : float <<get>> <<set>>
    + ignoreTimeScale : bool <<get>> <<set>>
    + TweenValue(floatPercentage:float) : void
    + AddOnChangedCallback(callback:UnityAction<Color>) : void
    + GetIgnoreTimescale() : bool
    + GetDuration() : float
    + ValidTarget() : bool
}
class FloatTween <<struct>> {
    + startValue : float <<get>> <<set>>
    + targetValue : float <<get>> <<set>>
    + duration : float <<get>> <<set>>
    + ignoreTimeScale : bool <<get>> <<set>>
    + TweenValue(floatPercentage:float) : void
    + AddOnChangedCallback(callback:UnityAction<float>) : void
    + GetIgnoreTimescale() : bool
    + GetDuration() : float
    + ValidTarget() : bool
}
class "TweenRunner`1"<T> {
    + Init(coroutineContainer:MonoBehaviour) : void
    + StartTween(info:T) : void
    + StopTween() : void
}
enum ColorTweenMode {
    All,
    RGB,
    Alpha,
}
class ColorTweenCallback {
}
class FloatTweenCallback {
}
class "UnityEvent`1"<T> {
}
ITweenValue <|-- ColorTween
ColorTween --> "startColor" Color
ColorTween --> "targetColor" Color
ColorTween --> "tweenMode" ColorTweenMode
ITweenValue <|-- FloatTween
ColorTween +-- ColorTweenMode
ColorTween +-- ColorTweenCallback
"UnityEvent`1" "<Color>" <|-- ColorTweenCallback
FloatTween +-- FloatTweenCallback
"UnityEvent`1" "<float>" <|-- FloatTweenCallback
class TMP_DefaultControls <<static>> {
    {static} CreateUIObject(name:string, parent:GameObject) : GameObject
    + {static} CreateScrollbar(resources:Resources) : GameObject
    + {static} CreateButton(resources:Resources) : GameObject
    + {static} CreateText(resources:Resources) : GameObject
    + {static} CreateInputField(resources:Resources) : GameObject
    + {static} CreateDropdown(resources:Resources) : GameObject
}
class Resources <<struct>> {
}
TMP_DefaultControls +-- Resources
Resources --> "standard" Sprite
Resources --> "background" Sprite
Resources --> "inputField" Sprite
Resources --> "knob" Sprite
Resources --> "checkmark" Sprite
Resources --> "dropdown" Sprite
Resources --> "mask" Sprite
class TMP_Dropdown {
    + alphaFadeSpeed : float <<get>> <<set>>
    + value : int <<get>> <<set>>
    + SetValueWithoutNotify(input:int) : void
    SetValue(value:int, sendCallback:bool) : void
    + IsExpanded : bool <<get>>
    + RefreshShownValue() : void
    + AddOptions(options:List<OptionData>) : void
    + AddOptions(options:List<string>) : void
    + AddOptions(options:List<Sprite>) : void
    + ClearOptions() : void
    + <<virtual>> OnPointerClick(eventData:PointerEventData) : void
    + <<virtual>> OnSubmit(eventData:BaseEventData) : void
    + <<virtual>> OnCancel(eventData:BaseEventData) : void
    + Show() : void
    + Hide() : void
}
class DropdownItem {
    + <<virtual>> OnPointerEnter(eventData:PointerEventData) : void
    + <<virtual>> OnCancel(eventData:BaseEventData) : void
}
class OptionData {
    + text : string <<get>> <<set>>
    + OptionData()
    + OptionData(text:string)
    + OptionData(image:Sprite)
    + OptionData(text:string, image:Sprite)
}
class OptionDataList {
    + OptionDataList()
}
class DropdownEvent {
}
class "List`1"<T> {
}
class "UnityEvent`1"<T> {
}
Selectable <|-- TMP_Dropdown
IPointerClickHandler <|-- TMP_Dropdown
ISubmitHandler <|-- TMP_Dropdown
ICancelHandler <|-- TMP_Dropdown
TMP_Dropdown --> "template" RectTransform
TMP_Dropdown --> "captionText" TMP_Text
TMP_Dropdown --> "captionImage" Image
TMP_Dropdown --> "placeholder" Graphic
TMP_Dropdown --> "itemText" TMP_Text
TMP_Dropdown --> "itemImage" Image
TMP_Dropdown --> "options<OptionData>" "List`1"
TMP_Dropdown --> "onValueChanged" DropdownEvent
TMP_Dropdown +-- DropdownItem
MonoBehaviour <|-- DropdownItem
IPointerEnterHandler <|-- DropdownItem
ICancelHandler <|-- DropdownItem
DropdownItem --> "text" TMP_Text
DropdownItem --> "image" Image
DropdownItem --> "rectTransform" RectTransform
DropdownItem --> "toggle" Toggle
TMP_Dropdown +-- OptionData
OptionData --> "image" Sprite
TMP_Dropdown +-- OptionDataList
OptionDataList --> "options<OptionData>" "List`1"
TMP_Dropdown +-- DropdownEvent
"UnityEvent`1" "<int>" <|-- DropdownEvent
enum AtlasPopulationMode {
    Static= 0x0,
    Dynamic= 0x1,
}
class TMP_FontAsset {
    + version : string <<get>> <<internal set>>
    <<internal>> m_SourceFontFileGUID : string
    <<internal>> m_AtlasTextureIndex : int
    + atlasTextureCount : int <<get>>
    + isMultiAtlasTexturesEnabled : bool <<get>> <<set>>
    + atlasWidth : int <<get>> <<internal set>>
    <<internal>> m_AtlasWidth : int
    + atlasHeight : int <<get>> <<internal set>>
    <<internal>> m_AtlasHeight : int
    + atlasPadding : int <<get>> <<internal set>>
    <<internal>> m_AtlasPadding : int
    + normalStyle : float = 0
    + normalSpacingOffset : float = 0
    + boldStyle : float = 0.75f
    + boldSpacing : float = 7f
    + italicStyle : byte = 35
    + tabSize : byte = 10
    <<internal>> IsFontAssetLookupTablesDirty : bool
    + {static} CreateFontAsset(font:Font) : TMP_FontAsset
    + {static} CreateFontAsset(font:Font, samplingPointSize:int, atlasPadding:int, renderMode:GlyphRenderMode, atlasWidth:int, atlasHeight:int, atlasPopulationMode:AtlasPopulationMode, enableMultiAtlasSupport:bool) : TMP_FontAsset
    Awake() : void
    + ReadFontAssetDefinition() : void
    <<internal>> InitializeDictionaryLookupTables() : void
    <<internal>> InitializeGlyphLookupDictionary() : void
    <<internal>> InitializeCharacterLookupDictionary() : void
    <<internal>> InitializeGlyphPaidAdjustmentRecordsLookupDictionary() : void
    <<internal>> AddSynthesizedCharactersAndFaceMetrics() : void
    AddSynthesizedCharacter(unicode:uint, addImmediately:bool) : void
    <<internal>> AddCharacterToLookupCache(unicode:uint, character:TMP_Character) : void
    <<internal>> SortCharacterTable() : void
    <<internal>> SortGlyphTable() : void
    <<internal>> SortFontFeatureTable() : void
    <<internal>> SortAllTables() : void
    + HasCharacter(character:int) : bool
    + HasCharacter(character:char, searchFallbacks:bool, tryAddCharacter:bool) : bool
    HasCharacter_Internal(character:uint, searchFallbacks:bool, tryAddCharacter:bool) : bool
    + HasCharacters(text:string, missingCharacters:List<char>) : bool
    + HasCharacters(text:string, missingCharacters:uint[], searchFallbacks:bool, tryAddCharacter:bool) : bool
    + HasCharacters(text:string) : bool
    + {static} GetCharacters(fontAsset:TMP_FontAsset) : string
    + {static} GetCharactersArray(fontAsset:TMP_FontAsset) : int[]
    <<internal>> GetGlyphIndex(unicode:uint) : uint
    <<internal>> {static} RegisterFontAssetForFontFeatureUpdate(fontAsset:TMP_FontAsset) : void
    <<internal>> {static} UpdateFontFeaturesForFontAssetsInQueue() : void
    <<internal>> {static} RegisterFontAssetForAtlasTextureUpdate(fontAsset:TMP_FontAsset) : void
    <<internal>> {static} UpdateAtlasTexturesForFontAssetsInQueue() : void
    + TryAddCharacters(unicodes:uint[], includeFontFeatures:bool) : bool
    + TryAddCharacters(unicodes:uint[], missingUnicodes:uint[], includeFontFeatures:bool) : bool
    + TryAddCharacters(characters:string, includeFontFeatures:bool) : bool
    + TryAddCharacters(characters:string, missingCharacters:string, includeFontFeatures:bool) : bool
    <<internal>> TryAddCharacterInternal(unicode:uint, character:TMP_Character) : bool
    <<internal>> TryGetCharacter_and_QueueRenderToTexture(unicode:uint, character:TMP_Character) : bool
    <<internal>> TryAddGlyphsToAtlasTextures() : void
    TryAddGlyphsToNewAtlasTexture() : bool
    SetupNewAtlasTexture() : void
    <<internal>> UpdateAtlasTexture() : void
    <<internal>> UpdateGlyphAdjustmentRecords() : void
    <<internal>> UpdateGlyphAdjustmentRecords(glyphIndexes:uint[]) : void
    <<internal>> UpdateGlyphAdjustmentRecords(glyphIndexes:List<uint>) : void
    <<internal>> UpdateGlyphAdjustmentRecords(newGlyphIndexes:List<uint>, allGlyphIndexes:List<uint>) : void
    CopyListDataToArray(srcList:List<T>, dstArray:T[]) : void
    + ClearFontAssetData(setAtlasSizeToZero:bool) : void
    <<internal>> UpdateFontAssetData() : void
    <<internal>> ClearFontAssetTables() : void
    <<internal>> ClearAtlasTextures(setAtlasSizeToZero:bool) : void
    <<internal>> UpgradeFontAsset() : void
    UpgradeGlyphAdjustmentTableToFontFeatureTable() : void
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
class "HashSet`1"<T> {
}
TMP_Asset <|-- TMP_FontAsset
TMP_FontAsset --> "sourceFontFile" Font
TMP_FontAsset --> "atlasPopulationMode" AtlasPopulationMode
TMP_FontAsset --> "faceInfo" FaceInfo
TMP_FontAsset --> "m_FaceInfo" FaceInfo
TMP_FontAsset --> "glyphTable<Glyph>" "List`1"
TMP_FontAsset o-> "m_GlyphTable<Glyph>" "List`1"
TMP_FontAsset --> "glyphLookupTable<uint,Glyph>" "Dictionary`2"
TMP_FontAsset --> "m_GlyphLookupDictionary<uint,Glyph>" "Dictionary`2"
TMP_FontAsset --> "characterTable<TMP_Character>" "List`1"
TMP_FontAsset o-> "m_CharacterTable<TMP_Character>" "List`1"
TMP_FontAsset --> "characterLookupTable<uint,TMP_Character>" "Dictionary`2"
TMP_FontAsset --> "m_CharacterLookupDictionary<uint,TMP_Character>" "Dictionary`2"
TMP_FontAsset --> "atlasTexture" Texture2D
TMP_FontAsset --> "m_AtlasTexture" Texture2D
TMP_FontAsset --> "usedGlyphRects<GlyphRect>" "List`1"
TMP_FontAsset --> "freeGlyphRects<GlyphRect>" "List`1"
TMP_FontAsset --> "fontInfo" FaceInfo_Legacy
TMP_FontAsset --> "atlas" Texture2D
TMP_FontAsset --> "atlasRenderMode" GlyphRenderMode
TMP_FontAsset --> "m_AtlasRenderMode" GlyphRenderMode
TMP_FontAsset --> "m_glyphInfoList<TMP_Glyph>" "List`1"
TMP_FontAsset o-> "m_KerningTable" KerningTable
TMP_FontAsset --> "fontFeatureTable" TMP_FontFeatureTable
TMP_FontAsset o-> "m_FontFeatureTable" TMP_FontFeatureTable
TMP_FontAsset --> "fallbackFontAssetTable<TMP_FontAsset>" "List`1"
TMP_FontAsset --> "m_FallbackFontAssetTable<TMP_FontAsset>" "List`1"
TMP_FontAsset --> "creationSettings" FontAssetCreationSettings
TMP_FontAsset --> "m_CreationSettings" FontAssetCreationSettings
TMP_FontAsset o-> "FallbackSearchQueryLookup<int>" "HashSet`1"
TMP_FontAsset o-> "m_GlyphsToAdd<uint>" "List`1"
TMP_FontAsset o-> "m_GlyphsToAddLookup<uint>" "HashSet`1"
TMP_FontAsset o-> "m_CharactersToAdd<TMP_Character>" "List`1"
TMP_FontAsset o-> "m_CharactersToAddLookup<uint>" "HashSet`1"
TMP_FontAsset o-> "s_MissingCharacterList<uint>" "List`1"
TMP_FontAsset o-> "m_MissingUnicodesFromFontFile<uint>" "HashSet`1"
class FaceInfo_Legacy {
    + Name : string
    + PointSize : float
    + Scale : float
    + CharacterCount : int
    + LineHeight : float
    + Baseline : float
    + Ascender : float
    + CapHeight : float
    + Descender : float
    + CenterLine : float
    + SuperscriptOffset : float
    + SubscriptOffset : float
    + SubSize : float
    + Underline : float
    + UnderlineThickness : float
    + strikethrough : float
    + strikethroughThickness : float
    + TabWidth : float
    + Padding : float
    + AtlasWidth : float
    + AtlasHeight : float
}
class TMP_Glyph {
    + {static} Clone(source:TMP_Glyph) : TMP_Glyph
}
class FontAssetCreationSettings <<struct>> {
    + sourceFontFileName : string
    + sourceFontFileGUID : string
    + pointSizeSamplingMode : int
    + pointSize : int
    + padding : int
    + packingMode : int
    + atlasWidth : int
    + atlasHeight : int
    + characterSetSelectionMode : int
    + characterSequence : string
    + referencedFontAssetGUID : string
    + referencedTextAssetGUID : string
    + fontStyle : int
    + fontStyleModifier : float
    + renderMode : int
    + includeFontFeatures : bool
    <<internal>> FontAssetCreationSettings(sourceFontFileGUID:string, pointSize:int, pointSizeSamplingMode:int, padding:int, packingMode:int, atlasWidth:int, atlasHeight:int, characterSelectionMode:int, characterSet:string, renderMode:int)
}
class TMP_FontWeightPair <<struct>> {
}
class KerningPairKey <<struct>> {
    + ascii_Left : uint
    + ascii_Right : uint
    + key : uint
    + KerningPairKey(ascii_left:uint, ascii_right:uint)
}
class GlyphValueRecord_Legacy <<struct>> {
    + xPlacement : float
    + yPlacement : float
    + xAdvance : float
    + yAdvance : float
    <<internal>> GlyphValueRecord_Legacy(valueRecord:UnityEngine.TextCore.LowLevel.GlyphValueRecord)
}
class KerningPair {
    + firstGlyph : uint <<get>> <<set>>
    + secondGlyph : uint <<get>> <<set>>
    + xOffset : float
    + ignoreSpacingAdjustments : bool <<get>>
    + KerningPair()
    + KerningPair(left:uint, right:uint, offset:float)
    + KerningPair(firstGlyph:uint, firstGlyphAdjustments:GlyphValueRecord_Legacy, secondGlyph:uint, secondGlyphAdjustments:GlyphValueRecord_Legacy)
    <<internal>> ConvertLegacyKerningData() : void
}
class KerningTable {
    + KerningTable()
    + AddKerningPair() : void
    + AddKerningPair(first:uint, second:uint, offset:float) : int
    + AddGlyphPairAdjustmentRecord(first:uint, firstAdjustments:GlyphValueRecord_Legacy, second:uint, secondAdjustments:GlyphValueRecord_Legacy) : int
    + RemoveKerningPair(left:int, right:int) : void
    + RemoveKerningPair(index:int) : void
    + SortKerningPairs() : void
}
class TMP_FontUtilities <<static>> {
    + {static} SearchForCharacter(font:TMP_FontAsset, unicode:uint, character:TMP_Character) : TMP_FontAsset
    + {static} SearchForCharacter(fonts:List<TMP_FontAsset>, unicode:uint, character:TMP_Character) : TMP_FontAsset
}
class "List`1"<T> {
}
TMP_TextElement_Legacy <|-- TMP_Glyph
TMP_FontWeightPair --> "regularTypeface" TMP_FontAsset
TMP_FontWeightPair --> "italicTypeface" TMP_FontAsset
KerningPair --> "firstGlyphAdjustments" GlyphValueRecord_Legacy
KerningPair --> "secondGlyphAdjustments" GlyphValueRecord_Legacy
KerningPair o-> "empty" KerningPair
KerningTable --> "kerningPairs<KerningPair>" "List`1"
class TMP_FontAssetUtilities {
    {static} TMP_FontAssetUtilities()
    + {static} GetCharacterFromFontAsset(unicode:uint, sourceFontAsset:TMP_FontAsset, includeFallbacks:bool, fontStyle:FontStyles, fontWeight:FontWeight, isAlternativeTypeface:bool) : TMP_Character
    + {static} GetCharacterFromFontAssets(unicode:uint, sourceFontAsset:TMP_FontAsset, fontAssets:List<TMP_FontAsset>, includeFallbacks:bool, fontStyle:FontStyles, fontWeight:FontWeight, isAlternativeTypeface:bool) : TMP_Character
    + {static} GetSpriteCharacterFromSpriteAsset(unicode:uint, spriteAsset:TMP_SpriteAsset, includeFallbacks:bool) : TMP_SpriteCharacter
    {static} GetSpriteCharacterFromSpriteAsset_Internal(unicode:uint, spriteAsset:TMP_SpriteAsset, includeFallbacks:bool) : TMP_SpriteCharacter
}
TMP_FontAssetUtilities --> "instance" TMP_FontAssetUtilities
enum FontFeatureLookupFlags {
    None=     0x0,
    IgnoreLigatures=   0x004,
    IgnoreSpacingAdjustments=   0x100,
}
class TMP_GlyphValueRecord <<struct>> {
    + xPlacement : float <<get>> <<set>>
    + yPlacement : float <<get>> <<set>>
    + xAdvance : float <<get>> <<set>>
    + yAdvance : float <<get>> <<set>>
    <<internal>> m_XPlacement : float
    <<internal>> m_YPlacement : float
    <<internal>> m_XAdvance : float
    <<internal>> m_YAdvance : float
    + TMP_GlyphValueRecord(xPlacement:float, yPlacement:float, xAdvance:float, yAdvance:float)
    <<internal>> TMP_GlyphValueRecord(valueRecord:GlyphValueRecord_Legacy)
    <<internal>> TMP_GlyphValueRecord(valueRecord:GlyphValueRecord)
}
class TMP_GlyphAdjustmentRecord <<struct>> {
    + glyphIndex : uint <<get>> <<set>>
    <<internal>> m_GlyphIndex : uint
    + TMP_GlyphAdjustmentRecord(glyphIndex:uint, glyphValueRecord:TMP_GlyphValueRecord)
    <<internal>> TMP_GlyphAdjustmentRecord(adjustmentRecord:GlyphAdjustmentRecord)
}
class TMP_GlyphPairAdjustmentRecord {
    + TMP_GlyphPairAdjustmentRecord(firstAdjustmentRecord:TMP_GlyphAdjustmentRecord, secondAdjustmentRecord:TMP_GlyphAdjustmentRecord)
    <<internal>> TMP_GlyphPairAdjustmentRecord(glyphPairAdjustmentRecord:GlyphPairAdjustmentRecord)
}
class GlyphPairKey <<struct>> {
    + firstGlyphIndex : uint
    + secondGlyphIndex : uint
    + key : uint
    + GlyphPairKey(firstGlyphIndex:uint, secondGlyphIndex:uint)
    <<internal>> GlyphPairKey(record:TMP_GlyphPairAdjustmentRecord)
}
TMP_GlyphAdjustmentRecord --> "glyphValueRecord" TMP_GlyphValueRecord
TMP_GlyphAdjustmentRecord --> "m_GlyphValueRecord" TMP_GlyphValueRecord
TMP_GlyphPairAdjustmentRecord --> "firstAdjustmentRecord" TMP_GlyphAdjustmentRecord
TMP_GlyphPairAdjustmentRecord --> "secondAdjustmentRecord" TMP_GlyphAdjustmentRecord
TMP_GlyphPairAdjustmentRecord --> "featureLookupFlags" FontFeatureLookupFlags
TMP_GlyphPairAdjustmentRecord --> "m_FirstAdjustmentRecord" TMP_GlyphAdjustmentRecord
TMP_GlyphPairAdjustmentRecord --> "m_SecondAdjustmentRecord" TMP_GlyphAdjustmentRecord
TMP_GlyphPairAdjustmentRecord --> "m_FeatureLookupFlags" FontFeatureLookupFlags
class TMP_FontFeatureTable {
    + TMP_FontFeatureTable()
    + SortGlyphPairAdjustmentRecords() : void
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
TMP_FontFeatureTable --> "glyphPairAdjustmentRecords<TMP_GlyphPairAdjustmentRecord>" "List`1"
TMP_FontFeatureTable --> "m_GlyphPairAdjustmentRecords<TMP_GlyphPairAdjustmentRecord>" "List`1"
TMP_FontFeatureTable --> "m_GlyphPairAdjustmentRecordLookupDictionary<uint,TMP_GlyphPairAdjustmentRecord>" "Dictionary`2"
class TMP_InputField {
    <<const>> kEmailSpecialCharacters : string = "!#$%&'*+-/=?^_`{|&#125;~"
    + shouldHideMobileInput : bool <<get>> <<set>>
    + shouldHideSoftKeyboard : bool <<get>> <<set>>
    + text : string <<get>> <<set>>
    + SetTextWithoutNotify(input:string) : void
    SetText(value:string, sendCallback:bool) : void
    + isFocused : bool <<get>>
    + caretBlinkRate : float <<get>> <<set>>
    + caretWidth : int <<get>> <<set>>
    + scrollSensitivity : float <<get>> <<set>>
    + customCaretColor : bool <<get>> <<set>>
    + characterLimit : int <<get>> <<set>>
    + pointSize : float <<get>> <<set>>
    + onFocusSelectAll : bool <<get>> <<set>>
    + resetOnDeActivation : bool <<get>> <<set>>
    + restoreOriginalTextOnEscape : bool <<get>> <<set>>
    + isRichTextEditingAllowed : bool <<get>> <<set>>
    + lineLimit : int <<get>> <<set>>
    + readOnly : bool <<get>> <<set>>
    + richText : bool <<get>> <<set>>
    + multiLine : bool <<get>>
    + asteriskChar : char <<get>> <<set>>
    + wasCanceled : bool <<get>>
    + caretPosition : int <<get>> <<set>>
    + selectionAnchorPosition : int <<get>> <<set>>
    + selectionFocusPosition : int <<get>> <<set>>
    + stringPosition : int <<get>> <<set>>
    + selectionStringAnchorPosition : int <<get>> <<set>>
    + selectionStringFocusPosition : int <<get>> <<set>>
    CaretBlink() : IEnumerator
    SetCaretVisible() : void
    SetCaretActive() : void
    + MoveTextEnd(shift:bool) : void
    + MoveTextStart(shift:bool) : void
    + MoveToEndOfLine(shift:bool, ctrl:bool) : void
    + MoveToStartOfLine(shift:bool, ctrl:bool) : void
    {static} clipboard : string <<get>> <<set>>
    UpdateStringPositionFromKeyboard() : void
    + <<virtual>> OnBeginDrag(eventData:PointerEventData) : void
    + <<virtual>> OnDrag(eventData:PointerEventData) : void
    MouseDragOutsideRect(eventData:PointerEventData) : IEnumerator
    + <<virtual>> OnEndDrag(eventData:PointerEventData) : void
    + <<override>> OnPointerDown(eventData:PointerEventData) : void
    + ProcessEvent(e:Event) : void
    + <<virtual>> OnUpdateSelected(eventData:BaseEventData) : void
    + <<virtual>> OnScroll(eventData:PointerEventData) : void
    UpdateScrollbar() : void
    OnScrollbarValueChange(value:float) : void
    UpdateMaskRegions() : void
    AdjustTextPositionRelativeToViewport(relativePosition:float) : void
    + ForceLabelUpdate() : void
    + <<virtual>> Rebuild(update:CanvasUpdate) : void
    + <<virtual>> LayoutComplete() : void
    + <<virtual>> GraphicUpdateComplete() : void
    + ActivateInputField() : void
    + <<override>> OnSelect(eventData:BaseEventData) : void
    + <<virtual>> OnPointerClick(eventData:PointerEventData) : void
    + OnControlClick() : void
    + ReleaseSelection() : void
    + DeactivateInputField(clearSelection:bool) : void
    + <<override>> OnDeselect(eventData:BaseEventData) : void
    + <<virtual>> OnSubmit(eventData:BaseEventData) : void
    SetTextComponentWrapMode() : void
    SetTextComponentRichTextMode() : void
    SetToCustomIfContentTypeIsNot(allowedContentTypes:ContentType[]) : void
    SetToCustom() : void
    SetToCustom(characterValidation:CharacterValidation) : void
    + <<virtual>> CalculateLayoutInputHorizontal() : void
    + <<virtual>> CalculateLayoutInputVertical() : void
    + <<virtual>> minWidth : float <<get>>
    + <<virtual>> preferredWidth : float <<get>>
    + <<virtual>> flexibleWidth : float <<get>>
    + <<virtual>> minHeight : float <<get>>
    + <<virtual>> preferredHeight : float <<get>>
    + <<virtual>> flexibleHeight : float <<get>>
    + <<virtual>> layoutPriority : int <<get>>
    + SetGlobalPointSize(pointSize:float) : void
    + SetGlobalFontAsset(fontAsset:TMP_FontAsset) : void
}
class SetPropertyUtility <<static>> {
    + {static} SetColor(currentValue:Color, newValue:Color) : bool
    + {static} SetEquatableStruct(currentValue:T, newValue:T) : bool
    + {static} SetStruct(currentValue:T, newValue:T) : bool
    + {static} SetClass(currentValue:T, newValue:T) : bool
}
enum ContentType {
    Standard,
    Autocorrected,
    IntegerNumber,
    DecimalNumber,
    Alphanumeric,
    Name,
    EmailAddress,
    Password,
    Pin,
    Custom,
}
enum InputType {
    Standard,
    AutoCorrect,
    Password,
}
enum CharacterValidation {
    None,
    Digit,
    Integer,
    Decimal,
    Alphanumeric,
    Name,
    Regex,
    EmailAddress,
    CustomValidator,
}
enum LineType {
    SingleLine,
    MultiLineSubmit,
    MultiLineNewline,
}
class SubmitEvent {
}
class OnChangeEvent {
}
class SelectionEvent {
}
class TextSelectionEvent {
}
class TouchScreenKeyboardEvent {
}
enum EditState {
    Continue,
    Finish,
}
class "UnityEvent`1"<T> {
}
class "UnityEvent`3"<T1,T2,T3> {
}
Selectable <|-- TMP_InputField
IUpdateSelectedHandler <|-- TMP_InputField
IBeginDragHandler <|-- TMP_InputField
IDragHandler <|-- TMP_InputField
IEndDragHandler <|-- TMP_InputField
IPointerClickHandler <|-- TMP_InputField
ISubmitHandler <|-- TMP_InputField
ICanvasElement <|-- TMP_InputField
ILayoutElement <|-- TMP_InputField
IScrollHandler <|-- TMP_InputField
TMP_InputField --> "textViewport" RectTransform
TMP_InputField --> "textComponent" TMP_Text
TMP_InputField --> "placeholder" Graphic
TMP_InputField --> "verticalScrollbar" Scrollbar
TMP_InputField --> "caretColor" Color
TMP_InputField --> "selectionColor" Color
TMP_InputField --> "onEndEdit" SubmitEvent
TMP_InputField --> "onSubmit" SubmitEvent
TMP_InputField --> "onSelect" SelectionEvent
TMP_InputField --> "onDeselect" SelectionEvent
TMP_InputField --> "onTextSelection" TextSelectionEvent
TMP_InputField --> "onEndTextSelection" TextSelectionEvent
TMP_InputField --> "onValueChanged" OnChangeEvent
TMP_InputField --> "onTouchScreenKeyboardStatusChanged" TouchScreenKeyboardEvent
TMP_InputField --> "onValidateInput" OnValidateInput
TMP_InputField --> "fontAsset" TMP_FontAsset
TMP_InputField --> "contentType" ContentType
TMP_InputField --> "lineType" LineType
TMP_InputField --> "inputType" InputType
TMP_InputField --> "keyboardType" TouchScreenKeyboardType
TMP_InputField --> "characterValidation" CharacterValidation
TMP_InputField --> "inputValidator" TMP_InputValidator
TMP_InputField +-- ContentType
TMP_InputField +-- InputType
TMP_InputField +-- CharacterValidation
TMP_InputField +-- LineType
TMP_InputField +-- SubmitEvent
"UnityEvent`1" "<string>" <|-- SubmitEvent
TMP_InputField +-- OnChangeEvent
"UnityEvent`1" "<string>" <|-- OnChangeEvent
TMP_InputField +-- SelectionEvent
"UnityEvent`1" "<string>" <|-- SelectionEvent
TMP_InputField +-- TextSelectionEvent
"UnityEvent`3" "<string,int,int>" <|-- TextSelectionEvent
TMP_InputField +-- TouchScreenKeyboardEvent
"UnityEvent`1" "<TouchScreenKeyboard.Status>" <|-- TouchScreenKeyboardEvent
TMP_InputField +-- EditState
abstract class TMP_InputValidator {
    + {abstract} Validate(text:string, pos:int, ch:char) : char
}
ScriptableObject <|-- TMP_InputValidator
class TMP_LineInfo <<struct>> {
    <<internal>> controlCharacterCount : int
    + characterCount : int
    + visibleCharacterCount : int
    + spaceCount : int
    + wordCount : int
    + firstCharacterIndex : int
    + firstVisibleCharacterIndex : int
    + lastCharacterIndex : int
    + lastVisibleCharacterIndex : int
    + length : float
    + lineHeight : float
    + ascender : float
    + baseline : float
    + descender : float
    + maxAdvance : float
    + width : float
    + marginLeft : float
    + marginRight : float
}
TMP_LineInfo --> "alignment" HorizontalAlignmentOptions
TMP_LineInfo --> "lineExtents" Extents
class "TMP_ListPool`1"<T> <<static>> {
    + {static} Get() : List<T>
    + {static} Release(toRelease:List<T>) : void
}
class TMP_MaterialManager <<static>> {
    {static} TMP_MaterialManager()
    {static} OnPreRender(cam:Camera) : void
    {static} OnPreRenderCanvas() : void
    + {static} GetStencilMaterial(baseMaterial:Material, stencilID:int) : Material
    + {static} ReleaseStencilMaterial(stencilMaterial:Material) : void
    + {static} GetBaseMaterial(stencilMaterial:Material) : Material
    + {static} SetStencil(material:Material, stencilID:int) : Material
    + {static} AddMaskingMaterial(baseMaterial:Material, stencilMaterial:Material, stencilID:int) : void
    + {static} RemoveStencilMaterial(stencilMaterial:Material) : void
    + {static} ReleaseBaseMaterial(baseMaterial:Material) : void
    + {static} ClearMaterials() : void
    + {static} GetStencilID(obj:GameObject) : int
    + {static} GetMaterialForRendering(graphic:MaskableGraphic, baseMaterial:Material) : Material
    <<internal>> {static} GetFallbackMaterial(fontAsset:TMP_FontAsset, sourceMaterial:Material, atlasIndex:int) : Material
    + {static} GetFallbackMaterial(sourceMaterial:Material, targetMaterial:Material) : Material
    + {static} AddFallbackMaterialReference(targetMaterial:Material) : void
    + {static} RemoveFallbackMaterialReference(targetMaterial:Material) : void
    + {static} CleanupFallbackMaterials() : void
    + {static} ReleaseFallbackMaterial(fallackMaterial:Material) : void
    + {static} CopyMaterialPresetProperties(source:Material, destination:Material) : void
}
class FallbackMaterial {
    + baseID : int
    + fallbackID : long
    + count : int
}
class MaskingMaterial {
    + count : int
    + stencilID : int
}
TMP_MaterialManager +-- FallbackMaterial
FallbackMaterial --> "baseMaterial" Material
FallbackMaterial --> "fallbackMaterial" Material
TMP_MaterialManager +-- MaskingMaterial
MaskingMaterial --> "baseMaterial" Material
MaskingMaterial --> "stencilMaterial" Material
enum VertexSortingOrder {
    Normal,
    Reverse,
}
class TMP_MeshInfo <<struct>> {
    + vertexCount : int
    + TMP_MeshInfo(mesh:Mesh, size:int)
    + TMP_MeshInfo(mesh:Mesh, size:int, isVolumetric:bool)
    + ResizeMeshInfo(size:int) : void
    + ResizeMeshInfo(size:int, isVolumetric:bool) : void
    + Clear() : void
    + Clear(uploadChanges:bool) : void
    + ClearUnusedVertices() : void
    + ClearUnusedVertices(startIndex:int) : void
    + ClearUnusedVertices(startIndex:int, updateMesh:bool) : void
    + SortGeometry(order:VertexSortingOrder) : void
    + SortGeometry(sortingOrder:IList<int>) : void
    + SwapVertexData(src:int, dst:int) : void
}
TMP_MeshInfo --> "mesh" Mesh
TMP_MeshInfo --> "material" Material
class "TMP_ObjectPool`1"<T> {
    + countAll : int <<get>>
    + countActive : int <<get>>
    + countInactive : int <<get>>
    + TMP_ObjectPool(actionOnGet:UnityAction<T>, actionOnRelease:UnityAction<T>)
    + Get() : T
    + Release(element:T) : void
}
class TMP_ResourceManager {
    {static} TMP_ResourceManager()
    <<internal>> {static} GetTextSettings() : TMP_Settings
    + {static} AddFontAsset(fontAsset:TMP_FontAsset) : void
    + {static} TryGetFontAsset(hashcode:int, fontAsset:TMP_FontAsset) : bool
    <<internal>> {static} RebuildFontAssetCache(instanceID:int) : void
}
enum TagHashCode {
    BOLD= 66,
    SLASH_BOLD= 1613,
    ITALIC= 73,
    SLASH_ITALIC= 1606,
    UNDERLINE= 85,
    SLASH_UNDERLINE= 1626,
    STRIKETHROUGH= 83,
    SLASH_STRIKETHROUGH= 1628,
    MARK= 2699125,
    SLASH_MARK= 57644506,
    SUBSCRIPT= 92132,
    SLASH_SUBSCRIPT= 1770219,
    SUPERSCRIPT= 92150,
    SLASH_SUPERSCRIPT= 1770233,
    COLOR= 81999901,
    SLASH_COLOR= 1909026194,
    ALPHA= 75165780,
    A= 65,
    SLASH_A= 1614,
    SIZE= 3061285,
    SLASH_SIZE= 58429962,
    SPRITE= -991527447,
    BR= 2256,
    NO_BREAK= 2856657,
    SLASH_NO_BREAK= 57477502,
    STYLE= 100252951,
    SLASH_STYLE= 1927738392,
    FONT= 2586451,
    SLASH_FONT= 57747708,
    SLASH_MATERIAL= -1100708252,
    LINK= 2656128,
    SLASH_LINK= 57686191,
    FONT_WEIGHT= -1889896162,
    SLASH_FONT_WEIGHT= -757976431,
    NO_PARSE= -408011596,
    SLASH_NO_PARSE= -294095813,
    POSITION= 85420,
    SLASH_POSITION= 1777699,
    VERTICAL_OFFSET= 1952379995,
    SLASH_VERTICAL_OFFSET= -11107948,
    SPACE= 100083556,
    SLASH_SPACE= 1927873067,
    PAGE= 2808691,
    SLASH_PAGE= 58683868,
    ALIGN= 75138797,
    SLASH_ALIGN= 1916026786,
    WIDTH= 105793766,
    SLASH_WIDTH= 1923459625,
    GRADIENT= -1999759898,
    SLASH_GRADIENT= -1854491959,
    CHARACTER_SPACE= -1584382009,
    SLASH_CHARACTER_SPACE= -1394426712,
    MONOSPACE= -1340221943,
    SLASH_MONOSPACE= -1638865562,
    CLASS= 82115566,
    INDENT= -1514123076,
    SLASH_INDENT= -1496889389,
    LINE_INDENT= -844305121,
    SLASH_LINE_INDENT= 93886352,
    MARGIN= -1355614050,
    SLASH_MARGIN= -1649644303,
    MARGIN_LEFT= -272933656,
    MARGIN_RIGHT= -447416589,
    LINE_HEIGHT= -799081892,
    SLASH_LINE_HEIGHT= 200452819,
    ACTION= -1827519330,
    SLASH_ACTION= -1187217679,
    SCALE= 100553336,
    SLASH_SCALE= 1928413879,
    ROTATE= -1000007783,
    SLASH_ROTATE= -764695562,
    LOWERCASE= -1506899689,
    SLASH_LOWERCASE= -1451284584,
    ALLCAPS= 218273952,
    SLASH_ALLCAPS= -797437649,
    UPPERCASE= -305409418,
    SLASH_UPPERCASE= -582368199,
    SMALLCAPS= -766062114,
    SLASH_SMALLCAPS= 199921873,
    LIGA= 2655971,
    SLASH_LIGA= 57686604,
    FRAC= 2598518,
    SLASH_FRAC= 57774681,
    NAME= 2875623,
    INDEX= 84268030,
    TINT= 2960519,
    ANIM= 2283339,
    MATERIAL= 825491659,
    HREF= 2535353,
    RED= 91635,
    GREEN= 87065851,
    BLUE= 2457214,
    YELLOW= -882444668,
    ORANGE= -1108587920,
    BLACK= 81074727,
    WHITE= 105680263,
    PURPLE= -1250222130,
    LEFT= 2660507,
    RIGHT= 99937376,
    CENTER= -1591113269,
    JUSTIFIED= 817091359,
    FLUSH= 85552164,
    PLUS= 43,
    MINUS= 45,
    PX= 2568,
    PLUS_PX= 49507,
    MINUS_PX= 47461,
    EM= 2216,
    PLUS_EM= 49091,
    MINUS_EM= 46789,
    PCT= 85031,
    PLUS_PCT= 1634348,
    MINUS_PCT= 1567082,
    PERCENTAGE= 37,
    PLUS_PERCENTAGE= 1454,
    MINUS_PERCENTAGE= 1512,
    TRUE= 2932022,
    FALSE= 85422813,
    NORMAL= -1183493901,
    DEFAULT= -620974005,
}
enum TagValueType {
    None= 0x0,
    NumericalValue= 0x1,
    StringValue= 0x2,
    ColorValue= 0x4,
}
enum TagUnitType {
    Pixels= 0x0,
    FontUnits= 0x1,
    Percentage= 0x2,
}
enum Unicode {
    SPACE= 0x20,
    DOUBLE_QUOTE= 0x22,
    NUMBER_SIGN= 0x23,
    PERCENTAGE= 0x25,
    PLUS= 0x2B,
    MINUS= 0x2D,
    PERIOD= 0x2E,
    HYPHEN_MINUS= 0x2D,
    SOFT_HYPHEN= 0xAD,
    HYPHEN= 0x2010,
    NON_BREAKING_HYPHEN= 0x2011,
    ZERO_WIDTH_SPACE= 0x200B,
    RIGHT_SINGLE_QUOTATION= 0x2019,
    APOSTROPHE= 0x27,
    WORD_JOINER= 0x2060,
}
class TMP_ScrollbarEventHandler {
    + isSelected : bool
    + OnPointerClick(eventData:PointerEventData) : void
    + OnSelect(eventData:BaseEventData) : void
    + OnDeselect(eventData:BaseEventData) : void
}
MonoBehaviour <|-- TMP_ScrollbarEventHandler
IPointerClickHandler <|-- TMP_ScrollbarEventHandler
ISelectHandler <|-- TMP_ScrollbarEventHandler
IDeselectHandler <|-- TMP_ScrollbarEventHandler
class TMP_SelectionCaret {
    + <<override>> Cull(clipRect:Rect, validRect:bool) : void
}
MaskableGraphic <|-- TMP_SelectionCaret
class TMP_Settings {
    + {static} version : string <<get>>
    + {static} enableWordWrapping : bool <<get>>
    + {static} enableKerning : bool <<get>>
    + {static} enableExtraPadding : bool <<get>>
    + {static} enableTintAllSprites : bool <<get>>
    + {static} enableParseEscapeCharacters : bool <<get>>
    + {static} enableRaycastTarget : bool <<get>>
    + {static} getFontFeaturesAtRuntime : bool <<get>>
    + {static} missingGlyphCharacter : int <<get>> <<set>>
    + {static} warningsDisabled : bool <<get>>
    + {static} defaultFontAssetPath : string <<get>>
    + {static} defaultFontSize : float <<get>>
    + {static} defaultTextAutoSizingMinRatio : float <<get>>
    + {static} defaultTextAutoSizingMaxRatio : float <<get>>
    + {static} autoSizeTextContainer : bool <<get>>
    + {static} isTextObjectScaleStatic : bool <<get>> <<set>>
    + {static} matchMaterialPreset : bool <<get>>
    + {static} defaultSpriteAssetPath : string <<get>>
    + {static} enableEmojiSupport : bool <<get>> <<set>>
    + {static} missingCharacterSpriteUnicode : uint <<get>> <<set>>
    + {static} defaultColorGradientPresetsPath : string <<get>>
    + {static} styleSheetsResourcePath : string <<get>>
    + {static} useModernHangulLineBreakingRules : bool <<get>> <<set>>
    + {static} LoadDefaultSettings() : TMP_Settings
    + {static} GetSettings() : TMP_Settings
    + {static} GetFontAsset() : TMP_FontAsset
    + {static} GetSpriteAsset() : TMP_SpriteAsset
    + {static} GetStyleSheet() : TMP_StyleSheet
    + {static} LoadLinebreakingRules() : void
}
class "List`1"<T> {
}
class LineBreakingTable {
}
class "Dictionary`2"<T1,T2> {
}
ScriptableObject <|-- TMP_Settings
TMP_Settings --> "defaultFontAsset" TMP_FontAsset
TMP_Settings --> "defaultTextMeshProTextContainerSize" Vector2
TMP_Settings --> "defaultTextMeshProUITextContainerSize" Vector2
TMP_Settings --> "fallbackFontAssets<TMP_FontAsset>" "List`1"
TMP_Settings --> "defaultSpriteAsset" TMP_SpriteAsset
TMP_Settings --> "defaultStyleSheet" TMP_StyleSheet
TMP_Settings --> "leadingCharacters" TextAsset
TMP_Settings --> "followingCharacters" TextAsset
TMP_Settings --> "linebreakingRules" LineBreakingTable
TMP_Settings --> "instance" TMP_Settings
TMP_Settings +-- LineBreakingTable
LineBreakingTable --> "leadingCharacters<int,char>" "Dictionary`2"
LineBreakingTable --> "followingCharacters<int,char>" "Dictionary`2"
class ShaderUtilities <<static>> {
    + {static} ID_MainTex : int
    + {static} ID_FaceTex : int
    + {static} ID_FaceColor : int
    + {static} ID_FaceDilate : int
    + {static} ID_Shininess : int
    + {static} ID_UnderlayColor : int
    + {static} ID_UnderlayOffsetX : int
    + {static} ID_UnderlayOffsetY : int
    + {static} ID_UnderlayDilate : int
    + {static} ID_UnderlaySoftness : int
    + {static} ID_WeightNormal : int
    + {static} ID_WeightBold : int
    + {static} ID_OutlineTex : int
    + {static} ID_OutlineWidth : int
    + {static} ID_OutlineSoftness : int
    + {static} ID_OutlineColor : int
    + {static} ID_Outline2Color : int
    + {static} ID_Outline2Width : int
    + {static} ID_Padding : int
    + {static} ID_GradientScale : int
    + {static} ID_ScaleX : int
    + {static} ID_ScaleY : int
    + {static} ID_PerspectiveFilter : int
    + {static} ID_Sharpness : int
    + {static} ID_TextureWidth : int
    + {static} ID_TextureHeight : int
    + {static} ID_BevelAmount : int
    + {static} ID_GlowColor : int
    + {static} ID_GlowOffset : int
    + {static} ID_GlowPower : int
    + {static} ID_GlowOuter : int
    + {static} ID_GlowInner : int
    + {static} ID_LightAngle : int
    + {static} ID_EnvMap : int
    + {static} ID_EnvMatrix : int
    + {static} ID_EnvMatrixRotation : int
    + {static} ID_MaskCoord : int
    + {static} ID_ClipRect : int
    + {static} ID_MaskSoftnessX : int
    + {static} ID_MaskSoftnessY : int
    + {static} ID_VertexOffsetX : int
    + {static} ID_VertexOffsetY : int
    + {static} ID_UseClipRect : int
    + {static} ID_StencilID : int
    + {static} ID_StencilOp : int
    + {static} ID_StencilComp : int
    + {static} ID_StencilReadMask : int
    + {static} ID_StencilWriteMask : int
    + {static} ID_ShaderFlags : int
    + {static} ID_ScaleRatio_A : int
    + {static} ID_ScaleRatio_B : int
    + {static} ID_ScaleRatio_C : int
    + {static} Keyword_Bevel : string = "BEVEL_ON"
    + {static} Keyword_Glow : string = "GLOW_ON"
    + {static} Keyword_Underlay : string = "UNDERLAY_ON"
    + {static} Keyword_Ratios : string = "RATIOS_OFF"
    + {static} Keyword_MASK_SOFT : string = "MASK_SOFT"
    + {static} Keyword_MASK_HARD : string = "MASK_HARD"
    + {static} Keyword_MASK_TEX : string = "MASK_TEX"
    + {static} Keyword_Outline : string = "OUTLINE_ON"
    + {static} ShaderTag_ZTestMode : string = "unity_GUIZTestMode"
    + {static} ShaderTag_CullMode : string = "_CullMode"
    + {static} isInitialized : bool = false
    {static} ShaderUtilities()
    + {static} GetShaderPropertyIDs() : void
    + {static} UpdateShaderRatios(mat:Material) : void
    + {static} GetFontExtent(material:Material) : Vector4
    + {static} IsMaskingEnabled(material:Material) : bool
    + {static} GetPadding(material:Material, enableExtraPadding:bool, isBold:bool) : float
    + {static} GetPadding(materials:Material[], enableExtraPadding:bool, isBold:bool) : float
}
ShaderUtilities --> "ShaderRef_MobileSDF" Shader
ShaderUtilities --> "k_ShaderRef_MobileSDF" Shader
ShaderUtilities --> "ShaderRef_MobileBitmap" Shader
ShaderUtilities --> "k_ShaderRef_MobileBitmap" Shader
class TMP_Sprite {
    + name : string
    + hashCode : int
    + unicode : int
}
TMP_TextElement_Legacy <|-- TMP_Sprite
TMP_Sprite --> "pivot" Vector2
TMP_Sprite --> "sprite" Sprite
class TMP_SpriteAnimator {
    Awake() : void
    OnEnable() : void
    OnDisable() : void
    + StopAllAnimations() : void
    + DoSpriteAnimation(currentCharacter:int, spriteAsset:TMP_SpriteAsset, start:int, end:int, framerate:int) : void
    DoSpriteAnimationInternal(currentCharacter:int, spriteAsset:TMP_SpriteAsset, start:int, end:int, framerate:int) : IEnumerator
}
MonoBehaviour <|-- TMP_SpriteAnimator
class TMP_SpriteAsset {
    + version : string <<get>> <<internal set>>
    <<internal>> m_IsSpriteAssetLookupTablesDirty : bool = false
    Awake() : void
    GetDefaultSpriteMaterial() : Material
    + UpdateLookupTables() : void
    + GetSpriteIndexFromHashcode(hashCode:int) : int
    + GetSpriteIndexFromUnicode(unicode:uint) : int
    + GetSpriteIndexFromName(name:string) : int
    + {static} SearchForSpriteByUnicode(spriteAsset:TMP_SpriteAsset, unicode:uint, includeFallbacks:bool, spriteIndex:int) : TMP_SpriteAsset
    + {static} SearchForSpriteByHashCode(spriteAsset:TMP_SpriteAsset, hashCode:int, includeFallbacks:bool, spriteIndex:int) : TMP_SpriteAsset
    + SortGlyphTable() : void
    <<internal>> SortCharacterTable() : void
    <<internal>> SortGlyphAndCharacterTables() : void
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
TMP_Asset <|-- TMP_SpriteAsset
TMP_SpriteAsset --> "m_NameLookup<int,int>" "Dictionary`2"
TMP_SpriteAsset --> "m_GlyphIndexLookup<uint,int>" "Dictionary`2"
TMP_SpriteAsset --> "faceInfo" FaceInfo
TMP_SpriteAsset --> "m_FaceInfo" FaceInfo
TMP_SpriteAsset --> "spriteSheet" Texture
TMP_SpriteAsset --> "spriteCharacterTable<TMP_SpriteCharacter>" "List`1"
TMP_SpriteAsset --> "spriteCharacterLookupTable<uint,TMP_SpriteCharacter>" "Dictionary`2"
TMP_SpriteAsset --> "m_SpriteCharacterLookup<uint,TMP_SpriteCharacter>" "Dictionary`2"
TMP_SpriteAsset --> "spriteGlyphTable<TMP_SpriteGlyph>" "List`1"
TMP_SpriteAsset --> "m_SpriteGlyphLookup<uint,TMP_SpriteGlyph>" "Dictionary`2"
TMP_SpriteAsset --> "spriteInfoList<TMP_Sprite>" "List`1"
TMP_SpriteAsset --> "fallbackSpriteAssets<TMP_SpriteAsset>" "List`1"
enum SpriteAssetImportFormats {
    None= 0,
    TexturePackerJsonArray= 0x1,
}
class TexturePacker_JsonArray {
}
class SpriteFrame <<struct>> {
    + x : float
    + y : float
    + w : float
    + h : float
    + <<override>> ToString() : string
}
class SpriteSize <<struct>> {
    + w : float
    + h : float
    + <<override>> ToString() : string
}
class Frame <<struct>> {
    + filename : string
    + rotated : bool
    + trimmed : bool
}
class Meta <<struct>> {
    + app : string
    + version : string
    + image : string
    + format : string
    + scale : float
    + smartupdate : string
}
class SpriteDataObject {
}
class "List`1"<T> {
}
TexturePacker_JsonArray +-- SpriteFrame
TexturePacker_JsonArray +-- SpriteSize
TexturePacker_JsonArray +-- Frame
Frame --> "frame" SpriteFrame
Frame --> "spriteSourceSize" SpriteFrame
Frame --> "sourceSize" SpriteSize
Frame --> "pivot" Vector2
TexturePacker_JsonArray +-- Meta
Meta --> "size" SpriteSize
TexturePacker_JsonArray +-- SpriteDataObject
SpriteDataObject --> "frames<Frame>" "List`1"
SpriteDataObject --> "meta" Meta
class TMP_SpriteCharacter {
    + name : string <<get>> <<set>>
    + hashCode : int <<get>>
    + TMP_SpriteCharacter()
    + TMP_SpriteCharacter(unicode:uint, glyph:TMP_SpriteGlyph)
    + TMP_SpriteCharacter(unicode:uint, spriteAsset:TMP_SpriteAsset, glyph:TMP_SpriteGlyph)
    <<internal>> TMP_SpriteCharacter(unicode:uint, glyphIndex:uint)
}
TMP_TextElement <|-- TMP_SpriteCharacter
class TMP_SpriteGlyph {
    + TMP_SpriteGlyph()
    + TMP_SpriteGlyph(index:uint, metrics:GlyphMetrics, glyphRect:GlyphRect, scale:float, atlasIndex:int)
    + TMP_SpriteGlyph(index:uint, metrics:GlyphMetrics, glyphRect:GlyphRect, scale:float, atlasIndex:int, sprite:Sprite)
}
Glyph <|-- TMP_SpriteGlyph
TMP_SpriteGlyph --> "sprite" Sprite
class TMP_Style {
    + name : string <<get>> <<set>>
    + hashCode : int <<get>> <<set>>
    + styleOpeningDefinition : string <<get>>
    + styleClosingDefinition : string <<get>>
    <<internal>> TMP_Style(styleName:string, styleOpeningDefinition:string, styleClosingDefinition:string)
    + RefreshStyle() : void
}
TMP_Style --> "NormalStyle" TMP_Style
TMP_Style --> "k_NormalStyle" TMP_Style
class TMP_StyleSheet {
    + GetStyle(hashCode:int) : TMP_Style
    + GetStyle(name:string) : TMP_Style
    + RefreshStyles() : void
}
class "List`1"<T> {
}
ScriptableObject <|-- TMP_StyleSheet
TMP_StyleSheet --> "styles<TMP_Style>" "List`1"
class TMP_SubMesh {
    + isDefaultMaterial : bool <<get>> <<set>>
    + padding : float <<get>> <<set>>
    + {static} AddSubTextObject(textComponent:TextMeshPro, materialReference:MaterialReference) : TMP_SubMesh
    OnEnable() : void
    OnDisable() : void
    OnDestroy() : void
    + DestroySelf() : void
    GetMaterial(mat:Material) : Material
    CreateMaterialInstance(source:Material) : Material
    GetSharedMaterial() : Material
    SetSharedMaterial(mat:Material) : void
    + GetPaddingForMaterial() : float
    + UpdateMeshPadding(isExtraPadding:bool, isUsingBold:bool) : void
    + SetVerticesDirty() : void
    + SetMaterialDirty() : void
}
MonoBehaviour <|-- TMP_SubMesh
TMP_SubMesh --> "fontAsset" TMP_FontAsset
TMP_SubMesh --> "spriteAsset" TMP_SpriteAsset
TMP_SubMesh --> "material" Material
TMP_SubMesh --> "sharedMaterial" Material
TMP_SubMesh --> "fallbackMaterial" Material
TMP_SubMesh --> "fallbackSourceMaterial" Material
TMP_SubMesh --> "renderer" Renderer
TMP_SubMesh --> "meshFilter" MeshFilter
TMP_SubMesh --> "mesh" Mesh
TMP_SubMesh --> "textComponent" TMP_Text
class TMP_SubMeshUI {
    + isDefaultMaterial : bool <<get>> <<set>>
    + padding : float <<get>> <<set>>
    + {static} AddSubTextObject(textComponent:TextMeshProUGUI, materialReference:MaterialReference) : TMP_SubMeshUI
    + <<override>> GetModifiedMaterial(baseMaterial:Material) : Material
    + GetPaddingForMaterial() : float
    + GetPaddingForMaterial(mat:Material) : float
    + UpdateMeshPadding(isExtraPadding:bool, isUsingBold:bool) : void
    + <<override>> SetAllDirty() : void
    + <<override>> SetVerticesDirty() : void
    + <<override>> SetLayoutDirty() : void
    + <<override>> SetMaterialDirty() : void
    + SetPivotDirty() : void
    GetRootCanvasTransform() : Transform
    + <<override>> Cull(clipRect:Rect, validRect:bool) : void
    + <<override>> Rebuild(update:CanvasUpdate) : void
    + RefreshMaterial() : void
    + <<override>> RecalculateClipping() : void
    GetMaterial() : Material
    GetMaterial(mat:Material) : Material
    CreateMaterialInstance(source:Material) : Material
    GetSharedMaterial() : Material
    SetSharedMaterial(mat:Material) : void
}
MaskableGraphic <|-- TMP_SubMeshUI
TMP_SubMeshUI --> "fontAsset" TMP_FontAsset
TMP_SubMeshUI --> "spriteAsset" TMP_SpriteAsset
TMP_SubMeshUI --> "mainTexture" Texture
TMP_SubMeshUI --> "material" Material
TMP_SubMeshUI --> "sharedMaterial" Material
TMP_SubMeshUI --> "fallbackMaterial" Material
TMP_SubMeshUI --> "fallbackSourceMaterial" Material
TMP_SubMeshUI --> "materialForRendering" Material
TMP_SubMeshUI --> "mesh" Mesh
TMP_SubMeshUI --> "textComponent" TMP_Text
interface ITextElement {
    Rebuild(update:CanvasUpdate) : void
    GetInstanceID() : int
}
enum TextAlignmentOptions {
    TopLeft= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Top,
    Top= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Top,
    TopRight= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Top,
    TopJustified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Top,
    TopFlush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Top,
    TopGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Top,
    Left= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Middle,
    Center= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Middle,
    Right= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Middle,
    Justified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Middle,
    Flush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Middle,
    CenterGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Middle,
    BottomLeft= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Bottom,
    Bottom= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Bottom,
    BottomRight= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Bottom,
    BottomJustified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Bottom,
    BottomFlush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Bottom,
    BottomGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Bottom,
    BaselineLeft= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Baseline,
    Baseline= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Baseline,
    BaselineRight= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Baseline,
    BaselineJustified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Baseline,
    BaselineFlush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Baseline,
    BaselineGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Baseline,
    MidlineLeft= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Geometry,
    Midline= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Geometry,
    MidlineRight= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Geometry,
    MidlineJustified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Geometry,
    MidlineFlush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Geometry,
    MidlineGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Geometry,
    CaplineLeft= HorizontalAlignmentOptions.Left | VerticalAlignmentOptions.Capline,
    Capline= HorizontalAlignmentOptions.Center | VerticalAlignmentOptions.Capline,
    CaplineRight= HorizontalAlignmentOptions.Right | VerticalAlignmentOptions.Capline,
    CaplineJustified= HorizontalAlignmentOptions.Justified | VerticalAlignmentOptions.Capline,
    CaplineFlush= HorizontalAlignmentOptions.Flush | VerticalAlignmentOptions.Capline,
    CaplineGeoAligned= HorizontalAlignmentOptions.Geometry | VerticalAlignmentOptions.Capline,
    Converted= 0xFFFF,
}
enum HorizontalAlignmentOptions {
    Left= 0x1,
    Center= 0x2,
    Right= 0x4,
    Justified= 0x8,
    Flush= 0x10,
    Geometry= 0x20,
}
enum VerticalAlignmentOptions {
    Top= 0x100,
    Middle= 0x200,
    Bottom= 0x400,
    Baseline= 0x800,
    Geometry= 0x1000,
    Capline= 0x2000,
}
enum TextRenderFlags {
    DontRender= 0x0,
    Render= 0xFF,
}
enum TMP_TextElementType {
    Character,
    Sprite,
}
enum MaskingTypes {
    MaskOff= 0,
    MaskHard= 1,
    MaskSoft= 2,
}
enum TextOverflowModes {
    Overflow= 0,
    Ellipsis= 1,
    Masking= 2,
    Truncate= 3,
    ScrollRect= 4,
    Page= 5,
    Linked= 6,
}
enum MaskingOffsetMode {
    Percentage= 0,
    Pixel= 1,
}
enum TextureMappingOptions {
    Character= 0,
    Line= 1,
    Paragraph= 2,
    MatchAspect= 3,
}
enum FontStyles {
    Normal= 0x0,
    Bold= 0x1,
    Italic= 0x2,
    Underline= 0x4,
    LowerCase= 0x8,
    UpperCase= 0x10,
    SmallCaps= 0x20,
    Strikethrough= 0x40,
    Superscript= 0x80,
    Subscript= 0x100,
    Highlight= 0x200,
}
enum FontWeight {
    Thin= 100,
    ExtraLight= 200,
    Light= 300,
    Regular= 400,
    Medium= 500,
    SemiBold= 600,
    Bold= 700,
    Heavy= 800,
    Black= 900,
}
abstract class TMP_Text {
    + <<virtual>> text : string <<get>> <<set>>
    + isRightToLeftText : bool <<get>> <<set>>
    + alpha : float <<get>> <<set>>
    + enableVertexGradient : bool <<get>> <<set>>
    + tintAllSprites : bool <<get>> <<set>>
    + overrideColorTags : bool <<get>> <<set>>
    + outlineWidth : float <<get>> <<set>>
    + fontSize : float <<get>> <<set>>
    + fontScale : float <<get>>
    + pixelsPerUnit : float <<get>>
    + enableAutoSizing : bool <<get>> <<set>>
    + fontSizeMin : float <<get>> <<set>>
    + fontSizeMax : float <<get>> <<set>>
    + isUsingBold : bool <<get>>
    + characterSpacing : float <<get>> <<set>>
    + wordSpacing : float <<get>> <<set>>
    + lineSpacing : float <<get>> <<set>>
    + lineSpacingAdjustment : float <<get>> <<set>>
    + paragraphSpacing : float <<get>> <<set>>
    + characterWidthAdjustment : float <<get>> <<set>>
    + enableWordWrapping : bool <<get>> <<set>>
    + wordWrappingRatios : float <<get>> <<set>>
    + isTextOverflowing : bool <<get>>
    + firstOverflowCharacterIndex : int <<get>>
    + isTextTruncated : bool <<get>>
    + enableKerning : bool <<get>> <<set>>
    + extraPadding : bool <<get>> <<set>>
    + richText : bool <<get>> <<set>>
    + parseCtrlCharacters : bool <<get>> <<set>>
    + isOverlay : bool <<get>> <<set>>
    + isOrthographic : bool <<get>> <<set>>
    + enableCulling : bool <<get>> <<set>>
    + ignoreVisibility : bool <<get>> <<set>>
    + mappingUvLineOffset : float <<get>> <<set>>
    + isTextObjectScaleStatic : bool <<get>> <<set>>
    + vertexBufferAutoSizeReduction : bool <<get>> <<set>>
    + firstVisibleCharacter : int <<get>> <<set>>
    + maxVisibleCharacters : int <<get>> <<set>>
    + maxVisibleWords : int <<get>> <<set>>
    + maxVisibleLines : int <<get>> <<set>>
    + useMaxVisibleDescender : bool <<get>> <<set>>
    + pageToDisplay : int <<get>> <<set>>
    + havePropertiesChanged : bool <<get>> <<set>>
    + isUsingLegacyAnimationComponent : bool <<get>> <<set>>
    + <<virtual>> autoSizeTextContainer : bool <<get>> <<set>>
    + isVolumetricText : bool <<get>> <<set>>
    + {static}  <<event>> OnFontAssetRequest : Func<int, string, TMP_FontAsset> 
    + {static}  <<event>> OnSpriteAssetRequest : Func<int, string, TMP_SpriteAsset> 
    + <<virtual>>  <<event>> OnPreRenderText : Action<TMP_TextInfo> 
    + flexibleHeight : float <<get>>
    + flexibleWidth : float <<get>>
    + minWidth : float <<get>>
    + minHeight : float <<get>>
    + maxWidth : float <<get>>
    + maxHeight : float <<get>>
    + <<virtual>> preferredWidth : float <<get>>
    + <<virtual>> preferredHeight : float <<get>>
    + <<virtual>> renderedWidth : float <<get>>
    + <<virtual>> renderedHeight : float <<get>>
    + layoutPriority : int <<get>>
    <<internal>> m_isWaitingOnResourceLoad : bool
    <<internal>> m_isInputParsingRequired : bool = false
    <<internal>> <<virtual>> UpdateCulling() : void
    + <<virtual>> ForceMeshUpdate(ignoreActiveState:bool, forceTextReparsing:bool) : void
    <<internal>> SetTextInternal(text:string) : void
    + <<virtual>> UpdateGeometry(mesh:Mesh, index:int) : void
    + <<virtual>> UpdateVertexData(flags:TMP_VertexDataUpdateFlags) : void
    + <<virtual>> UpdateVertexData() : void
    + <<virtual>> SetVertices(vertices:Vector3[]) : void
    + <<virtual>> UpdateMeshPadding() : void
    + <<override>> CrossFadeColor(targetColor:Color, duration:float, ignoreTimeScale:bool, useAlpha:bool) : void
    + <<override>> CrossFadeAlpha(alpha:float, duration:float, ignoreTimeScale:bool) : void
    + SetText(text:string, syncTextInputBox:bool) : void
    + SetText(text:string, arg0:float) : void
    + SetText(text:string, arg0:float, arg1:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float, arg3:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float, arg3:float, arg4:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float, arg3:float, arg4:float, arg5:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float, arg3:float, arg4:float, arg5:float, arg6:float) : void
    + SetText(text:string, arg0:float, arg1:float, arg2:float, arg3:float, arg4:float, arg5:float, arg6:float, arg7:float) : void
    + SetText(text:StringBuilder) : void
    + SetText(text:char[]) : void
    + SetText(text:char[], start:int, length:int) : void
    + SetCharArray(sourceText:char[]) : void
    + SetCharArray(sourceText:char[], start:int, length:int) : void
    + SetCharArray(sourceText:int[], start:int, length:int) : void
    ReplaceOpeningStyleTag(sourceText:string, srcIndex:int, srcOffset:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceOpeningStyleTag(sourceText:int[], srcIndex:int, srcOffset:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceOpeningStyleTag(sourceText:char[], srcIndex:int, srcOffset:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceOpeningStyleTag(sourceText:StringBuilder, srcIndex:int, srcOffset:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceClosingStyleTag(sourceText:string, srcIndex:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceClosingStyleTag(sourceText:int[], srcIndex:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceClosingStyleTag(sourceText:char[], srcIndex:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    ReplaceClosingStyleTag(sourceText:StringBuilder, srcIndex:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    GetStyle(hashCode:int) : TMP_Style
    InsertOpeningStyleTag(style:TMP_Style, srcIndex:int, charBuffer:UnicodeChar[], writeIndex:int) : bool
    InsertClosingStyleTag(charBuffer:UnicodeChar[], writeIndex:int) : bool
    IsTagName(text:string, tag:string, index:int) : bool
    IsTagName(text:char[], tag:string, index:int) : bool
    IsTagName(text:int[], tag:string, index:int) : bool
    IsTagName(text:StringBuilder, tag:string, index:int) : bool
    GetTagHashCode(text:string, index:int, closeIndex:int) : int
    GetTagHashCode(text:char[], index:int, closeIndex:int) : int
    GetTagHashCode(text:int[], index:int, closeIndex:int) : int
    GetTagHashCode(text:StringBuilder, index:int, closeIndex:int) : int
    ResizeInternalArray(array:T[]) : void
    ResizeInternalArray(array:T[], size:int) : void
    AddFloatToCharArray(value:float, padding:int, precision:int, writeIndex:int) : void
    AddIntegerToCharArray(number:double, padding:int, writeIndex:int) : void
    + GetPreferredValues() : Vector2
    + GetPreferredValues(width:float, height:float) : Vector2
    + GetPreferredValues(text:string) : Vector2
    + GetPreferredValues(text:string, width:float, height:float) : Vector2
    GetPreferredWidth(margin:Vector2) : float
    GetPreferredHeight(margin:Vector2) : float
    + GetRenderedValues() : Vector2
    + GetRenderedValues(onlyVisibleCharacters:bool) : Vector2
    GetRenderedWidth() : float
    GetRenderedHeight() : float
    <<internal>> <<virtual>> GetCanvasSpaceClippingRect() : Rect
    + <<virtual>> GetTextInfo(text:string) : TMP_TextInfo
    + <<virtual>> ComputeMarginSize() : void
    <<internal>> GetTextElement(unicode:uint, fontAsset:TMP_FontAsset, fontStyle:FontStyles, fontWeight:FontWeight, isUsingAlternativeTypeface:bool) : TMP_TextElement
    + <<virtual>> ClearMesh() : void
    + <<virtual>> ClearMesh(uploadGeometry:bool) : void
    + <<virtual>> GetParsedText() : string
    <<internal>> IsSelfOrLinkedAncestor(targetTextComponent:TMP_Text) : bool
    <<internal>> ReleaseLinkedTextComponent(targetTextComponent:TMP_Text) : void
    <<internal>> <<virtual>> InternalUpdate() : void
    GetAttributeParameters(chars:char[], startIndex:int, length:int, parameters:float[]) : int
}
class CharacterSubstitution <<struct>> {
    + index : int
    + unicode : uint
    + CharacterSubstitution(index:int, unicode:uint)
}
enum TextInputSources {
    Text= 0,
    SetText= 1,
    SetCharArray= 2,
    String= 3,
}
class UnicodeChar <<struct>> {
    + unicode : int
    + stringIndex : int
    + length : int
}
class SpecialCharacter <<struct>> {
    + materialIndex : int
    + SpecialCharacter(character:TMP_Character, materialIndex:int)
}
class "TMP_TextProcessingStack`1"<T> {
}
ITextElement --> "sharedMaterial" Material
MaskableGraphic <|-- TMP_Text
TMP_Text --> "textPreprocessor" ITextPreprocessor
TMP_Text --> "font" TMP_FontAsset
TMP_Text --> "fontSharedMaterial" Material
TMP_Text --> "fontMaterial" Material
TMP_Text --> "color" Color
TMP_Text --> "colorGradient" VertexGradient
TMP_Text --> "colorGradientPreset" TMP_ColorGradient
TMP_Text --> "spriteAsset" TMP_SpriteAsset
TMP_Text --> "styleSheet" TMP_StyleSheet
TMP_Text --> "textStyle" TMP_Style
TMP_Text --> "m_TextStyle" TMP_Style
TMP_Text --> "faceColor" Color32
TMP_Text --> "outlineColor" Color32
TMP_Text --> "fontWeight" FontWeight
TMP_Text --> "fontStyle" FontStyles
TMP_Text --> "horizontalAlignment" HorizontalAlignmentOptions
TMP_Text --> "verticalAlignment" VerticalAlignmentOptions
TMP_Text --> "alignment" TextAlignmentOptions
TMP_Text --> "overflowMode" TextOverflowModes
TMP_Text --> "linkedTextComponent" TMP_Text
TMP_Text --> "parentLinkedComponent" TMP_Text
TMP_Text --> "horizontalMapping" TextureMappingOptions
TMP_Text --> "verticalMapping" TextureMappingOptions
TMP_Text --> "renderMode" TextRenderFlags
TMP_Text --> "geometrySortingOrder" VertexSortingOrder
TMP_Text --> "margin" Vector4
TMP_Text --> "textInfo" TMP_TextInfo
TMP_Text --> "transform" Transform
TMP_Text --> "rectTransform" RectTransform
TMP_Text --> "mesh" Mesh
TMP_Text --> "bounds" Bounds
TMP_Text --> "textBounds" Bounds
TMP_Text --> "m_inputSource" TextInputSources
TMP_Text o-> "m_EllipsisInsertionCandidateStack<WordWrapState>" "TMP_TextProcessingStack`1"
TMP_Text +-- CharacterSubstitution
TMP_Text +-- TextInputSources
TMP_Text +-- UnicodeChar
TMP_Text +-- SpecialCharacter
SpecialCharacter --> "character" TMP_Character
SpecialCharacter --> "fontAsset" TMP_FontAsset
SpecialCharacter --> "material" Material
enum TextElementType {
    Character= 0x1,
    Sprite= 0x2,
}
class TMP_TextElement {
    + unicode : uint <<get>> <<set>>
    + glyphIndex : uint <<get>> <<set>>
    + scale : float <<get>> <<set>>
    <<internal>> m_Unicode : uint
    <<internal>> m_GlyphIndex : uint
    <<internal>> m_Scale : float
}
TMP_TextElement --> "elementType" TextElementType
TMP_TextElement --> "textAsset" TMP_Asset
TMP_TextElement --> "glyph" Glyph
TMP_TextElement --> "m_TextAsset" TMP_Asset
TMP_TextElement --> "m_Glyph" Glyph
class TMP_TextElement_Legacy {
    + id : int
    + x : float
    + y : float
    + width : float
    + height : float
    + xOffset : float
    + yOffset : float
    + xAdvance : float
    + scale : float
}
class TMP_TextInfo {
    + characterCount : int
    + spriteCount : int
    + spaceCount : int
    + wordCount : int
    + linkCount : int
    + lineCount : int
    + pageCount : int
    + materialCount : int
    + TMP_TextInfo()
    <<internal>> TMP_TextInfo(characterCount:int)
    + TMP_TextInfo(textComponent:TMP_Text)
    + Clear() : void
    + ClearMeshInfo(updateMesh:bool) : void
    + ClearAllMeshInfo() : void
    + ResetVertexLayout(isVolumetric:bool) : void
    + ClearUnusedVertices(materials:MaterialReference[]) : void
    + ClearLineInfo() : void
    <<internal>> ClearPageInfo() : void
    + CopyMeshInfoVertexData() : TMP_MeshInfo[]
    + {static} Resize(array:T[], size:int) : void
    + {static} Resize(array:T[], size:int, isBlockAllocated:bool) : void
}
TMP_TextInfo o-> "k_InfinityVectorPositive" Vector2
TMP_TextInfo o-> "k_InfinityVectorNegative" Vector2
TMP_TextInfo --> "textComponent" TMP_Text
class TMP_TextParsingUtilities {
    {static} TMP_TextParsingUtilities()
    + {static} GetHashCode(s:string) : int
    + {static} GetHashCodeCaseSensitive(s:string) : int
    <<const>> k_LookupStringL : string = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|&#125;~-"
    <<const>> k_LookupStringU : string = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|&#125;~-"
    + {static} ToLowerASCIIFast(c:char) : char
    + {static} ToUpperASCIIFast(c:char) : char
    + {static} ToUpperASCIIFast(c:uint) : uint
    + {static} ToLowerASCIIFast(c:uint) : uint
    + {static} IsHighSurrogate(c:uint) : bool
    + {static} IsLowSurrogate(c:uint) : bool
}
TMP_TextParsingUtilities --> "instance" TMP_TextParsingUtilities
class TMP_FontStyleStack <<struct>> {
    + bold : byte
    + italic : byte
    + underline : byte
    + strikethrough : byte
    + highlight : byte
    + superscript : byte
    + subscript : byte
    + uppercase : byte
    + lowercase : byte
    + smallcaps : byte
    + Clear() : void
    + Add(style:FontStyles) : byte
    + Remove(style:FontStyles) : byte
}
class "TMP_TextProcessingStack`1"<T> <<struct>> {
    + index : int
    m_DefaultItem : T
    m_Capacity : int
    m_RolloverSize : int
    m_Count : int
    <<const>> k_DefaultCapacity : int = 4
    + TMP_TextProcessingStack(stack:T[])
    + TMP_TextProcessingStack(capacity:int)
    + TMP_TextProcessingStack(capacity:int, rolloverSize:int)
    + Count : int <<get>>
    + current : T <<get>>
    + rolloverSize : int <<get>> <<set>>
    + Clear() : void
    + SetDefault(item:T) : void
    + Add(item:T) : void
    + Remove() : T
    + Push(item:T) : void
    + Pop() : T
    + Peek() : T
    + CurrentItem() : T
    + PreviousItem() : T
}
enum CaretPosition {
    None,
    Left,
    Right,
}
class CaretInfo <<struct>> {
    + index : int
    + CaretInfo(index:int, position:CaretPosition)
}
class TMP_TextUtilities <<static>> {
    + {static} GetCursorIndexFromPosition(textComponent:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} GetCursorIndexFromPosition(textComponent:TMP_Text, position:Vector3, camera:Camera, cursor:CaretPosition) : int
    + {static} FindNearestLine(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} FindNearestCharacterOnLine(text:TMP_Text, position:Vector3, line:int, camera:Camera, visibleOnly:bool) : int
    + {static} IsIntersectingRectTransform(rectTransform:RectTransform, position:Vector3, camera:Camera) : bool
    + {static} FindIntersectingCharacter(text:TMP_Text, position:Vector3, camera:Camera, visibleOnly:bool) : int
    + {static} FindNearestCharacter(text:TMP_Text, position:Vector3, camera:Camera, visibleOnly:bool) : int
    + {static} FindIntersectingWord(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} FindNearestWord(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} FindIntersectingLine(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} FindIntersectingLink(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} FindNearestLink(text:TMP_Text, position:Vector3, camera:Camera) : int
    + {static} ScreenPointToWorldPointInRectangle(transform:Transform, screenPoint:Vector2, cam:Camera, worldPoint:Vector3) : bool
    + {static} DistanceToLine(a:Vector3, b:Vector3, point:Vector3) : float
    <<const>> k_lookupStringL : string = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|&#125;~-"
    <<const>> k_lookupStringU : string = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|&#125;~-"
    + {static} ToLowerFast(c:char) : char
    + {static} ToUpperFast(c:char) : char
    + {static} GetHashCode(s:string) : int
    + {static} GetSimpleHashCode(s:string) : int
    + {static} GetSimpleHashCodeLowercase(s:string) : uint
    + {static} HexToInt(hex:char) : int
    + {static} StringHexToInt(s:string) : int
}
class LineSegment <<struct>> {
    + LineSegment(p1:Vector3, p2:Vector3)
}
CaretInfo --> "position" CaretPosition
TMP_TextUtilities +-- LineSegment
LineSegment --> "Point1" Vector3
LineSegment --> "Point2" Vector3
class TMP_UpdateManager {
    TMP_UpdateManager()
    <<internal>> {static} RegisterTextObjectForUpdate(textObject:TMP_Text) : void
    + {static} RegisterTextElementForLayoutRebuild(element:TMP_Text) : void
    + {static} RegisterTextElementForGraphicRebuild(element:TMP_Text) : void
    + {static} RegisterTextElementForCullingUpdate(element:TMP_Text) : void
    OnCameraPreCull() : void
    DoRebuilds() : void
    <<internal>> {static} UnRegisterTextObjectForUpdate(textObject:TMP_Text) : void
    + {static} UnRegisterTextElementForRebuild(element:TMP_Text) : void
}
TMP_UpdateManager --> "instance" TMP_UpdateManager
class TMP_UpdateRegistry {
    + {static} RegisterCanvasElementForLayoutRebuild(element:ICanvasElement) : void
    + {static} RegisterCanvasElementForGraphicRebuild(element:ICanvasElement) : void
    + {static} UnRegisterCanvasElementForRebuild(element:ICanvasElement) : void
}
TMP_UpdateRegistry --> "instance" TMP_UpdateRegistry
class TMP_EditorTests {
    + Setup() : void
    + InternalResourceCheck(filePath:string, guid:string) : void
    + TextParsing_TextInfoTest_WordWrappingDisabled(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + TextParsing_TextInfoTest_WordWrappingEnabled(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + TextParsing_TextInfoTest_TopJustifiedAlignment(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + TextParsing_TextInfoTest_RichText(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
}
class TMP_RuntimeTests {
    + Setup() : void
    + {static} TestCases_Parsing_TextInfo_WordWrapDisabled() : IEnumerable<object[]>
    + Parsing_TextInfo_WordWrapDisabled(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + {static} TestCases_Parsing_TextInfo_WordWrapEnabled() : IEnumerable<object[]>
    + Parsing_TextInfo_WordWrapEnabled(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + {static} TestCases_Parsing_TextInfo_AlignmentTopJustified() : IEnumerable<object[]>
    + Parsing_TextInfo_AlignmentTopJustified(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
    + {static} TestCases_Parsing_TextInfo_RichText() : IEnumerable<object[]>
    + Parsing_TextInfo_RichText(sourceTextIndex:int, characterCount:int, spaceCount:int, wordCount:int, lineCount:int) : void
}
class EditClipInAnimationWindow {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class EditSubTimeline {
    IsValid(state:WindowState, clips:TimelineClip[]) : bool
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
    {static} ExecuteInternal(state:WindowState, directors:IList<PlayableDirector>, directorIndex:int, clip:TimelineClip) : void
}
class TrimStart {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class TrimEnd {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class Split {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class CompleteLastLoop {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class TrimLastLoop {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class MatchDuration {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class DoubleSpeed {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class HalfSpeed {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class ResetDuration {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class ResetSpeed {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class ResetAll {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class Tile {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class FindSourceAsset {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class CopyClipsToClipboard {
    + <<override>> Execute(state:WindowState, clips:TimelineClip[]) : bool
}
class "ItemAction`1"<T> {
}
ClipAction <|-- EditClipInAnimationWindow
ClipAction <|-- EditSubTimeline
"ItemAction`1" "<TimelineClip>" <|-- TrimStart
"ItemAction`1" "<TimelineClip>" <|-- TrimEnd
ClipAction <|-- Split
ClipAction <|-- CompleteLastLoop
ClipAction <|-- TrimLastLoop
ClipAction <|-- MatchDuration
ClipAction <|-- DoubleSpeed
ClipAction <|-- HalfSpeed
ClipAction <|-- ResetDuration
ClipAction <|-- ResetSpeed
ClipAction <|-- ResetAll
ClipAction <|-- Tile
ClipAction <|-- FindSourceAsset
ClipAction <|-- CopyClipsToClipboard
abstract class "ItemAction`1"<T> {
    + {abstract} Execute(state:WindowState, items:T[]) : bool
    + CanExecute(state:WindowState, items:T[]) : bool
    + {static} HandleShortcut(state:WindowState, evt:Event, item:T) : bool
    + {static} GetMenuEntries(items:T[], menuItems:List<MenuActionItem>) : void
    + {static} Invoke(state:WindowState, items:T[]) : bool
    + {static} Invoke(state:WindowState, item:T) : bool
}
class "List`1"<T> {
}
MenuItemActionBase <|-- "ItemAction`1"
"ItemAction`1" --> "s_ActionClasses<ItemAction<T>>" "List`1"
"ItemAction`1" --> "actions<ItemAction<T>>" "List`1"
class CopyMarkersToClipboard {
    + <<override>> Execute(state:WindowState, markers:IMarker[]) : bool
}
class "ItemAction`1"<T> {
}
MarkerAction <|-- CopyMarkersToClipboard
abstract class TimelineAction {
    + {abstract} Execute(state:WindowState) : bool
    + <<virtual>> GetDisplayState(state:WindowState) : MenuActionDisplayState
    + <<virtual>> IsChecked(state:WindowState) : bool
    CanExecute(state:WindowState) : bool
    + {static} Invoke(state:WindowState) : void
    + {static} GetMenuEntries(actions:IEnumerable<TimelineAction>, mousePos:Vector2?, items:List<MenuActionItem>) : void
    + {static} HandleShortcut(state:WindowState, evt:Event) : bool
}
abstract class MarkerHeaderAction {
}
class CopyAction {
    + {static} Do(state:WindowState) : bool
    + <<override>> GetDisplayState(state:WindowState) : MenuActionDisplayState
    + <<override>> Execute(state:WindowState) : bool
}
class PasteAction {
    + {static} Do(state:WindowState) : bool
    + <<override>> GetDisplayState(state:WindowState) : MenuActionDisplayState
    + <<override>> Execute(state:WindowState) : bool
    CanPaste(state:WindowState) : bool
    {static} CanPasteItems(itemsGroups:ICollection<ItemsPerTrack>, state:WindowState, mousePosition:Vector2?) : bool
    {static} PasteItems(state:WindowState, mousePosition:Vector2?) : void
    {static} FindSuitableParentForSingleTrackPasteWithoutMouse(itemsGroup:ItemsPerTrack) : TrackAsset
    {static} IsTrackValidForItems(track:TrackAsset, items:IEnumerable<ITimelineItem>) : bool
    {static} GetPickedTrack() : TrackAsset
    {static} PasteTracks(state:WindowState) : void
}
class DuplicateAction {
    + <<override>> Execute(state:WindowState) : bool
    <<internal>> Execute(state:WindowState, gapBetweenItems:Func<ITimelineItem, ITimelineItem, double>) : bool
    {static} CalculateDuplicateTime(duplicatedItems:IEnumerable<ItemsPerTrack>, gapBetweenItems:Func<ITimelineItem, ITimelineItem, double>) : double
}
class DeleteAction {
    + <<override>> GetDisplayState(state:WindowState) : MenuActionDisplayState
    {static} CanDelete(state:WindowState) : bool
    + <<override>> Execute(state:WindowState) : bool
    <<internal>> {static} DeleteItems(items:IEnumerable<ITimelineItem>) : void
}
class MatchContent {
    + <<override>> GetDisplayState(state:WindowState) : MenuActionDisplayState
    + <<override>> Execute(state:WindowState) : bool
}
class PlayTimelineAction {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectAllAction {
    + <<override>> Execute(state:WindowState) : bool
}
class PreviousFrameAction {
    + <<override>> Execute(state:WindowState) : bool
}
class NextFrameAction {
    + <<override>> Execute(state:WindowState) : bool
}
class FrameAllAction {
    + <<override>> Execute(state:WindowState) : bool
}
class FrameSelectedAction {
    + {static} FrameRange(startTime:float, endTime:float, state:WindowState) : void
    + <<override>> Execute(state:WindowState) : bool
    + {static} FrameInlineCurves(curveEditorOwner:IClipCurveEditorOwner, state:WindowState, selectionOnly:bool) : void
}
class PrevKeyAction {
    + <<override>> Execute(state:WindowState) : bool
}
class NextKeyAction {
    + <<override>> Execute(state:WindowState) : bool
}
class GotoStartAction {
    + <<override>> Execute(state:WindowState) : bool
}
class GotoEndAction {
    + <<override>> Execute(state:WindowState) : bool
}
class ZoomIn {
    + <<override>> Execute(state:WindowState) : bool
}
class ZoomOut {
    + <<override>> Execute(state:WindowState) : bool
}
class CollapseGroup {
    + <<override>> Execute(state:WindowState) : bool
}
class UnCollapseGroup {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectLeftClip {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectRightClip {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectUpClip {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectUpTrack {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectDownClip {
    + <<override>> Execute(state:WindowState) : bool
}
class SelectDownTrack {
    + <<override>> Execute(state:WindowState) : bool
}
class MultiselectLeftClip {
    + <<override>> Execute(state:WindowState) : bool
}
class MultiselectRightClip {
    + <<override>> Execute(state:WindowState) : bool
}
class MultiselectUpTrack {
    + <<override>> Execute(state:WindowState) : bool
}
class MultiselectDownTrack {
    + <<override>> Execute(state:WindowState) : bool
}
class ToggleClipTrackArea {
    + <<override>> Execute(state:WindowState) : bool
}
class ToggleMuteMarkersOnTimeline {
    + <<override>> IsChecked(state:WindowState) : bool
    + <<override>> Execute(state:WindowState) : bool
    {static} ToggleMute(state:WindowState) : void
    {static} IsMarkerTrackValid(state:WindowState) : bool
}
class ToggleShowMarkersOnTimeline {
    + <<override>> IsChecked(state:WindowState) : bool
    + <<override>> Execute(state:WindowState) : bool
    {static} ToggleShow(state:WindowState) : void
}
class "KeyValuePair`2"<T1,T2> {
}
MenuItemActionBase <|-- TimelineAction
TimelineAction <|-- MarkerHeaderAction
TimelineAction <|-- CopyAction
TimelineAction <|-- PasteAction
TimelineAction <|-- DuplicateAction
TimelineAction <|-- DeleteAction
TimelineAction <|-- MatchContent
TimelineAction <|-- PlayTimelineAction
TimelineAction <|-- SelectAllAction
TimelineAction <|-- PreviousFrameAction
TimelineAction <|-- NextFrameAction
TimelineAction <|-- FrameAllAction
TimelineAction <|-- FrameSelectedAction
TimelineAction <|-- PrevKeyAction
TimelineAction <|-- NextKeyAction
TimelineAction <|-- GotoStartAction
TimelineAction <|-- GotoEndAction
TimelineAction <|-- ZoomIn
TimelineAction <|-- ZoomOut
TimelineAction <|-- CollapseGroup
TimelineAction <|-- UnCollapseGroup
TimelineAction <|-- SelectLeftClip
TimelineAction <|-- SelectRightClip
TimelineAction <|-- SelectUpClip
TimelineAction <|-- SelectUpTrack
TimelineAction <|-- SelectDownClip
TimelineAction <|-- SelectDownTrack
TimelineAction <|-- MultiselectLeftClip
TimelineAction <|-- MultiselectRightClip
TimelineAction <|-- MultiselectUpTrack
TimelineAction <|-- MultiselectDownTrack
TimelineAction <|-- ToggleClipTrackArea
MarkerHeaderAction <|-- ToggleMuteMarkersOnTimeline
MarkerHeaderAction <|-- ToggleShowMarkersOnTimeline
abstract class TrackAction {
    + {abstract} Execute(state:WindowState, tracks:TrackAsset[]) : bool
    + {static} Invoke(state:WindowState, tracks:TrackAsset[]) : void
    + {static} GetMenuEntries(state:WindowState, mousePos:Vector2?, tracks:TrackAsset[], items:List<MenuActionItem>) : void
    + {static} HandleShortcut(state:WindowState, evt:Event, tracks:TrackAsset[]) : bool
    <<internal>> InternalGetDisplayState(state:WindowState, tracks:TrackAsset[]) : MenuActionDisplayState
}
class EditTrackInAnimationWindow {
    + {static} Do(state:WindowState, track:TrackAsset) : bool
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    {static} CreateTimeControlClipData(track:TrackAsset) : TimelineWindowTimeControl.ClipData
}
class LockSelectedTrack {
    + {static} <<readonly>> LockSelectedTrackOnlyText : string
    + {static} <<readonly>> UnlockSelectedTrackOnlyText : string
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    + {static} Lock(state:WindowState, tracks:TrackAsset[], shouldlock:bool) : void
}
class LockTrack {
    + {static} <<readonly>> UnlockText : string
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    + {static} SetLockState(tracks:TrackAsset[], shouldLock:bool, state:WindowState) : void
}
class ShowHideMarkers {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    {static} ShowHide(state:WindowState, tracks:TrackAsset[], shouldLock:bool) : void
}
class MuteSelectedTrack {
    + {static} <<readonly>> UnmuteSelectedText : string
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    + {static} Mute(state:WindowState, tracks:TrackAsset[], shouldMute:bool) : void
}
class MuteTrack {
    + {static} <<readonly>> UnMuteText : string
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
    + {static} Mute(state:WindowState, tracks:TrackAsset[], shouldMute:bool) : void
}
class DeleteTracks {
    + {static} Do(timeline:TimelineAsset, track:TrackAsset) : void
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class CopyTracksToClipboard {
    + {static} Do(state:WindowState, tracks:TrackAsset[]) : bool
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class DuplicateTracks {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class RemoveInvalidMarkersAction {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class "List`1"<T> {
}
MenuItemActionBase <|-- TrackAction
TrackAction --> "s_ActionClasses<TrackAction>" "List`1"
TrackAction --> "actions<TrackAction>" "List`1"
TrackAction <|-- EditTrackInAnimationWindow
TrackAction <|-- LockSelectedTrack
TrackAction <|-- LockTrack
TrackAction <|-- ShowHideMarkers
TrackAction <|-- MuteSelectedTrack
TrackAction <|-- MuteTrack
TrackAction <|-- DeleteTracks
TrackAction <|-- CopyTracksToClipboard
TrackAction <|-- DuplicateTracks
TrackAction <|-- RemoveInvalidMarkersAction
class ActivationTrackEditor {
    {static} <<readonly>> ClipText : string
    {static} <<readonly>> k_ErrorParentString : string
    {static} <<readonly>> k_ErrorString : string
    + <<override>> GetTrackOptions(track:TrackAsset, binding:Object) : TrackDrawOptions
    GetErrorText(track:TrackAsset, binding:Object) : string
    + <<override>> OnCreate(track:TrackAsset, copiedFrom:TrackAsset) : void
}
TrackEditor <|-- ActivationTrackEditor
class ActivationTrackInspector {
    + <<override>> OnInspectorGUI() : void
    + <<override>> OnEnable() : void
}
class Styles <<static>> {
}
TrackAssetInspector <|-- ActivationTrackInspector
ActivationTrackInspector --> "m_PostPlaybackProperty" SerializedProperty
ActivationTrackInspector +-- Styles
Styles o-> "PostPlaybackStateText" GUIContent
class TimelineSceneInfo {
    + numTracks : int = 0
    + minDuration : int
    + maxDuration : int
    + minNumTracks : int
    + maxNumTracks : int
    + numRecorded : int = 0
}
class TrackInfo <<struct>> {
    + name : string
    + percent : double
}
class TimelineEventInfo {
    + num_timelines : int
    + min_duration : int
    + max_duration : int
    + min_num_tracks : int
    + max_num_tracks : int
    + recorded_percent : double
    + most_popular_user_track : string
    + TimelineEventInfo(sceneInfo:TimelineSceneInfo)
    + {static} IsUserType(t:Type) : bool
}
class TimelineAnalytics <<static>> {
}
class "Dictionary`2"<T1,T2> {
}
class "HashSet`1"<T> {
}
class "List`1"<T> {
}
class TimelineAnalyticsPreProcess {
    + callbackOrder : int <<get>>
    + OnPreprocessBuild(report:BuildReport) : void
}
class TimelineAnalyticsProcess {
    + callbackOrder : int <<get>>
    + OnProcessScene(scene:Scene, report:BuildReport) : void
}
class TimelineAnalyticsPostProcess {
    + callbackOrder : int <<get>>
    + OnPostprocessBuild(report:BuildReport) : void
}
TimelineSceneInfo o-> "trackCount<string,int>" "Dictionary`2"
TimelineSceneInfo o-> "userTrackTypesCount<string,int>" "Dictionary`2"
TimelineSceneInfo o-> "uniqueDirectors<TimelineAsset>" "HashSet`1"
TimelineEventInfo o-> "track_info<TrackInfo>" "List`1"
TimelineAnalytics o-> "_timelineSceneInfo" TimelineSceneInfo
TimelineAnalytics +-- TimelineAnalyticsPreProcess
IPreprocessBuildWithReport <|-- TimelineAnalyticsPreProcess
TimelineAnalytics +-- TimelineAnalyticsProcess
IProcessSceneWithReport <|-- TimelineAnalyticsProcess
TimelineAnalytics +-- TimelineAnalyticsPostProcess
IPostprocessBuildWithReport <|-- TimelineAnalyticsPostProcess
class MatchOffsetsPreviousAction {
    + <<override>> Execute(state:WindowState, items:TimelineClip[]) : bool
}
class MatchOffsetsNextAction {
    + <<override>> Execute(state:WindowState, items:TimelineClip[]) : bool
}
class ResetOffsets {
    + <<override>> Execute(state:WindowState, items:TimelineClip[]) : bool
}
class "ItemAction`1"<T> {
}
ClipAction <|-- MatchOffsetsPreviousAction
ClipAction <|-- MatchOffsetsNextAction
ClipAction <|-- ResetOffsets
class CurveBindingPair <<struct>> {
}
class CurveBindingGroup {
    + isFloatCurve : bool <<get>>
    + isObjectCurve : bool <<get>>
    + count : int <<get>>
}
class AnimationClipCurveInfo {
    m_CurveDirty : bool = true
    m_KeysDirty : bool = true
    + dirty : bool <<get>> <<set>>
    + version : int <<get>>
    + GetCurveTimes(curve:EditorCurveBinding) : float[]
    + GetCurveTimes(curves:EditorCurveBinding[]) : float[]
    RebuildKeyCache() : void
    + Update(clip:AnimationClip) : void
    + GetBindingForCurve(curve:AnimationCurve, binding:EditorCurveBinding) : bool
    + GetCurveForBinding(binding:EditorCurveBinding) : AnimationCurve
    + GetObjectCurveForBinding(binding:EditorCurveBinding) : ObjectReferenceKeyframe[]
    + GetGroupBinding(groupID:string) : CurveBindingGroup
}
class AnimationClipCurveCache {
    m_IsEnabled : bool
    + OnEnable() : void
    + OnDisable() : void
    OnCurveWasModified(clip:AnimationClip, binding:EditorCurveBinding, modification:AnimationUtility.CurveModifiedType) : void
    + GetCurveInfo(clip:AnimationClip) : AnimationClipCurveInfo
    + ClearCachedProxyClips() : void
    + Clear() : void
}
class EditorCurveBindingExtension <<static>> {
    + {static} GetGroupID(binding:EditorCurveBinding) : string
}
class CurveBindingGroupExtensions <<static>> {
    + {static} IsEnableGroup(curves:CurveBindingGroup) : bool
    + {static} IsVectorGroup(curves:CurveBindingGroup) : bool
    + {static} IsColorGroup(curves:CurveBindingGroup) : bool
    + {static} GetDescription(group:CurveBindingGroup, t:float) : string
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
CurveBindingPair --> "binding" EditorCurveBinding
CurveBindingPair --> "curve" AnimationCurve
CurveBindingGroup --> "timeRange" Vector2
CurveBindingGroup --> "valueRange" Vector2
AnimationClipCurveInfo --> "objectCurves<ObjectReferenceKeyframe[]>" "List`1"
AnimationClipCurveInfo --> "m_groupings<string,CurveBindingGroup>" "Dictionary`2"
AnimationClipCurveInfo --> "m_individualBindinsKey<EditorCurveBinding,float[]>" "Dictionary`2"
AnimationClipCurveCache --> "s_Instance" AnimationClipCurveCache
AnimationClipCurveCache o-> "m_ClipCache<AnimationClip,AnimationClipCurveInfo>" "Dictionary`2"
AnimationClipCurveCache --> "Instance" AnimationClipCurveCache
class AnimationOffsetMenu <<static>> {
    + {static} MatchFieldsPrefix : string = "Match Offsets Fields/"
    {static} EnforcePreviewMode(state:WindowState) : bool
    <<internal>> {static} MatchClipsToPrevious(state:WindowState, clips:TimelineClip[]) : void
    <<internal>> {static} MatchClipsToNext(state:WindowState, clips:TimelineClip[]) : void
    + {static} ResetClipOffsets(state:WindowState, clips:TimelineClip[]) : void
}
AnimationOffsetMenu o-> "MatchPreviousMenuItem" GUIContent
AnimationOffsetMenu o-> "MatchNextMenuItem" GUIContent
AnimationOffsetMenu o-> "ResetOffsetMenuItem" GUIContent
class AnimationPlayableAssetEditor {
    + {static} <<readonly>> k_NoClipAssignedError : string
    + {static} <<readonly>> k_LegacyClipError : string
    {static} <<readonly>> k_MotionCurveError : string
    {static} <<readonly>> k_RootCurveError : string
    + <<override>> GetClipOptions(clip:TimelineClip) : ClipDrawOptions
    + <<override>> OnCreate(clip:TimelineClip, track:TrackAsset, clonedFrom:TimelineClip) : void
    GetErrorText(animationAsset:AnimationPlayableAsset, track:AnimationTrack, defaultError:string) : string
}
ClipEditor <|-- AnimationPlayableAssetEditor
class AddOverrideTrackAction {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class ConvertToClipModeAction {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class ConvertFromClipTrackAction {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
abstract class TrackOffsetBaseAction {
    + <<override>> Execute(state:WindowState, tracks:TrackAsset[]) : bool
}
class ApplyTransformOffsetAction {
}
class ApplySceneOffsetAction {
}
class ApplyAutoAction {
}
TrackAction <|-- AddOverrideTrackAction
TrackAction <|-- ConvertToClipModeAction
TrackAction <|-- ConvertFromClipTrackAction
TrackAction <|-- TrackOffsetBaseAction
TrackOffsetBaseAction --> "trackOffset" TrackOffset
TrackOffsetBaseAction <|-- ApplyTransformOffsetAction
ApplyTransformOffsetAction --> "trackOffset" TrackOffset
TrackOffsetBaseAction <|-- ApplySceneOffsetAction
ApplySceneOffsetAction --> "trackOffset" TrackOffset
TrackOffsetBaseAction <|-- ApplyAutoAction
ApplyAutoAction --> "trackOffset" TrackOffset
class BindingSelector {
    m_PartOfSelection : bool
    + BindingSelector(window:EditorWindow, curveEditor:CurveEditor, trackGlobalTreeViewState:TreeViewState)
    + selectable : bool <<get>>
    + selectableObject : object <<get>>
    + selected : bool <<get>> <<set>>
    + <<virtual>> Delete(state:WindowState) : void
    + OnGUI(targetRect:Rect) : void
    + InitIfNeeded(rect:Rect, dataSource:CurveDataSource, isNewSelection:bool) : void
    OnItemSelectionChanged(selection:int[]) : void
    RefreshAll() : void
    RefreshSelection() : void
    RefreshSelection(selection:int[]) : void
    + RefreshCurves() : void
    + RefreshTree() : void
    <<internal>> <<virtual>> IsRenamingNodeAllowed(node:TreeViewItem) : bool
}
BindingSelector --> "m_TreeView" TreeViewController
BindingSelector --> "treeViewController" TreeViewController
BindingSelector --> "m_TrackGlobalTreeViewState" TreeViewState
BindingSelector --> "m_TreeViewState" TreeViewState
BindingSelector --> "m_TreeViewDataSource" BindingTreeViewDataSource
BindingSelector --> "m_CurveDataSource" CurveDataSource
BindingSelector --> "m_Window" TimelineWindow
BindingSelector --> "m_CurveEditor" CurveEditor
BindingSelector --> "m_DopeLines" ReorderableList
class BindingTreeViewDataSource {
    + <<const>> RootID : int
    + <<const>> GroupID : int
    + BindingTreeViewDataSource(treeView:TreeViewController, clip:AnimationClip, curveDataSource:CurveDataSource)
    SetupRootNodeSettings() : void
    {static} GroupName(binding:EditorCurveBinding) : string
    {static} PropertyName(binding:EditorCurveBinding, arrayPrefixToRemove:string) : string
    + <<override>> FetchData() : void
    + UpdateData() : void
}
class CurveTreeViewNode {
    + CurveTreeViewNode(id:int, parent:TreeViewItem, displayName:string, bindings:EditorCurveBinding[])
}
TreeViewDataSource <|-- BindingTreeViewDataSource
BindingTreeViewDataSource --> "m_Clip" AnimationClip
BindingTreeViewDataSource --> "m_CurveDataSource" CurveDataSource
TreeViewItem <|-- CurveTreeViewNode
class BindingTreeViewGUI {
    {static} <<readonly>> s_RowRightOffset : float = 10
    {static} <<readonly>> s_ColorIndicatorTopMargin : float = 3
    + BindingTreeViewGUI(treeView:TreeViewController)
    + <<override>> OnRowGUI(rowRect:Rect, node:TreeViewItem, row:int, selected:bool, focused:bool) : void
    + <<override>> BeginRename(item:TreeViewItem, delay:float) : bool
    DoCurveColorIndicator(rect:Rect, node:CurveTreeViewNode) : void
}
TreeViewGUI <|-- BindingTreeViewGUI
BindingTreeViewGUI o-> "s_KeyColorForNonCurves" Color
BindingTreeViewGUI o-> "s_ChildrenCurveLabelColor" Color
class ClipCurveEditor {
    {static} <<readonly>> s_GridLabelWidth : float = 40.0f
    m_LastFrameRate : float = 30.0f
    m_LastClipVersion : int
    m_LastCurveCount : int
    m_ShouldRestoreShownArea : bool
    isNewSelection : bool <<get>>
    + ClipCurveEditor(dataSource:CurveDataSource, parentWindow:TimelineWindow, hostTrack:TrackAsset)
    + SelectAllKeys() : void
    + FrameClip() : void
    <<internal>> OnCurvesUpdated() : void
    + DrawHeader(headerRect:Rect) : void
    UpdateCurveEditorIfNeeded(state:WindowState) : void
    + DrawCurveEditor(rect:Rect, state:WindowState, clipRange:Vector2, loop:bool, selected:bool) : void
    {static} CalculateCurveVisibleTimeRange(timeAreaShownRange:Vector2, curve:CurveDataSource) : Vector2
    SetupMarginsAndRect(rect:Rect, state:WindowState) : void
    RestoreShownArea() : void
    {static} DrawCurveEditorBackground(rect:Rect) : void
    {static} CalculateTopMargin(height:float) : float
    {static} DrawOutline(rect:Rect, thickness:float) : void
    {static} DrawOverlay(rect:Rect, clipRange:Vector2, color:Color) : void
    DrawGrid(rect:Rect, curveXPosition:float) : void
}
class FrameFormatCurveEditorState {
    + rippleTime : bool <<get>>
}
class UnformattedCurveEditorState {
    + rippleTime : bool <<get>>
}
ClipCurveEditor --> "m_CurveEditor" CurveEditor
ClipCurveEditor o-> "s_CurveEditorSettings" CurveEditorSettings
ClipCurveEditor --> "m_BindingHierarchy" BindingSelector
ClipCurveEditor --> "bindingHierarchy" BindingSelector
ClipCurveEditor --> "shownAreaInsideMargins" Rect
ClipCurveEditor o-> "m_ScrollPosition" Vector2
ClipCurveEditor --> "m_DataSource" CurveDataSource
ClipCurveEditor --> "m_ViewModel" TrackViewModelData
ClipCurveEditor --> "curveEditor" CurveEditor
ClipCurveEditor --> "dataSource" CurveDataSource
ClipCurveEditor +-- FrameFormatCurveEditorState
ICurveEditorState <|-- FrameFormatCurveEditorState
FrameFormatCurveEditorState --> "timeRange" Vector2
ClipCurveEditor +-- UnformattedCurveEditorState
ICurveEditorState <|-- UnformattedCurveEditorState
UnformattedCurveEditorState --> "timeRange" Vector2
abstract class CurveDataSource {
    + {static} Create(trackGUI:IRowGUI) : CurveDataSource
    + {static} Create(clipGUI:TimelineClipGUI) : CurveDataSource
    m_ID : int? = null
    + id : int <<get>>
    + {abstract} start : float <<get>>
    + {abstract} timeScale : float <<get>>
    + {abstract} groupingName : string <<get>>
    + <<virtual>> UpdateCurves(updatedCurves:List<CurveWrapper>) : void
    + <<virtual>> RebuildCurves() : void
    + GetBackgroundRect(state:WindowState) : Rect
    + GenerateWrappers(bindings:List<EditorCurveBinding>) : List<CurveWrapper>
}
class ClipAnimationCurveDataSource {
    {static} <<readonly>> k_GroupingName : string
    + ClipAnimationCurveDataSource(clipGUI:TimelineClipGUI)
    + <<override>> start : float <<get>>
    + <<override>> timeScale : float <<get>>
    + <<override>> groupingName : string <<get>>
}
class ClipParametersCurveDataSource {
    {static} <<readonly>> k_GroupingName : string
    + ClipParametersCurveDataSource(clipGUI:TimelineClipGUI)
    + <<override>> start : float <<get>>
    + <<override>> timeScale : float <<get>>
    + <<override>> groupingName : string <<get>>
    + <<override>> UpdateCurves(updatedCurves:List<CurveWrapper>) : void
    + <<override>> RebuildCurves() : void
}
class InfiniteClipCurveDataSource {
    {static} <<readonly>> k_GroupingName : string
    + InfiniteClipCurveDataSource(trackGui:IRowGUI)
    + <<override>> start : float <<get>>
    + <<override>> timeScale : float <<get>>
    + <<override>> groupingName : string <<get>>
}
class TrackParametersCurveDataSource {
    {static} <<readonly>> k_GroupingName : string
    + TrackParametersCurveDataSource(trackGui:IRowGUI)
    + <<override>> start : float <<get>>
    + <<override>> timeScale : float <<get>>
    + <<override>> groupingName : string <<get>>
    + <<override>> UpdateCurves(updatedCurves:List<CurveWrapper>) : void
    + <<override>> RebuildCurves() : void
}
CurveDataSource --> "m_TrackGUI" IRowGUI
CurveDataSource --> "animationClip" AnimationClip
CurveDataSource <|-- ClipAnimationCurveDataSource
ClipAnimationCurveDataSource --> "m_ClipGUI" TimelineClipGUI
ClipAnimationCurveDataSource --> "animationClip" AnimationClip
CurveDataSource <|-- ClipParametersCurveDataSource
ClipParametersCurveDataSource --> "m_ClipGUI" TimelineClipGUI
ClipParametersCurveDataSource --> "m_CurvesProxy" CurvesProxy
ClipParametersCurveDataSource --> "animationClip" AnimationClip
CurveDataSource <|-- InfiniteClipCurveDataSource
InfiniteClipCurveDataSource --> "m_AnimationTrack" AnimationTrack
InfiniteClipCurveDataSource --> "animationClip" AnimationClip
CurveDataSource <|-- TrackParametersCurveDataSource
TrackParametersCurveDataSource --> "m_CurvesProxy" CurvesProxy
TrackParametersCurveDataSource --> "animationClip" AnimationClip
class CurvesProxy {
    + hasCurves : bool <<get>>
    + duration : double <<get>>
    + defaultCurvesName : string <<get>>
    <<readonly>> m_IsAnimatable : bool
    m_ProxyIsRebuilding : int = 0
    + CurvesProxy(originalOwner:ICurvesOwner)
    + CreateCurves(curvesClipName:string) : void
    + ConfigureCurveWrapper(wrapper:CurveWrapper) : void
    + RebuildCurves() : void
    + UpdateCurves(updatedCurves:List<CurveWrapper>) : void
    UpdateCurve(binding:EditorCurveBinding, curve:AnimationCurve) : void
    ApplyConstraints(binding:EditorCurveBinding, curve:AnimationCurve) : void
    HandleCurveUpdated(binding:EditorCurveBinding, updatedCurve:AnimationCurve) : void
    HandleConstantCurveValueChanged(binding:EditorCurveBinding, updatedCurve:AnimationCurve) : void
    HandleAllKeysDeleted(binding:EditorCurveBinding) : void
    RebuildProxyCurves() : void
    CreateProxyCurve(prop:SerializedProperty, clip:AnimationClip, owner:UnityObject, propertyName:string) : void
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
class RebuildGuard <<struct>> {
    + RebuildGuard(owner:CurvesProxy)
    + Dispose() : void
}
ICurvesOwner <|-- CurvesProxy
CurvesProxy --> "curves" AnimationClip
CurvesProxy --> "asset" UnityObject
CurvesProxy --> "assetOwner" UnityObject
CurvesProxy --> "targetTrack" TrackAsset
CurvesProxy --> "m_OriginalOwner" ICurvesOwner
CurvesProxy o-> "m_PropertiesMap<EditorCurveBinding,SerializedProperty>" "Dictionary`2"
CurvesProxy --> "m_ProxyCurves" AnimationClip
CurvesProxy --> "proxyCurves" AnimationClip
CurvesProxy --> "m_AllAnimatableParameters<SerializedProperty>" "List`1"
CurvesProxy --> "allAnimatableParameters<SerializedProperty>" "List`1"
CurvesProxy +-- RebuildGuard
IDisposable <|-- RebuildGuard
RebuildGuard --> "m_Owner" CurvesProxy
class TimelineAnimationUtilities {
    + {static} ValidateOffsetAvailabitity(director:PlayableDirector, animator:Animator) : bool
    + {static} GetPreviousClip(clip:TimelineClip) : TimelineClip
    + {static} GetNextClip(clip:TimelineClip) : TimelineClip
    + {static} UpdateClipOffsets(asset:AnimationPlayableAsset, track:AnimationTrack, transform:Transform, globalPosition:Vector3, globalRotation:Quaternion) : RigidTransform
    + {static} GetTrackOffsets(track:AnimationTrack, transform:Transform) : RigidTransform
    + {static} UpdateTrackOffset(track:AnimationTrack, transform:Transform, offsets:RigidTransform) : void
    {static} GetMatchFields(clip:TimelineClip) : MatchTargetFields
    {static} WriteMatchFields(asset:AnimationPlayableAsset, result:RigidTransform, fields:MatchTargetFields) : void
    + {static} MatchPrevious(currentClip:TimelineClip, matchPoint:Transform, director:PlayableDirector) : void
    + {static} MatchNext(currentClip:TimelineClip, matchPoint:Transform, director:PlayableDirector) : void
    + {static} CreateTimeController(state:WindowState, clip:TimelineClip) : TimelineWindowTimeControl
    + {static} CreateTimeController(state:WindowState, clipData:TimelineWindowTimeControl.ClipData) : TimelineWindowTimeControl
    + {static} EditAnimationClipWithTimeController(animationClip:AnimationClip, timeController:TimelineWindowTimeControl, sourceObject:Object) : void
    + {static} UnlinkAnimationWindowFromTracks(tracks:IEnumerable<TrackAsset>) : void
    + {static} UnlinkAnimationWindowFromClips(timelineClips:IEnumerable<TimelineClip>) : void
    + {static} UnlinkAnimationWindowFromAnimationClips(clips:ICollection<AnimationClip>) : void
    + {static} UnlinkAnimationWindow() : void
    + {static} GetAnimationWindowCurrentFrame() : int
    + {static} SetAnimationWindowCurrentFrame(frame:int) : void
    + {static} ConstrainCurveToBooleanValues(curve:AnimationCurve) : void
    + {static} ConstrainCurveToRange(curve:AnimationCurve, minValue:float, maxValue:float) : void
    + {static} IsAnimationClip(clip:TimelineClip) : bool
}
enum OffsetEditMode {
    None= -1,
    Translation= 0,
    Rotation= 1,
}
class RigidTransform <<struct>> {
    + {static} Compose(pos:Vector3, rot:Quaternion) : RigidTransform
    + {static} Mul(a:RigidTransform, b:RigidTransform) : RigidTransform
    + {static} Inverse(a:RigidTransform) : RigidTransform
}
TimelineAnimationUtilities +-- OffsetEditMode
TimelineAnimationUtilities +-- RigidTransform
RigidTransform --> "position" Vector3
RigidTransform --> "rotation" Quaternion
RigidTransform --> "identity" RigidTransform
class ActiveInModeAttribute {
    + ActiveInModeAttribute(timelineModes:TimelineModes)
}
Attribute <|-- ActiveInModeAttribute
ActiveInModeAttribute --> "modes" TimelineModes
class MenuEntryAttribute {
    + <<readonly>> priority : int
    + <<readonly>> name : string
    + <<readonly>> subMenuPath : string
    + MenuEntryAttribute(path:string, priority:int)
}
Attribute <|-- MenuEntryAttribute
class ShortcutAttribute {
    <<readonly>> m_Identifier : string
    <<readonly>> m_EventCommandName : string
    <<readonly>> m_MenuShortcut : string
    + ShortcutAttribute(identifier:string)
    + ShortcutAttribute(identifier:string, commandName:string)
    + ShortcutAttribute(key:KeyCode, modifiers:ShortcutModifiers)
    + GetMenuShortcut() : string
    + MatchesEvent(evt:Event) : bool
}
class ShortcutPlatformOverrideAttribute {
    + ShortcutPlatformOverrideAttribute(platform:RuntimePlatform, key:KeyCode, modifiers:ShortcutModifiers)
    + MatchesCurrentPlatform() : bool
}
Attribute <|-- ShortcutAttribute
ShortcutAttribute <|-- ShortcutPlatformOverrideAttribute
ShortcutPlatformOverrideAttribute --> "platform" RuntimePlatform
class AudioClipPropertiesDrawer {
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
}
class Styles <<static>> {
    + <<const>> VolumeControl : string = "AudioClipPropertiesDrawer.volume"
    <<const>> k_Indent : string = "    "
    + <<const>> valuesFormatter : string = "0.###"
    + {static} mixedPropertiesInfo : string
    + {static} audioSourceContribution : string
}
PropertyDrawer <|-- AudioClipPropertiesDrawer
AudioClipPropertiesDrawer o-> "s_MixInfoBuilder" StringBuilder
AudioClipPropertiesDrawer +-- Styles
class AudioPlayableAssetEditor {
    <<readonly>> k_NoClipAssignedError : string
    + <<override>> GetClipOptions(clip:TimelineClip) : ClipDrawOptions
    + <<override>> DrawBackground(clip:TimelineClip, region:ClipBackgroundRegion) : void
    {static} GammaCorrect(color:Color) : Color
}
class "Dictionary`2"<T1,T2> {
}
ClipEditor <|-- AudioPlayableAssetEditor
AudioPlayableAssetEditor o-> "m_PersistentPreviews<TimelineClip,WaveformPreview>" "Dictionary`2"
AudioPlayableAssetEditor o-> "m_ColorSpace" ColorSpace
class AudioPlayableAssetInspector {
    + <<override>> ApplyChanges() : void
}
BasicAssetInspector <|-- AudioPlayableAssetInspector
class AudioTrackInspector {
    + <<override>> OnEnable() : void
    DrawMixInfoSection() : void
    ShouldDisableSpatialBlend() : bool
}
class Styles <<static>> {
    + <<const>> VolumeControl : string = "AudioTrackInspector.volume"
    + <<const>> StereoPanControl : string = "AudioTrackInspector.stereoPan"
    + <<const>> SpatialBlendControl : string = "AudioTrackInspector.spatialBlend"
    <<const>> k_Indent : string = "    "
    + <<const>> valuesFormatter : string = "0.###"
    + <<const>> mixInfoSectionSeparator : string = "\n\n"
    + {static} mixedPropertiesInfo : string
}
TrackAssetInspector <|-- AudioTrackInspector
AudioTrackInspector o-> "s_MixInfoBuilder" StringBuilder
AudioTrackInspector --> "m_VolumeProperty" SerializedProperty
AudioTrackInspector --> "m_StereoPanProperty" SerializedProperty
AudioTrackInspector --> "m_SpatialBlendProperty" SerializedProperty
AudioTrackInspector --> "m_Director" PlayableDirector
AudioTrackInspector +-- Styles
class ControlPlayableAssetEditor {
    + <<override>> GetClipOptions(clip:TimelineClip) : ClipDrawOptions
    + <<override>> OnCreate(clip:TimelineClip, track:TrackAsset, clonedFrom:TimelineClip) : void
    + <<override>> GetSubTimelines(clip:TimelineClip, director:PlayableDirector, subTimelines:List<PlayableDirector>) : void
}
ClipEditor <|-- ControlPlayableAssetEditor
class ClipBackgroundRegion <<struct>> {
    + startTime : double <<get>>
    + endTime : double <<get>>
    + ClipBackgroundRegion(_position:Rect, _startTime:double, _endTime:double)
    + <<override>> Equals(obj:object) : bool
    + Equals(other:ClipBackgroundRegion) : bool
    + <<override>> GetHashCode() : int
}
class ClipDrawOptions <<struct>> {
    + errorText : string <<get>> <<set>>
    + tooltip : string <<get>> <<set>>
    + <<override>> Equals(obj:object) : bool
    + Equals(other:ClipDrawOptions) : bool
    + <<override>> GetHashCode() : int
}
class ClipEditor {
    {static} <<readonly>> k_NoPlayableAssetError : string
    {static} <<readonly>> k_ScriptLoadError : string
    <<internal>> <<readonly>> supportsSubTimelines : bool
    + ClipEditor()
    + <<virtual>> GetClipOptions(clip:TimelineClip) : ClipDrawOptions
    + <<virtual>> DrawBackground(clip:TimelineClip, region:ClipBackgroundRegion) : void
    + <<virtual>> OnCreate(clip:TimelineClip, track:TrackAsset, clonedFrom:TimelineClip) : void
    + GetErrorText(clip:TimelineClip) : string
    + GetDefaultHighlightColor(clip:TimelineClip) : Color
    + <<virtual>> OnClipChanged(clip:TimelineClip) : void
    + <<virtual>> GetSubTimelines(clip:TimelineClip, director:PlayableDirector, subTimelines:List<PlayableDirector>) : void
}
class "IEnumerable`1"<T> {
}
ClipBackgroundRegion --> "position" Rect
ClipDrawOptions --> "highlightColor" Color
ClipDrawOptions --> "icons<Texture2D>" "IEnumerable`1"
class CustomTimelineEditorCache {
    + {static} GetEditorForType(type:Type) : TEditorClass
    + {static} ClearCache() : void
    + {static} GetClipEditor(clip:TimelineClip) : ClipEditor
    + {static} GetDefaultClipEditor() : ClipEditor
    + {static} GetTrackEditor(track:TrackAsset) : TrackEditor
    + {static} GetDefaultTrackEditor() : TrackEditor
    + {static} GetMarkerEditor(marker:IMarker) : MarkerEditor
    + {static} GetDefaultMarkerEditor() : MarkerEditor
}
class "SubClassCache`1"<TEditorClass> <<static>> {
    + {static} DefaultInstance : TEditorClass <<get>>
    + {static} GetEditorForType(type:Type) : TEditorClass
    + {static} Clear() : void
}
CustomTimelineEditorCache +-- "SubClassCache`1"
enum MarkerUIStates {
    None= 0,
    Selected= 1 << 0,
    Collapsed= 1 << 1,
}
class MarkerDrawOptions <<struct>> {
    + tooltip : string <<get>> <<set>>
    + errorText : string <<get>> <<set>>
    + <<override>> Equals(obj:object) : bool
    + Equals(other:MarkerDrawOptions) : bool
    + <<override>> GetHashCode() : int
}
class MarkerOverlayRegion <<struct>> {
    + startTime : double <<get>>
    + endTime : double <<get>>
    + MarkerOverlayRegion(_markerRegion:Rect, _timelineRegion:Rect, _startTime:double, _endTime:double)
    + <<override>> Equals(obj:object) : bool
    + Equals(other:MarkerOverlayRegion) : bool
    + <<override>> GetHashCode() : int
}
class MarkerEditor {
    <<internal>> <<readonly>> supportsDrawOverlay : bool
    + MarkerEditor()
    + <<virtual>> GetMarkerOptions(marker:IMarker) : MarkerDrawOptions
    + <<virtual>> OnCreate(marker:IMarker, clonedFrom:IMarker) : void
    + <<virtual>> DrawOverlay(marker:IMarker, uiState:MarkerUIStates, region:MarkerOverlayRegion) : void
}
MarkerOverlayRegion --> "markerRegion" Rect
MarkerOverlayRegion --> "timelineRegion" Rect
class MarkerTrackEditor {
    + {static} <<readonly>> DefaultMarkerTrackHeight : float = 20
    + <<override>> GetTrackOptions(track:TrackAsset, binding:Object) : TrackDrawOptions
}
TrackEditor <|-- MarkerTrackEditor
class TrackDrawOptions <<struct>> {
    + errorText : string <<get>> <<set>>
    + minimumHeight : float <<get>> <<set>>
    + <<override>> Equals(obj:object) : bool
    + Equals(other:TrackDrawOptions) : bool
    + <<override>> GetHashCode() : int
}
enum TrackBindingErrors {
    None= 0,
    BoundGameObjectDisabled= 1 << 0,
    NoValidComponent= 1 << 1,
    BehaviourIsDisabled= 1 << 2,
    InvalidBinding= 1 << 3,
    PrefabBound= 1 << 4,
    All= Int32.MaxValue,
}
class TrackEditor {
    {static} <<readonly>> k_BoundGameObjectDisabled : string
    {static} <<readonly>> k_NoValidComponent : string
    {static} <<readonly>> k_RequiredComponentIsDisabled : string
    {static} <<readonly>> k_InvalidBinding : string
    {static} <<readonly>> k_PrefabBound : string
    + {static} <<readonly>> DefaultTrackHeight : float = 30.0f
    + {static} <<readonly>> MinimumTrackHeight : float = 10.0f
    + {static} <<readonly>> MaximumTrackHeight : float = 256.0f
    + <<virtual>> GetTrackOptions(track:TrackAsset, binding:UnityEngine.Object) : TrackDrawOptions
    + GetErrorText(track:TrackAsset, boundObject:UnityEngine.Object, detectErrors:TrackBindingErrors) : string
    + GetTrackColor(track:TrackAsset) : Color
    + GetBindingType(track:TrackAsset) : System.Type
    + <<virtual>> OnCreate(track:TrackAsset, copiedFrom:TrackAsset) : void
    + <<virtual>> OnTrackChanged(track:TrackAsset) : void
}
class "Dictionary`2"<T1,T2> {
}
TrackDrawOptions --> "trackColor" Color
TrackDrawOptions --> "icon" Texture2D
TrackEditor o-> "m_BindingCache<TrackAsset,System.Type>" "Dictionary`2"
class AnimatedParameterExtensions <<static>> {
    + {static} HasAnyAnimatableParameters(curvesOwner:ICurvesOwner) : bool
    + {static} GetAllAnimatableParameters(curvesOwner:ICurvesOwner) : IEnumerable<SerializedProperty>
    + {static} IsParameterAnimatable(curvesOwner:ICurvesOwner, parameterName:string) : bool
    + {static} IsParameterAnimated(curvesOwner:ICurvesOwner, parameterName:string) : bool
    + {static} GetCurveBinding(curvesOwner:ICurvesOwner, parameterName:string) : EditorCurveBinding
    + {static} GetUniqueRecordedClipName(curvesOwner:ICurvesOwner) : string
    + {static} GetAnimatedParameter(curvesOwner:ICurvesOwner, bindingName:string) : AnimationCurve
    + {static} AddAnimatedParameterValueAt(curvesOwner:ICurvesOwner, parameterName:string, value:float, time:float) : bool
    + {static} SanitizeCurvesData(curvesOwner:ICurvesOwner) : void
    + {static} AddAnimatedParameter(curvesOwner:ICurvesOwner, parameterName:string) : bool
    + {static} RemoveAnimatedParameter(curvesOwner:ICurvesOwner, parameterName:string) : bool
    + {static} SetAnimatedParameter(curvesOwner:ICurvesOwner, parameterName:string, curve:AnimationCurve) : bool
    {static} InternalAddParameter(curvesOwner:ICurvesOwner, parameterName:string, binding:EditorCurveBinding, property:SerializedProperty) : bool
}
class AnimationTrackExtensions <<static>> {
    + {static} ConvertToClipMode(track:AnimationTrack) : void
    + {static} ConvertFromClipMode(track:AnimationTrack, timeline:TimelineAsset) : void
    + {static} CanConvertToClipMode(track:AnimationTrack) : bool
    + {static} CanConvertFromClipMode(track:AnimationTrack) : bool
}
class TrackExtensions <<static>> {
    + {static} <<readonly>> kMinOverlapTime : double
    + {static} GetOrCreateClip(track:AnimationTrack) : AnimationClip
    + {static} CreateClip(track:TrackAsset, time:double) : TimelineClip
    {static} Overlaps(blendOut:TimelineClip, blendIn:TimelineClip) : bool
    + {static} ComputeBlendsFromOverlaps(asset:TrackAsset) : void
    <<internal>> {static} ComputeBlendsFromOverlaps(clips:TimelineClip[]) : void
    <<internal>> {static} UpdateClipIntersection(blendOutClip:TimelineClip, blendInClip:TimelineClip) : void
    <<internal>> {static} RecursiveSubtrackClone(source:TrackAsset, duplicate:TrackAsset, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, assetOwner:PlayableAsset) : void
    <<internal>> {static} Duplicate(track:TrackAsset, sourceTable:IExposedPropertyTable, destTable:IExposedPropertyTable, destinationTimeline:TimelineAsset) : TrackAsset
    <<internal>> {static} ReparentTracks(tracksToMove:List<TrackAsset>, targetParent:PlayableAsset, insertMarker:TrackAsset, insertBefore:bool) : bool
    <<internal>> {static} FilterTracks(tracks:IEnumerable<TrackAsset>) : IEnumerable<TrackAsset>
    <<internal>> {static} IsVisibleRecursive(track:TrackAsset) : bool
    <<internal>> {static} GetCollapsed(track:TrackAsset) : bool
    <<internal>> {static} SetCollapsed(track:TrackAsset, collapsed:bool) : void
    <<internal>> {static} GetShowMarkers(track:TrackAsset) : bool
    <<internal>> {static} SetShowMarkers(track:TrackAsset, collapsed:bool) : void
    <<internal>> {static} GetShowInlineCurves(track:TrackAsset) : bool
    <<internal>> {static} SetShowInlineCurves(track:TrackAsset, inlineOn:bool) : void
    <<internal>> {static} ShouldShowInfiniteClipEditor(track:TrackAsset) : bool
    <<internal>> {static} ShouldShowInfiniteClipEditor(track:AnimationTrack) : bool
    <<internal>> {static} RemoveBrokenTrack(parent:PlayableAsset, track:ScriptableObject) : bool
    <<internal>> {static} GetGapAtTime(track:TrackAsset, time:double, startGap:double, endGap:double) : bool
    + {static} IsCompatibleWithClip(track:TrackAsset, clip:TimelineClip) : bool
    + {static} GetFlattenedChildTracks(asset:TrackAsset, list:List<TrackAsset>) : void
    + {static} GetFlattenedChildTracks(asset:TrackAsset) : IEnumerable<TrackAsset>
}
class AnimationPlayableAssetInspector {
    + <<override>> OnInspectorGUI() : void
    ShowAnimationClipField() : void
    TransformOffsetsMatchFieldsGUI() : void
    TransformOffsetsGUI() : void
    Reevaluate() : void
    SetTimeToClip() : void
    + OnEnable() : void
    OnDestroy() : void
    OnSceneGUI(sceneView:SceneView) : void
    GetTransform() : Transform
    DoManipulators() : void
    ShowAnimationClipWarnings() : void
    ShouldShowOffsets() : bool
    ShowRecordableClipRename() : void
}
class Styles <<static>> {
}
Editor <|-- AnimationPlayableAssetInspector
AnimationPlayableAssetInspector --> "m_TimelineWindow" TimelineWindow
AnimationPlayableAssetInspector --> "m_Binding" GameObject
AnimationPlayableAssetInspector --> "m_EditorClip" EditorClip
AnimationPlayableAssetInspector --> "m_PositionProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_RotationProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_AnimClipProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_UseTrackMatchFieldsProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_MatchTargetFieldsProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_SerializedAnimClip" SerializedObject
AnimationPlayableAssetInspector --> "m_SerializedAnimClipName" SerializedProperty
AnimationPlayableAssetInspector --> "m_RemoveStartOffsetProperty" SerializedProperty
AnimationPlayableAssetInspector --> "m_ApplyFootIK" SerializedProperty
AnimationPlayableAssetInspector --> "m_Loop" SerializedProperty
AnimationPlayableAssetInspector --> "m_LastPosition" Vector3
AnimationPlayableAssetInspector --> "m_LastRotation" Vector3
AnimationPlayableAssetInspector +-- Styles
Styles o-> "RotationText" GUIContent
Styles o-> "AnimClipText" GUIContent
Styles o-> "TransformOffsetTitle" GUIContent
Styles o-> "AnimationClipName" GUIContent
Styles o-> "MatchTargetFieldsTitle" GUIContent
Styles o-> "UseDefaults" GUIContent
Styles o-> "RemoveStartOffset" GUIContent
Styles o-> "ApplyFootIK" GUIContent
Styles o-> "Loop" GUIContent
class AnimationTrackInspector {
    Evaluate() : void
    RebuildGraph() : void
    + <<override>> OnInspectorGUI() : void
    AnimatesRootTransform() : bool
    ShouldDrawOffsets() : bool
    DrawRootTransformOffset() : void
    SetupOffsetTooltip() : bool
    DrawRootTransformDropDown() : void
    DrawMatchFieldsGUI() : void
    DrawRootMotionOffsetFields() : void
    DrawRootMotionToolBar() : void
    UpdateOffsets() : void
    DrawAvatarProperties() : void
    + {static} ShowMotionOffsetEditModeToolbar(motionOffset:TimelineAnimationUtilities.OffsetEditMode) : void
    + <<override>> OnEnable() : void
    + OnDestroy() : void
    OnSceneGUI(sceneView:SceneView) : void
    DoOffsetManipulator() : void
    + DrawRecordedOffsetProperties() : void
    + {static} MatchTargetsFieldGUI(property:SerializedProperty) : void
    {static} GetOffsetMode(track:AnimationTrack) : TrackOffset
    GetOffsetMode(hasMultiple:bool) : TrackOffset
}
class Styles <<static>> {
    + {static} <<readonly>> TransformOffsetInfo : string
    + {static} <<readonly>> SceneOffsetInfo : string
    + {static} <<readonly>> AutoOffsetInfo : string
    + {static} <<readonly>> AutoOffsetWarning : string
    + {static} <<readonly>> InheritedFromParent : string
    + {static} <<readonly>> InheritedToolTip : string
    {static} Styles()
}
TrackAssetInspector <|-- AnimationTrackInspector
AnimationTrackInspector --> "m_MatchFieldsProperty" SerializedProperty
AnimationTrackInspector --> "m_TrackPositionProperty" SerializedProperty
AnimationTrackInspector --> "m_TrackRotationProperty" SerializedProperty
AnimationTrackInspector --> "m_AvatarMaskProperty" SerializedProperty
AnimationTrackInspector --> "m_ApplyAvatarMaskProperty" SerializedProperty
AnimationTrackInspector --> "m_TrackOffsetProperty" SerializedProperty
AnimationTrackInspector --> "m_RecordedOffsetPositionProperty" SerializedProperty
AnimationTrackInspector --> "m_RecordedOffsetEulerProperty" SerializedProperty
AnimationTrackInspector --> "m_lastPosition" Vector3
AnimationTrackInspector --> "m_lastRotation" Vector3
AnimationTrackInspector o-> "m_TempContent" GUIContent
AnimationTrackInspector +-- Styles
Styles o-> "MatchTargetFieldsTitle" GUIContent
Styles o-> "PositionIcon" GUIContent
Styles o-> "RotationIcon" GUIContent
Styles o-> "XTitle" GUIContent
Styles o-> "YTitle" GUIContent
Styles o-> "ZTitle" GUIContent
Styles o-> "PositionTitle" GUIContent
Styles o-> "RotationTitle" GUIContent
Styles o-> "OffsetModeTitle" GUIContent
Styles o-> "RecordingOffsets" GUIContent
class BasicAssetInspector {
    + <<override>> OnInspectorGUI() : void
    + <<virtual>> ApplyChanges() : void
    {static} SkipField(fieldName:string) : bool
}
class ActivationPlayableAssetInspector {
}
Editor <|-- BasicAssetInspector
BasicAssetInspector <|-- ActivationPlayableAssetInspector
class BuiltInPresets <<static>> {
    {static} ReverseCurve(curve:AnimationCurve) : AnimationCurve
}
BuiltInPresets --> "s_BlendInPresets" CurvePresetLibrary
BuiltInPresets --> "s_BlendOutPresets" CurvePresetLibrary
BuiltInPresets --> "blendInPresets" CurvePresetLibrary
BuiltInPresets --> "blendOutPresets" CurvePresetLibrary
class DirectorNamedColorInspector {
    + <<override>> OnInspectorGUI() : void
}
Editor <|-- DirectorNamedColorInspector
class EditorClip {
    + lastHash : int <<get>> <<set>>
    + <<override>> GetHashCode() : int
}
ScriptableObject <|-- EditorClip
EditorClip --> "m_Clip" TimelineClip
EditorClip --> "clip" TimelineClip
class EditorClipFactory <<static>> {
    + {static} GetEditorClip(clip:TimelineClip) : EditorClip
    + {static} RemoveEditorClip(clip:TimelineClip) : void
    + {static} Contains(clip:TimelineClip) : bool
}
class "Dictionary`2"<T1,T2> {
}
EditorClipFactory o-> "s_EditorCache<TimelineClip,EditorClip>" "Dictionary`2"
class GroupTrackInspector {
    + <<override>> OnInspectorGUI() : void
    + <<override>> OnEnable() : void
    {static} OnDrawHeader(rect:Rect) : void
    OnDrawSubTrack(rect:Rect, index:int, selected:bool, focused:bool) : void
}
class Styles <<static>> {
}
TrackAssetInspector <|-- GroupTrackInspector
GroupTrackInspector --> "m_SubTracks" ReorderableList
GroupTrackInspector +-- Styles
Styles o-> "GroupSubTrackHeaderName" GUIContent
Styles o-> "GroupSubTrackHeaderType" GUIContent
Styles o-> "GroupSubTrackHeaderDuration" GUIContent
Styles o-> "GroupSubTrackHeaderFrames" GUIContent
Styles o-> "GroupInvalidTrack" GUIContent
class MarkerInspector {
    <<internal>> <<override>> IsEnabled() : bool
    <<internal>> <<override>> OnHeaderTitleGUI(titleRect:Rect, header:string) : void
    {static} IsCurrentSequenceReadOnly() : bool
}
class Styles <<static>> {
    + {static} <<readonly>> MultipleMarkerSelectionTitle : string
    + {static} <<readonly>> UndoCommand : string
}
BasicAssetInspector <|-- MarkerInspector
MarkerInspector +-- Styles
class TimeFieldDrawer {
    {static} currentFrameRate : float <<get>>
    + <<override>> OnGUI(position:Rect, property:SerializedProperty, label:GUIContent) : void
    {static} TimeField(rect:Rect, property:SerializedProperty, label:GUIContent) : void
    {static} TimeFieldWithEditMode(rect:Rect, property:SerializedProperty, label:GUIContent) : void
}
PropertyDrawer <|-- TimeFieldDrawer
TimeFieldDrawer --> "state" WindowState
class TimelineAssetInspector {
    InitializeProperties() : void
    + OnEnable() : void
    <<internal>> <<override>> IsEnabled() : bool
    + <<override>> OnInspectorGUI() : void
}
class Styles <<static>> {
}
Editor <|-- TimelineAssetInspector
TimelineAssetInspector --> "m_FrameRateProperty" SerializedProperty
TimelineAssetInspector --> "m_DurationModeProperty" SerializedProperty
TimelineAssetInspector --> "m_FixedDurationProperty" SerializedProperty
TimelineAssetInspector +-- Styles
Styles o-> "FrameRate" GUIContent
Styles o-> "DurationMode" GUIContent
Styles o-> "Duration" GUIContent
Styles o-> "HeaderTitleMultiselection" GUIContent
enum InputEvent {
    None= 0,
    DragEnter= 1,
    DragExit= 2,
    Drag= 4,
    KeyboardInput= 8,
}
class InputEventMethods <<static>> {
    + {static} InputHasBegun(evt:InputEvent) : bool
}
class TimelineInspectorUtility <<static>> {
    + {static} TimeField(property:SerializedProperty, label:GUIContent, readOnly:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : void
    + {static} TimeField(rect:Rect, property:SerializedProperty, label:GUIContent, readOnly:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : void
    + {static} TimeFieldUsingTimeReference(label:GUIContent, time:double, readOnly:bool, showMixed:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : double
    + {static} DurationFieldUsingTimeReference(label:GUIContent, start:double, end:double, readOnly:bool, showMixed:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : double
    + {static} TimeField(rect:Rect, label:GUIContent, time:double, readOnly:bool, showMixed:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : double
    + {static} TimeField(label:GUIContent, time:double, readOnly:bool, showMixed:bool, frameRate:double, minValue:double, maxValue:double, inputEvent:InputEvent) : double
    {static} InputEventType(rect:Rect, id:int) : InputEvent
    {static} DelayedAndDraggableDoubleField(rect:Rect, label:GUIContent, value:double, inputEvent:InputEvent, dragSensitivity:double) : double
    {static} DelayedAndDraggableIntField(rect:Rect, label:GUIContent, value:int, inputEvent:InputEvent, dragSensitivity:long) : int
    <<internal>> {static} DelayedAndDraggableDoubleField(label:GUIContent, value:double, action:InputEvent, dragSensitivity:double) : double
    {static} DelayedAndDraggableDoubleField(rect:Rect, label:GUIContent, property:SerializedProperty, inputEvent:InputEvent) : void
    {static} DelayedAndDraggableDoubleField(rect:Rect, label:GUIContent, value:double, inputEvent:InputEvent) : double
    {static} DelayedAndDraggableIntField(rect:Rect, label:GUIContent, value:int, inputEvent:InputEvent) : int
    <<internal>> {static} Clamp(val:T, min:T, max:T) : T
    + {static} GetInspectorForObjects(objects:UnityEngine.Object[]) : Editor
}
class Styles <<static>> {
}
TimelineInspectorUtility +-- Styles
Styles o-> "SecondsPrefix" GUIContent
Styles o-> "FramesPrefix" GUIContent
class TrackAssetInspector {
    m_IsBuiltInType : bool
    + <<override>> OnInspectorGUI() : void
    <<internal>> <<override>> IsEnabled() : bool
    <<internal>> <<override>> OnHeaderTitleGUI(titleRect:Rect, header:string) : void
    <<internal>> <<override>> OnHeaderIconGUI(iconRect:Rect) : void
    <<internal>> <<override>> DrawHeaderHelpAndSettingsGUI(r:Rect) : Rect
    + <<virtual>> OnEnable() : void
    DrawInspector() : void
    {static} IsCurrentSequenceReadOnly() : bool
}
class TrackCurvesWrapper {
    + lastCurveVersion : int <<get>> <<set>>
    + lastEvalTime : double <<get>> <<set>>
    + TrackCurvesWrapper(track:TrackAsset)
    + ToLocalTime(time:double) : double
}
Editor <|-- TrackAssetInspector
TrackAssetInspector --> "m_TrackCurvesWrapper" TrackCurvesWrapper
TrackAssetInspector --> "m_Name" SerializedProperty
TrackAssetInspector --> "m_HeaderIcon" Texture
TrackAssetInspector +-- TrackCurvesWrapper
ICurvesOwnerInspectorWrapper <|-- TrackCurvesWrapper
TrackCurvesWrapper --> "curvesOwner" ICurvesOwner
TrackCurvesWrapper --> "serializedPlayableAsset" SerializedObject
class ClipItem {
    + ClipItem(clip:TimelineClip)
    + start : double <<get>> <<set>>
    + end : double <<get>>
    + duration : double <<get>>
    + IsCompatibleWithTrack(track:TrackAsset) : bool
    + PushUndo(operation:string) : void
    + supportsBlending : bool <<get>>
    + hasLeftBlend : bool <<get>>
    + hasRightBlend : bool <<get>>
    + leftBlendDuration : double <<get>>
    + rightBlendDuration : double <<get>>
    + SetStart(time:double) : void
    + SetEnd(time:double, affectTimeScale:bool) : void
    + Delete() : void
    + TrimStart(time:double) : void
    + TrimEnd(time:double) : void
    + CloneTo(parent:TrackAsset, time:double) : ITimelineItem
    + <<override>> ToString() : string
    + Equals(otherClip:ClipItem) : bool
    + <<override>> GetHashCode() : int
    + Equals(other:ITimelineItem) : bool
    + <<override>> Equals(obj:object) : bool
}
IBlendable <|-- ClipItem
ITrimmable <|-- ClipItem
ClipItem --> "m_Clip" TimelineClip
ClipItem --> "clip" TimelineClip
ClipItem --> "parentTrack" TrackAsset
ClipItem --> "gui" TimelineItemGUI
class ItemsGroup {
    + start : double <<get>> <<set>>
    + end : double <<get>>
    + ItemsGroup(items:IEnumerable<ITimelineItem>)
}
ItemsGroup --> "m_LeftMostItem" ITimelineItem
ItemsGroup --> "m_RightMostItem" ITimelineItem
ItemsGroup --> "leftMostItem" ITimelineItem
ItemsGroup --> "rightMostItem" ITimelineItem
class ItemsPerTrack {
    + ItemsPerTrack(targetTrack:TrackAsset, items:IEnumerable<ITimelineItem>)
}
class "IEnumerable`1"<T> {
}
ItemsPerTrack --> "targetTrack" TrackAsset
ItemsPerTrack --> "items<ITimelineItem>" "IEnumerable`1"
ItemsPerTrack --> "clips<TimelineClip>" "IEnumerable`1"
ItemsPerTrack --> "markers<IMarker>" "IEnumerable`1"
ItemsPerTrack --> "leftMostItem" ITimelineItem
ItemsPerTrack --> "rightMostItem" ITimelineItem
class ItemsUtils <<static>> {
    + {static} ToItemsPerTrack(items:IEnumerable<ITimelineItem>) : IEnumerable<ItemsPerTrack>
    + {static} ToItem(clip:TimelineClip) : ITimelineItem
    + {static} ToItem(marker:IMarker) : ITimelineItem
    + {static} ToItems(clips:IEnumerable<TimelineClip>) : IEnumerable<ITimelineItem>
    + {static} ToItems(markers:IEnumerable<IMarker>) : IEnumerable<ITimelineItem>
    + {static} GetItems(track:TrackAsset) : IEnumerable<ITimelineItem>
    + {static} GetItemRange(track:TrackAsset, start:double, end:double) : void
    + {static} GetItemsExcept(track:TrackAsset, items:IEnumerable<ITimelineItem>) : IEnumerable<ITimelineItem>
    + {static} GetItemTypes(items:IEnumerable<ITimelineItem>) : IEnumerable<Type>
    + {static} GetItemTypes(itemsGroups:IEnumerable<ItemsPerTrack>) : IEnumerable<Type>
    + {static} SetItemsStartTime(newItems:IEnumerable<ItemsPerTrack>, time:double) : void
    + {static} TimeGapBetweenItems(leftItem:ITimelineItem, rightItem:ITimelineItem, state:WindowState) : double
}
class "Dictionary`2"<T1,T2> {
}
ItemsUtils o-> "s_ClipCache<TimelineClip,ClipItem>" "Dictionary`2"
ItemsUtils o-> "s_MarkerCache<IMarker,MarkerItem>" "Dictionary`2"
interface ITimelineItem {
    start : double <<get>> <<set>>
    end : double <<get>>
    duration : double <<get>>
    IsCompatibleWithTrack(track:TrackAsset) : bool
    Delete() : void
    CloneTo(parent:TrackAsset, time:double) : ITimelineItem
    PushUndo(operation:string) : void
}
interface ITrimmable {
    SetStart(time:double) : void
    SetEnd(time:double, affectTimeScale:bool) : void
    TrimStart(time:double) : void
    TrimEnd(time:double) : void
}
interface IBlendable {
    supportsBlending : bool <<get>>
    hasLeftBlend : bool <<get>>
    hasRightBlend : bool <<get>>
    leftBlendDuration : double <<get>>
    rightBlendDuration : double <<get>>
}
class "IEquatable`1"<T> {
}
"IEquatable`1" "<ITimelineItem>" <|-- ITimelineItem
ITimelineItem --> "parentTrack" TrackAsset
ITimelineItem --> "gui" TimelineItemGUI
ITimelineItem <|-- ITrimmable
ITimelineItem <|-- IBlendable
class MarkerItem {
    + MarkerItem(marker:IMarker)
    + start : double <<get>> <<set>>
    + end : double <<get>>
    + duration : double <<get>>
    + IsCompatibleWithTrack(track:TrackAsset) : bool
    + PushUndo(operation:string) : void
    + Delete() : void
    + CloneTo(parent:TrackAsset, time:double) : ITimelineItem
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
    + Equals(other:ITimelineItem) : bool
    + <<override>> Equals(obj:object) : bool
}
ITimelineItem <|-- MarkerItem
MarkerItem --> "m_Marker" IMarker
MarkerItem --> "marker" IMarker
MarkerItem --> "parentTrack" TrackAsset
MarkerItem --> "gui" TimelineItemGUI
class EditMode <<static>> {
    {static} GetSubEditMode(type:EditType) : ISubEditMode
    {static} GetSubEditType(key:KeyCode) : EditType
    + {static} ClearEditMode() : void
    + {static} BeginTrim(item:ITimelineItem, trimDirection:TrimEdge) : void
    + {static} TrimStart(item:ITimelineItem, time:double) : void
    + {static} TrimEnd(item:ITimelineItem, time:double, affectTimeScale:bool) : void
    + {static} DrawTrimGUI(state:WindowState, item:TimelineItemGUI, edge:TrimEdge) : void
    + {static} FinishTrim() : void
    + {static} BeginMove(moveItemHandler:MoveItemHandler) : void
    + {static} UpdateMove() : void
    + {static} OnTrackDetach(grabbedTrackItems:IEnumerable<ItemsPerTrack>) : void
    + {static} HandleTrackSwitch(grabbedTrackItems:IEnumerable<ItemsPerTrack>) : void
    + {static} AllowTrackSwitch() : bool
    + {static} AdjustStartTime(state:WindowState, itemsGroup:ItemsPerTrack, time:double) : double
    + {static} ValidateDrag(itemsGroup:ItemsPerTrack) : bool
    + {static} DrawMoveGUI(state:WindowState, movingItems:IEnumerable<MovingItems>) : void
    + {static} FinishMove() : void
    + {static} FinalizeInsertItemsAtTime(newItems:IEnumerable<ItemsPerTrack>, requestedTime:double) : void
    + {static} PrepareItemsDelete(newItems:IEnumerable<ItemsPerTrack>) : void
    + {static} HandleModeClutch() : void
}
enum EditType {
    None= -1,
    Mix= 0,
    Ripple= 1,
    Replace= 2,
}
interface ISubEditMode {
    Reset() : void
}
class "SubEditMode`3"<TMoveMode,TTrimMode,TAddDeleteMode> {
    + SubEditMode(guiColor:Color, key:KeyCode)
    + Reset() : void
    m_MoveItemMode : TMoveMode
    m_TrimItemMode : TTrimMode
    m_AddDeleteItemMode : TAddDeleteMode
}
class "Dictionary`2"<T1,T2> {
}
EditMode o-> "k_EditModes<EditType,ISubEditMode>" "Dictionary`2"
EditMode o-> "s_CurrentEditType" EditType
EditMode o-> "s_OverrideEditType" EditType
EditMode --> "s_CurrentTrimItem" ITrimmable
EditMode --> "s_CurrentTrimDirection" TrimEdge
EditMode --> "s_CurrentMoveItemHandler" MoveItemHandler
EditMode o-> "s_InputHandler" EditModeInputHandler
EditMode --> "trimMode" ITrimItemMode
EditMode --> "trimDrawer" ITrimItemDrawer
EditMode --> "moveMode" IMoveItemMode
EditMode --> "moveDrawer" IMoveItemDrawer
EditMode --> "addDeleteMode" IAddDeleteItemMode
EditMode --> "inputHandler" EditModeInputHandler
EditMode --> "modeColor" Color
EditMode --> "editType" EditType
EditMode +-- EditType
EditMode +-- ISubEditMode
ISubEditMode --> "moveItemMode" IMoveItemMode
ISubEditMode --> "moveItemDrawer" IMoveItemDrawer
ISubEditMode --> "trimItemMode" ITrimItemMode
ISubEditMode --> "trimItemDrawer" ITrimItemDrawer
ISubEditMode --> "addDeleteItemMode" IAddDeleteItemMode
ISubEditMode --> "color" Color
ISubEditMode --> "clutchKey" KeyCode
EditMode +-- "SubEditMode`3"
ISubEditMode <|-- "SubEditMode`3"
"SubEditMode`3" --> "moveItemMode" IMoveItemMode
"SubEditMode`3" --> "moveItemDrawer" IMoveItemDrawer
"SubEditMode`3" --> "trimItemMode" ITrimItemMode
"SubEditMode`3" --> "trimItemDrawer" ITrimItemDrawer
"SubEditMode`3" --> "addDeleteItemMode" IAddDeleteItemMode
"SubEditMode`3" --> "color" Color
"SubEditMode`3" --> "clutchKey" KeyCode
class EditModeInputHandler {
    + EditModeInputHandler()
    + ProcessMove(action:InputEvent, value:double) : void
    + ProcessTrim(action:InputEvent, value:double, stretch:bool) : void
    + SetValueForEdge(items:IEnumerable<ITimelineItem>, edge:AttractedEdge, value:double) : void
    + OnGUI(state:WindowState, evt:Event) : void
    {static} ProcessInputAction(handler:IInputHandler, action:InputEvent, value:double, state:WindowState) : void
}
interface IInputHandler {
    OnEnterDrag(items:IEnumerable<ITimelineItem>, state:WindowState) : void
    OnDrag(value:double, state:WindowState) : void
    OnExitDrag() : void
    OnSetValue(items:IEnumerable<ITimelineItem>, value:double, state:WindowState) : void
}
class TrimInputHandler {
    isDragging : bool <<get>> <<set>>
    + stretch : bool <<get>> <<set>>
    + OnEnterDrag(items:IEnumerable<ITimelineItem>, state:WindowState) : void
    + OnDrag(endValue:double, state:WindowState) : void
    + OnExitDrag() : void
    + OnSetValue(items:IEnumerable<ITimelineItem>, endValue:double, state:WindowState) : void
    + OnGUI(state:WindowState) : void
}
class MoveInputHandler {
    + OnEnterDrag(items:IEnumerable<ITimelineItem>, state:WindowState) : void
    + OnDrag(value:double, state:WindowState) : void
    + OnExitDrag() : void
    + OnSetValue(items:IEnumerable<ITimelineItem>, value:double, state:WindowState) : void
    + OnGUI(evt:Event) : void
    + {static} SetValueForEdge(items:IEnumerable<ITimelineItem>, edge:AttractedEdge, value:double, state:WindowState) : void
}
class "IEnumerable`1"<T> {
}
EditModeInputHandler --> "m_MoveHandler" MoveInputHandler
EditModeInputHandler --> "m_TrimHandler" TrimInputHandler
EditModeInputHandler +-- IInputHandler
EditModeInputHandler +-- TrimInputHandler
IInputHandler <|-- TrimInputHandler
TrimInputHandler --> "grabbedItems<ITimelineItem>" "IEnumerable`1"
EditModeInputHandler +-- MoveInputHandler
IInputHandler <|-- MoveInputHandler
MoveInputHandler --> "m_MoveItemHandler" MoveItemHandler
class TimeAreaAutoPanner {
    <<const>> k_PixelDistanceToMaxSpeed : float = 100.0f
    <<const>> k_MaxPanSpeed : float = 30.0f
    + TimeAreaAutoPanner(state:WindowState)
    + OnGUI(evt:Event) : void
    {static} GetPanFactor(v:float, min:float, max:float, factor:float) : bool
}
TimeAreaAutoPanner --> "m_State" WindowState
TimeAreaAutoPanner --> "m_Window" TimelineWindow
TimeAreaAutoPanner --> "m_ViewRect" Rect
class TimeIndicator <<static>> {
    + {static} Draw(state:WindowState, time:double) : void
    + {static} Draw(state:WindowState, start:double, end:double) : void
}
TimeIndicator o-> "s_Tooltip" Tooltip
class TimelineClipGroup {
    + start : double <<get>> <<set>>
    + end : double <<get>>
    + TimelineClipGroup(clips:IEnumerable<TimelineClip>)
}
TimelineClipGroup --> "m_LeftMostClip" TimelineClip
TimelineClipGroup --> "m_RightMostClip" TimelineClip
class ControlPlayableInspector {
    m_CycleReference : bool
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
    + DisablePlayOnAwake(sourceObject:GameObject) : void
    + DisablePlayOnAwake(director:PlayableDirector) : void
    CheckForCyclicReference() : void
}
class Styles <<static>> {
    {static} s_DisabledBecauseOfSelfControlTooltip : string = "Must be disabled when the Source Game Object references the same PlayableDirector component that is being controlled"
}
Editor <|-- ControlPlayableInspector
ControlPlayableInspector --> "m_SourceObject" SerializedProperty
ControlPlayableInspector --> "m_PrefabObject" SerializedProperty
ControlPlayableInspector --> "m_UpdateParticle" SerializedProperty
ControlPlayableInspector --> "m_UpdateDirector" SerializedProperty
ControlPlayableInspector --> "m_UpdateITimeControl" SerializedProperty
ControlPlayableInspector --> "m_SearchHierarchy" SerializedProperty
ControlPlayableInspector --> "m_UseActivation" SerializedProperty
ControlPlayableInspector --> "m_PostPlayback" SerializedProperty
ControlPlayableInspector --> "m_RandomSeed" SerializedProperty
ControlPlayableInspector o-> "m_SourceObjectLabel" GUIContent
ControlPlayableInspector +-- Styles
Styles o-> "activationContent" GUIContent
Styles o-> "activationDisabledContent" GUIContent
Styles o-> "prefabContent" GUIContent
Styles o-> "advancedContent" GUIContent
Styles o-> "updateParticleSystemsContent" GUIContent
Styles o-> "updatePlayableDirectorContent" GUIContent
Styles o-> "updatePlayableDirectorDisabledContent" GUIContent
Styles o-> "updateITimeControlContent" GUIContent
Styles o-> "updateHierarchy" GUIContent
Styles o-> "randomSeedContent" GUIContent
Styles o-> "postPlayableContent" GUIContent
class AnimationTrackRecorder {
    + {static} <<readonly>> kRecordClipDefaultName : string
    m_CurveCount : int = 0
    m_ClipTime : double
    m_needRebuildRects : bool
    m_TrackHasPreviewComponents : bool
    + PrepareForRecord(state:WindowState) : void
    + PrepareTrack(track:TrackAsset, state:WindowState, gameObject:GameObject, startTime:double) : AnimationClip
    {static} GetCurveCount(animationClip:AnimationClip) : int
    + FinializeTrack(track:TrackAsset, state:WindowState) : void
    + FinalizeRecording(state:WindowState) : void
    + {static} GetUniqueRecordedClipName(owner:Object, name:string) : string
    + {static} AddRecordableClip(parentTrack:TrackAsset, state:WindowState, atTime:double) : TimelineClip
    <<internal>> {static} GetAddedRecordingClipRange(track:TrackAsset, state:WindowState, atTime:double, start:double, end:double) : void
    <<internal>> {static} ShiftAnimationClip(clip:AnimationClip, amount:float) : void
    {static} ShiftKeys(keys:Keyframe[], time:float) : Keyframe[]
    {static} ShiftObjectKeys(keys:ObjectReferenceKeyframe[], time:float) : ObjectReferenceKeyframe[]
}
AnimationTrackRecorder --> "m_TargetClip" AnimationClip
AnimationTrackRecorder --> "recordClip" TimelineClip
class TimelineRecording <<static>> <<partial>> {
    <<internal>> {static} ProcessUndoModification(modifications:UndoPropertyModification[], state:WindowState) : UndoPropertyModification[]
    {static} GetTarget(undo:UndoPropertyModification) : UnityEngine.Object
    {static} GetTrackForGameObject(gameObject:GameObject, state:WindowState) : TrackAsset
    + {static} GetRecordingTrack(property:SerializedProperty, state:WindowState) : TrackAsset
    {static} GatherModifications(property:SerializedProperty, modifications:List<PropertyModification>) : void
    + {static} CanRecord(property:SerializedProperty, state:WindowState) : bool
    + {static} AddKey(prop:SerializedProperty, state:WindowState) : void
    + {static} AddKey(modifications:IEnumerable<PropertyModification>, state:WindowState) : void
    {static} PropertyModificationToUndoPropertyModification(prop:PropertyModification) : UndoPropertyModification
    {static} GetRecordingClip(asset:TrackAsset, state:WindowState, startTime:double, timeScale:double) : AnimationClip
    {static} GetClipAndRelativeTime(target:UnityEngine.Object, state:WindowState, outClip:AnimationClip, keyTime:double, keyInRange:bool) : bool
    + {static} HasCurve(modifications:IEnumerable<PropertyModification>, target:UnityEngine.Object, state:WindowState) : bool
    + {static} HasKey(modifications:IEnumerable<PropertyModification>, target:UnityEngine.Object, state:WindowState) : bool
    {static} HasBinding(target:UnityEngine.Object, modification:PropertyModification, clip:AnimationClip, binding:EditorCurveBinding) : bool
    + {static} RemoveKey(target:UnityEngine.Object, modifications:IEnumerable<PropertyModification>, state:WindowState) : void
    {static} GetKeyTimes(target:UnityEngine.Object, modifications:IEnumerable<PropertyModification>, state:WindowState) : HashSet<double>
    + {static} NextKey(target:UnityEngine.Object, modifications:IEnumerable<PropertyModification>, state:WindowState) : void
    + {static} PrevKey(target:UnityEngine.Object, modifications:IEnumerable<PropertyModification>, state:WindowState) : void
    + {static} RemoveCurve(target:UnityEngine.Object, modifications:IEnumerable<PropertyModification>, state:WindowState) : void
    + {static} GetRecordableGameObjects(state:WindowState) : IEnumerable<GameObject>
}
class "List`1"<T> {
}
TimelineRecording o-> "s_TempPropertyModifications<PropertyModification>" "List`1"
class TimelineRecordingContextualResponder {
    + TimelineRecordingContextualResponder(_state:WindowState)
    + HasAnyCandidates() : bool
    + HasAnyCurves() : bool
    + AddCandidateKeys() : void
    + AddAnimatedKeys() : void
    + IsAnimatable(modifications:PropertyModification[]) : bool
    + IsEditable(targetObject:Object) : bool
    + KeyExists(modifications:PropertyModification[]) : bool
    + CandidateExists(modifications:PropertyModification[]) : bool
    + CurveExists(modifications:PropertyModification[]) : bool
    + AddKey(modifications:PropertyModification[]) : void
    + RemoveKey(modifications:PropertyModification[]) : void
    + RemoveCurve(modifications:PropertyModification[]) : void
    + GoToNextKeyframe(modifications:PropertyModification[]) : void
    + GoToPreviousKeyframe(modifications:PropertyModification[]) : void
}
IAnimationContextualResponder <|-- TimelineRecordingContextualResponder
TimelineRecordingContextualResponder --> "state" WindowState
class TimelineRecording <<static>> <<partial>> {
    + <<const>> kLocalPosition : string = "m_LocalPosition"
    + <<const>> kLocalRotation : string = "m_LocalRotation"
    + <<const>> kLocalEulerHint : string = "m_LocalEulerAnglesHint"
    <<const>> kRotationWarning : string = "You are recording with an initial rotation offset. This may result in a misrepresentation of euler angles. When recording transform properties, it is recommended to reset rotation prior to recording"
    + {static} IsRecordingAnimationTrack : bool <<get>>
    <<internal>> {static} ProcessMonoBehaviourModification(modifications:UndoPropertyModification[], state:WindowState) : UndoPropertyModification[]
    <<internal>> {static} IsPosition(modification:UndoPropertyModification) : bool
    <<internal>> {static} IsRotation(modification:UndoPropertyModification) : bool
    <<internal>> {static} IsPositionOrRotation(modification:UndoPropertyModification) : bool
    <<internal>> {static} UpdatePreviewMode(mods:UndoPropertyModification[], go:GameObject) : void
    <<internal>> {static} IsRootModification(modification:UndoPropertyModification) : bool
    <<internal>> {static} ClipHasPositionOrRotation(clip:AnimationClip) : bool
    <<internal>> {static} ComputeInitialClipOffsets(track:AnimationTrack, mods:UndoPropertyModification[], animator:Animator) : TimelineAnimationUtilities.RigidTransform
    <<internal>> {static} GetInitialTransform(mods:UndoPropertyModification[], animator:Animator) : TimelineAnimationUtilities.RigidTransform
    <<internal>> {static} SetPreviousPositionAndRotation(mods:UndoPropertyModification[], animator:Animator, pos:Vector3, rot:Quaternion) : void
    <<internal>> {static} AddTrackOffset(track:AnimationTrack, mods:UndoPropertyModification[], clip:AnimationClip, animator:Animator) : void
    <<internal>> {static} AddClipOffset(track:AnimationTrack, mods:UndoPropertyModification[], clip:TimelineClip, animator:Animator) : void
    <<internal>> {static} GetLocalToTrack(track:AnimationTrack, clip:TimelineClip) : TimelineAnimationUtilities.RigidTransform
    <<internal>> {static} HasOffsets(track:AnimationTrack, clip:TimelineClip) : bool
    <<internal>> {static} RemoveOffsets(modification:UndoPropertyModification, track:AnimationTrack, clip:TimelineClip, mods:UndoPropertyModification[]) : void
    <<internal>> {static} ReapplyOffsets(modification:UndoPropertyModification, track:AnimationTrack, clip:TimelineClip, mods:UndoPropertyModification[]) : void
    {static} GatherRelatedModifications(toMatch:UndoPropertyModification, list:List<UndoPropertyModification>) : UndoPropertyModification[]
    {static} GetGameObjectFromModification(mod:UndoPropertyModification) : GameObject
    {static} GetChildLevel(parent:GameObject, child:GameObject) : int
    {static} DoesPropertyPathMatch(a:string, b:string) : bool
    <<internal>> {static} GetPreviousPositionAndRotation(mods:UndoPropertyModification[], position:Vector3, rotation:Quaternion) : void
    <<internal>> {static} GetCurrentPositionAndRotation(mods:UndoPropertyModification[], position:Vector3, rotation:Quaternion) : void
    <<internal>> {static} SetPreviousPositionAndRotation(mods:UndoPropertyModification[], pos:Vector3, rot:Quaternion) : void
    <<internal>> {static} SetCurrentPositionAndRotation(mods:UndoPropertyModification[], pos:Vector3, rot:Quaternion) : void
    <<internal>> {static} ParseFloat(str:string, defaultVal:float) : float
    <<internal>> {static} HandleEulerModifications(track:AnimationTrack, clip:TimelineClip, animClip:AnimationClip, time:float, mods:UndoPropertyModification[]) : UndoPropertyModification[]
    <<internal>> {static} FindBestEulerHint(rotation:Quaternion, clip:AnimationClip, time:float, transform:Transform) : IEnumerable<UndoPropertyModification>
}
class RecordingState {
    + SaveCurve(curve:AnimationWindowCurve) : void
    + AddPropertyModification(binding:EditorCurveBinding, propertyModification:PropertyModification, keepPrefabOverride:bool) : void
    + addZeroFrame : bool <<get>>
    + currentFrame : int <<get>> <<set>>
    + DiscardModification(modification:PropertyModification) : bool
}
class "List`1"<T> {
}
TimelineRecording o-> "s_RecordState" RecordingState
TimelineRecording o-> "s_TrackRecorder" AnimationTrackRecorder
TimelineRecording o-> "s_UnprocessedMods<UndoPropertyModification>" "List`1"
TimelineRecording o-> "s_ModsToProcess<UndoPropertyModification>" "List`1"
TimelineRecording --> "s_LastTrackWarning" AnimationTrack
TimelineRecording +-- RecordingState
IAnimationRecordingState <|-- RecordingState
RecordingState --> "activeGameObject" GameObject
RecordingState --> "activeRootGameObject" GameObject
RecordingState --> "activeAnimationClip" AnimationClip
class TimelineRecording <<static>> <<partial>> {
    <<internal>> {static} HasAnyPlayableAssetModifications(modifications:UndoPropertyModification[]) : bool
    <<internal>> {static} ProcessPlayableAssetModification(modifications:UndoPropertyModification[], state:WindowState) : UndoPropertyModification[]
    {static} ProcessPlayableAssetModification(mod:UndoPropertyModification, state:WindowState) : bool
    <<internal>> {static} FindClipWithAsset(asset:TimelineAsset, target:IPlayableAsset) : TimelineClip
    {static} ProcessPlayableAssetRecording(mod:UndoPropertyModification, state:WindowState, curvesOwner:ICurvesOwner) : bool
    {static} IsPlayableAssetProperty(property:SerializedProperty) : bool
}
class TrackAssetRecordingExtensions <<static>> {
    <<internal>> {static} OnRecordingArmed(track:TrackAsset, director:PlayableDirector) : void
    <<internal>> {static} OnRecordingTimeChanged(track:TrackAsset, director:PlayableDirector) : void
    <<internal>> {static} OnRecordingUnarmed(track:TrackAsset, director:PlayableDirector) : void
    <<internal>> {static} CanRecordAtTime(track:TrackAsset, time:double) : bool
    <<internal>> {static} GetActiveRecordingAnimationClip(track:TrackAsset) : AnimationClip
    <<internal>> {static} IsRecordingToClip(track:TrackAsset, clip:TimelineClip) : bool
    <<internal>> {static} FindRecordingClipAtTime(track:TrackAsset, time:double, target:TimelineClip) : bool
    <<internal>> {static} FindRecordingAnimationClipAtTime(trackAsset:TrackAsset, time:double) : AnimationClip
    <<internal>> {static} ClearRecordingState() : void
}
class "Dictionary`2"<T1,T2> {
}
TrackAssetRecordingExtensions o-> "s_ActiveClips<TrackAsset,AnimationClip>" "Dictionary`2"
class SignalAssetInspector {
    + {static} CreateNewSignal() : void
}
class DoCreateSignalAsset {
    + <<override>> Action(instanceId:int, pathName:string, resourceFile:string) : void
}
Editor <|-- SignalAssetInspector
SignalAssetInspector +-- DoCreateSignalAsset
class SignalEmitterEditor {
    {static} <<readonly>> MissingAssetError : string
    + <<override>> GetMarkerOptions(marker:IMarker) : MarkerDrawOptions
}
MarkerEditor <|-- SignalEmitterEditor
class SignalEmitterInspector {
    m_TargetsHaveTheSameBinding : bool
    signalAssetSameValue : bool <<get>>
    OnEnable() : void
    <<internal>> <<override>> IsEnabled() : bool
    + <<override>> OnInspectorGUI() : void
    <<internal>> <<override>> OnHeaderIconGUI(iconRect:Rect) : void
    <<internal>> <<override>> DrawHeaderHelpAndSettingsGUI(r:Rect) : Rect
    AvailableSignalAssets() : IEnumerable<SignalAsset>
    CreateNewSignalAsset(path:string) : void
    UpdateState() : void
    GetOrCreateReceiverEditor(c:Component) : Editor
    OnDisable() : void
    OnDestroy() : void
    OnUndoRedo() : void
    ApplyChangesAndRefreshReceivers() : void
    DrawNameSelectorAndSignalList() : void
    DrawReceivers() : void
    DrawSignalFlags() : void
    DrawSignal() : void
    <<internal>> CreateNewSignalAsset(path:string) : void
    AssignSignalAsset(newAsset:SignalAsset) : void
    DrawNameSelector() : void
    DrawReceiverHeader(receiver:Component) : bool
    DrawReceiverObjectField() : void
    AddReceiverComponent() : void
    {static} SkipField(fieldName:string) : bool
    {static} DrawSplitLine(y:float) : void
    {static} GetBoundGameObject(track:TrackAsset, associatedDirector:PlayableDirector) : GameObject
    {static} IsCurrentSequenceReadOnly() : bool
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
MarkerInspector <|-- SignalEmitterInspector
ISignalAssetProvider <|-- SignalEmitterInspector
SignalEmitterInspector --> "m_RetroactiveProperty" SerializedProperty
SignalEmitterInspector --> "m_EmitOnceProperty" SerializedProperty
SignalEmitterInspector --> "m_Signal" SignalEmitter
SignalEmitterInspector --> "m_BoundGameObject" GameObject
SignalEmitterInspector --> "m_AssociatedDirector" PlayableDirector
SignalEmitterInspector o-> "m_Editors<Component,Editor>" "Dictionary`2"
SignalEmitterInspector o-> "m_Foldouts<Component,bool>" "Dictionary`2"
SignalEmitterInspector o-> "m_Receivers<Component>" "List`1"
SignalEmitterInspector --> "s_FoldoutStyle" GUIStyle
SignalEmitterInspector --> "foldoutStyle" GUIStyle
SignalEmitterInspector --> "signalAsset" SignalAsset
class SignalEventDrawer {
    {static} FindBoundObject(property:SerializedProperty) : GameObject
}
UnityEventDrawer <|-- SignalEventDrawer
class SignalManager {
    <<internal>> SignalManager()
    + {static} CreateSignalAssetInstance(path:string) : SignalAsset
    + Dispose() : void
    Register(a:SignalAsset) : void
    Refresh() : void
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
IDisposable <|-- SignalManager
SignalManager --> "m_Instance" SignalManager
SignalManager o-> "m_assets<SignalAsset>" "List`1"
SignalManager --> "instance" SignalManager
SignalManager --> "assets<SignalAsset>" "IEnumerable`1"
class SignalReceiverHeader {
    + SignalReceiverHeader(state:MultiColumnHeaderState)
}
MultiColumnHeader <|-- SignalReceiverHeader
class SignalReceiverInspector {
    OnEnable() : void
    OnDisable() : void
    OnUndoRedo() : void
    + <<override>> OnInspectorGUI() : void
    DrawEmitterControls() : void
    <<internal>> SetAssetContext(asset:SignalAsset) : void
    DrawAddRemoveButtons() : void
    InitTreeView(so:SerializedObject) : void
}
Editor <|-- SignalReceiverInspector
SignalReceiverInspector --> "m_Target" SignalReceiver
SignalReceiverInspector --> "m_TreeState" TreeViewState
SignalReceiverInspector --> "m_MultiColumnHeaderState" MultiColumnHeaderState
SignalReceiverInspector --> "m_TreeView" SignalReceiverTreeView
SignalReceiverInspector --> "signalEmitterContext" SignalEmitter
interface ISignalAssetProvider {
    AvailableSignalAssets() : IEnumerable<SignalAsset>
    CreateNewSignalAsset(path:string) : void
}
class SignalUtility <<static>> {
    <<const>> k_SignalExtension : string = "signal"
    + {static} DrawSignalNames(assetProvider:ISignalAssetProvider, position:Rect, label:GUIContent, multipleValues:bool) : void
    + {static} GetNewSignalPath() : string
    + {static} IsSignalAssetHandled(receiver:SignalReceiver, asset:SignalAsset) : bool
    + {static} AddNewReaction(receiver:SignalReceiver, signalAsset:SignalAsset) : void
    + {static} DrawCenteredMessage(message:string) : void
    + {static} DrawCenteredButton(buttonLabel:GUIContent) : bool
}
class SignalReceiverUtility <<static>> {
    <<const>> k_DefaultTreeviewHeaderHeight : int = 20
    + {static} headerHeight : int <<get>>
    + {static} FindSignalsProperty(obj:SerializedObject) : SerializedProperty
    + {static} FindEventsProperty(obj:SerializedObject) : SerializedProperty
}
ISignalAssetProvider --> "signalAsset" SignalAsset
class Styles <<static>> {
    + {static} <<readonly>> SignalListDuplicateOption : string
    + {static} <<readonly>> SignalListDeleteOption : string
    + {static} <<readonly>> NoBoundGO : string
    + {static} <<readonly>> MultiEditNotSupportedOnDifferentBindings : string
    + {static} <<readonly>> MultiEditNotSupportedOnDifferentSignals : string
    + {static} <<readonly>> UndoCreateSignalAsset : string
    + {static} <<readonly>> UndoDuplicateRow : string
    + {static} <<readonly>> UndoDeleteRow : string
    + {static} <<readonly>> UndoAddReaction : string
    + {static} <<readonly>> NoReaction : string
    + {static} <<readonly>> NoSignalReceiverComponent : string
    + {static} <<readonly>> ProjectHasNoSignalAsset : string
}
Styles o-> "RetroactiveLabel" GUIContent
Styles o-> "EmitOnceLabel" GUIContent
Styles o-> "EmitSignalLabel" GUIContent
Styles o-> "ObjectLabel" GUIContent
Styles o-> "CreateNewSignal" GUIContent
Styles o-> "AddSignalReceiverComponent" GUIContent
Styles o-> "EmptySignalList" GUIContent
Styles o-> "AddReactionButton" GUIContent
Styles o-> "NewSignalWindowTitle" GUIContent
Styles o-> "NewSignalDefaultName" GUIContent
Styles o-> "NewSignalWindowMessage" GUIContent
Styles o-> "OptionsStyle" GUIStyle
Styles o-> "SignalEmitterIcon" GUIContent
interface ISequenceState {
    start : double <<get>>
    timeScale : double <<get>>
    duration : double <<get>>
    isReadOnly : bool <<get>>
    time : double <<get>> <<set>>
    frame : int <<get>> <<set>>
    frameRate : float <<get>> <<set>>
    GetEvaluableRange() : Range
    TimeAsString(timeValue:double, format:string) : string
    ToGlobalTime(t:double) : double
    ToLocalTime(t:double) : double
    ResetIsReadOnly() : void
}
class NullSequenceState {
    + start : double <<get>>
    + timeScale : double <<get>>
    + duration : double <<get>>
    + isReadOnly : bool <<get>>
    + time : double <<get>> <<set>>
    + frame : int <<get>> <<set>>
    + frameRate : float <<get>> <<set>>
    + GetEvaluableRange() : Range
    + TimeAsString(timeValue:double, format:string) : string
    + ToGlobalTime(t:double) : double
    + ToLocalTime(t:double) : double
    + ResetIsReadOnly() : void
    + Dispose() : void
}
IDisposable <|-- ISequenceState
ISequenceState --> "asset" TimelineAsset
ISequenceState --> "director" PlayableDirector
ISequenceState --> "hostClip" TimelineClip
ISequenceState --> "viewModel" TimelineAssetViewModel
ISequenceState <|-- NullSequenceState
NullSequenceState --> "asset" TimelineAsset
NullSequenceState --> "director" PlayableDirector
NullSequenceState --> "hostClip" TimelineClip
NullSequenceState --> "m_ViewModel" TimelineAssetViewModel
NullSequenceState --> "viewModel" TimelineAssetViewModel
class SequenceHierarchy {
    + count : int <<get>>
    + {static} CreateInstance() : SequenceHierarchy
    + Init(owner:WindowState) : void
    OnValidate() : void
    + Add(asset:TimelineAsset, director:PlayableDirector, hostClip:TimelineClip) : void
    + Remove() : void
    + GetStateAtIndex(index:int) : ISequenceState
    + RemoveUntilCount(expectedCount:int) : void
    + Clear() : void
    + ToSequencePath() : SequencePath
    + NeedsUpdate(path:SequencePath, forceRebuild:bool) : bool
    + FromSequencePath(path:SequencePath, forceRebuild:bool) : void
    Add_Internal(asset:TimelineAsset, director:PlayableDirector, hostClip:TimelineClip) : void
    Remove_Internal() : void
    RemoveUntilCount_Internal(expectedCount:int) : void
    Clear_Internal() : void
    UpdateSerializedPath() : void
    {static} ValidateSubElements(subElements:List<SequencePathSubElement>, director:PlayableDirector, buildingBlocks:List<SequenceBuildingBlock>) : bool
    {static} AddToCurrentUndoGroup(target:Object) : void
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
class SequenceBuildingBlock <<struct>> {
}
ScriptableObject <|-- SequenceHierarchy
SequenceHierarchy o-> "m_Sequences<ISequenceState>" "List`1"
SequenceHierarchy --> "m_WindowState" WindowState
SequenceHierarchy --> "m_SerializedPath" SequencePath
SequenceHierarchy --> "masterSequence" ISequenceState
SequenceHierarchy --> "editSequence" ISequenceState
SequenceHierarchy --> "allSequences<ISequenceState>" "IEnumerable`1"
SequenceHierarchy +-- SequenceBuildingBlock
SequenceBuildingBlock --> "asset" TimelineAsset
SequenceBuildingBlock --> "director" PlayableDirector
SequenceBuildingBlock --> "hostClip" TimelineClip
class SequencePath {
    m_SelectionRoot : int
    + selectionRoot : int <<get>>
    + SetSelectionRoot(instanceID:int) : void
    + AddSubSequence(state:ISequenceState, resolver:IExposedPropertyTable) : void
    + Clear() : void
    + {static} AreEqual(lhs:SequencePath, rhs:SequencePath) : bool
    + <<override>> ToString() : string
}
class SequencePathSubElement {
    + trackInstanceID : int
    + trackHash : int
    + clipIndex : int
    + clipHash : int
    + subDirectorIndex : int
    + {static} Create(state:ISequenceState, resolver:IExposedPropertyTable) : SequencePathSubElement
    + {static} AreEqual(lhs:SequencePathSubElement, rhs:SequencePathSubElement) : bool
    + <<override>> ToString() : string
}
class "List`1"<T> {
}
SequencePath --> "m_SubElements<SequencePathSubElement>" "List`1"
SequencePath --> "subElements<SequencePathSubElement>" "List`1"
class SequenceState {
    m_Time : double
    m_CachedEvaluableRange : Range?
    + start : double <<get>>
    + timeScale : double <<get>>
    + duration : double <<get>>
    m_IsReadOnly : bool?
    + isReadOnly : bool <<get>>
    + ResetIsReadOnly() : void
    + time : double <<get>> <<set>>
    + frame : int <<get>> <<set>>
    + frameRate : float <<get>> <<set>>
    + SequenceState(windowState:WindowState, asset:TimelineAsset, director:PlayableDirector, hostClip:TimelineClip, parentSequence:SequenceState)
    + GetEvaluableRange() : Range
    + TimeAsString(timeValue:double, format:string) : string
    + ToGlobalTime(t:double) : double
    + ToLocalTime(t:double) : double
    GetLocalTime() : double
    SetLocalTime(newTime:double) : void
    GetGlobalEvaluableRange() : Range
    + Dispose() : void
}
ISequenceState <|-- SequenceState
SequenceState --> "m_WindowState" WindowState
SequenceState --> "m_ParentSequence" SequenceState
SequenceState --> "asset" TimelineAsset
SequenceState --> "director" PlayableDirector
SequenceState --> "hostClip" TimelineClip
SequenceState --> "viewModel" TimelineAssetViewModel
class WindowState {
    <<const>> k_TimeCodeTextFieldId : int = 3790
    m_Recording : bool
    m_DirtyStamp : int
    m_SequencerHeaderWidth : float
    m_BindingAreaWidth : float
    m_MustRebuildGraph : bool
    m_LastTime : float
    + {static} kTimeEpsilon : double <<get>>
    + {static} <<readonly>> kMaxShownTime : float
    +  <<event>> windowOnGuiStarted : Action<WindowState, Event> 
    +  <<event>> windowOnGuiFinished : Action<WindowState, Event> 
    +  <<event>> OnPlayStateChange : Action<bool> 
    +  <<event>> OnDirtyStampChange : Action 
    +  <<event>> OnRebuildGraphChange : Action 
    +  <<event>> OnTimeChange : Action 
    +  <<event>> OnRecordingChange : Action 
    +  <<event>> OnBeforeSequenceChange : Action 
    +  <<event>> OnAfterSequenceChange : Action 
    + WindowState(w:TimelineWindow, hierarchy:SequenceHierarchy)
    + rebuildGraph : bool <<get>> <<set>>
    + mouseDragLag : float <<get>> <<set>>
    + AddCaptured(manipulator:Manipulator) : void
    + RemoveCaptured(manipulator:Manipulator) : void
    + isJogging : bool <<get>> <<set>>
    + viewStateHash : int <<get>>
    + bindingAreaWidth : float <<get>> <<set>>
    + sequencerHeaderWidth : float <<get>> <<set>>
    + mainAreaWidth : float <<get>> <<set>>
    + trackScale : float <<get>> <<set>>
    + dirtyStamp : int <<get>>
    + showQuadTree : bool <<get>> <<set>>
    + canRecord : bool <<get>>
    + recording : bool <<get>> <<set>>
    + previewMode : bool <<get>> <<set>>
    + playing : bool <<get>>
    + playbackSpeed : float <<get>> <<set>>
    + frameSnap : bool <<get>> <<set>>
    + edgeSnaps : bool <<get>> <<set>>
    + muteAudioScrubbing : bool <<get>> <<set>>
    + playRangeLoopMode : bool <<get>> <<set>>
    + timeInFrames : bool <<get>> <<set>>
    + showAudioWaveform : bool <<get>> <<set>>
    + showMarkerHeader : bool <<get>> <<set>>
    UnSelectMarkerOnHeaderTrack() : void
    + isClipSnapping : bool <<get>> <<set>>
    + OnDestroy() : void
    + OnSceneSaved() : void
    + SetCurrentSequence(timelineAsset:TimelineAsset, director:PlayableDirector, hostClip:TimelineClip) : void
    + PopSequencesUntilCount(count:int) : void
    + GetCurrentSequencePath() : SequencePath
    + SetCurrentSequencePath(path:SequencePath, forceRebuild:bool) : void
    + GetAllSequences() : IEnumerable<ISequenceState>
    + SnapToFrameIfRequired(currentTime:double) : double
    + Reset() : void
    + GetSnappedTimeAtMousePosition(mousePos:Vector2) : double
    {static} SyncNotifyValue(oldValue:T, newValue:T, changeStateCallback:Action) : void
    + SetTimeAreaTransform(newTranslation:Vector2, newScale:Vector2) : void
    + SetTimeAreaShownRange(min:float, max:float) : void
    <<internal>> TimeAreaChanged() : void
    + ResetPreviewMode() : void
    + TimeIsInRange(value:float) : bool
    + RangeIsVisible(range:Range) : bool
    + EnsurePlayHeadIsVisible() : void
    + SetPlayHeadToMiddle() : void
    <<internal>> UpdateLastFrameTime() : void
    + windowHeight : float <<get>>
    + playRangeEnabled : bool <<get>> <<set>>
    + GetWindow() : TimelineWindow
    + Play() : void
    + Pause() : void
    + SetPlaying(start:bool) : void
    + Stop() : void
    InvokePlayStateChangeCallback(isPlaying:bool) : void
    + RebuildPlayableGraph() : void
    + Evaluate() : void
    + EvaluateImmediate() : void
    + Refresh() : void
    + UpdateViewStateHash() : void
    + IsEditingASubItem() : bool
    + IsEditingASubTimeline() : bool
    + IsEditingAnEmptyTimeline() : bool
    + IsEditingAPrefabAsset() : bool
    + IsCurrentEditingASequencerTextField() : bool
    + TimeToTimeAreaPixel(t:double) : float
    + TimeToScreenSpacePixel(time:double) : float
    + TimeToPixel(time:double) : float
    + PixelToTime(pixel:float) : float
    + PixelDeltaToDeltaTime(p:float) : float
    + TimeAreaPixelToTime(pixel:float) : float
    + ScreenSpacePixelToTimeAreaTime(p:float) : float
    + TrackSpacePixelToTimeAreaTime(p:float) : float
    + OffsetTimeArea(pixels:int) : void
    + GetSceneReference(asset:TrackAsset) : GameObject
    + CalculateRowRects() : void
    + ArmForRecord(track:TrackAsset) : void
    + UnarmForRecord(track:TrackAsset) : void
    + UpdateRecordingState() : void
    + IsTrackRecordable(track:TrackAsset) : bool
    + IsArmedForRecord(track:TrackAsset) : bool
    + GetArmedTrack(track:TrackAsset) : TrackAsset
    CheckRecordingState() : void
    OnCurrentDirectorWillChange() : void
    + GatherProperties(director:PlayableDirector) : void
    OnStartPreview(director:PlayableDirector) : void
    OnStopPreview() : void
    <<internal>> ProcessStartFramePendingUpdates() : void
    <<internal>> ProcessEndFramePendingUpdates() : void
    + AddStartFrameDelegate(updateDelegate:PendingUpdateDelegate) : void
    + AddEndFrameDelegate(updateDelegate:PendingUpdateDelegate) : void
    <<internal>> InvokeWindowOnGuiStarted(evt:Event) : void
    <<internal>> InvokeWindowOnGuiFinished(evt:Event) : void
    + UpdateRootPlayableDuration(duration:double) : void
    + InvokeTimeChangeCallback() : void
    ValidatePlayRange(range:Vector2) : Vector2
    EnsureWindowTimeConsistency() : void
    SynchronizeSequencesAfterPlayback() : void
    {static} SynchronizeViewModelTime(state:ISequenceState) : void
    {static} ForceTimeOnDirector(director:PlayableDirector) : void
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
WindowState --> "m_Window" TimelineWindow
WindowState o-> "m_SpacePartitioner" SpacePartitioner
WindowState o-> "m_CaptureSession<Manipulator>" "List`1"
WindowState o-> "m_PropertyCollector" PropertyCollector
WindowState --> "s_PreviewDriver" AnimationModeDriver
WindowState --> "m_PreviewedAnimators<Animator>" "List`1"
WindowState --> "m_PreviewedComponents<IAnimationWindowPreview>" "List`1"
WindowState o-> "k_NullSequenceState" ISequenceState
WindowState o-> "m_ArmedTracks<TrackAsset,TrackAsset>" "Dictionary`2"
WindowState --> "m_OnStartFrameUpdates<PendingUpdateDelegate>" "List`1"
WindowState --> "m_OnEndFrameUpdates<PendingUpdateDelegate>" "List`1"
WindowState --> "m_SequenceHierarchy" SequenceHierarchy
WindowState --> "previewDriver" AnimationModeDriver
WindowState --> "editorWindow" EditorWindow
WindowState --> "editSequence" ISequenceState
WindowState --> "masterSequence" ISequenceState
WindowState --> "referenceSequence" ISequenceState
WindowState --> "spacePartitioner" SpacePartitioner
WindowState --> "captured<Manipulator>" "List`1"
WindowState --> "timeReferenceMode" TimeReferenceMode
WindowState --> "playRange" Vector2
WindowState --> "autoScrollMode" PlaybackScrollMode
WindowState --> "previewedDirectors<PlayableDirector>" "List`1"
WindowState --> "timeAreaShownRange" Vector2
WindowState --> "timeAreaTranslation" Vector2
WindowState --> "timeAreaScale" Vector2
WindowState --> "timeAreaRect" Rect
class AnimationTrackKeyDataSource {
    <<readonly>> m_TrackOffset : float
    + AnimationTrackKeyDataSource(track:AnimationTrack)
}
BasePropertyKeyDataSource <|-- AnimationTrackKeyDataSource
class Control {
    + HandleManipulatorsEvents(state:WindowState) : bool
    + AddManipulator(m:Manipulator) : void
}
class "List`1"<T> {
}
Control o-> "m_Manipulators<Manipulator>" "List`1"
interface IClipCurveEditorOwner {
    inlineCurvesSelected : bool <<get>> <<set>>
    showLoops : bool <<get>>
}
class InlineCurveResizeHandle {
    + InlineCurveResizeHandle(trackGUI:TimelineTrackGUI)
    + Draw(headerRect:Rect, trackRect:Rect, state:WindowState) : void
}
class InlineCurveEditor {
    m_LastSelectionWasClip : bool
    + InlineCurveEditor(trackGUI:TimelineTrackGUI)
    {static} MouseOverTrackArea(curveRect:Rect, trackRect:Rect) : bool
    {static} MouseOverHeaderArea(headerRect:Rect, trackRect:Rect) : bool
    {static} DrawCurveEditor(clipCurveEditorOwner:IClipCurveEditorOwner, state:WindowState, headerRect:Rect, trackRect:Rect, activeRange:Vector2, locked:bool) : void
    + Draw(headerRect:Rect, trackRect:Rect, state:WindowState) : void
    + Refresh() : void
    {static} RefreshInlineCurves(guiItem:IClipCurveEditorOwner) : void
    DrawCurveEditorForTrack(headerRect:Rect, trackRect:Rect, state:WindowState) : void
    DrawCurveEditorsForClipsOnTrack(headerRect:Rect, trackRect:Rect, state:WindowState) : void
    DrawCurvesEditorForNothingSelected(headerRect:Rect, trackRect:Rect, state:WindowState) : void
    ShouldShowClipCurves(state:WindowState) : bool
    ShouldShowTrackCurves() : bool
    TrackHasCurvesToShow() : bool
    UpdateViewModel() : void
    {static} HandleCurrentEvent() : void
}
IClipCurveEditorOwner --> "clipCurveEditor" ClipCurveEditor
IClipCurveEditorOwner --> "owner" TrackAsset
IBounds <|-- InlineCurveResizeHandle
InlineCurveResizeHandle --> "boundingRect" Rect
InlineCurveResizeHandle --> "trackGUI" TimelineTrackGUI
IBounds <|-- InlineCurveEditor
InlineCurveEditor --> "m_TrackRect" Rect
InlineCurveEditor --> "m_HeaderRect" Rect
InlineCurveEditor --> "m_TrackGUI" TimelineTrackGUI
InlineCurveEditor --> "m_ResizeHandle" InlineCurveResizeHandle
InlineCurveEditor --> "m_LastSelectedClipGUI" TimelineClipGUI
InlineCurveEditor --> "boundingRect" Rect
InlineCurveEditor --> "currentClipGui" TimelineClipGUI
InlineCurveEditor --> "currentCurveEditor" IClipCurveEditorOwner
interface IPropertyKeyDataSource {
    GetKeys() : float[]
    GetDescriptions() : Dictionary<float, string>
}
abstract class BasePropertyKeyDataSource {
    + <<virtual>> GetKeys() : float[]
    + <<virtual>> GetDescriptions() : Dictionary<float, string>
}
IPropertyKeyDataSource <|-- BasePropertyKeyDataSource
BasePropertyKeyDataSource o-> "k_StringBuilder" StringBuilder
interface IRowGUI {
    locked : bool <<get>>
    showMarkers : bool <<get>>
    muted : bool <<get>>
    ToWindowSpace(treeViewRect:Rect) : Rect
}
IRowGUI --> "asset" TrackAsset
IRowGUI --> "boundingRect" Rect
class ItemActionShortcutManipulator {
}
class DrillIntoClip {
}
class ContextMenuManipulator {
}
Manipulator <|-- ItemActionShortcutManipulator
Manipulator <|-- DrillIntoClip
Manipulator <|-- ContextMenuManipulator
class TimelinePanManipulator {
    <<const>> k_MaxPanSpeed : float = 50.0f
    m_Active : bool
    {static} Pan(evt:Event, state:WindowState) : bool
}
class TimelineZoomManipulator {
    m_FocalTime : float
    m_LastMouseMoveX : float
    m_ZoomFactor : float = 1
    m_WheelUsedLast : bool
    TimelineZoomManipulator()
    <<internal>> DoZoom(zoomFactor:float, state:WindowState) : void
    {static} DoZoom(zoomFactor:float, state:WindowState, refRange:Vector2, focalTime:float) : void
    <<internal>> {static} InvalidateWheelZoom() : void
    {static} PixelToZoom(x:float) : float
}
class TimelineShortcutManipulator {
}
class InlineCurvesShortcutManipulator {
}
Manipulator <|-- TimelinePanManipulator
Manipulator <|-- TimelineZoomManipulator
TimelineZoomManipulator o-> "m_MouseDownPos" Vector2
TimelineZoomManipulator o-> "m_InitialShownRange" Vector2
TimelineZoomManipulator o-> "Instance" TimelineZoomManipulator
Manipulator <|-- TimelineShortcutManipulator
Manipulator <|-- InlineCurvesShortcutManipulator
class InlineCurveResize {
    m_Captured : bool
    m_CapturedHeight : float
    m_CaptureMouseYPos : float
}
class TrackDoubleClick {
}
class TrackShortcutManipulator {
}
Manipulator <|-- InlineCurveResize
InlineCurveResize --> "m_Target" InlineCurveResizeHandle
Manipulator <|-- TrackDoubleClick
Manipulator <|-- TrackShortcutManipulator
abstract class Manipulator {
    m_Id : int
    + <<virtual>> Overlay(evt:Event, state:WindowState) : void
    + HandleEvent(state:WindowState) : bool
}
class PickerUtils <<static>> {
    + {static} DoPick(state:WindowState, mousePosition:Vector2) : void
    + {static} PickedLayerableOfType() : T
    + {static} PickedInlineCurveResizer() : InlineCurveResizeHandle
    + {static} PickedTrackBaseGUI() : TimelineTrackBaseGUI
}
class "List`1"<T> {
}
PickerUtils --> "pickedElements<object>" "List`1"
class TimelineClipHandle {
    + TimelineClipHandle(theClipGUI:TimelineClipGUI, trimDirection:TrimEdge)
    + Draw(clientRect:Rect, width:float, state:WindowState) : void
}
ILayerable <|-- TimelineClipHandle
TimelineClipHandle --> "m_Rect" Rect
TimelineClipHandle --> "m_ClipGUI" TimelineClipGUI
TimelineClipHandle --> "m_TrimDirection" TrimEdge
TimelineClipHandle --> "m_ZOrder" LayerZOrder
TimelineClipHandle --> "boundingRect" Rect
TimelineClipHandle --> "trimDirection" TrimEdge
TimelineClipHandle --> "clipGUI" TimelineClipGUI
TimelineClipHandle --> "zOrder" LayerZOrder
class TimelineClipUnion {
    m_Start : double
    m_Duration : double
    m_InitUnionRect : bool = true
    Add(clip:TimelineClipGUI) : void
    + Draw(parentRect:Rect, state:WindowState) : void
    + {static} Build(clips:List<TimelineClipGUI>) : List<TimelineClipUnion>
    + {static} Encompass(a:Rect, b:Rect) : Rect
    + {static} Intersection(r1:Rect, r2:Rect, intersection:Rect) : bool
}
class "List`1"<T> {
}
TimelineClipUnion o-> "m_Members<TimelineClipGUI>" "List`1"
TimelineClipUnion --> "m_BoundingRect" Rect
TimelineClipUnion --> "m_Union" Rect
class TimelineDataSource {
    + TimelineDataSource(parentGUI:TimelineTreeViewGUI, treeView:TreeViewController, sequencerWindow:TimelineWindow)
    + <<override>> IsExpanded(item:TreeViewItem) : bool
    + <<override>> IsExpandable(item:TreeViewItem) : bool
    + <<sealed>> <<override>> FetchData() : void
    CreateItem(scriptableObject:ScriptableObject, tree:Dictionary<TrackAsset, TimelineTrackBaseGUI>, selectedRows:IEnumerable<TrackAsset>, parentTreeViewItem:TreeViewItem) : TimelineTrackBaseGUI
    + <<override>> CanBeParent(item:TreeViewItem) : bool
    + ExpandItems(item:TreeViewItem) : void
}
class "List`1"<T> {
}
TreeViewDataSource <|-- TimelineDataSource
TimelineDataSource --> "m_TimelineWindow" TimelineWindow
TimelineDataSource --> "m_ParentGUI" TimelineTreeViewGUI
TimelineDataSource --> "allTrackGuis<TimelineTrackBaseGUI>" "List`1"
TimelineDataSource --> "treeroot" TreeViewItem
class TimelineDragging {
    <<const>> k_GenericDragId : string = "TimelineDragging"
    <<readonly>> kDragSensitivity : int = 2
    + TimelineDragging(treeView:TreeViewController, window:TimelineWindow, data:TimelineAsset)
    + <<override>> CanStartDrag(targetItem:TreeViewItem, draggedItemIDs:List<int>, mouseDownPosition:Vector2) : bool
    + <<override>> StartDrag(draggedNode:TreeViewItem, draggedItemIDs:List<int>) : void
    + {static} IsDraggingEvent() : bool
    + {static} ResolveType(types:IEnumerable<System.Type>, onComplete:Action<Type>, formatString:string) : bool
    + <<override>> DragElement(targetItem:TreeViewItem, targetItemRect:Rect, row:int) : bool
    GetNextItem(item:TreeViewItem) : TreeViewItem
    + <<override>> DoDrag(parentItem:TreeViewItem, targetItem:TreeViewItem, perform:bool, dropPos:DropPosition) : DragAndDropVisualMode
    ClearInsertionMarkers(item:TreeViewItem) : void
    ShouldUseHierarchyDragAndDrop() : bool
    + {static} HandleHierarchyPaneDragAndDrop(objectsBeingDropped:IEnumerable<UnityObject>, targetTrack:TrackAsset, perform:bool, timeline:TimelineAsset, director:PlayableDirector, typeResolver:TypeResolver, insertBefore:TrackAsset) : DragAndDropVisualMode
    + {static} HandleClipPaneObjectDragAndDrop(objectsBeingDropped:IEnumerable<UnityObject>, targetTrack:TrackAsset, perform:bool, timeline:TimelineAsset, parent:TrackAsset, director:PlayableDirector, candidateTime:double, typeResolver:TypeResolver, insertBefore:TrackAsset) : DragAndDropVisualMode
    {static} HandleTrackAndItemCreation(objectsBeingDropped:IEnumerable<UnityEngine.Object>, candidateTime:double, typeResolver:TypeResolver, timeline:TimelineAsset, parent:TrackAsset, validTrackTypes:IEnumerable<Type>, insertBefore:TrackAsset) : bool
    {static} HandleItemCreation(objectsBeingDropped:IEnumerable<UnityEngine.Object>, targetTrack:TrackAsset, candidateTime:double, typeResolver:TypeResolver, allowMenu:bool) : void
    + {static} HandleClipPaneMonoScriptDragAndDrop(scriptsBeingDropped:IEnumerable<MonoScript>, targetTrack:TrackAsset, perform:bool, timeline:TimelineAsset, parent:TrackAsset, director:PlayableDirector, candidateTime:double) : DragAndDropVisualMode
    + {static} HandleClipPanePlayableAssetDragAndDrop(assetsBeingDropped:IEnumerable<IPlayableAsset>, targetTrack:TrackAsset, perform:bool, timeline:TimelineAsset, parent:TrackAsset, director:PlayableDirector, candidateTime:double, typeResolver:TypeResolver) : DragAndDropVisualMode
    {static} ValidateObjectDrop(obj:UnityObject) : bool
    + HandleTrackDrop(parentItem:TreeViewItem, targetItem:TreeViewItem, perform:bool, dropPos:DropPosition) : DragAndDropVisualMode
    + {static} HandleBindingDragAndDrop(dropTarget:TrackAsset, requiredBindingType:Type) : void
    {static} ValidDrag(target:TreeViewItem, draggedItems:List<TreeViewItem>) : bool
}
class "IEnumerable`1"<T> {
}
class "Action`1"<T> {
}
class TimelineDragData {
    + TimelineDragData(draggedItems:List<TreeViewItem>)
}
class "List`1"<T> {
}
TreeViewDragging <|-- TimelineDragging
TimelineDragging --> "m_Timeline" TimelineAsset
TimelineDragging --> "m_Window" TimelineWindow
TimelineDragging +-- TimelineDragData
TimelineDragData --> "draggedItems<TreeViewItem>" "List`1"
class TimelineGroupGUI {
    m_MustRecomputeUnions : bool = true
    m_GroupDepth : int
    <<readonly>> m_IsReferencedTrack : bool
    + ToWindowSpace(localRect:Rect) : Rect
    + <<override>> expandable : bool <<get>>
    + TimelineGroupGUI(treeview:TreeViewController, treeviewGUI:TimelineTreeViewGUI, id:int, depth:int, parent:TreeViewItem, displayName:string, trackAsset:TrackAsset, isRoot:bool)
    + <<virtual>> GetHeight(state:WindowState) : float
    + <<override>> OnGraphRebuilt() : void
    {static} CalculateGroupDepth(parent:TreeViewItem) : int
    <<internal>> {static} Spaced(width:float) : float
    DrawTrackButtons(headerRect:Rect, state:WindowState) : void
    + SetExpanded(expanded:bool) : void
    + <<override>> Draw(headerRect:Rect, contentRect:Rect, state:WindowState) : void
    DrawName(rect:Rect, isSelected:bool) : void
    IsTrackRecording(state:WindowState) : bool
    RecomputeRectUnions() : void
    {static} AllChildrenMuted(groupGui:TimelineGroupGUI) : bool
}
class "List`1"<T> {
}
TimelineTrackBaseGUI <|-- TimelineGroupGUI
TimelineGroupGUI o-> "m_Unions<TimelineClipUnion>" "List`1"
TimelineGroupGUI --> "boundingRect" Rect
TimelineGroupGUI --> "expandedRect" Rect
TimelineGroupGUI --> "rowRect" Rect
TimelineGroupGUI --> "dropRect" Rect
abstract class TimelineTrackBaseGUI {
    + isExpanded : bool <<get>> <<set>>
    + isDropTarget : bool <<protected get>> <<set>>
    + <<virtual>> GetVerticalSpacingBetweenTracks() : float
    + visibleRow : bool <<get>> <<set>>
    + visibleExpanded : bool <<get>> <<set>>
    + drawInsertionMarkerBefore : bool <<get>> <<set>>
    + drawInsertionMarkerAfter : bool <<get>> <<set>>
    + {abstract} expandable : bool <<get>>
    + {abstract} Draw(headerRect:Rect, contentRect:Rect, state:WindowState) : void
    + {abstract} OnGraphRebuilt() : void
    + {static} FindGUITrack(track:TrackAsset) : TimelineTrackBaseGUI
    DrawTrackStateBox(trackRect:Rect, track:TrackAsset) : void
    + DrawInsertionMarkers(rowRectWithIndent:Rect) : void
    + ClearDrawFlags() : void
}
class Styles <<static>> {
}
TreeViewItem <|-- TimelineTrackBaseGUI
IBounds <|-- TimelineTrackBaseGUI
TimelineTrackBaseGUI --> "m_TreeViewGUI" TimelineTreeViewGUI
TimelineTrackBaseGUI --> "m_Drawer" TrackDrawer
TimelineTrackBaseGUI --> "treeViewToWindowTransformation" Vector2
TimelineTrackBaseGUI --> "track" TrackAsset
TimelineTrackBaseGUI --> "treeView" TreeViewController
TimelineTrackBaseGUI --> "TimelineWindow" TimelineWindow
TimelineTrackBaseGUI --> "drawer" TrackDrawer
TimelineTrackBaseGUI --> "boundingRect" Rect
TimelineTrackBaseGUI +-- Styles
Styles o-> "s_LockedAndMuted" GUIContent
Styles o-> "s_LockedAndPartiallyMuted" GUIContent
Styles o-> "s_Locked" GUIContent
Styles o-> "s_Muted" GUIContent
Styles o-> "s_PartiallyMuted" GUIContent
Styles o-> "lockBg" Texture2D
class TimelineTrackErrorGUI {
    + TimelineTrackErrorGUI(treeview:TreeViewController, treeviewGUI:TimelineTreeViewGUI, id:int, depth:int, parent:TreeViewItem, displayName:string, track:ScriptableObject, owner:PlayableAsset)
    + <<override>> expandable : bool <<get>>
    + <<override>> Draw(headerRect:Rect, contentRect:Rect, state:WindowState) : void
    DrawMissingTrackHeader(headerRect:Rect, state:WindowState) : void
    DrawRemoveMenu(headerRect:Rect, state:WindowState) : void
    {static} DrawMissingTrackBody(contentRect:Rect) : void
    {static} DrawScriptWarningBox(trackRect:Rect, content:GUIContent) : void
    + <<override>> OnGraphRebuilt() : void
}
class Styles <<static>> {
}
TimelineTrackBaseGUI <|-- TimelineTrackErrorGUI
TimelineTrackErrorGUI --> "m_TrackRect" Rect
TimelineTrackErrorGUI --> "m_ScriptableObject" ScriptableObject
TimelineTrackErrorGUI --> "m_Owner" PlayableAsset
TimelineTrackErrorGUI o-> "s_GUIContent" GUIContent
TimelineTrackErrorGUI --> "boundingRect" Rect
TimelineTrackErrorGUI +-- Styles
Styles o-> "ErrorText" GUIContent
Styles o-> "IconWarn" Texture2D
Styles o-> "RemoveTrack" GUIContent
Styles o-> "WarningBoxBackgroundColor" Color
Styles o-> "WarningBoxHighlightColor" Color
class TimelineTrackGUI {
    m_InlineCurvesSkipped : bool
    m_TrackHash : int
    m_BlendHash : int
    m_LastDirtyIndex : int
    + <<override>> expandable : bool <<get>>
    + inlineCurvesSelected : bool <<get>> <<set>>
    showLoops : bool <<get>>
    {static} DoesTrackAllowsRecording(track:TrackAsset) : bool
    m_TrackHasAnimatableParameters : bool?
    trackHasAnimatableParameters : bool <<get>>
    + locked : bool <<get>>
    + showMarkers : bool <<get>>
    + muted : bool <<get>>
    showTrackRecordingDisabled : bool <<get>>
    + TimelineTrackGUI(tv:TreeViewController, w:TimelineTreeViewGUI, id:int, depth:int, parent:TreeViewItem, displayName:string, sequenceActor:TrackAsset)
    + <<override>> GetVerticalSpacingBetweenTracks() : float
    UpdateInfiniteClipEditor(window:TimelineWindow) : void
    DetectTrackChanged() : void
    OnTrackChanged() : void
    UpdateDrawData(state:WindowState) : void
    + <<override>> Draw(headerRect:Rect, contentRect:Rect, state:WindowState) : void
    DrawInlineCurves(curvesHeaderRect:Rect, curvesContentRect:Rect, state:WindowState) : void
    {static} IsInlineCurvesEditorInBounds(windowSpaceTrackRect:Rect, inlineCurveHeight:float, state:WindowState) : bool
    DrawErrorIcon(position:Rect, state:WindowState) : void
    DrawBackground(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : void
    InlineCurveHeight() : float
    + <<override>> GetHeight(state:WindowState) : float
    GetTrackContentHeight(state:WindowState) : float
    {static} CanDrawIcon(icon:GUIContent) : bool
    showSceneReference : bool <<get>>
    DrawTrackHeader(trackHeaderRect:Rect, state:WindowState) : void
    DrawHeaderBackground(headerRect:Rect) : void
    DrawTrackColorKind(rect:Rect) : void
    DrawTrackIconKind(rect:Rect, state:WindowState) : float
    DrawTrackBinding(rect:Rect, headerRect:Rect) : void
    DrawTrackDropDownMenu(rect:Rect) : float
    CanDrawInlineCurve() : bool
    DrawInlineCurveButton(rect:Rect, state:WindowState) : float
    DrawRecordButton(rect:Rect, state:WindowState) : float
    DrawCustomTrackButton(rect:Rect, state:WindowState) : float
    DrawLockMarkersButton(rect:Rect, state:WindowState) : float
    {static} ObjectBindingField(position:Rect, obj:Object, binding:PlayableBinding) : void
    DoTrackBindingGUI(rect:Rect, headerRect:Rect) : void
    IsRecording(state:WindowState) : bool
    DrawRecordingTrackBackground(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : void
    UpdateClipOverlaps() : void
    <<internal>> RebuildGUICacheIfNecessary() : void
    BlendHash() : int
    + <<override>> OnGraphRebuilt() : void
    RefreshCurveEditor() : void
}
class TrackDrawData <<struct>> {
    + m_AllowsRecording : bool
    + m_ShowTrackBindings : bool
    + m_HasBinding : bool
    + m_IsSubTrack : bool
}
class Styles <<static>> {
    + {static} <<readonly>> kArmForRecordDisabled : string
}
class "List`1"<T> {
}
TimelineGroupGUI <|-- TimelineTrackGUI
IClipCurveEditorOwner <|-- TimelineTrackGUI
IRowGUI <|-- TimelineTrackGUI
TimelineTrackGUI --> "s_ArmForRecordContentOn" GUIContent
TimelineTrackGUI --> "s_ArmForRecordContentOff" GUIContent
TimelineTrackGUI --> "s_ArmForRecordDisabled" GUIContent
TimelineTrackGUI --> "m_InfiniteTrackDrawer" InfiniteTrackDrawer
TimelineTrackGUI --> "m_ItemsDrawer" TrackItemsDrawer
TimelineTrackGUI --> "m_TrackDrawData" TrackDrawData
TimelineTrackGUI --> "m_TrackDrawOptions" TrackDrawOptions
TimelineTrackGUI --> "m_TrackEditor" TrackEditor
TimelineTrackGUI --> "m_DefaultTrackIcon" GUIContent
TimelineTrackGUI --> "inlineCurveEditor" InlineCurveEditor
TimelineTrackGUI --> "clipCurveEditor" ClipCurveEditor
TimelineTrackGUI --> "owner" TrackAsset
TimelineTrackGUI --> "clips<TimelineClipGUI>" "List`1"
TimelineTrackGUI --> "asset" TrackAsset
TimelineTrackGUI +-- TrackDrawData
TrackDrawData --> "m_Binding" PlayableBinding
TrackDrawData --> "m_TrackIcon" Texture
TimelineTrackGUI +-- Styles
Styles o-> "kProblemIcon" Texture2D
class TimelineTreeView {
    m_FoldoutWidth : float
    m_MaxWidthOfRows : float
    {static} <<readonly>> kMinTrackHeight : float = 25.0f
    {static} <<readonly>> kFoldOutOffset : float = 14.0f
    + showInsertionMarker : bool <<get>> <<set>>
    + <<virtual>> topRowMargin : float <<get>>
    + <<virtual>> bottomRowMargin : float <<get>>
    + TimelineTreeView(sequencerWindow:TimelineWindow, treeView:TreeViewController)
    ItemDoubleClickedCallback(id:int) : void
    ContextClickOutsideItemsCallback() : void
    ContextClickItemCallback(id:int) : void
    SelectionChangedCallback(ids:int[]) : void
    + OnInitialize() : void
    + GetRectForFraming(row:int) : Rect
    + <<virtual>> BeginRowGUI() : void
    + <<virtual>> EndRowGUI() : void
    + <<virtual>> OnRowGUI(rowRect:Rect, item:TreeViewItem, row:int, selected:bool, focused:bool) : void
    DrawFoldout(item:TreeViewItem, foldoutRect:Rect, indent:float) : void
    + GetRenameRect(rowRect:Rect, row:int, item:TreeViewItem) : Rect
    + BeginPingItem(item:TreeViewItem, topPixelOfRow:float, availableWidth:float) : void
    + EndPingItem() : void
    + GetRowRect(row:int, rowWidth:float) : Rect
    + GetRowRect(row:int) : Rect
    {static} GetSpacing(item:TreeViewItem) : float
    + CalculateRowRects() : void
    + <<virtual>> BeginRename(item:TreeViewItem, delay:float) : bool
    + <<virtual>> EndRename() : void
    + <<virtual>> GetContentIndent(item:TreeViewItem) : float
    + GetNumRowsOnPageUpDown(fromItem:TreeViewItem, pageUp:bool, heightOfTreeView:float) : int
    + GetFirstAndLastRowVisible(firstRowVisible:int, lastRowVisible:int) : void
    + GetTotalSize() : Vector2
    + <<virtual>> halfDropBetweenHeight : float <<get>>
}
class "List`1"<T> {
}
ITreeViewGUI <|-- TimelineTreeView
TimelineTreeView --> "m_DraggingInsertionMarkerRect" Rect
TimelineTreeView --> "m_TreeView" TreeViewController
TimelineTreeView o-> "m_RowRects<Rect>" "List`1"
TimelineTreeView o-> "m_ExpandedRowRects<Rect>" "List`1"
TimelineTreeView --> "m_State" WindowState
TimelineTreeView --> "m_Styles" DirectorStyles
class TimelineTreeViewGUI {
    + showingVerticalScrollBar : bool <<get>>
    + FrameItem(item:TreeViewItem) : void
    + TimelineTreeViewGUI(sequencerWindow:TimelineWindow, timeline:TimelineAsset, rect:Rect)
    + CalculateRowRects() : void
    + Reload() : void
    + OnGUI(rect:Rect) : void
    + GetRowRect(row:int) : Rect
    {static} AddVisibleTrackRecursive(list:List<TimelineTrackBaseGUI>, track:TimelineTrackBaseGUI) : void
}
class "List`1"<T> {
}
TimelineTreeViewGUI --> "m_Timeline" TimelineAsset
TimelineTreeViewGUI --> "m_TreeView" TreeViewController
TimelineTreeViewGUI --> "m_TimelineTreeView" TimelineTreeView
TimelineTreeViewGUI --> "m_Window" TimelineWindow
TimelineTreeViewGUI --> "m_DataSource" TimelineDataSource
TimelineTreeViewGUI --> "root" TreeViewItem
TimelineTreeViewGUI --> "allClipGuis<TimelineClipGUI>" "List`1"
TimelineTreeViewGUI --> "allTrackGuis<TimelineTrackBaseGUI>" "List`1"
TimelineTreeViewGUI --> "contentSize" Vector2
TimelineTreeViewGUI --> "scrollPosition" Vector2
TimelineTreeViewGUI --> "timelineDragging" TimelineDragging
TimelineTreeViewGUI --> "gui" ITreeViewGUI
TimelineTreeViewGUI --> "data" ITreeViewDataSource
TimelineTreeViewGUI --> "TimelineWindow" TimelineWindow
class TrackPropertyCurvesDataSource {
    + TrackPropertyCurvesDataSource(track:TrackAsset)
}
BasePropertyKeyDataSource <|-- TrackPropertyCurvesDataSource
class AnimatedParameterCache <<static>> {
    + {static} TryGetScriptPlayableFields(type:Type, scriptPlayableFields:FieldInfo[]) : bool
    + {static} SetScriptPlayableFields(type:Type, scriptPlayableFields:FieldInfo[]) : void
    + {static} TryGetFieldInfoForProperty(property:SerializedProperty, fieldInfo:FieldInfo) : bool
    + {static} SetFieldInfoForProperty(property:SerializedProperty, fieldInfo:FieldInfo) : void
    + {static} TryGetIsPropertyAnimatable(property:SerializedProperty, isAnimatable:bool) : bool
    + {static} SetIsPropertyAnimatable(property:SerializedProperty, isAnimatable:bool) : void
    + {static} TryGetBindingName(type:Type, path:string, bindingName:string) : bool
    + {static} SetBindingName(type:Type, path:string, bindingName:string) : void
}
class PropertyKey <<struct>> {
    <<readonly>> m_Path : string
    + PropertyKey(property:SerializedProperty)
    + PropertyKey(type:Type, path:string)
    + Equals(other:PropertyKey) : bool
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class "Dictionary`2"<T1,T2> {
}
class "IEquatable`1"<T> {
}
AnimatedParameterCache o-> "k_ScriptPlayableFieldsCache<Type,FieldInfo[]>" "Dictionary`2"
AnimatedParameterCache o-> "k_PropertyFieldInfoCache<PropertyKey,FieldInfo>" "Dictionary`2"
AnimatedParameterCache o-> "k_PropertyIsAnimatableCache<PropertyKey,bool>" "Dictionary`2"
AnimatedParameterCache o-> "k_BindingNameCache<PropertyKey,string>" "Dictionary`2"
"IEquatable`1" "<PropertyKey>" <|-- PropertyKey
PropertyKey --> "m_Type" Type
class AnimatedParameterUtility <<static>> {
    + {static} ToCurvesOwner(playableAsset:IPlayableAsset, timeline:TimelineAsset) : ICurvesOwner
    + {static} TryGetSerializedPlayableAsset(asset:UnityObject, serializedObject:SerializedObject) : bool
    + {static} GetSerializedPlayableAsset(asset:UnityObject) : SerializedObject
    + {static} UpdateSerializedPlayableAsset(asset:UnityObject) : void
    + {static} HasScriptPlayable(asset:UnityObject) : bool
    + {static} GetScriptPlayableFields(asset:IPlayableAsset) : FieldInfo[]
    {static} GetScriptPlayableFields_Internal(asset:IPlayableAsset) : FieldInfo[]
    + {static} HasAnyAnimatableParameters(asset:UnityObject) : bool
    + {static} GetAllAnimatableParameters(asset:UnityObject) : IEnumerable<SerializedProperty>
    {static} SelectAnimatableProperty(prop:SerializedProperty) : IEnumerable<SerializedProperty>
    + {static} IsParameterAnimatable(asset:UnityObject, parameterName:string) : bool
    + {static} IsParameterAnimatable(property:SerializedProperty) : bool
    {static} IsParameterAnimatable_Internal(property:SerializedProperty) : bool
    {static} IsParameterKeyable(property:SerializedProperty) : bool
    {static} IsKeyableInHierarchy(property:SerializedProperty) : bool
    {static} IsParameterAtPathAnimatable(asset:UnityObject, path:string) : bool
    + {static} IsTypeAnimatable(type:SerializedPropertyType) : bool
    + {static} IsParameterAnimated(asset:UnityObject, animationData:AnimationClip, parameterName:string) : bool
    + {static} GetAnimatedParameter(asset:UnityObject, animationData:AnimationClip, parameterName:string) : AnimationCurve
    + {static} GetCurveBinding(asset:UnityObject, parameterName:string) : EditorCurveBinding
    + {static} GetAnimatedParameterBindingName(asset:UnityObject, parameterName:string) : string
    {static} GetAnimatedParameterBindingName_Internal(asset:UnityObject, parameterName:string) : string
    + {static} BindingMatchesParameterName(binding:EditorCurveBinding, parameterName:string) : bool
    + {static} GetValidAnimationType(asset:UnityObject) : Type
    + {static} GetFieldInfoForProperty(property:SerializedProperty) : FieldInfo
    + {static} GetAttributeForProperty(property:SerializedProperty) : T
}
AnimatedParameterUtility o-> "k_DefaultAnimationType" Type
AnimatedParameterUtility --> "s_CachedObject" SerializedObject
class BindingUtility <<static>> {
    + {static} GetRequiredBindingType(binding:PlayableBinding) : Type
    + {static} Bind(director:PlayableDirector, bindTo:TrackAsset, objectToBind:Object) : void
    + {static} GetBindingAction(requiredBindingType:Type, objectToBind:Object) : BindingAction
}
enum BindingAction {
    DoNotBind,
    BindDirectly,
    BindToExistingComponent,
    BindToMissingComponent,
}
enum TitleMode {
    None,
    DisabledComponent,
    Prefab,
    PrefabOutOfContext,
    Asset,
    GameObject,
}
class BreadCrumbTitle <<struct>> {
    + name : string
}
class BreadcrumbDrawer {
    {static} <<readonly>> k_DisabledComponentText : string
    {static} <<readonly>> k_PrefabOutOfContext : string
    <<const>> k_Elipsis : string = "…"
    {static} BreadcrumbDrawer()
    {static} FitTextInArea(areaWidth:float, text:string, style:GUIStyle) : string
    + {static} Draw(breadcrumbAreaWidth:float, labels:List<BreadCrumbTitle>, navigateToBreadcrumbIndex:Action<int>) : void
    {static} GetTextContent(width:int, text:BreadCrumbTitle, style:GUIStyle) : GUIContent
    {static} DrawBreadcrumbAsSelectedSubSequence(width:int, label:BreadCrumbTitle, style:GUIStyle, backgroundStyle:GUIStyle) : void
    {static} GetBreadcrumbLayoutRect(content:GUIContent, style:GUIStyle) : Rect
    {static} DrawActiveBreadcrumb(width:int, label:BreadCrumbTitle, style:GUIStyle, backgroundStyle:GUIStyle) : Rect
}
BreadCrumbTitle --> "mode" TitleMode
BreadcrumbDrawer o-> "s_TextContent" GUIContent
BreadcrumbDrawer --> "k_BreadCrumbLeft" GUIStyle
BreadcrumbDrawer --> "k_BreadCrumbMid" GUIStyle
BreadcrumbDrawer --> "k_BreadCrumbLeftBg" GUIStyle
BreadcrumbDrawer --> "k_BreadCrumbMidBg" GUIStyle
BreadcrumbDrawer --> "k_BreadCrumbMidSelected" GUIStyle
BreadcrumbDrawer --> "k_BreadCrumbMidBgSelected" GUIStyle
BreadcrumbDrawer --> "k_TimelineIcon" Texture
class Clipboard {
    {static} <<readonly>> kListInitialSize : int = 10
    + Clipboard()
    + CopyItems(items:IEnumerable<ITimelineItem>) : void
    CopyItem(clipItem:ClipItem) : ClipItem
    {static} CopyItem(markerItem:MarkerItem) : MarkerItem
    + CopyTracks(tracks:IEnumerable<TrackAsset>) : void
    + GetTracks() : IEnumerable<ClipboardTrackEntry>
    + GetCopiedItems() : IEnumerable<ItemsPerTrack>
    + Clear() : void
    {static} CreateTimeline() : TimelineAsset
}
class ExposedReferenceTable {
    + SetReferenceValue(id:PropertyName, value:Object) : void
    + GetReferenceValue(id:PropertyName, idValid:bool) : Object
    + ClearReferenceValue(id:PropertyName) : void
    + Clear() : void
}
class ClipboardTrackEntry <<struct>> {
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
Clipboard o-> "m_ItemsData<ItemsPerTrack>" "List`1"
Clipboard o-> "m_trackData<ClipboardTrackEntry>" "List`1"
Clipboard --> "rootTimeline" TimelineAsset
Clipboard o-> "exposedPropertyTable" IExposedPropertyTable
Clipboard +-- ExposedReferenceTable
IExposedPropertyTable <|-- ExposedReferenceTable
ExposedReferenceTable o-> "m_ReferenceTable<PropertyName,Object>" "Dictionary`2"
Clipboard +-- ClipboardTrackEntry
ClipboardTrackEntry --> "item" TrackAsset
ClipboardTrackEntry --> "parent" TrackAsset
class ClipModifier <<static>> {
    + {static} Delete(timeline:TimelineAsset, clip:TimelineClip) : bool
    + {static} Tile(clips:TimelineClip[]) : bool
    + {static} TrimStart(clips:TimelineClip[], trimTime:double) : bool
    + {static} TrimStart(clip:TimelineClip, trimTime:double) : bool
    + {static} TrimEnd(clips:TimelineClip[], trimTime:double) : bool
    + {static} TrimEnd(clip:TimelineClip, trimTime:double) : bool
    + {static} MatchDuration(clips:TimelineClip[]) : bool
    + {static} Split(clips:TimelineClip[], splitTime:double, director:PlayableDirector) : bool
    + {static} SetStart(clip:TimelineClip, time:double) : void
    + {static} SetEnd(clip:TimelineClip, time:double, affectTimeScale:bool) : void
    + {static} ResetEditing(clips:TimelineClip[]) : bool
    + {static} ResetEditing(clip:TimelineClip) : bool
    + {static} MatchContent(clips:TimelineClip[]) : bool
    + {static} MatchContent(clip:TimelineClip) : bool
    + {static} TrimClipWithEditMode(clip:TimelineClip, edge:TrimEdge, time:double) : void
    + {static} CompleteLastLoop(clips:TimelineClip[]) : bool
    + {static} CompleteLastLoop(clip:TimelineClip) : void
    + {static} TrimLastLoop(clips:TimelineClip[]) : bool
    + {static} TrimLastLoop(clip:TimelineClip) : void
    {static} FixLoops(clip:TimelineClip, completeLastLoop:bool) : void
    + {static} DoubleSpeed(clips:TimelineClip[]) : bool
    + {static} HalfSpeed(clips:TimelineClip[]) : bool
    + {static} ResetSpeed(clips:TimelineClip[]) : bool
}
class ControlPlayableUtility <<static>> {
    + {static} DetectCycle(asset:ControlPlayableAsset, director:PlayableDirector, set:HashSet<PlayableDirector>) : bool
    + {static} GetPlayableAssets(director:PlayableDirector) : IEnumerable<ControlPlayableAsset>
}
class CustomTrackDrawerAttribute <<sealed>> {
    + CustomTrackDrawerAttribute(type:Type)
}
class CustomTimelineEditorAttribute <<sealed>> {
    + CustomTimelineEditorAttribute(type:Type)
}
Attribute <|-- CustomTrackDrawerAttribute
CustomTrackDrawerAttribute --> "assetType" Type
Attribute <|-- CustomTimelineEditorAttribute
CustomTimelineEditorAttribute --> "classToEdit" Type
class DisplayNameHelper <<static>> {
    {static} <<readonly>> k_NoAssetDisplayName : string
    {static} <<readonly>> k_ReadOnlyDisplayName : string
    + {static} GetDisplayName(sequence:ISequenceState) : string
    + {static} GetDisplayName(asset:PlayableAsset) : string
    + {static} GetDisplayName(director:PlayableDirector) : string
}
DisplayNameHelper o-> "k_StringBuilder" StringBuilder
class Graphics <<static>> {
    + {static} ShadowLabel(rect:Rect, text:string, style:GUIStyle, textColor:Color, shadowColor:Color) : void
    + {static} ShadowLabel(rect:Rect, content:GUIContent, style:GUIStyle, textColor:Color, shadowColor:Color) : void
    + {static} DrawLine(p1:Vector3, p2:Vector3, color:Color) : void
    + {static} DrawPolygonAA(color:Color, vertices:Vector3[]) : void
    + {static} DrawDottedLine(p1:Vector3, p2:Vector3, segmentsLength:float, col:Color) : void
    + {static} DrawLineAtTime(state:WindowState, time:double, color:Color, dotted:bool) : void
    + {static} DrawTextureRepeated(area:Rect, texture:Texture) : void
    + {static} DrawShadow(clientRect:Rect) : void
    + {static} DrawBackgroundRect(state:WindowState, rect:Rect, subSequenceMode:bool) : void
}
class GUIColorOverride <<struct>> {
    + GUIColorOverride(newColor:Color)
    + Dispose() : void
}
IDisposable <|-- GUIColorOverride
GUIColorOverride --> "m_OldColor" Color
class GUIGroupScope <<struct>> {
    + GUIGroupScope(position:Rect)
    + Dispose() : void
}
IDisposable <|-- GUIGroupScope
class GUIMixedValueScope <<struct>> {
    <<readonly>> m_PrevValue : bool
    + GUIMixedValueScope(newValue:bool)
    + Dispose() : void
}
IDisposable <|-- GUIMixedValueScope
class GUIViewportScope <<struct>> {
    m_open : bool
    + GUIViewportScope(position:Rect)
    + Dispose() : void
    CloseScope() : void
}
IDisposable <|-- GUIViewportScope
class KeyTraverser {
    m_DirtyStamp : int
    m_LastHash : int
    <<readonly>> m_Epsilon : float
    m_LastIndex : int
    + lastIndex : int <<get>>
    + {static} GetClipKeyTimes(clip:TimelineClip) : IEnumerable<float>
    + {static} GetTrackKeyTimes(track:AnimationTrack) : IEnumerable<float>
    {static} CalcAnimClipHash(asset:TrackAsset) : int
    <<internal>> {static} CalcAnimClipHash(asset:TimelineAsset) : int
    RebuildKeyCache() : void
    + KeyTraverser(timeline:TimelineAsset, epsilon:float)
    CheckCache(dirtyStamp:int) : void
    + GetNextKey(key:float, dirtyStamp:int) : float
    + GetPrevKey(key:float, dirtyStamp:int) : float
    + GetKeyCount(dirtyStamp:int) : int
}
KeyTraverser --> "m_Asset" TimelineAsset
class MarkerModifier <<static>> {
    + {static} DeleteMarker(marker:IMarker) : void
    + {static} CloneMarkersToParent(markers:IEnumerable<IMarker>, parent:TrackAsset) : IEnumerable<IMarker>
    + {static} CloneMarkerToParent(marker:IMarker, parent:TrackAsset) : IMarker
    {static} AddMarkerToParent(marker:ScriptableObject, parent:TrackAsset) : void
}
class ObjectExtension <<static>> {
    + {static} IsSceneObject(obj:Object) : bool
    + {static} IsPrefab(obj:Object) : bool
}
class ObjectReferenceField <<struct>> {
    + propertyPath : string
    + isSceneReference : bool
    + {static} FindObjectReferences(type:System.Type) : ObjectReferenceField[]
    + {static} FindObjectReferences() : ObjectReferenceField[]
    + Find(sourceObject:ScriptableObject, context:Object) : Object
    + IsAssignable(obj:Object) : bool
    + Assign(scriptableObject:ScriptableObject, value:Object, exposedTable:IExposedPropertyTable) : bool
}
class PropertyCollector {
    + Reset() : void
    + Clear() : void
    + PushActiveGameObject(gameObject:GameObject) : void
    + PopActiveGameObject() : void
    + AddFromClip(clip:AnimationClip) : void
    + AddFromClips(clips:IEnumerable<AnimationClip>) : void
    + AddFromName(name:string) : void
    + AddFromName(name:string) : void
    + AddFromClip(obj:GameObject, clip:AnimationClip) : void
    + AddFromClips(animatorRoot:GameObject, clips:IEnumerable<AnimationClip>) : void
    + AddFromName(obj:GameObject, name:string) : void
    + AddFromName(obj:GameObject, name:string) : void
    + AddFromName(component:Component, name:string) : void
    + AddFromComponent(obj:GameObject, component:Component) : void
    AddPropertiesFromClip(go:GameObject, clip:AnimationClip) : void
    {static} AddPropertiesFromName(go:GameObject, property:string) : void
    {static} AddPropertiesFromName(go:GameObject, compType:Type, property:string) : void
    + AddObjectProperties(obj:Object, clip:AnimationClip) : void
    AddSerializedPlayableModifications(asset:IPlayableAsset, clip:AnimationClip) : void
}
class "Stack`1"<T> {
}
IPropertyCollector <|-- PropertyCollector
PropertyCollector o-> "m_ObjectStack<GameObject>" "Stack`1"
class Range <<struct>> {
    + start : double
    + end : double
    + length : double <<get>>
    + {static} Union(lhs:Range, rhs:Range) : Range
    + {static} Intersection(lhs:Range, rhs:Range) : Range
    + <<override>> ToString() : string
    + ToString(format:string) : string
}
class SequenceMenuNameFormater {
    + Format(text:string) : string
}
class "Dictionary`2"<T1,T2> {
}
SequenceMenuNameFormater o-> "m_UniqueItem<int,int>" "Dictionary`2"
interface IBounds {
}
class SpacePartitioner {
    + Clear() : void
    + AddBounds(bounds:IBounds) : void
    + AddBounds(item:object, rect:Rect) : void
    + GetItemsAtPosition(position:Vector2) : IEnumerable<T>
    + GetItemsInArea(area:Rect) : IEnumerable<T>
    + DebugDraw() : void
}
class "CachedList`1"<T> {
}
class Entry <<struct>> {
    + item : object <<get>> <<set>>
    + intervalStart : long <<get>> <<set>>
    + intervalEnd : long <<get>> <<set>>
    {static} + FromFloat(f:float) : Int64
}
class "IntervalTree`1"<T> {
}
class "List`1"<T> {
}
IBounds --> "boundingRect" Rect
SpacePartitioner o-> "k_GuiEventLock" EventType
SpacePartitioner o-> "m_Tree<Entry>" "IntervalTree`1"
SpacePartitioner o-> "m_CacheList<Entry>" "List`1"
SpacePartitioner +-- "CachedList`1"
"CachedList`1" o-> "Instance<T>" "List`1"
SpacePartitioner +-- Entry
IInterval <|-- Entry
Entry --> "bounds" Rect
class StyleManager <<static>> {
    {static} <<readonly>> k_ErrorCannotFindStyle : string
    + {static} UssStyleForType(type:Type) : GUIStyle
    {static} CustomStyleForType(type:Type) : string
    {static} IsStyleValid(ussStyle:string) : bool
    {static} ClearCacheIfInvalid() : void
}
class "Dictionary`2"<T1,T2> {
}
StyleManager o-> "s_CustomStyles<Type,GUIStyle>" "Dictionary`2"
StyleManager --> "s_CurrentSkin" GUISkin
class StyleNormalColorOverride <<struct>> {
    + StyleNormalColorOverride(style:GUIStyle, newColor:Color)
    + Dispose() : void
}
IDisposable <|-- StyleNormalColorOverride
StyleNormalColorOverride --> "m_Style" GUIStyle
StyleNormalColorOverride --> "m_OldColor" Color
class KeyboardNavigation <<static>> {
    + {static} FrameTrackHeader(treeItem:TreeViewItem) : void
    + {static} TrackHeadActive() : bool
    + {static} ClipAreaActive() : bool
    + {static} GetVisibleSelectedItems() : IEnumerable<ITimelineItem>
    + {static} GetVisibleTracks() : IEnumerable<TimelineTrackBaseGUI>
    {static} PreviousTrack(track:TrackAsset) : TrackAsset
    {static} NextTrack(track:TrackAsset) : TrackAsset
    {static} PreviousItem(item:ITimelineItem, clipOnly:bool) : ITimelineItem
    {static} NextItem(item:ITimelineItem, clipOnly:bool) : ITimelineItem
    {static} FilterItems(items:List<ITimelineItem>) : bool
    {static} GetClosestItem(track:TrackAsset, refItem:ITimelineItem) : ITimelineItem
    + {static} FocusFirstVisibleItem(state:WindowState, focusTracks:IEnumerable<TrackAsset>) : bool
    + {static} CollapseGroup(state:WindowState) : bool
    + {static} SelectLeftItem(state:WindowState, shift:bool) : bool
    + {static} SelectRightItem(state:WindowState, shift:bool) : bool
    + {static} UnCollapseGroup(state:WindowState) : bool
    + {static} SelectUpTrack(shift:bool) : bool
    + {static} SelectUpItem(state:WindowState) : bool
    + {static} SelectDownTrack(shift:bool) : bool
    + {static} SelectDownItem(state:WindowState) : bool
}
class TimeReferenceUtility <<static>> {
    + {static} SnapToFrame(time:double) : double
    + {static} ToTimeString(time:double, format:string) : string
    + {static} FromTimeString(timeString:string) : double
}
TimeReferenceUtility --> "state" WindowState
class TrackModifier <<static>> {
    + {static} DeleteTrack(timeline:TimelineAsset, track:TrackAsset) : bool
}
class TrackResourceCache <<static>> {
    + {static} GetTrackIcon(track:TrackAsset) : GUIContent
    + {static} GetTrackColor(track:TrackAsset) : Color
    + {static} ClearTrackIconCache() : void
    + {static} SetTrackIcon(content:GUIContent) : void
    + {static} ClearTrackColorCache() : void
    + {static} SetTrackColor(c:Color) : void
}
TrackResourceCache o-> "s_DefaultIcon" GUIContent
class TypeUtility <<static>> {
    + {static} IsConcretePlayableAsset(t:Type) : bool
    + {static} AllClipTypes() : IEnumerable<Type>
    + {static} AllTrackTypes() : IEnumerable<Type>
    + {static} GetVisiblePlayableAssetsHandledByTrack(trackType:Type) : IEnumerable<Type>
    + {static} GetPlayableAssetsHandledByTrack(trackType:Type) : IEnumerable<Type>
    + {static} GetTrackBindingAttribute(trackType:Type) : TrackBindingTypeAttribute
    + {static} TrackHasClipForObject(trackType:Type, obj:Object) : bool
    + {static} MarkerTypesWithFieldForObject(obj:Object) : IEnumerable<Type>
    + {static} GetTrackTypesForObject(obj:Object) : IEnumerable<Type>
    + {static} IsTrackCreatableFromObject(obj:Object, trackType:Type) : bool
    + {static} GetTracksCreatableFromObject(obj:Object) : IEnumerable<Type>
    + {static} GetAssetTypesForObject(trackType:Type, obj:Object) : IEnumerable<Type>
    + {static} GetAllMarkerTypes() : IEnumerable<Type>
    + {static} GetUserMarkerTypes() : IEnumerable<Type>
    + {static} GetBuiltInMarkerTypes() : IEnumerable<Type>
    + {static} DoesTrackSupportMarkerType(track:TrackAsset, type:Type) : bool
    <<internal>> {static} GetDisplayName(t:Type) : string
    + {static} IsHiddenInMenu(type:Type) : bool
    + {static} ObjectReferencesForType(type:Type) : IEnumerable<ObjectReference>
    + {static} HasOverrideMethod(t:System.Type, name:string) : bool
    + {static} IsBuiltIn(t:System.Type) : bool
}
class ObjectReference <<struct>> {
    + isSceneReference : bool
}
TypeUtility +-- ObjectReference
ObjectReference --> "type" Type
enum PlaybackScrollMode {
    None,
    Pan,
    Smooth,
}
class PlaybackScroller <<static>> {
    + {static} AutoScroll(state:WindowState) : void
    {static} DoSmoothScroll(state:WindowState) : void
    {static} DoPanScroll(state:WindowState) : void
}
class TimelineMarkerHeaderGUI {
    m_TrackHash : int
    + TimelineMarkerHeaderGUI(asset:TimelineAsset, state:WindowState)
    + locked : bool <<get>>
    + showMarkers : bool <<get>>
    + muted : bool <<get>>
    ToWindowSpace(rect:Rect) : Rect
    + Draw(markerHeaderRect:Rect, markerContentRect:Rect, state:WindowState) : void
    + Rebuild() : void
    HandleDragAndDrop() : void
    Hash() : int
    {static} DrawMarkerDrawer(data:DrawData, state:WindowState) : void
    {static} DrawMarkerDrawerHeaderBackground(data:DrawData) : void
    {static} DrawMarkerDrawerHeader(data:DrawData, state:WindowState) : void
    {static} DrawMarkerDrawerContentBackground(data:DrawData) : void
    {static} DrawLockButton(rect:Rect, state:WindowState) : void
    {static} DrawTrackDropDownMenu(rect:Rect, state:WindowState) : void
    {static} DrawMuteButton(rect:Rect, state:WindowState) : void
}
class DrawData <<struct>> {
    + showLockButton : bool
    + showMuteButton : bool
}
IRowGUI <|-- TimelineMarkerHeaderGUI
ILayerable <|-- TimelineMarkerHeaderGUI
TimelineMarkerHeaderGUI --> "timeline" TimelineAsset
TimelineMarkerHeaderGUI --> "state" WindowState
TimelineMarkerHeaderGUI --> "m_Layer" MarkersLayer
TimelineMarkerHeaderGUI o-> "m_ZOrder" LayerZOrder
TimelineMarkerHeaderGUI --> "asset" TrackAsset
TimelineMarkerHeaderGUI --> "boundingRect" Rect
TimelineMarkerHeaderGUI --> "zOrder" LayerZOrder
TimelineMarkerHeaderGUI +-- DrawData
DrawData --> "headerRect" Rect
DrawData --> "contentRect" Rect
DrawData --> "trackSwatchStyle" GUIStyle
DrawData --> "trackHeaderFont" GUIStyle
DrawData --> "colorTrackFont" Color
class TimelineWindow <<partial>> {
    m_LastFrameHadSequence : bool
    m_ForceRefreshLastSelection : bool
    m_CurrentSceneHashCode : int
    m_HasBeenInitialized : bool
    + isDragging : bool <<get>> <<set>>
    + locked : bool <<get>> <<set>>
    + hierarchyChangedThisFrame : bool <<get>>
    + TimelineWindow()
    OnLockStateChanged(locked:bool) : void
    OnEnable() : void
    OnDisable() : void
    OnDestroy() : void
    OnLostFocus() : void
    OnFocus() : void
    OnHierarchyChange() : void
    OnStateChange() : void
    OnGUI() : void
    {static} DetectStylesChange() : void
    DetectActiveSceneChanges() : void
    DetectStateChanges() : void
    Initialize() : void
    RefreshLastSelectionIfRequired() : void
    InitializeGUIIfRequired() : void
    UpdateGUIConstants() : void
    UpdateViewStateHash() : void
    {static} PerformUndo() : bool
    + RebuildGraphIfNecessary(evaluate:bool) : void
    + <<new>> RepaintImmediately() : void
    <<internal>> {static} IsEditingTimelineAsset(timelineAsset:TimelineAsset) : bool
    <<internal>> {static} RepaintIfEditingTimelineAsset(timelineAsset:TimelineAsset) : void
    + {static} CreateNewTimeline() : void
    + {static} ShowWindow() : void
    + {static} OnDoubleClick(instanceID:int, line:int) : bool
    + <<virtual>> AddItemsToMenu(menu:GenericMenu) : void
    <<internal>> TreeViewKeyboardCallback() : void
}
class TimelineWindowPreferences {
    + frameSnap : bool = true
    + edgeSnaps : bool = true
    + muteAudioScrub : bool = true
    + playRangeLoopMode : bool = true
}
class "List`1"<T> {
}
class DoCreateTimeline {
    + <<override>> Action(instanceId:int, pathName:string, resourceFile:string) : void
}
EditorWindow <|-- TimelineWindow
IHasCustomMenu <|-- TimelineWindow
TimelineWindow o-> "m_Preferences" TimelineWindowPreferences
TimelineWindow --> "preferences" TimelineWindowPreferences
TimelineWindow o-> "m_PreviewResizer" PreviewResizer
TimelineWindow --> "m_SequenceHierarchy" SequenceHierarchy
TimelineWindow --> "s_LastHierarchy" SequenceHierarchy
TimelineWindow --> "instance" TimelineWindow
TimelineWindow --> "clientArea" Rect
TimelineWindow --> "styles" DirectorStyles
TimelineWindow --> "allTracks<TimelineTrackBaseGUI>" "List`1"
TimelineWindow --> "state" WindowState
TimelineWindow +-- TimelineWindowPreferences
TimelineWindowPreferences --> "autoScrollMode" PlaybackScrollMode
TimelineWindowPreferences o-> "timeReferenceMode" TimeReferenceMode
TimelineWindow +-- DoCreateTimeline
class TimelineWindowTimeControl {
    OnStateChange() : void
    + Init(animState:AnimationWindowState, clip:TimelineClip) : void
    + Init(animState:AnimationWindowState, clip:ClipData) : void
    + <<override>> OnEnable() : void
    + OnDisable() : void
    ChangeTime(newTime:float) : void
    {static} ChangeFrame(frame:int) : void
    + <<override>> GoToTime(newTime:float) : void
    + <<override>> GoToFrame(frame:int) : void
    + <<override>> StartScrubTime() : void
    + <<override>> EndScrubTime() : void
    + <<override>> ScrubTime(newTime:float) : void
    + <<override>> GoToPreviousFrame() : void
    + <<override>> GoToNextFrame() : void
    GetCurves() : AnimationWindowCurve[]
    + <<override>> GoToPreviousKeyframe() : void
    + <<override>> GoToNextKeyframe() : void
    + <<override>> GoToFirstKeyframe() : void
    + <<override>> GoToLastKeyframe() : void
    + <<override>> canPlay : bool <<get>>
    + <<override>> playing : bool <<get>>
    {static} SetPlaybackState(playbackState:bool) : void
    + <<override>> StartPlayback() : bool
    + <<override>> StopPlayback() : void
    + <<override>> PlaybackUpdate() : bool
    + <<override>> canRecord : bool <<get>>
    + <<override>> recording : bool <<get>>
    + <<override>> canPreview : bool <<get>>
    + <<override>> previewing : bool <<get>>
    + <<override>> StartRecording(targetObject:Object) : bool
    + <<override>> StopRecording() : void
    + <<override>> OnSelectionChanged() : void
    + <<override>> ResampleAnimation() : void
    + <<override>> StartPreview() : bool
    + <<override>> StopPreview() : void
    + <<override>> ProcessCandidates() : void
    + <<override>> ClearCandidates() : void
    durationD : double <<get>>
    ToGlobalTime(localTime:float) : double
    ToAnimationClipTime(globalTime:double) : float
}
class ClipData <<struct>> {
    + start : double
    + duration : double
}
IAnimationWindowControl <|-- TimelineWindowTimeControl
TimelineWindowTimeControl --> "m_ClipData" ClipData
TimelineWindowTimeControl --> "m_Clip" TimelineClip
TimelineWindowTimeControl --> "m_AnimWindowState" AnimationWindowState
TimelineWindowTimeControl --> "track" TrackAsset
TimelineWindowTimeControl --> "window" TimelineWindow
TimelineWindowTimeControl --> "state" WindowState
TimelineWindowTimeControl --> "time" AnimationKeyTime
TimelineWindowTimeControl +-- ClipData
ClipData --> "track" TrackAsset
class TimelineWindow <<partial>> {
    + ClearCurrentTimeline() : void
    + SetCurrentTimeline(seq:TimelineAsset) : void
    + SetCurrentTimeline(director:PlayableDirector, hostClip:TimelineClip) : void
    SetCurrentTimeline(seq:TimelineAsset, instanceOfDirector:PlayableDirector, hostClip:TimelineClip, force:bool) : void
    OnBeforeSequenceChange() : void
    OnAfterSequenceChange() : void
}
class TimelineWindow <<partial>> {
    {static} GetTitleMode(sequence:ISequenceState) : TitleMode
    DoBreadcrumbGUI() : void
    NavigateToBreadcrumbIndex(index:int) : void
    DoSequenceSelectorGUI() : void
    ShowSequenceSelector() : void
    OnSequenceSelected(arg:object) : void
}
class "List`1"<T> {
}
TimelineWindow o-> "m_BreadCrumbLabels<BreadCrumbTitle>" "List`1"
class TimelineWindow <<partial>> {
    DurationGUI(area:TimelineItemArea, duration:double) : void
    DrawDuration(drawhead:bool, drawline:bool, duration:double) : void
    HighlightTimeAreaRange(range:Range, lineColor:Color) : void
    OnTrackDurationDrag(newTime:double) : void
}
TimelineWindow --> "m_TimelineDuration" TimeAreaItem
class TimelineWindow <<partial>> {
    OnSelectionChangedInactive() : void
    InitializeEditorCallbacks() : void
    OnEditorQuit() : void
    RemoveEditorCallbacks() : void
    OnPrefabApplied(go:GameObject) : void
    OnSceneSaved(scene:Scene) : void
    OnCurveModified(clip:AnimationClip, binding:EditorCurveBinding, type:AnimationUtility.CurveModifiedType) : void
    OnPlayModeStateChanged(playModeState:PlayModeStateChange) : void
    PostprocessAnimationRecordingModifications(modifications:UndoPropertyModification[]) : UndoPropertyModification[]
    DirtyModifiedObjects(modifications:UndoPropertyModification[]) : void
    ProcessAssetModifications(modifications:UndoPropertyModification[]) : UndoPropertyModification[]
    OnUndoRedo() : void
    {static} ValidateSelection() : void
    OnComponentWasAdded(c:Component) : void
}
class TimelineWindow <<partial>> {
    m_HierarchySplitterPerc : float
    m_SplitterCaptured : int
    m_VerticalScrollBarSize : float
    m_HorizontalScrollBarSize : float
    headerHeight : float <<get>>
    + verticalScrollbarWidth : float <<get>>
    + horizontalScrollbarHeight : float <<get>>
    breadCrumbAreaWidth : float <<get>>
    DoLayout() : void
    TimelineSectionGUI() : void
    SplitterGUI() : void
    TrackViewsGUI() : void
    UserOverlaysGUI() : void
    DrawHeaderBackground() : void
    HandleBottomFillerDragAndDrop(rect:Rect) : void
    DrawHeaderBackgroundBottomFiller() : void
    SequencerGUI() : void
    SubTimelineRangeGUI() : void
    HandleSplitterResize() : void
    OptionsGUI() : void
    AddStandardFrameRateMenu(menu:GenericMenu, name:string, value:float) : bool
    ChangeTimeCode(obj:object) : void
    + AddUserOverlay(marker:IMarker, rect:Rect, editor:MarkerEditor, collapsed:bool, selected:bool) : void
}
class MarkerOverlay <<struct>> {
    + isSelected : bool
    + isCollapsed : bool
}
enum TimelineItemArea {
    Header,
    Lines,
}
class "List`1"<T> {
}
TimelineWindow o-> "s_ActiveMode" TimelineMode
TimelineWindow o-> "s_EditAssetMode" TimelineMode
TimelineWindow o-> "s_InactiveMode" TimelineMode
TimelineWindow o-> "s_DisabledMode" TimelineMode
TimelineWindow o-> "s_PrefabOutOfContextMode" TimelineMode
TimelineWindow o-> "s_ReadonlyMode" TimelineMode
TimelineWindow o-> "m_OverlayQueue<MarkerOverlay>" "List`1"
TimelineWindow --> "markerHeaderRect" Rect
TimelineWindow --> "markerContentRect" Rect
TimelineWindow --> "trackRect" Rect
TimelineWindow --> "sequenceRect" Rect
TimelineWindow --> "sequenceHeaderRect" Rect
TimelineWindow --> "sequenceContentRect" Rect
TimelineWindow --> "currentMode" TimelineMode
TimelineWindow +-- MarkerOverlay
MarkerOverlay --> "marker" IMarker
MarkerOverlay --> "rect" Rect
MarkerOverlay --> "editor" MarkerEditor
TimelineWindow +-- TimelineItemArea
class TimelineWindow <<partial>> {
    SequencerHeaderGUI() : void
    MarkerHeaderGUI() : void
    TransportToolbarGUI() : void
    PreviewModeButtonGUI() : void
    GotoBeginingSequenceGUI() : void
    PlayButtonGUIEditor() : void
    PlayButtonGUIPlayMode() : void
    PlayButtonGUI() : void
    NextEventButtonGUI() : void
    PreviousEventButtonGUI() : void
    GotoEndSequenceGUI() : void
    PlayRangeButtonGUI() : void
    AddButtonGUI() : void
    ShowMarkersButton() : void
    <<internal>> SetShowMarkerHeader(newValue:bool) : void
    <<internal>> SetShowTrackMarkers(track:TrackAsset, showMarkerHeader:bool) : void
    {static} EditModeToolbarGUI(mode:TimelineMode) : void
    TimeCodeGUI() : void
    ReferenceTimeGUI() : void
    OnTimeReferenceModeChanged() : void
}
TimelineWindow --> "m_MarkerHeaderGUI" TimelineMarkerHeaderGUI
class TimelineWindow <<partial>> {
    InitializeManipulators() : void
}
TimelineWindow o-> "m_PreTreeViewControl" Control
TimelineWindow o-> "m_PostTreeViewControl" Control
TimelineWindow o-> "m_RectangleSelect" RectangleSelect
TimelineWindow o-> "m_RectangleZoom" RectangleZoom
class TimelineWindow <<partial>> {
}
class PlayableLookup {
    <<const>> k_InitialDictionarySize : int = 10
    + UpdatePlayableLookup(clip:TimelineClip, go:GameObject, p:Playable) : void
    + UpdatePlayableLookup(track:TrackAsset, go:GameObject, p:Playable) : void
    UpdatePlayableLookup(timelineAsset:TimelineAsset, curvesOwner:ICurvesOwner, go:GameObject, p:Playable) : void
    + GetPlayableFromAnimClip(clip:AnimationClip, p:Playable) : bool
    + GetTimelineClipFromCurves(clip:AnimationClip) : TimelineClip
    + ClearPlayableLookup() : void
}
class "Dictionary`2"<T1,T2> {
}
TimelineWindow o-> "m_PlayableLookup" PlayableLookup
TimelineWindow +-- PlayableLookup
PlayableLookup o-> "m_AnimationClipToPlayable<AnimationClip,Playable>" "Dictionary`2"
PlayableLookup o-> "m_AnimationClipToTimelineClip<AnimationClip,TimelineClip>" "Dictionary`2"
class TimelineWindow <<partial>> {
    PlayRangeGUI(area:TimelineItemArea) : void
    DrawPlayRange(drawHeads:bool, drawLines:bool) : void
    OnTrackHeadMinSelectDrag(newTime:double) : void
    OnTrackHeadMaxSelectDrag(newTime:double) : void
}
TimelineWindow --> "m_PlayRangeEnd" TimeAreaItem
TimelineWindow --> "m_PlayRangeStart" TimeAreaItem
class TimelineWindow <<partial>> {
    OnPreviewPlayModeChanged(isPlaying:bool) : void
    PreparePreviewPlay() : void
    <<internal>> OnPreviewPlay() : void
    ApplyJog() : void
    EnsurePlayRangeIsRespected() : void
}
class TimelineWindow <<partial>> {
    OnSelectionChange() : void
    RefreshSelection(forceRebuild:bool) : void
    RestoreLastSelection(forceRebuild:bool) : void
    SetCurrentSelection(obj:Object) : void
}
TimelineWindow --> "m_SequencePath" SequencePath
class TimelineWindow <<partial>> {
    InitializeStateChange() : void
}
class TimelineWindow <<partial>> {
    m_LastFrameRate : float
    m_TimeAreaDirty : bool = true
    InitializeTimeArea() : void
    TimelineGUI() : void
    InitTimeAreaFrameRate() : void
    SyncTimeAreaShownRange() : void
}
class Styles <<static>> {
    + {static} DurationModeText : string
}
class TimelineTimeArea {
    + TimelineTimeArea(state:WindowState, minimalGUI:bool)
    + <<override>> FormatTickTime(time:float, frameRate:float, timeFormat:TimeFormat) : string
}
TimelineWindow --> "m_TimeArea" TimelineTimeArea
TimelineWindow --> "timeArea" TimeArea
TimelineWindow +-- Styles
TimelineWindow +-- TimelineTimeArea
TimeArea <|-- TimelineTimeArea
TimelineTimeArea --> "m_State" WindowState
class TimelineWindow <<partial>> {
    TimeCursorGUI(area:TimelineItemArea) : void
    CanDrawTimeCursor(area:TimelineItemArea) : bool
    DrawTimeOnSlider() : void
    DrawTimeCursor(drawHead:bool, drawline:bool) : void
    OnTrackHeadDrag(newTime:double) : void
}
TimelineWindow --> "m_PlayHead" TimeAreaItem
class TimelineWindow <<partial>> {
    TracksGUI(clientRect:Rect, state:WindowState, trackState:TimelineModeGUIState) : void
    DrawNoSequenceGUI(windowState:WindowState) : void
    DrawTracksGUI(clientRect:Rect, trackState:TimelineModeGUIState) : void
    DrawOverlay(overlayData:OverlayData) : void
    RefreshInlineCurves() : void
}
enum OverlayDataTypes {
    None,
    BackgroundColor,
    BackgroundTexture,
    TextBox,
}
class OverlayData <<struct>> {
    + text : string <<get>>
    + {static} CreateColorOverlay(rectangle:Rect, backgroundColor:Color) : OverlayData
    + {static} CreateTextureOverlay(rectangle:Rect, backTexture:Texture2D) : OverlayData
    + {static} CreateTextBoxOverlay(rectangle:Rect, msg:string, textstyle:GUIStyle, textcolor:Color, bgTextColor:Color, bgTextStyle:GUIStyle) : OverlayData
}
class "List`1"<T> {
}
TimelineWindow --> "treeView" TimelineTreeViewGUI
TimelineWindow o-> "OverlayDrawData<OverlayData>" "List`1"
TimelineWindow +-- OverlayDataTypes
TimelineWindow +-- OverlayData
OverlayData --> "types" OverlayDataTypes
OverlayData --> "rect" Rect
OverlayData --> "texture" Texture2D
OverlayData --> "color" Color
OverlayData --> "backgroundTextStyle" GUIStyle
OverlayData --> "textStyle" GUIStyle
class WindowConstants <<static>> {
    + <<const>> timeAreaYPosition : float = 19.0f
    + <<const>> timeAreaHeight : float = 22.0f
    + <<const>> timeAreaMinWidth : float = 50.0f
    + <<const>> timeAreaShownRangePadding : float = 5.0f
    + <<const>> markerRowHeight : float = 18.0f
    + <<const>> markerRowYPosition : float
    + <<const>> defaultHeaderWidth : float = 315.0f
    + <<const>> defaultBindingAreaWidth : float = 40.0f
    + <<const>> minHierarchySplitter : float = 0.15f
    + <<const>> maxHierarchySplitter : float = 10.50f
    + <<const>> hierarchySplitterDefaultPercentage : float = 0.2f
    + <<const>> minHeaderWidth : float = 315.0f
    + <<const>> maxHeaderWidth : float = 650.0f
    + <<const>> maxTimeAreaScaling : float = 90000.0f
    + <<const>> minTimeCodeWidth : float = 28.0f
    + <<const>> sliderWidth : float = 15
    + <<const>> shadowUnderTimelineHeight : float = 15.0f
    + <<const>> createButtonWidth : float = 70.0f
    + <<const>> refTimeWidth : float = 50.0f
    + <<const>> selectorWidth : float = 23.0f
    + <<const>> cogButtonWidth : float = 32.0f
    + <<const>> cogButtonPadding : float = 16.0f
    + <<const>> trackHeaderButtonSize : float = 16.0f
    + <<const>> trackHeaderButtonPadding : float = 6f
    + <<const>> trackHeaderButtonSpacing : float = 3.0f
    + <<const>> trackOptionButtonVerticalPadding : float = 0f
    + <<const>> trackHeaderMaxButtonsWidth : float
    + <<const>> trackInsertionMarkerHeight : float = 1f
    + <<const>> autoPanPaddingInPixels : int = 50
}
class ActivationMixerPlayable {
    m_BoundGameObjectInitialStateIsActive : bool
    + {static} Create(graph:PlayableGraph, inputCount:int) : ScriptPlayable<ActivationMixerPlayable>
    + <<override>> OnPlayableDestroy(playable:Playable) : void
    + <<override>> ProcessFrame(playable:Playable, info:FrameData, playerData:object) : void
}
PlayableBehaviour <|-- ActivationMixerPlayable
class ActivationPlayableAsset {
    + <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
}
PlayableAsset <|-- ActivationPlayableAsset
ITimelineClipAsset <|-- ActivationPlayableAsset
ActivationPlayableAsset --> "clipCaps" ClipCaps
class ActivationTrack {
    <<internal>> <<override>> CanCompileClips() : bool
    + <<override>> CreateTrackMixer(graph:PlayableGraph, go:GameObject, inputCount:int) : Playable
    <<internal>> UpdateTrackMode() : void
    + <<override>> GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
}
enum PostPlaybackState {
    Active,
    Inactive,
    Revert,
    LeaveAsIs,
}
TrackAsset <|-- ActivationTrack
ActivationTrack o-> "m_PostPlaybackState" PostPlaybackState
ActivationTrack --> "m_ActivationMixer" ActivationMixerPlayable
ActivationTrack --> "postPlaybackState" PostPlaybackState
ActivationTrack +-- PostPlaybackState
class AnimationOutputWeightProcessor {
    + AnimationOutputWeightProcessor(output:AnimationPlayableOutput)
    FindMixers() : void
    FindMixers(parent:Playable, port:int, node:Playable) : void
    + Evaluate() : void
}
class WeightInfo <<struct>> {
    + port : int
}
class "List`1"<T> {
}
ITimelineEvaluateCallback <|-- AnimationOutputWeightProcessor
AnimationOutputWeightProcessor --> "m_Output" AnimationPlayableOutput
AnimationOutputWeightProcessor --> "m_MotionXPlayable" AnimationMotionXToDeltaPlayable
AnimationOutputWeightProcessor o-> "m_Mixers<WeightInfo>" "List`1"
AnimationOutputWeightProcessor +-- WeightInfo
WeightInfo --> "mixer" Playable
WeightInfo --> "parentMixer" Playable
class AnimationPlayableAsset <<partial>> {
    + useTrackMatchFields : bool <<get>> <<set>>
    + removeStartOffset : bool <<get>> <<set>>
    + applyFootIK : bool <<get>> <<set>>
    <<internal>> hasRootTransforms : bool <<get>>
    + <<override>> duration : double <<get>>
    + <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
    <<internal>> {static} CreatePlayable(graph:PlayableGraph, clip:AnimationClip, positionOffset:Vector3, eulerOffset:Vector3, removeStartOffset:bool, mode:AppliedOffsetMode, applyFootIK:bool, loop:LoopMode) : Playable
    + ResetOffsets() : void
    + GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
    <<internal>> {static} HasRootTransforms(clip:AnimationClip) : bool
}
enum LoopMode {
    UseSourceAsset= 0,
    On= 1,
    Off= 2,
}
class "IEnumerable`1"<T> {
}
PlayableAsset <|-- AnimationPlayableAsset
ITimelineClipAsset <|-- AnimationPlayableAsset
IPropertyPreview <|-- AnimationPlayableAsset
AnimationPlayableAsset --> "position" Vector3
AnimationPlayableAsset --> "rotation" Quaternion
AnimationPlayableAsset --> "eulerAngles" Vector3
AnimationPlayableAsset --> "matchTargetFields" MatchTargetFields
AnimationPlayableAsset --> "loop" LoopMode
AnimationPlayableAsset --> "appliedOffsetMode" AppliedOffsetMode
AnimationPlayableAsset --> "clip" AnimationClip
AnimationPlayableAsset --> "outputs<PlayableBinding>" "IEnumerable`1"
AnimationPlayableAsset --> "clipCaps" ClipCaps
AnimationPlayableAsset +-- LoopMode
class AnimationPreviewUpdateCallback {
    + AnimationPreviewUpdateCallback(output:AnimationPlayableOutput)
    + Evaluate() : void
}
class "List`1"<T> {
}
ITimelineEvaluateCallback <|-- AnimationPreviewUpdateCallback
AnimationPreviewUpdateCallback --> "m_Output" AnimationPlayableOutput
AnimationPreviewUpdateCallback --> "m_Graph" PlayableGraph
AnimationPreviewUpdateCallback --> "m_PreviewComponents<IAnimationWindowPreview>" "List`1"
enum MatchTargetFields {
    PositionX= 1 << 0,
    PositionY= 1 << 1,
    PositionZ= 1 << 2,
    RotationX= 1 << 3,
    RotationY= 1 << 4,
    RotationZ= 1 << 5,
}
enum TrackOffset {
    ApplyTransformOffsets,
    ApplySceneOffsets,
    Auto,
}
enum AppliedOffsetMode {
    NoRootTransform,
    TransformOffset,
    SceneOffset,
    TransformOffsetLegacy,
    SceneOffsetLegacy,
    SceneOffsetEditor,
    SceneOffsetLegacyEditor,
}
class MatchTargetFieldConstants <<static>> {
    + {static} HasAny(me:MatchTargetFields, fields:MatchTargetFields) : bool
    + {static} Toggle(me:MatchTargetFields, flag:MatchTargetFields) : MatchTargetFields
}
class AnimationTrack <<partial>> {
    <<const>> k_DefaultInfiniteClipName : string = "Recorded"
    <<const>> k_DefaultRecordableClipName : string = "Recorded"
    m_InfiniteClipTimeOffset : double
    m_InfiniteClipRemoveOffset : bool
    m_InfiniteClipApplyFootIK : bool = true
    m_ApplyAvatarMask : bool = true
    + applyOffsets : bool <<get>> <<set>>
    <<internal>> infiniteClipRemoveOffset : bool <<get>> <<set>>
    + applyAvatarMask : bool <<get>> <<set>>
    <<internal>> <<override>> CanCompileClips() : bool
    + inClipMode : bool <<get>>
    <<internal>> infiniteClipApplyFootIK : bool <<get>> <<set>>
    <<internal>> infiniteClipTimeOffset : double <<get>> <<set>>
    ResetOffsets() : void
    + CreateClip(clip:AnimationClip) : TimelineClip
    + CreateInfiniteClip(infiniteClipName:string) : void
    + CreateRecordableClip(animClipName:string) : TimelineClip
    <<internal>> UpdateClipOffsets() : void
    CompileTrackPlayable(graph:PlayableGraph, track:TrackAsset, go:GameObject, tree:IntervalTree<RuntimeElement>, mode:AppliedOffsetMode) : Playable
    CreateLayerMixer(graph:PlayableGraph, go:GameObject, inputCount:int) : Playable
    <<internal>> <<override>> OnCreateClipPlayableGraph(graph:PlayableGraph, go:GameObject, tree:IntervalTree<RuntimeElement>) : Playable
    RequiresMotionXPlayable(mode:AppliedOffsetMode, gameObject:GameObject) : bool
    {static} UsesAbsoluteMotion(mode:AppliedOffsetMode) : bool
    HasController(gameObject:GameObject) : bool
    <<internal>> GetBinding(director:PlayableDirector) : Animator
    {static} CreateGroupMixer(graph:PlayableGraph, go:GameObject, inputCount:int) : AnimationLayerMixerPlayable
    CreateInfiniteTrackPlayable(graph:PlayableGraph, go:GameObject, tree:IntervalTree<RuntimeElement>, mode:AppliedOffsetMode) : Playable
    ApplyTrackOffset(graph:PlayableGraph, root:Playable, go:GameObject, mode:AppliedOffsetMode) : Playable
    <<internal>> <<override>> GetEvaluationTime(outStart:double, outDuration:double) : void
    <<internal>> <<override>> GetSequenceTime(outStart:double, outDuration:double) : void
    AssignAnimationClip(clip:TimelineClip, animClip:AnimationClip) : void
    + <<override>> GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
    GetOffsetMode(go:GameObject, animatesRootTransform:bool) : AppliedOffsetMode
    <<internal>> AnimatesRootTransform() : bool
}
class "IEnumerable`1"<T> {
}
MatchTargetFieldConstants o-> "All" MatchTargetFields
MatchTargetFieldConstants o-> "None" MatchTargetFields
MatchTargetFieldConstants o-> "Position" MatchTargetFields
MatchTargetFieldConstants o-> "Rotation" MatchTargetFields
TrackAsset <|-- AnimationTrack
ILayerable <|-- AnimationTrack
AnimationTrack o-> "m_InfiniteClipOffsetPosition" Vector3
AnimationTrack o-> "m_InfiniteClipOffsetEulerAngles" Vector3
AnimationTrack o-> "m_MatchTargetFields" MatchTargetFields
AnimationTrack o-> "m_Position" Vector3
AnimationTrack o-> "m_EulerAngles" Vector3
AnimationTrack --> "m_AvatarMask" AvatarMask
AnimationTrack o-> "m_TrackOffset" TrackOffset
AnimationTrack --> "m_InfiniteClip" AnimationClip
AnimationTrack --> "position" Vector3
AnimationTrack --> "rotation" Quaternion
AnimationTrack --> "eulerAngles" Vector3
AnimationTrack --> "trackOffset" TrackOffset
AnimationTrack --> "matchTargetFields" MatchTargetFields
AnimationTrack --> "infiniteClip" AnimationClip
AnimationTrack --> "avatarMask" AvatarMask
AnimationTrack --> "outputs<PlayableBinding>" "IEnumerable`1"
AnimationTrack --> "infiniteClipOffsetPosition" Vector3
AnimationTrack --> "infiniteClipOffsetRotation" Quaternion
AnimationTrack --> "infiniteClipOffsetEulerAngles" Vector3
interface ICurvesOwner {
    hasCurves : bool <<get>>
    duration : double <<get>>
    CreateCurves(curvesClipName:string) : void
    defaultCurvesName : string <<get>>
}
ICurvesOwner --> "curves" AnimationClip
ICurvesOwner --> "asset" Object
ICurvesOwner --> "assetOwner" Object
ICurvesOwner --> "targetTrack" TrackAsset
class AnimationPlayableAsset <<partial>> {
    {static} <<readonly>> k_LatestVersion : int
    m_Version : int
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
    OnUpgradeFromVersion(oldVersion:int) : void
}
enum Versions {
    Initial= 0,
    RotationAsEuler= 1,
}
class AnimationPlayableAssetUpgrade <<static>> {
    + {static} ConvertRotationToEuler(asset:AnimationPlayableAsset) : void
}
ISerializationCallbackReceiver <|-- AnimationPlayableAsset
AnimationPlayableAsset +-- Versions
AnimationPlayableAsset +-- AnimationPlayableAssetUpgrade
class AnimationTrack <<partial>> {
    m_ApplyOffsets : bool
    <<internal>> <<override>> OnUpgradeFromVersion(oldVersion:int) : void
}
class AnimationTrackUpgrade <<static>> {
    + {static} ConvertRotationsToEuler(track:AnimationTrack) : void
    + {static} ConvertRootMotion(track:AnimationTrack) : void
    + {static} ConvertInfiniteTrack(track:AnimationTrack) : void
}
AnimationTrack o-> "m_OpenClipOffsetRotation" Quaternion
AnimationTrack o-> "m_Rotation" Quaternion
AnimationTrack --> "openClipOffsetPosition" Vector3
AnimationTrack --> "openClipOffsetRotation" Quaternion
AnimationTrack --> "openClipOffsetEulerAngles" Vector3
AnimationTrack +-- AnimationTrackUpgrade
class TimelineClip <<partial>> {
    <<const>> k_LatestVersion : int
    m_Version : int
    UpgradeToLatestVersion() : void
}
enum Versions {
    Initial= 0,
    ClipInFromGlobalToLocal= 1,
}
class TimelineClipUpgrade <<static>> {
    + {static} UpgradeClipInFromGlobalToLocal(clip:TimelineClip) : void
}
TimelineClip +-- Versions
TimelineClip +-- TimelineClipUpgrade
class TimelineAsset <<partial>> {
    <<const>> k_LatestVersion : int
    m_Version : int
    UpgradeToLatestVersion() : void
}
enum Versions {
    Initial= 0,
}
class TimelineAssetUpgrade <<static>> {
}
TimelineAsset +-- Versions
TimelineAsset +-- TimelineAssetUpgrade
class TrackAsset <<partial>> {
    <<const>> k_LatestVersion : int
    m_Version : int
    <<internal>> <<virtual>> OnUpgradeFromVersion(oldVersion:int) : void
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
    UpgradeToLatestVersion() : void
}
enum Versions {
    Initial= 0,
    RotationAsEuler= 1,
    RootMotionUpgrade= 2,
    AnimatedTrackProperties= 3,
}
class TrackAssetUpgrade <<static>> {
}
ISerializationCallbackReceiver <|-- TrackAsset
TrackAsset --> "m_AnimClip" AnimationClip
TrackAsset +-- Versions
TrackAsset +-- TrackAssetUpgrade
class TrackColorAttribute {
    + TrackColorAttribute(r:float, g:float, b:float)
}
Attribute <|-- TrackColorAttribute
TrackColorAttribute --> "m_Color" Color
TrackColorAttribute --> "color" Color
class AudioClipProperties {
    + volume : float = 1.0f
}
PlayableBehaviour <|-- AudioClipProperties
class AudioMixerProperties {
    + volume : float = 1.0f
    + stereoPan : float = 0.0f
    + spatialBlend : float = 0.0f
    + <<override>> PrepareFrame(playable:Playable, info:FrameData) : void
}
PlayableBehaviour <|-- AudioMixerProperties
class AudioPlayableAsset {
    m_Loop : bool
    m_bufferingTime : float = 0.1f
    <<internal>> bufferingTime : float <<get>> <<set>>
    + loop : bool <<get>> <<set>>
    + <<override>> duration : double <<get>>
    + <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
}
class "IEnumerable`1"<T> {
}
PlayableAsset <|-- AudioPlayableAsset
ITimelineClipAsset <|-- AudioPlayableAsset
AudioPlayableAsset --> "m_Clip" AudioClip
AudioPlayableAsset o-> "m_ClipProperties" AudioClipProperties
AudioPlayableAsset --> "clip" AudioClip
AudioPlayableAsset --> "outputs<PlayableBinding>" "IEnumerable`1"
AudioPlayableAsset --> "clipCaps" ClipCaps
class AudioTrack {
    + CreateClip(clip:AudioClip) : TimelineClip
    <<internal>> <<override>> CompileClips(graph:PlayableGraph, go:GameObject, timelineClips:IList<TimelineClip>, tree:IntervalTree<RuntimeElement>) : Playable
    OnValidate() : void
}
class "IEnumerable`1"<T> {
}
TrackAsset <|-- AudioTrack
AudioTrack o-> "m_TrackProperties" AudioMixerProperties
AudioTrack --> "outputs<PlayableBinding>" "IEnumerable`1"
class ControlPlayableAsset {
    <<const>> k_MaxRandInt : int = 10000
    + updateParticle : bool = true
    + particleRandomSeed : uint
    + updateDirector : bool = true
    + updateITimeControl : bool = true
    + searchHierarchy : bool = false
    + active : bool = true
    m_Duration : double
    m_SupportLoop : bool
    <<internal>> controllingDirectors : bool <<get>>
    <<internal>> controllingParticles : bool <<get>>
    + OnEnable() : void
    + <<override>> duration : double <<get>>
    + <<override>> CreatePlayable(graph:PlayableGraph, go:GameObject) : Playable
    {static} ConnectPlayablesToMixer(graph:PlayableGraph, playables:List<Playable>) : Playable
    CreateActivationPlayable(root:GameObject, graph:PlayableGraph, outplayables:List<Playable>) : void
    SearchHiearchyAndConnectParticleSystem(particleSystems:IEnumerable<ParticleSystem>, graph:PlayableGraph, outplayables:List<Playable>) : void
    SearchHierarchyAndConnectDirector(directors:IEnumerable<PlayableDirector>, graph:PlayableGraph, outplayables:List<Playable>, disableSelfReferences:bool) : void
    {static} SearchHierarchyAndConnectControlableScripts(controlableScripts:IEnumerable<MonoBehaviour>, graph:PlayableGraph, outplayables:List<Playable>) : void
    {static} ConnectMixerAndPlayable(graph:PlayableGraph, mixer:Playable, playable:Playable, portIndex:int) : void
    <<internal>> GetComponent(gameObject:GameObject) : IList<T>
    {static} GetControlableScripts(root:GameObject) : IEnumerable<MonoBehaviour>
    <<internal>> UpdateDurationAndLoopFlag(directors:IList<PlayableDirector>, particleSystems:IList<ParticleSystem>) : void
    GetParticleSystemRoots(go:GameObject) : IList<ParticleSystem>
    {static} GetParticleSystemRoots(t:Transform, roots:ICollection<ParticleSystem>) : void
    + GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
}
class "List`1"<T> {
}
class "ExposedReference`1"<T> {
}
PlayableAsset <|-- ControlPlayableAsset
IPropertyPreview <|-- ControlPlayableAsset
ITimelineClipAsset <|-- ControlPlayableAsset
ControlPlayableAsset o-> "k_EmptyDirectorsList<PlayableDirector>" "List`1"
ControlPlayableAsset o-> "k_EmptyParticlesList<ParticleSystem>" "List`1"
ControlPlayableAsset --> "sourceGameObject<GameObject>" "ExposedReference`1"
ControlPlayableAsset --> "prefabGameObject" GameObject
ControlPlayableAsset --> "m_ControlDirectorAsset" PlayableAsset
ControlPlayableAsset --> "clipCaps" ClipCaps
class ControlTrack {
}
TrackAsset <|-- ControlTrack
class InfiniteRuntimeClip {
    + InfiniteRuntimeClip(playable:Playable)
    + <<override>> enable : bool <<set>>
    + <<override>> EvaluateAt(localTime:double, frameData:FrameData) : void
}
RuntimeElement <|-- InfiniteRuntimeClip
InfiniteRuntimeClip --> "intervalStart" Int64
InfiniteRuntimeClip --> "intervalEnd" Int64
interface IInterval {
}
class IntervalTreeNode <<struct>> {
    + first : int
    + last : int
    + left : int
    + right : int
}
class "IntervalTree`1"<T> {
    <<const>> kMinNodeSize : int = 10
    <<const>> kInvalidNode : int
    + dirty : bool <<get>> <<internal set>>
    + Add(item:T) : void
    + IntersectsWith(value:Int64, results:List<T>) : void
    + IntersectsWithRange(start:Int64, end:Int64, results:List<T>) : void
    + UpdateIntervals() : void
    + Clear() : void
}
class Entry <<struct>> {
}
class "List`1"<T> {
}
IInterval --> "intervalStart" Int64
IInterval --> "intervalEnd" Int64
IntervalTreeNode --> "center" Int64
"IntervalTree`1" o-> "kCenterUnknown" Int64
"IntervalTree`1" o-> "m_Entries<Entry>" "List`1"
"IntervalTree`1" o-> "m_Nodes<IntervalTreeNode>" "List`1"
"IntervalTree`1" +-- Entry
Entry --> "intervalStart" Int64
Entry --> "intervalEnd" Int64
Entry --> "item" T
class RuntimeClip {
    + <<override>> start : double <<get>>
    + <<override>> duration : double <<get>>
    + RuntimeClip(clip:TimelineClip, clipPlayable:Playable, parentMixer:Playable)
    Create(clip:TimelineClip, clipPlayable:Playable, parentMixer:Playable) : void
    + <<override>> enable : bool <<set>>
    + SetTime(time:double) : void
    + SetDuration(duration:double) : void
    + <<override>> EvaluateAt(localTime:double, frameData:FrameData) : void
    + <<override>> Reset() : void
}
RuntimeClipBase <|-- RuntimeClip
RuntimeClip --> "m_Clip" TimelineClip
RuntimeClip --> "m_Playable" Playable
RuntimeClip --> "m_ParentMixer" Playable
RuntimeClip --> "clip" TimelineClip
RuntimeClip --> "mixer" Playable
RuntimeClip --> "playable" Playable
abstract class RuntimeClipBase {
    + {abstract} start : double <<get>>
    + {abstract} duration : double <<get>>
}
RuntimeElement <|-- RuntimeClipBase
RuntimeClipBase --> "intervalStart" Int64
RuntimeClipBase --> "intervalEnd" Int64
abstract class RuntimeElement {
    + intervalBit : int <<get>> <<set>>
    + {abstract} enable : bool <<set>>
    + {abstract} EvaluateAt(localTime:double, frameData:FrameData) : void
    + <<virtual>> Reset() : void
}
IInterval <|-- RuntimeElement
RuntimeElement --> "intervalStart" Int64
RuntimeElement --> "intervalEnd" Int64
class ScheduleRuntimeClip {
    + <<override>> start : double <<get>>
    + <<override>> duration : double <<get>>
    + SetTime(time:double) : void
    + ScheduleRuntimeClip(clip:TimelineClip, clipPlayable:Playable, parentMixer:Playable, startDelay:double, finishTail:double)
    + <<override>> enable : bool <<set>>
    + <<override>> EvaluateAt(localTime:double, frameData:FrameData) : void
}
RuntimeClipBase <|-- ScheduleRuntimeClip
ScheduleRuntimeClip --> "clip" TimelineClip
ScheduleRuntimeClip --> "mixer" Playable
ScheduleRuntimeClip --> "playable" Playable
interface IMarker {
    time : double <<get>> <<set>>
    Initialize(parent:TrackAsset) : void
}
IMarker --> "parent" TrackAsset
interface INotificationOptionProvider {
}
INotificationOptionProvider --> "flags" NotificationFlags
abstract class Marker {
    m_Time : double
    + time : double <<get>> <<set>>
    Initialize(parentTrack:TrackAsset) : void
    + <<virtual>> OnInitialize(aPent:TrackAsset) : void
}
ScriptableObject <|-- Marker
IMarker <|-- Marker
Marker --> "parent" TrackAsset
class MarkerList <<struct>> {
    m_CacheDirty : bool
    m_HasNotifications : bool
    + MarkerList(capacity:int)
    + Add(item:ScriptableObject) : void
    + Remove(item:IMarker) : bool
    + Remove(item:ScriptableObject, timelineAsset:TimelineAsset, thingToDirty:PlayableAsset) : bool
    + Clear() : void
    + Contains(item:ScriptableObject) : bool
    + GetMarkers() : IEnumerable<IMarker>
    + Count : int <<get>>
    + GetRawMarkerList() : List<ScriptableObject>
    + CreateMarker(type:Type, time:double, owner:TrackAsset) : IMarker
    + HasNotifications() : bool
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
    BuildCache() : void
}
class "List`1"<T> {
}
ISerializationCallbackReceiver <|-- MarkerList
MarkerList --> "m_Objects<ScriptableObject>" "List`1"
MarkerList --> "m_Cache<IMarker>" "List`1"
MarkerList --> "markers<IMarker>" "List`1"
class MarkerTrack {
}
class "IEnumerable`1"<T> {
}
TrackAsset <|-- MarkerTrack
MarkerTrack --> "outputs<PlayableBinding>" "IEnumerable`1"
class SignalTrack {
}
MarkerTrack <|-- SignalTrack
class TrackAssetExtensions <<static>> {
    + {static} GetGroup(asset:TrackAsset) : GroupTrack
    + {static} SetGroup(asset:TrackAsset, group:GroupTrack) : void
}
class ActivationControlPlayable {
    + {static} Create(graph:PlayableGraph, gameObject:GameObject, postPlaybackState:ActivationControlPlayable.PostPlaybackState) : ScriptPlayable<ActivationControlPlayable>
    + <<override>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
    + <<override>> ProcessFrame(playable:Playable, info:FrameData, userData:object) : void
    + <<override>> OnGraphStart(playable:Playable) : void
    + <<override>> OnPlayableDestroy(playable:Playable) : void
}
enum PostPlaybackState {
    Active,
    Inactive,
    Revert,
}
enum InitialState {
    Unset,
    Active,
    Inactive,
}
PlayableBehaviour <|-- ActivationControlPlayable
ActivationControlPlayable o-> "gameObject" GameObject
ActivationControlPlayable o-> "postPlayback" PostPlaybackState
ActivationControlPlayable --> "m_InitialState" InitialState
ActivationControlPlayable +-- PostPlaybackState
ActivationControlPlayable +-- InitialState
class BasicPlayableBehaviour {
    + BasicPlayableBehaviour()
    + <<virtual>> duration : double <<get>>
    + <<virtual>> OnGraphStart(playable:Playable) : void
    + <<virtual>> OnGraphStop(playable:Playable) : void
    + <<virtual>> OnPlayableCreate(playable:Playable) : void
    + <<virtual>> OnPlayableDestroy(playable:Playable) : void
    + <<virtual>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<virtual>> OnBehaviourPause(playable:Playable, info:FrameData) : void
    + <<virtual>> PrepareFrame(playable:Playable, info:FrameData) : void
    + <<virtual>> ProcessFrame(playable:Playable, info:FrameData, playerData:object) : void
    + <<virtual>> CreatePlayable(graph:PlayableGraph, owner:GameObject) : Playable
}
class "IEnumerable`1"<T> {
}
ScriptableObject <|-- BasicPlayableBehaviour
IPlayableAsset <|-- BasicPlayableBehaviour
IPlayableBehaviour <|-- BasicPlayableBehaviour
BasicPlayableBehaviour --> "outputs<PlayableBinding>" "IEnumerable`1"
class DirectorControlPlayable {
    + {static} Create(graph:PlayableGraph, director:PlayableDirector) : ScriptPlayable<DirectorControlPlayable>
    + <<override>> OnPlayableDestroy(playable:Playable) : void
    + <<override>> PrepareFrame(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
    + <<override>> ProcessFrame(playable:Playable, info:FrameData, playerData:object) : void
    SyncSpeed(speed:double) : void
    SyncPlayState(graph:PlayableGraph, playableTime:double) : void
    DetectDiscontinuity(playable:Playable, info:FrameData) : bool
    DetectOutOfSync(playable:Playable) : bool
    UpdateTime(playable:Playable) : void
}
PlayableBehaviour <|-- DirectorControlPlayable
DirectorControlPlayable --> "director" PlayableDirector
interface ITimeControl {
    SetTime(time:double) : void
    OnControlTimeStart() : void
    OnControlTimeStop() : void
}
enum NotificationFlags {
    TriggerInEditMode= 1 << 0,
    Retroactive= 1 << 1,
    TriggerOnce= 1 << 2,
}
class ParticleControlPlayable {
    <<const>> kUnsetTime : float
    m_LastTime : float
    m_RandomSeed : uint = 1
    m_SystemTime : float
    + {static} Create(graph:PlayableGraph, component:ParticleSystem, randomSeed:uint) : ScriptPlayable<ParticleControlPlayable>
    + Initialize(ps:ParticleSystem, randomSeed:uint) : void
    SetRandomSeed() : void
    + <<override>> PrepareFrame(playable:Playable, data:FrameData) : void
    + <<override>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
}
PlayableBehaviour <|-- ParticleControlPlayable
ParticleControlPlayable --> "particleSystem" ParticleSystem
class PrefabControlPlayable {
    + {static} Create(graph:PlayableGraph, prefabGameObject:GameObject, parentTransform:Transform) : ScriptPlayable<PrefabControlPlayable>
    + Initialize(prefabGameObject:GameObject, parentTransform:Transform) : GameObject
    + <<override>> OnPlayableDestroy(playable:Playable) : void
    + <<override>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
    {static} SetHideFlagsRecursive(gameObject:GameObject) : void
}
PlayableBehaviour <|-- PrefabControlPlayable
PrefabControlPlayable --> "m_Instance" GameObject
PrefabControlPlayable --> "prefabInstance" GameObject
class TimeControlPlayable {
    m_started : bool
    + {static} Create(graph:PlayableGraph, timeControl:ITimeControl) : ScriptPlayable<TimeControlPlayable>
    + Initialize(timeControl:ITimeControl) : void
    + <<override>> PrepareFrame(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPlay(playable:Playable, info:FrameData) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
}
PlayableBehaviour <|-- TimeControlPlayable
TimeControlPlayable --> "m_timeControl" ITimeControl
class TimeNotificationBehaviour {
    m_PreviousTime : double
    m_NeedSortNotifications : bool
    + {static} Create(graph:PlayableGraph, duration:double, loopMode:DirectorWrapMode) : ScriptPlayable<TimeNotificationBehaviour>
    + AddNotification(time:double, payload:INotification, flags:NotificationFlags) : void
    + <<override>> OnGraphStart(playable:Playable) : void
    + <<override>> OnBehaviourPause(playable:Playable, info:FrameData) : void
    + <<override>> PrepareFrame(playable:Playable, info:FrameData) : void
    SortNotifications() : void
    {static} CanRestoreNotification(e:NotificationEntry, info:FrameData, currentTime:double, previousTime:double) : bool
    TriggerNotificationsInRange(start:double, end:double, info:FrameData, playable:Playable, checkState:bool) : void
    SyncDurationWithExternalSource(playable:Playable) : void
    {static} Trigger_internal(playable:Playable, output:PlayableOutput, e:NotificationEntry) : void
    {static} Restore_internal(e:NotificationEntry) : void
}
class NotificationEntry <<struct>> {
    + time : double
    + notificationFired : bool
    + triggerInEditor : bool <<get>>
    + prewarm : bool <<get>>
    + triggerOnce : bool <<get>>
}
class "List`1"<T> {
}
PlayableBehaviour <|-- TimeNotificationBehaviour
TimeNotificationBehaviour o-> "m_Notifications<NotificationEntry>" "List`1"
TimeNotificationBehaviour --> "m_TimeSource" Playable
TimeNotificationBehaviour --> "timeSource" Playable
TimeNotificationBehaviour +-- NotificationEntry
NotificationEntry --> "payload" INotification
NotificationEntry --> "flags" NotificationFlags
class PlayableTrack {
}
TrackAsset <|-- PlayableTrack
class Extrapolation <<static>> {
    <<internal>> {static} <<readonly>> kMinExtrapolationTime : double
    <<internal>> {static} CalculateExtrapolationTimes(asset:TrackAsset) : void
    {static} SortClipsByStartTime(clips:TimelineClip[]) : TimelineClip[]
}
class HashUtility <<static>> {
    + {static} CombineHash(h1:int, h2:int) : int
    + {static} CombineHash(h1:int, h2:int, h3:int) : int
    + {static} CombineHash(h1:int, h2:int, h3:int, h4:int) : int
    + {static} CombineHash(h1:int, h2:int, h3:int, h4:int, h5:int) : int
    + {static} CombineHash(h1:int, h2:int, h3:int, h4:int, h5:int, h6:int) : int
    + {static} CombineHash(h1:int, h2:int, h3:int, h4:int, h5:int, h6:int, h7:int) : int
    + {static} CombineHash(hashes:int[]) : int
}
interface IPropertyCollector {
    PushActiveGameObject(gameObject:GameObject) : void
    PopActiveGameObject() : void
    AddFromClip(clip:AnimationClip) : void
    AddFromClips(clips:IEnumerable<AnimationClip>) : void
    AddFromName(name:string) : void
    AddFromName(name:string) : void
    AddFromClip(obj:GameObject, clip:AnimationClip) : void
    AddFromClips(obj:GameObject, clips:IEnumerable<AnimationClip>) : void
    AddFromName(obj:GameObject, name:string) : void
    AddFromName(obj:GameObject, name:string) : void
    AddFromName(component:Component, name:string) : void
    AddFromComponent(obj:GameObject, component:Component) : void
    AddObjectProperties(obj:Object, clip:AnimationClip) : void
}
interface IPropertyPreview {
    GatherProperties(director:PlayableDirector, driver:IPropertyCollector) : void
}
class NotificationUtilities <<static>> {
    + {static} CreateNotificationsPlayable(graph:PlayableGraph, markers:IEnumerable<IMarker>, go:GameObject) : ScriptPlayable<TimeNotificationBehaviour>
    + {static} TrackTypeSupportsNotifications(type:Type) : bool
}
class TimelineCreateUtilities <<static>> {
    + {static} GenerateUniqueActorName(tracks:List<ScriptableObject>, name:string) : string
    + {static} SaveAssetIntoObject(childAsset:Object, masterAsset:Object) : void
    + {static} CreateAnimationClipForTrack(name:string, track:TrackAsset, isLegacy:bool) : AnimationClip
    + {static} ValidateParentTrack(parent:TrackAsset, childType:Type) : bool
}
class TimelineUndo <<static>> {
    + {static} PushDestroyUndo(timeline:TimelineAsset, thingToDirty:Object, objectToDestroy:Object, operation:string) : void
    + {static} PushUndo(thingToDirty:Object, operation:string) : void
    + {static} RegisterCreatedObjectUndo(thingCreated:Object, operation:string) : void
}
class TimeUtility <<static>> {
    + {static} <<readonly>> kTimeEpsilon : double = 1e-14
    + {static} <<readonly>> kFrameRateEpsilon : double = 1e-6
    + {static} <<readonly>> k_MaxTimelineDurationInSeconds : double = 9e6
    {static} ValidateFrameRate(frameRate:double) : void
    + {static} ToFrames(time:double, frameRate:double) : int
    + {static} ToExactFrames(time:double, frameRate:double) : double
    + {static} FromFrames(frames:int, frameRate:double) : double
    + {static} FromFrames(frames:double, frameRate:double) : double
    + {static} OnFrameBoundary(time:double, frameRate:double) : bool
    + {static} GetEpsilon(time:double, frameRate:double) : double
    + {static} OnFrameBoundary(time:double, frameRate:double, epsilon:double) : bool
    + {static} RoundToFrame(time:double, frameRate:double) : double
    + {static} TimeAsFrames(timeValue:double, frameRate:double, format:string) : string
    + {static} TimeAsTimeCode(timeValue:double, frameRate:double, format:string) : string
    + {static} ParseTimeCode(timeCode:string, frameRate:double, defaultValue:double) : double
    + {static} GetAnimationClipLength(clip:AnimationClip) : double
    {static} RemoveChar(str:string, charToRemoveFunc:Func<char, bool>) : string
}
class WeightUtility <<static>> {
    + {static} NormalizeMixer(mixer:Playable) : float
}
interface IDraggable {
    IsMovableNow() : bool
    UpdatePresenterPosition() : void
}
class Draggable {
    + clampToParentEdges : bool <<get>> <<set>>
    + Draggable(clampToParentEdges:bool)
}
MouseManipulator <|-- Draggable
Draggable --> "panSpeed" Vector2
class BaseObject {
    + {static} DestroyImmediate(o:object) : void
    + {static} InstanceIDToObject(instanceID:int) : BaseObject
    <<internal>> <<virtual>> OnEnable() : void
    <<internal>> <<virtual>> OnDestroy() : void
}
ScriptableObject <|-- BaseObject
class Cache {
    + {static} Create() : T
    + {static} Destroy(cache:Cache) : void
    + isUndoOperationSet : bool <<get>>
    + IncrementCurrentGroup() : void
    + <<virtual>> BeginUndoOperation(operationName:string) : void
    + EndUndoOperation() : void
    + IsRemoved(cacheObject:CacheObject) : bool
    + CreateCache() : T
    + Destroy(cacheObject:CacheObject) : void
    + Destroy() : void
}
BaseObject <|-- Cache
ICacheUndo <|-- Cache
Cache --> "undoOverride" IUndo
class CacheObject {
    + {static} Create(owner:Cache) : T
    OnAfterDeserialize() : void
    OnBeforeSerialize() : void
    <<internal>> <<virtual>> OnCreate() : void
}
BaseObject <|-- CacheObject
ISerializationCallbackReceiver <|-- CacheObject
CacheObject --> "owner" Cache
class SwitchModeTool {
}
BaseTool <|-- SwitchModeTool
class Brush {
    +  <<event>> onMove : Action<Brush> 
    +  <<event>> onSize : Action<Brush> 
    +  <<event>> onRepaint : Action<Brush> 
    +  <<event>> onStrokeBegin : Action<Brush> 
    +  <<event>> onStrokeDelta : Action<Brush> 
    +  <<event>> onStrokeStep : Action<Brush> 
    +  <<event>> onStrokeEnd : Action<Brush> 
    + isHot : bool <<get>>
    + isActivable : bool <<get>>
    + controlID : int <<get>>
    + hardness : float <<get>> <<set>>
    + step : float <<get>> <<set>>
    + size : float <<get>> <<set>>
    + Brush(guiWrapper:IGUIWrapper)
    + OnGUI() : void
}
Brush --> "position" Vector3
class SliderData <<struct>> {
}
interface IGUIWrapper {
    mouseButton : int <<get>>
    clickCount : int <<get>>
    isShiftDown : bool <<get>>
    isAltDown : bool <<get>>
    isActionKeyDown : bool <<get>>
    commandName : string <<get>>
    IsMouseDown(button:int) : bool
    IsMouseUp(button:int) : bool
    IsKeyDown(keyCode:KeyCode) : bool
    GetControlID(hint:int, focusType:FocusType) : int
    LayoutControl(controlID:int, distance:float) : void
    IsControlNearest(controlID:int) : bool
    IsControlHot(controlID:int) : bool
    IsMultiStepControlHot(controlID:int) : bool
    SetControlHot(controlID:int) : void
    SetMultiStepControlHot(controlID:int) : void
    DoSlider(id:int, sliderData:SliderData, newPosition:Vector3) : bool
    UseCurrentEvent() : void
    DistanceToSegment(p1:Vector3, p2:Vector3) : float
    DistanceToSegmentClamp(p1:Vector3, p2:Vector3) : float
    DistanceToCircle(center:Vector3, radius:float) : float
    GUIToWorld(guiPosition:Vector2) : Vector3
    GUIToWorld(guiPosition:Vector2, planeNormal:Vector3, planePosition:Vector3) : Vector3
    Repaint() : void
    IsRepainting() : bool
    IsEventOutsideWindow() : bool
    SetGuiChanged(changed:bool) : void
    GetHandleSize(position:Vector3) : float
    IsViewToolActive() : bool
    HasCurrentCamera() : bool
}
class GUIWrapper {
    + mouseButton : int <<get>>
    + clickCount : int <<get>>
    + isShiftDown : bool <<get>>
    + isAltDown : bool <<get>>
    + isActionKeyDown : bool <<get>>
    + commandName : string <<get>>
    + IsMouseDown(button:int) : bool
    + IsMouseUp(button:int) : bool
    + IsKeyDown(keyCode:KeyCode) : bool
    + GetControlID(hint:int, focusType:FocusType) : int
    + LayoutControl(controlID:int, distance:float) : void
    + IsControlNearest(controlID:int) : bool
    + IsControlHot(controlID:int) : bool
    + IsMultiStepControlHot(controlID:int) : bool
    + SetControlHot(controlID:int) : void
    + SetMultiStepControlHot(controlID:int) : void
    + DoSlider(id:int, sliderData:SliderData, newPosition:Vector3) : bool
    + UseCurrentEvent() : void
    + DistanceToSegment(p1:Vector3, p2:Vector3) : float
    + DistanceToSegmentClamp(p1:Vector3, p2:Vector3) : float
    + DistanceToCircle(center:Vector3, radius:float) : float
    + GUIToWorld(guiPosition:Vector2) : Vector3
    + GUIToWorld(guiPosition:Vector2, planeNormal:Vector3, planePosition:Vector3) : Vector3
    + Repaint() : void
    + IsRepainting() : bool
    + SetGuiChanged(changed:bool) : void
    + IsEventOutsideWindow() : bool
    + GetHandleSize(position:Vector3) : float
    + IsViewToolActive() : bool
    + HasCurrentCamera() : bool
}
SliderData --> "position" Vector3
SliderData --> "forward" Vector3
SliderData --> "up" Vector3
SliderData --> "right" Vector3
SliderData o-> "zero" SliderData
IGUIWrapper --> "mousePosition" Vector2
IGUIWrapper --> "eventType" EventType
IGUIWrapper <|-- GUIWrapper
GUIWrapper --> "mousePosition" Vector2
GUIWrapper --> "eventType" EventType
enum SkeletonAction {
    None= 0,
    Select= 1 << 0,
    RotateBone= 1 << 2,
    MoveBone= 1 << 3,
    FreeMoveBone= 1 << 4,
    MoveEndPosition= 1 << 5,
    MoveJoint= 1 << 6,
    ChangeLength= 1 << 7,
    CreateBone= 1 << 8,
    SplitBone= 1 << 9,
    Remove= 1 << 10,
}
enum SkeletonMode {
    Disabled= SkeletonAction.None,
    Selection= SkeletonAction.Select,
    EditPose= Selection | SkeletonAction.RotateBone | SkeletonAction.MoveBone,
    EditJoints= Selection | SkeletonAction.FreeMoveBone | SkeletonAction.MoveEndPosition | SkeletonAction.MoveJoint | SkeletonAction.Remove,
    CreateBone= Selection | SkeletonAction.MoveJoint | SkeletonAction.Remove | SkeletonAction.CreateBone,
    SplitBone= Selection | SkeletonAction.MoveEndPosition | SkeletonAction.MoveJoint | SkeletonAction.Remove | SkeletonAction.SplitBone,
}
interface ISkeletonView {
    InvalidID : int <<get>> <<set>>
    defaultControlID : int <<get>> <<set>>
    hoveredBoneID : int <<get>>
    hoveredJointID : int <<get>>
    hoveredBodyID : int <<get>>
    hoveredTailID : int <<get>>
    hotBoneID : int <<get>>
    BeginLayout() : void
    EndLayout() : void
    CanLayout() : bool
    GetMouseWorldPosition(planeNormal:Vector3, planePosition:Vector3) : Vector3
    LayoutBone(id:int, position:Vector3, endPosition:Vector3, forward:Vector3, up:Vector3, right:Vector3, isChainEnd:bool) : void
    DoSelectBone(id:int, additive:bool) : bool
    DoRotateBone(pivot:Vector3, normal:Vector3, deltaAngle:float) : bool
    DoMoveBone(deltaPosition:Vector3) : bool
    DoFreeMoveBone(deltaPosition:Vector3) : bool
    DoMoveJoint(deltaPosition:Vector3) : bool
    DoMoveEndPosition(endPosition:Vector3) : bool
    DoChangeLength(endPosition:Vector3) : bool
    DoCreateBoneStart(position:Vector3) : bool
    DoCreateBone(position:Vector3) : bool
    DoSplitBone(id:int, position:Vector3) : bool
    DoRemoveBone() : bool
    DoCancelMultistepAction(force:bool) : bool
    IsActionActive(action:SkeletonAction) : bool
    IsActionHot(action:SkeletonAction) : bool
    IsActionTriggering(action:SkeletonAction) : bool
    IsActionFinishing(action:SkeletonAction) : bool
    IsRepainting() : bool
    DrawBone(position:Vector3, right:Vector3, forward:Vector3, length:float, color:Color, isChained:bool, isSelected:bool, isJointHovered:bool, isTailHovered:bool, isHot:bool) : void
    DrawBoneParentLink(parentPosition:Vector3, position:Vector3, forward:Vector3, color:Color) : void
    DrawBoneOutline(position:Vector3, right:Vector3, forward:Vector3, length:float, color:Color, outlineScale:float) : void
    DrawCursors(canBeActive:bool) : void
}
ISkeletonView --> "mode" SkeletonMode
enum SpriteMeshViewMode {
    EditGeometry,
    CreateVertex,
    CreateEdge,
    SplitEdge,
}
enum MeshEditorAction {
    None,
    CreateVertex,
    MoveVertex,
    CreateEdge,
    SplitEdge,
    MoveEdge,
    SelectVertex,
    SelectEdge,
    Remove,
}
interface ISpriteMeshView {
    defaultControlID : int <<get>> <<set>>
    hoveredVertex : int <<get>>
    hoveredEdge : int <<get>>
    closestEdge : int <<get>>
    CancelMode() : void
    BeginLayout() : void
    EndLayout() : void
    LayoutVertex(position:Vector2, index:int) : void
    LayoutEdge(startPosition:Vector2, endPosition:Vector2, index:int) : void
    DoCreateVertex() : bool
    DoSelectVertex(additive:bool) : bool
    DoMoveVertex(delta:Vector2) : bool
    DoMoveEdge(delta:Vector2) : bool
    DoCreateEdge() : bool
    DoSplitEdge() : bool
    DoSelectEdge(additive:bool) : bool
    DoRemove() : bool
    DrawVertex(position:Vector2) : void
    DrawVertexHovered(position:Vector2) : void
    DrawVertexSelected(position:Vector2) : void
    BeginDrawEdges() : void
    EndDrawEdges() : void
    DrawEdge(startPosition:Vector2, endPosition:Vector2) : void
    DrawEdgeHovered(startPosition:Vector2, endPosition:Vector2) : void
    DrawEdgeSelected(startPosition:Vector2, endPosition:Vector2) : void
    IsActionTriggered(action:MeshEditorAction) : bool
    IsActionActive(action:MeshEditorAction) : bool
    IsActionHot(action:MeshEditorAction) : bool
    WorldToScreen(position:Vector2) : Vector2
    DoRepaint() : void
    CanRepaint() : bool
    CanLayout() : bool
}
class "ISelection`1"<T> {
}
ISpriteMeshView --> "mode" SpriteMeshViewMode
ISpriteMeshView --> "selection<int>" "ISelection`1"
ISpriteMeshView --> "frame" Rect
ISpriteMeshView --> "mouseWorldPosition" Vector2
class "RectSelectionTool`1"<T> {
    + controlID : int <<get>>
    + OnGUI() : void
}
class "IRectSelector`1"<T> {
}
"RectSelectionTool`1" --> "rectSelector<T>" "IRectSelector`1"
"RectSelectionTool`1" --> "cacheUndo" ICacheUndo
"RectSelectionTool`1" o-> "onSelectionStart" Action
"RectSelectionTool`1" o-> "onSelectionUpdate" Action
"RectSelectionTool`1" o-> "onSelectionEnd" Action
class RectSlider {
    <<internal>> Do() : Rect
    <<internal>> Do(controlID:int) : Rect
}
class SkeletonController {
    + editBindPose : bool <<get>> <<set>>
    + Reset() : void
    + OnGUI() : void
    + {static} AutoBoneName(parent:BoneCache, bones:IEnumerable<BoneCache>) : string
}
SkeletonController --> "view" ISkeletonView
SkeletonController --> "styleOverride" ISkeletonStyle
SkeletonController --> "selection" IBoneSelection
SkeletonController --> "skeleton" SkeletonCache
SkeletonController --> "hoveredBone" BoneCache
SkeletonController --> "hoveredTail" BoneCache
SkeletonController --> "hoveredBody" BoneCache
SkeletonController --> "hoveredJoint" BoneCache
SkeletonController --> "hotBone" BoneCache
class SkeletonView {
    <<internal>> <<const>> kDeleteCommandName : string = "Delete"
    <<internal>> <<const>> kSoftDeleteCommandName : string = "SoftDelete"
    + InvalidID : int <<get>> <<set>>
    + defaultControlID : int <<get>> <<set>>
    + hoveredBoneID : int <<get>>
    + hoveredJointID : int <<get>>
    + hoveredBodyID : int <<get>>
    + hoveredTailID : int <<get>>
    + hotBoneID : int <<get>>
    + SkeletonView(gw:IGUIWrapper)
    + BeginLayout() : void
    + EndLayout() : void
    + CanLayout() : bool
    + LayoutBone(id:int, position:Vector3, endPosition:Vector3, forward:Vector3, up:Vector3, right:Vector3, isChainEnd:bool) : void
    + GetMouseWorldPosition(planeNormal:Vector3, planePosition:Vector3) : Vector3
    + DoSelectBone(id:int, additive:bool) : bool
    + DoRotateBone(pivot:Vector3, normal:Vector3, deltaAngle:float) : bool
    + DoMoveBone(deltaPosition:Vector3) : bool
    + DoFreeMoveBone(deltaPosition:Vector3) : bool
    + DoMoveJoint(deltaPosition:Vector3) : bool
    + DoMoveEndPosition(endPosition:Vector3) : bool
    + DoChangeLength(endPosition:Vector3) : bool
    + DoCreateBoneStart(position:Vector3) : bool
    + CanCreateBone() : bool
    + DoCreateBone(position:Vector3) : bool
    + DoSplitBone(id:int, position:Vector3) : bool
    + DoRemoveBone() : bool
    + DoCancelMultistepAction(force:bool) : bool
    + IsActionActive(action:SkeletonAction) : bool
    + IsActionHot(action:SkeletonAction) : bool
    + IsActionTriggering(action:SkeletonAction) : bool
    + IsActionFinishing(action:SkeletonAction) : bool
    + IsRepainting() : bool
    + DrawBone(position:Vector3, right:Vector3, forward:Vector3, length:float, color:Color, isChained:bool, isSelected:bool, isJointHovered:bool, isTailHovered:bool, isHot:bool) : void
    + DrawBoneParentLink(parentPosition:Vector3, position:Vector3, forward:Vector3, color:Color) : void
    + DrawBoneOutline(position:Vector3, right:Vector3, forward:Vector3, length:float, color:Color, outlineScale:float) : void
    + DrawCursors(canBeActive:bool) : void
}
ISkeletonView <|-- SkeletonView
SkeletonView --> "mode" SkeletonMode
class Slider2D {
    + {static} Do(controlID:int, position:Vector2, drawCapFunction:Handles.CapFunction) : Vector2
}
class SpriteMeshController {
    + disable : bool <<get>> <<set>>
    + OnGUI() : void
}
class EdgeIntersectionResult <<struct>> {
    + startVertexIndex : int
    + endVertexIndex : int
    + intersectEdgeIndex : int
}
class "ISelection`1"<T> {
}
SpriteMeshController --> "spriteMeshView" ISpriteMeshView
SpriteMeshController --> "spriteMeshData" ISpriteMeshData
SpriteMeshController --> "selection<int>" "ISelection`1"
SpriteMeshController --> "cacheUndo" ICacheUndo
SpriteMeshController --> "triangulator" ITriangulator
SpriteMeshController --> "frame" Rect
SpriteMeshController +-- EdgeIntersectionResult
EdgeIntersectionResult --> "endPosition" Vector2
class SpriteMeshView {
    <<readonly>> m_VertexHashCode : int
    <<readonly>> m_EdgeHashCode : int
    <<const>> kDeleteCommandName : string = "Delete"
    <<const>> kSoftDeleteCommandName : string = "SoftDelete"
    <<const>> kEdgeWidth : float = 2f
    <<const>> kVertexRadius : float = 2.5f
    m_HoveredEdge : int
    m_HoveredEdgeControlID : int
    m_MoveEdgeControlID : int
    m_HoveredVertex : int
    m_PrevHoveredVertex : int
    m_HoveredVertexControlID : int
    m_MoveVertexControlID : int
    + defaultControlID : int <<get>> <<set>>
    + hoveredVertex : int <<get>>
    + hoveredEdge : int <<get>>
    + closestEdge : int <<get>>
    + SpriteMeshView(gw:IGUIWrapper)
    + CancelMode() : void
    + BeginLayout() : void
    + EndLayout() : void
    + LayoutVertex(position:Vector2, index:int) : void
    + LayoutEdge(startPosition:Vector2, endPosition:Vector2, index:int) : void
    + DoCreateVertex() : bool
    + DoSelectVertex(additive:bool) : bool
    + DoMoveVertex(delta:Vector2) : bool
    + DoMoveEdge(delta:Vector2) : bool
    + DoCreateEdge() : bool
    + DoSplitEdge() : bool
    + DoSelectEdge(additive:bool) : bool
    + DoRemove() : bool
    + DrawVertex(position:Vector2) : void
    + DrawVertexHovered(position:Vector2) : void
    + DrawVertexSelected(position:Vector2) : void
    + BeginDrawEdges() : void
    + EndDrawEdges() : void
    + DrawEdge(startPosition:Vector2, endPosition:Vector2) : void
    + DrawEdgeHovered(startPosition:Vector2, endPosition:Vector2) : void
    + DrawEdgeSelected(startPosition:Vector2, endPosition:Vector2) : void
    + IsActionActive(action:MeshEditorAction) : bool
    + IsActionHot(action:MeshEditorAction) : bool
    + IsActionTriggered(action:MeshEditorAction) : bool
    + WorldToScreen(position:Vector2) : Vector2
    + DoRepaint() : void
    + CanRepaint() : bool
    + CanLayout() : bool
}
class Styles {
    + Styles()
}
class "ISelection`1"<T> {
}
ISpriteMeshView <|-- SpriteMeshView
SpriteMeshView o-> "kEdgeColor" Color
SpriteMeshView o-> "kEdgeHoveredColor" Color
SpriteMeshView o-> "kEdgeSelectedColor" Color
SpriteMeshView --> "m_TempColor" Color
SpriteMeshView o-> "m_HotSliderData" SliderData
SpriteMeshView o-> "m_PreviousActiveAction" MeshEditorAction
SpriteMeshView --> "mode" SpriteMeshViewMode
SpriteMeshView --> "selection<int>" "ISelection`1"
SpriteMeshView --> "frame" Rect
SpriteMeshView --> "mouseWorldPosition" Vector2
SpriteMeshView +-- Styles
Styles --> "pointNormalStyle" GUIStyle
Styles --> "pointHoveredStyle" GUIStyle
Styles --> "pointSelectedStyle" GUIStyle
class "UnselectTool`1"<T> {
    + OnGUI() : void
}
class "ISelection`1"<T> {
}
"UnselectTool`1" --> "cacheUndo" ICacheUndo
"UnselectTool`1" --> "selection<T>" "ISelection`1"
"UnselectTool`1" o-> "onUnselect" Action
class WeightInspector {
    + controlID : int <<get>>
    + OnInspectorGUI() : void
}
class "ISelection`1"<T> {
}
WeightInspector --> "spriteMeshData" ISpriteMeshData
WeightInspector --> "cacheUndo" ICacheUndo
WeightInspector --> "selection<int>" "ISelection`1"
interface IMeshPreviewBehaviour {
    GetWeightMapOpacity(sprite:SpriteCache) : float
    DrawWireframe(sprite:SpriteCache) : bool
    Overlay(sprite:SpriteCache) : bool
    OverlayWireframe(sprite:SpriteCache) : bool
}
class DefaultPreviewBehaviour {
    + GetWeightMapOpacity(sprite:SpriteCache) : float
    + DrawWireframe(sprite:SpriteCache) : bool
    + Overlay(sprite:SpriteCache) : bool
    + OverlayWireframe(sprite:SpriteCache) : bool
}
class MeshPreviewBehaviour {
    + showWeightMap : bool <<get>> <<set>>
    + drawWireframe : bool <<get>> <<set>>
    + overlaySelected : bool <<get>> <<set>>
    + GetWeightMapOpacity(sprite:SpriteCache) : float
    + DrawWireframe(sprite:SpriteCache) : bool
    + Overlay(sprite:SpriteCache) : bool
    + OverlayWireframe(sprite:SpriteCache) : bool
}
IMeshPreviewBehaviour <|-- DefaultPreviewBehaviour
IMeshPreviewBehaviour <|-- MeshPreviewBehaviour
class MeshPreviewTool {
    <<internal>> <<override>> OnCreate() : void
    <<internal>> <<override>> OnDestroy() : void
    + DrawOverlay() : void
    + OverlayWireframe() : void
}
BaseTool <|-- MeshPreviewTool
MeshPreviewTool --> "previewBehaviourOverride" IMeshPreviewBehaviour
MeshPreviewTool --> "previewBehaviour" IMeshPreviewBehaviour
class MeshTool <<partial>> {
    + disable : bool <<get>> <<set>>
    + <<override>> defaultControlID : int <<get>>
    <<internal>> <<override>> OnCreate() : void
    <<internal>> SetupSprite(sprite:SpriteCache) : void
    + BeginPositionOverride() : void
    + EndPositionOverride() : void
    + UpdateWeights() : void
    + UpdateMesh() : void
}
class "ISelection`1"<T> {
}
BaseTool <|-- MeshTool
MeshTool --> "mesh" MeshCache
MeshTool --> "mode" SpriteMeshViewMode
MeshTool --> "selectionOverride<int>" "ISelection`1"
class MeshToolWrapper {
    + disableMeshEditor : bool <<get>> <<set>>
    + <<override>> defaultControlID : int <<get>>
}
BaseTool <|-- MeshToolWrapper
MeshToolWrapper --> "meshTool" MeshTool
MeshToolWrapper --> "skeletonTool" SkeletonTool
MeshToolWrapper --> "meshMode" SpriteMeshViewMode
MeshToolWrapper --> "skeletonMode" SkeletonMode
MeshToolWrapper --> "previewBehaviour" IMeshPreviewBehaviour
interface IOutlineGenerator {
    GenerateOutline(textureDataProvider:ITextureDataProvider, rect:Rect, detail:float, alphaTolerance:byte, holeDetection:bool, paths:Vector2[][]) : void
}
class OutlineGenerator {
    <<const>> kClipperScale : double = 1000.0
    + GenerateOutline(textureDataProvider:ITextureDataProvider, rect:Rect, detail:float, alphaTolerance:byte, holeDetection:bool, paths:Vector2[][]) : void
}
class "List`1"<T> {
}
IOutlineGenerator <|-- OutlineGenerator
class BoneSelection {
}
class "SerializableSelection`1"<T> {
}
"SerializableSelection`1" "<BoneCache>" <|-- BoneSelection
IBoneSelection <|-- BoneSelection
BoneSelection --> "root" BoneCache
interface IBoneSelection {
}
class "ITransformSelection`1"<T> {
}
"ITransformSelection`1" "<BoneCache>" <|-- IBoneSelection
class IndexedSelection {
}
class "SerializableSelection`1"<T> {
}
"SerializableSelection`1" "<int>" <|-- IndexedSelection
interface "ISelection`1"<T> {
    Count : int <<get>>
    activeElement : T <<get>> <<set>>
    Clear() : void
    BeginSelection() : void
    EndSelection(select:bool) : void
    Select(element:T, select:bool) : void
    Contains(element:T) : bool
}
interface "ITransformSelection`1"<T> {
    root : T <<get>>
}
class "ISelection`1"<T> {
}
"ISelection`1" "<T>" <|-- "ITransformSelection`1"
abstract class "SerializableSelection`1"<T> {
    <<internal>> <<readonly>> {static} kInvalidID : int
    + Count : int <<get>>
    + activeElement : T <<get>> <<set>>
    + Clear() : void
    + BeginSelection() : void
    + EndSelection(select:bool) : void
    + Select(element:T, select:bool) : void
    + Contains(element:T) : bool
    OnBeforeSerialize() : void
    OnAfterDeserialize() : void
}
class "ISelection`1"<T> {
}
"ISelection`1" "<T>" <|-- "SerializableSelection`1"
ISerializationCallbackReceiver <|-- "SerializableSelection`1"
class SkeletonSelection {
    + Count : int <<get>>
    + BeginSelection() : void
    + Clear() : void
    + Contains(element:BoneCache) : bool
    + EndSelection(select:bool) : void
    + Select(element:BoneCache, select:bool) : void
}
IBoneSelection <|-- SkeletonSelection
SkeletonSelection --> "activeElement" BoneCache
SkeletonSelection --> "root" BoneCache
class CircleVertexSelector {
    + radius : float <<get>> <<set>>
    + Select() : void
}
class "ICircleSelector`1"<T> {
}
class "ISelection`1"<T> {
}
"ICircleSelector`1" "<int>" <|-- CircleVertexSelector
CircleVertexSelector --> "selection<int>" "ISelection`1"
CircleVertexSelector --> "spriteMeshData" ISpriteMeshData
CircleVertexSelector --> "position" Vector2
class GenericVertexSelector {
    + Select() : void
}
class "ISelector`1"<T> {
}
class "ISelection`1"<T> {
}
class "Func`2"<T1,T2> {
}
"ISelector`1" "<int>" <|-- GenericVertexSelector
GenericVertexSelector --> "selection<int>" "ISelection`1"
GenericVertexSelector --> "spriteMeshData" ISpriteMeshData
GenericVertexSelector --> "SelectionCallback<int,bool>" "Func`2"
interface "ICircleSelector`1"<T> {
    radius : float <<get>> <<set>>
}
class "ISelector`1"<T> {
}
"ISelector`1" "<T>" <|-- "ICircleSelector`1"
interface "IRectSelector`1"<T> {
}
class "ISelector`1"<T> {
}
"ISelector`1" "<T>" <|-- "IRectSelector`1"
"IRectSelector`1" --> "rect" Rect
interface "ISelector`1"<T> {
    Select() : void
}
class "ISelection`1"<T> {
}
"ISelector`1" --> "selection<T>" "ISelection`1"
class RectBoneSelector {
    + Select() : void
}
class "IRectSelector`1"<T> {
}
class "ISelection`1"<T> {
}
"IRectSelector`1" "<BoneCache>" <|-- RectBoneSelector
RectBoneSelector --> "selection<BoneCache>" "ISelection`1"
RectBoneSelector --> "rect" Rect
class RectVertexSelector {
    + Select() : void
}
class "IRectSelector`1"<T> {
}
class "ISelection`1"<T> {
}
"IRectSelector`1" "<int>" <|-- RectVertexSelector
RectVertexSelector --> "selection<int>" "ISelection`1"
RectVertexSelector --> "spriteMeshData" ISpriteMeshData
RectVertexSelector --> "rect" Rect
class "Unselector`1"<T> {
    + Select() : void
}
class "ISelector`1"<T> {
}
class "ISelection`1"<T> {
}
"ISelector`1" "<T>" <|-- "Unselector`1"
"Unselector`1" --> "selection<T>" "ISelection`1"
interface ISkeletonStyle {
    GetColor(bone:BoneCache) : Color
    GetPreviewColor(index:int) : Color
    GetParentLinkColor(bone:BoneCache) : Color
    GetParentLinkPreviewColor(index:int) : Color
    GetOutlineColor(bone:BoneCache, isSelected:bool, isHovered:bool) : Color
    GetPreviewOutlineColor(index:int) : Color
    GetOutlineScale(isSelected:bool) : float
}
abstract class SkeletonStyleBase {
    + GetColor(bone:BoneCache) : Color
    + GetPreviewColor(index:int) : Color
    + GetParentLinkColor(bone:BoneCache) : Color
    + GetParentLinkPreviewColor(index:int) : Color
    + GetOutlineColor(bone:BoneCache, isSelected:bool, isHovered:bool) : Color
    + GetPreviewOutlineColor(index:int) : Color
    + GetOutlineScale(isSelected:bool) : float
}
class BoneColorSkeletonStyle {
}
class WeightmapSkeletonStyle {
}
class SkeletonStyles <<static>> {
}
ISkeletonStyle <|-- SkeletonStyleBase
SkeletonStyleBase <|-- BoneColorSkeletonStyle
SkeletonStyleBase <|-- WeightmapSkeletonStyle
SkeletonStyles o-> "Default" ISkeletonStyle
SkeletonStyles o-> "WeightMap" ISkeletonStyle
class SkeletonTool {
    + enableBoneInspector : bool <<get>> <<set>>
    + editBindPose : bool <<get>> <<set>>
    + <<override>> defaultControlID : int <<get>>
    <<internal>> <<override>> OnCreate() : void
    + <<override>> Initialize(layout:LayoutOverlay) : void
    BoneDataChanged(bone:BoneCache) : void
}
BaseTool <|-- SkeletonTool
SkeletonTool --> "mode" SkeletonMode
SkeletonTool --> "skeletonStyle" ISkeletonStyle
SkeletonTool --> "hoveredBone" BoneCache
SkeletonTool --> "skeleton" SkeletonCache
class SkeletonToolView {
    +  <<event>> onBoneNameChanged : Action<BoneCache, string> 
    +  <<event>> onBoneDepthChanged : Action<BoneCache, int> 
    + SkeletonToolView()
    + Initialize(layout:LayoutOverlay) : void
    + Show(target:BoneCache) : void
    + Hide() : void
    + Update(name:string, depth:int) : void
}
SkeletonToolView --> "target" BoneCache
class SkeletonToolWrapper {
    + editBindPose : bool <<get>> <<set>>
    + <<override>> defaultControlID : int <<get>>
}
BaseTool <|-- SkeletonToolWrapper
SkeletonToolWrapper --> "skeletonTool" SkeletonTool
SkeletonToolWrapper --> "mode" SkeletonMode
class Pose <<struct>> {
    + {static} Create(p:Vector3, r:Quaternion) : Pose
    + <<override>> Equals(other:object) : bool
    + <<override>> GetHashCode() : int
}
class BonePose <<struct>> {
    + length : float
    + {static} Create(p:Pose, l:float) : BonePose
    + <<override>> Equals(other:object) : bool
    + <<override>> GetHashCode() : int
}
class BoneCache {
    + NotInDefaultPose() : bool
    + isVisible : bool <<get>> <<set>>
    + depth : float <<get>> <<set>>
    + localLength : float <<get>> <<set>>
    + length : float <<get>> <<set>>
    <<internal>> GetChildrenWoldPose() : Pose[]
    <<internal>> SetChildrenWorldPose(worldPose:Pose[]) : void
    <<internal>> <<override>> OnDestroy() : void
    <<new>> + SetParent(newParent:TransformCache) : void
    <<new>> + SetParent(newParent:TransformCache, worldPositionStays:bool) : void
    + OrientToChainedChild(freezeChildren:bool) : void
    + SetDefaultPose() : void
    + RestoreDefaultPose() : void
}
Pose --> "position" Vector3
Pose --> "rotation" Quaternion
Pose --> "matrix" Matrix4x4
BonePose --> "pose" Pose
TransformCache <|-- BoneCache
BoneCache --> "m_BindPoseColor" Color
BoneCache --> "bindPoseColor" Color
BoneCache --> "parentBone" BoneCache
BoneCache --> "skeleton" SkeletonCache
BoneCache --> "chainedChild" BoneCache
BoneCache --> "localEndPosition" Vector3
BoneCache --> "endPosition" Vector3
BoneCache --> "localPose" BonePose
BoneCache --> "worldPose" BonePose
BoneCache --> "bindPose" Pose
class BoneCacheExtensions <<static>> {
    + {static} ToCharacterIfNeeded(bones:BoneCache[]) : BoneCache[]
    + {static} ToSpriteSheetIfNeeded(bones:BoneCache[]) : BoneCache[]
    + {static} ToCharacterIfNeeded(bone:BoneCache) : BoneCache
    + {static} ToSpriteSheetIfNeeded(bone:BoneCache) : BoneCache
    + {static} ToSpriteBone(bone:BoneCache, rootTransform:Matrix4x4, parentId:int) : UnityEngine.U2D.SpriteBone
    + {static} ToSpriteBone(bones:BoneCache[], rootTransform:Matrix4x4) : UnityEngine.U2D.SpriteBone[]
}
class CharacterCache {
    + GetEnumerator() : IEnumerator<CharacterPartCache>
    GetEnumerator() : IEnumerator
}
class "IEnumerable`1"<T> {
}
SkinningObject <|-- CharacterCache
"IEnumerable`1" "<CharacterPartCache>" <|-- CharacterCache
CharacterCache --> "skeleton" SkeletonCache
CharacterCache --> "dimension" Vector2Int
class CharacterGroupCache {
    + parentGroup : int
    + isVisible : bool <<get>> <<set>>
    + <<virtual>> order : int <<get>> <<set>>
}
class CharacterPartCache {
    + <<virtual>> order : int <<get>> <<set>>
    + parentGroup : int <<get>> <<set>>
    + <<virtual>> isVisible : bool <<get>> <<set>>
    + BoneCount : int <<get>>
    + GetBone(index:int) : BoneCache
    + IndexOf(bone:BoneCache) : int
    + Contains(bone:BoneCache) : bool
}
SkinningObject <|-- CharacterGroupCache
ICharacterOrder <|-- CharacterGroupCache
TransformCache <|-- CharacterPartCache
ICharacterOrder <|-- CharacterPartCache
CharacterPartCache --> "sprite" SpriteCache
class CharacterPartCacheExtensions <<static>> {
    + {static} SyncSpriteSheetSkeleton(characterPart:CharacterPartCache) : void
    + {static} DeassociateUnusedBones(characterPart:CharacterPartCache) : void
}
class MeshCache {
    + vertexCount : int <<get>>
    + boneCount : int <<get>>
    + GetPosition(index:int) : Vector2
    + SetPosition(index:int, position:Vector2) : void
    + GetWeight(index:int) : EditableBoneWeight
    + SetWeight(index:int, weight:EditableBoneWeight) : void
    + AddVertex(position:Vector2, weight:BoneWeight) : void
    + RemoveVertex(index:int) : void
    GetBoneData(index:int) : SpriteBoneData
    GetBoneDepth(index:int) : float
    + Clear() : void
    + ContainsBone(bone:BoneCache) : bool
    + SetCompatibleBoneSet(bones:BoneCache[]) : void
}
class "List`1"<T> {
}
SkinningObject <|-- MeshCache
ISpriteMeshData <|-- MeshCache
MeshCache --> "textureDataProvider" ITextureDataProvider
MeshCache --> "sprite" SpriteCache
MeshCache --> "vertices<Vertex2D>" "List`1"
MeshCache --> "vertexPositionOverride<Vector3>" "List`1"
MeshCache --> "edges<Edge>" "List`1"
MeshCache --> "indices<int>" "List`1"
MeshCache --> "frame" Rect
class MeshPreviewCache {
    + enableSkinning : bool <<get>> <<set>>
    + canSkin : bool <<get>>
    <<internal>> <<override>> OnCreate() : void
    <<internal>> <<override>> OnDestroy() : void
    + SetMeshDirty() : void
    + SetVerticesDirty() : void
    + SetSkinningDirty() : void
    + SetWeightsDirty() : void
    + SetIndicesDirty() : void
    + SetColorsDirty() : void
    + Prepare() : void
}
class "List`1"<T> {
}
SkinningObject <|-- MeshPreviewCache
MeshPreviewCache --> "sprite" SpriteCache
MeshPreviewCache --> "mesh" Mesh
MeshPreviewCache --> "defaultMesh" Mesh
MeshPreviewCache --> "vertices<Vector3>" "List`1"
class SkeletonCache {
    + isPosePreview : bool <<get>>
    + BoneCount : int <<get>>
    + AddBone(bone:BoneCache) : void
    + AddBone(bone:BoneCache, worldPositionStays:bool) : void
    + ReorderBones(boneCache:IEnumerable<BoneCache>) : void
    + DestroyBone(bone:BoneCache) : void
    + SetDefaultPose() : void
    + RestoreDefaultPose() : void
    + SetPosePreview() : void
    + GetLocalPose() : BonePose[]
    + SetLocalPose(pose:BonePose[]) : void
    + GetWorldPose() : BonePose[]
    + SetWorldPose(pose:BonePose[]) : void
    + GetBone(index:int) : BoneCache
    + IndexOf(bone:BoneCache) : int
    + Contains(bone:BoneCache) : bool
    + Clear() : void
    + GetUniqueName(bone:BoneCache) : string
}
TransformCache <|-- SkeletonCache
class SkeletonCacheExtensions <<static>> {
    + {static} RotateBones(skeleton:SkeletonCache, bones:BoneCache[], deltaAngle:float) : void
    + {static} MoveBones(skeleton:SkeletonCache, bones:BoneCache[], deltaPosition:Vector3) : void
    + {static} FreeMoveBones(skeleton:SkeletonCache, bones:BoneCache[], deltaPosition:Vector3) : void
    + {static} MoveJoints(skeleton:SkeletonCache, bones:BoneCache[], deltaPosition:Vector3) : void
    + {static} SetEndPosition(skeleton:SkeletonCache, bone:BoneCache, endPosition:Vector3) : void
    + {static} SplitBone(skeleton:SkeletonCache, boneToSplit:BoneCache, splitLength:float, name:string) : BoneCache
    + {static} CreateBone(skeleton:SkeletonCache, parentBone:BoneCache, position:Vector3, endPosition:Vector3, isChained:bool, name:string) : BoneCache
    + {static} SetBones(skeleton:SkeletonCache, bones:BoneCache[]) : void
    + {static} SetBones(skeleton:SkeletonCache, bones:BoneCache[], worldPositionStays:bool) : void
    + {static} AddBones(skeleton:SkeletonCache, bones:BoneCache[]) : void
    + {static} AddBones(skeleton:SkeletonCache, bones:BoneCache[], worldPositionStays:bool) : void
    + {static} DestroyBones(skeleton:SkeletonCache, bones:BoneCache[]) : void
}
class SkinningObject {
}
class SkinningCache {
    + brushSize : float <<get>> <<set>>
    + brushHardness : float <<get>> <<set>>
    + brushStep : float <<get>> <<set>>
    + visibililtyToolIndex : int <<get>> <<set>>
    + GetSprites() : SpriteCache[]
    + hasCharacter : bool <<get>>
    + applyingChanges : bool <<get>> <<set>>
    + Create(spriteEditor:ISpriteEditor, state:ISkinningCachePersistentState) : void
    + CreateToolCache(spriteEditor:ISpriteEditor, layoutOverlay:LayoutOverlay) : void
    + RestoreFromPersistentState() : void
    + RestoreToolStateFromPersistentState() : void
    <<internal>> Revert() : void
    <<internal>> BoneVisibilityChanged(sc:SkeletonCache) : void
    <<internal>> BoneExpansionChanged(boneCaches:BoneCache[]) : void
    <<internal>> GetExpandedBones() : BoneCache[]
    <<internal>> SpriteVisibilityChanged(cc:CharacterPartCache) : void
    <<internal>> GroupVisibilityChanged(gc:CharacterGroupCache) : void
    + Clear() : void
    + GetSprite(id:string) : SpriteCache
    + <<virtual>> GetMesh(sprite:SpriteCache) : MeshCache
    + <<virtual>> GetMeshPreview(sprite:SpriteCache) : MeshPreviewCache
    + GetSkeleton(sprite:SpriteCache) : SkeletonCache
    + <<virtual>> GetCharacterPart(sprite:SpriteCache) : CharacterPartCache
    + GetEffectiveSkeleton(sprite:SpriteCache) : SkeletonCache
    + GetTool(tool:Tools) : BaseTool
    + <<override>> BeginUndoOperation(operationName:string) : void
    + UndoScope(operationName:string) : UndoScope
    + UndoScope(operationName:string, incrementGroup:bool) : UndoScope
    + DisableUndoScope() : DisableUndoScope
    + CreateTool() : T
    + CreateSpriteSheetSkeletons() : void
    + SyncSpriteSheetSkeletons() : void
    + CreateSpriteSheetSkeleton(characterPart:CharacterPartCache) : void
    + RestoreBindPose() : void
    + UndoRedoPerformed() : void
    + CreateBoneCacheFromSpriteBones(spriteBones:UnityEngine.U2D.SpriteBone[], scale:float) : BoneCache[]
    + IsOnVisualElement() : bool
    CreateSpriteLibrary(spriteEditor:ISpriteEditor) : void
}
class SpriteMap {
}
class MeshMap {
}
class SkeletonMap {
}
class ToolMap {
}
class MeshPreviewMap {
}
class CharacterPartMap {
}
class "SerializableDictionary`2"<T1,T2> {
}
CacheObject <|-- SkinningObject
SkinningObject --> "skinningCache" SkinningCache
Cache <|-- SkinningCache
SkinningCache --> "selectedTool" BaseTool
SkinningCache --> "mode" SkinningMode
SkinningCache --> "selectedSprite" SpriteCache
SkinningCache --> "skeletonSelection" SkeletonSelection
SkinningCache --> "vertexSelection" IndexedSelection
SkinningCache --> "events" SkinningEvents
SkinningCache --> "selectionTool" SelectionTool
SkinningCache --> "character" CharacterCache
SkinningCache --> "spriteCategoryList" SpriteCategoryListCacheObject
SkinningCache +-- SpriteMap
"SerializableDictionary`2" "<string,SpriteCache>" <|-- SpriteMap
SkinningCache +-- MeshMap
"SerializableDictionary`2" "<SpriteCache,MeshCache>" <|-- MeshMap
SkinningCache +-- SkeletonMap
"SerializableDictionary`2" "<SpriteCache,SkeletonCache>" <|-- SkeletonMap
SkinningCache +-- ToolMap
"SerializableDictionary`2" "<Tools,BaseTool>" <|-- ToolMap
SkinningCache +-- MeshPreviewMap
"SerializableDictionary`2" "<SpriteCache,MeshPreviewCache>" <|-- MeshPreviewMap
SkinningCache +-- CharacterPartMap
"SerializableDictionary`2" "<SpriteCache,CharacterPartCache>" <|-- CharacterPartMap
interface ISkinningCachePersistentState {
    lastVisibilityToolActive : bool <<get>> <<set>>
    lastVisibilityToolIndex : int <<get>> <<set>>
    lastBrushSize : float <<get>> <<set>>
    lastBrushHardness : float <<get>> <<set>>
    lastBrushStep : float <<get>> <<set>>
}
class SkinningCachePersistentState {
    + SkinningCachePersistentState()
    + SetDefault() : void
    + lastSpriteId : string <<get>> <<set>>
    + lastVisibilityToolActive : bool <<get>> <<set>>
    + lastVisibilityToolIndex : int <<get>> <<set>>
    + lastBrushSize : float <<get>> <<set>>
    + lastBrushHardness : float <<get>> <<set>>
    + lastBrushStep : float <<get>> <<set>>
}
class "List`1"<T> {
}
class "SerializableDictionary`2"<T1,T2> {
}
class "ScriptableSingleton`1"<T> {
}
ISkinningCachePersistentState --> "lastSpriteId" String
ISkinningCachePersistentState --> "lastUsedTool" Tools
ISkinningCachePersistentState --> "lastBoneSelectionIds<int>" "List`1"
ISkinningCachePersistentState --> "lastTexture" Texture2D
ISkinningCachePersistentState --> "lastPreviewPose<int,BonePose>" "SerializableDictionary`2"
ISkinningCachePersistentState --> "lastBoneVisibility<int,bool>" "SerializableDictionary`2"
ISkinningCachePersistentState --> "lastBoneExpansion<int,bool>" "SerializableDictionary`2"
ISkinningCachePersistentState --> "lastSpriteVisibility<string,bool>" "SerializableDictionary`2"
ISkinningCachePersistentState --> "lastGroupVisibility<int,bool>" "SerializableDictionary`2"
ISkinningCachePersistentState --> "lastMode" SkinningMode
ISkinningCachePersistentState --> "lastVertexSelection" IndexedSelection
"ScriptableSingleton`1" "<SkinningCachePersistentState>" <|-- SkinningCachePersistentState
ISkinningCachePersistentState <|-- SkinningCachePersistentState
SkinningCachePersistentState --> "lastUsedTool" Tools
SkinningCachePersistentState --> "lastBoneSelectionIds<int>" "List`1"
SkinningCachePersistentState --> "lastTexture" Texture2D
SkinningCachePersistentState --> "lastPreviewPose<int,BonePose>" "SerializableDictionary`2"
SkinningCachePersistentState --> "lastBoneVisibility<int,bool>" "SerializableDictionary`2"
SkinningCachePersistentState --> "lastBoneExpansion<int,bool>" "SerializableDictionary`2"
SkinningCachePersistentState --> "lastSpriteVisibility<string,bool>" "SerializableDictionary`2"
SkinningCachePersistentState --> "lastGroupVisibility<int,bool>" "SerializableDictionary`2"
SkinningCachePersistentState --> "lastMode" SkinningMode
SkinningCachePersistentState --> "lastVertexSelection" IndexedSelection
enum SkinningMode {
    SpriteSheet,
    Character,
}
enum Tools {
    EditGeometry,
    CreateVertex,
    CreateEdge,
    SplitEdge,
    GenerateGeometry,
    EditPose,
    EditJoints,
    CreateBone,
    SplitBone,
    ReparentBone,
    WeightSlider,
    WeightBrush,
    GenerateWeights,
    BoneInfluence,
    CopyPaste,
    Visibility,
    SwitchMode,
}
class SkinningEvents {
}
class SpriteEvent {
}
class SkeletonEvent {
}
class MeshEvent {
}
class MeshPreviewEvent {
}
class SkinningModuleModeEvent {
}
class BoneSelectionEvent {
}
class BoneEvent {
}
class CharacterPartEvent {
}
class ToolChangeEvent {
}
class RestoreBindPoseEvent {
}
class CopyEvent {
}
class PasteEvent {
}
class ShortcutEvent {
}
class BoneVisibilityEvent {
}
class SpriteLibraryEvent {
}
class MeshPreviewBehaviourChangeEvent {
}
class "UnityEvent`1"<T> {
}
class "UnityEvent`4"<T1,T2,T3,T4> {
}
SkinningEvents --> "selectedSpriteChanged" SpriteEvent
SkinningEvents --> "skeletonPreviewPoseChanged" SkeletonEvent
SkinningEvents --> "skeletonBindPoseChanged" SkeletonEvent
SkinningEvents --> "skeletonTopologyChanged" SkeletonEvent
SkinningEvents --> "meshChanged" MeshEvent
SkinningEvents --> "meshPreviewChanged" MeshPreviewEvent
SkinningEvents --> "skinningModeChanged" SkinningModuleModeEvent
SkinningEvents --> "boneSelectionChanged" BoneSelectionEvent
SkinningEvents --> "boneNameChanged" BoneEvent
SkinningEvents --> "boneDepthChanged" BoneEvent
SkinningEvents --> "characterPartChanged" CharacterPartEvent
SkinningEvents --> "toolChanged" ToolChangeEvent
SkinningEvents --> "restoreBindPose" RestoreBindPoseEvent
SkinningEvents --> "copy" CopyEvent
SkinningEvents --> "paste" PasteEvent
SkinningEvents --> "shortcut" ShortcutEvent
SkinningEvents --> "boneVisibility" BoneVisibilityEvent
SkinningEvents --> "spriteLibraryChanged" SpriteLibraryEvent
SkinningEvents --> "meshPreviewBehaviourChange" MeshPreviewBehaviourChangeEvent
SkinningEvents +-- SpriteEvent
"UnityEvent`1" "<SpriteCache>" <|-- SpriteEvent
SkinningEvents +-- SkeletonEvent
"UnityEvent`1" "<SkeletonCache>" <|-- SkeletonEvent
SkinningEvents +-- MeshEvent
"UnityEvent`1" "<MeshCache>" <|-- MeshEvent
SkinningEvents +-- MeshPreviewEvent
"UnityEvent`1" "<MeshPreviewCache>" <|-- MeshPreviewEvent
SkinningEvents +-- SkinningModuleModeEvent
"UnityEvent`1" "<SkinningMode>" <|-- SkinningModuleModeEvent
SkinningEvents +-- BoneSelectionEvent
UnityEvent <|-- BoneSelectionEvent
SkinningEvents +-- BoneEvent
"UnityEvent`1" "<BoneCache>" <|-- BoneEvent
SkinningEvents +-- CharacterPartEvent
"UnityEvent`1" "<CharacterPartCache>" <|-- CharacterPartEvent
SkinningEvents +-- ToolChangeEvent
"UnityEvent`1" "<ITool>" <|-- ToolChangeEvent
SkinningEvents +-- RestoreBindPoseEvent
UnityEvent <|-- RestoreBindPoseEvent
SkinningEvents +-- CopyEvent
UnityEvent <|-- CopyEvent
SkinningEvents +-- PasteEvent
"UnityEvent`4" "<bool,bool,bool,bool>" <|-- PasteEvent
SkinningEvents +-- ShortcutEvent
"UnityEvent`1" "<string>" <|-- ShortcutEvent
SkinningEvents +-- BoneVisibilityEvent
"UnityEvent`1" "<string>" <|-- BoneVisibilityEvent
SkinningEvents +-- SpriteLibraryEvent
UnityEvent <|-- SpriteLibraryEvent
SkinningEvents +-- MeshPreviewBehaviourChangeEvent
"UnityEvent`1" "<IMeshPreviewBehaviour>" <|-- MeshPreviewBehaviourChangeEvent
class SpriteCache {
    + id : string <<get>> <<internal set>>
}
TransformCache <|-- SpriteCache
SpriteCache --> "textureRect" Rect
SpriteCache --> "pivotNormalized" Vector2
SpriteCache --> "pivotRectSpace" Vector2
SpriteCache --> "pivotTextureSpace" Vector2
class SpriteCacheExtensions <<static>> {
    + {static} GetMesh(sprite:SpriteCache) : MeshCache
    + {static} GetMeshPreview(sprite:SpriteCache) : MeshPreviewCache
    + {static} GetSkeleton(sprite:SpriteCache) : SkeletonCache
    + {static} GetCharacterPart(sprite:SpriteCache) : CharacterPartCache
    + {static} IsVisible(sprite:SpriteCache) : bool
    + {static} GetLocalToWorldMatrixFromMode(sprite:SpriteCache) : Matrix4x4
    + {static} GetBonesFromMode(sprite:SpriteCache) : BoneCache[]
    + {static} UpdateMesh(sprite:SpriteCache, bones:BoneCache[]) : void
    + {static} SmoothFill(sprite:SpriteCache) : void
    + {static} RestoreBindPose(sprite:SpriteCache) : void
    + {static} AssociateAllBones(sprite:SpriteCache) : bool
    + {static} AssociatePossibleBones(sprite:SpriteCache) : bool
    {static} PointToLineSegmentDistance(p:Vector2, a:Vector2, b:Vector2) : float
    {static} IntersectsSegment(rect:Rect, p1:Vector2, p2:Vector2) : bool
    + {static} DeassociateUnusedBones(sprite:SpriteCache) : void
    + {static} DeassociateAllBones(sprite:SpriteCache) : void
}
class TransformCache {
    <<internal>> <<virtual>> siblingIndex : int <<get>> <<set>>
    + ChildCount : int <<get>>
    <<internal>> <<override>> OnDestroy() : void
    + SetParent(newParent:TransformCache) : void
    + SetParent(newParent:TransformCache, worldPositionStays:bool) : void
    GetEnumerator() : IEnumerator<TransformCache>
    GetEnumerator() : IEnumerator
}
class "IEnumerable`1"<T> {
}
SkinningObject <|-- TransformCache
"IEnumerable`1" "<TransformCache>" <|-- TransformCache
TransformCache --> "parent" TransformCache
TransformCache --> "localPosition" Vector3
TransformCache --> "localRotation" Quaternion
TransformCache --> "localScale" Vector3
TransformCache --> "position" Vector3
TransformCache --> "rotation" Quaternion
TransformCache --> "right" Vector3
TransformCache --> "up" Vector3
TransformCache --> "forward" Vector3
TransformCache --> "localToWorldMatrix" Matrix4x4
TransformCache --> "worldToLocalMatrix" Matrix4x4
class TransformCacheExtensions <<static>> {
    <<internal>> {static} IsDescendant(transform:T, ancestor:T) : bool
    <<internal>> {static} IsDescendant(transform:T, ancestors:T[]) : bool
    <<internal>> {static} FindRoots(transforms:T[]) : T[]
    <<internal>> {static} FindRoot(transform:T, transforms:T[]) : T
}
interface ISkinningSerializer {
    CanDeserialize(data:string) : bool
    Deserialize(data:string) : SkinningCopyData
    Serialize(skinningData:SkinningCopyData) : string
}
class SpriteBoneCopyData {
    + order : int
}
class SkinningCopySpriteData {
    + spriteName : string
}
class SkinningCopyData {
    + pixelsPerUnit : float
}
class "List`1"<T> {
}
SkinningCopySpriteData --> "spriteBones<SpriteBoneCopyData>" "List`1"
SkinningCopySpriteData --> "vertices<Vertex2D>" "List`1"
SkinningCopySpriteData --> "indices<int>" "List`1"
SkinningCopySpriteData --> "edges<Edge>" "List`1"
SkinningCopySpriteData --> "boneWeightNames<string>" "List`1"
SkinningCopyData o-> "copyData<SkinningCopySpriteData>" "List`1"
class SkinningSerializerJSON {
    + CanDeserialize(data:string) : bool
    + Deserialize(data:string) : SkinningCopyData
    + Serialize(skinningData:SkinningCopyData) : string
}
ISkinningSerializer <|-- SkinningSerializerJSON
class SkinningXMLSerializer {
    + CanDeserialize(data:string) : bool
    + Deserialize(data:string) : SkinningCopyData
    + Serialize(skinningData:SkinningCopyData) : string
}
ISkinningSerializer <|-- SkinningXMLSerializer
class SelectListView {
    + <<new>> AddToSelection(index:int) : void
    + <<new>> ClearSelection() : void
}
class SpriteBoneInfluenceListWidget {
    m_IgnoreSelectionChange : bool = false
    + SpriteBoneInfluenceListWidget()
    + Update() : void
    <<internal>> OnBoneSelectionChanged() : void
}
class CustomUxmlFactory {
}
class CustomUxmlFactory {
}
class CustomUxmlTraits {
}
class "Action`1"<T> {
}
class "Func`1"<T> {
}
class "UxmlFactory`2"<T1,T2> {
}
ListView <|-- SelectListView
VisualElement <|-- SpriteBoneInfluenceListWidget
SpriteBoneInfluenceListWidget o-> "onAddBone" Action
SpriteBoneInfluenceListWidget o-> "onRemoveBone" Action
SpriteBoneInfluenceListWidget o-> "onReordered<IEnumerable<BoneCache>>" "Action`1"
SpriteBoneInfluenceListWidget o-> "onSelectionChanged<IEnumerable<BoneCache>>" "Action`1"
SpriteBoneInfluenceListWidget o-> "GetController<SpriteBoneInflueceToolController>" "Func`1"
SelectListView +-- CustomUxmlFactory
"UxmlFactory`2" "<SelectListView,UxmlTraits>" <|-- CustomUxmlFactory
SpriteBoneInfluenceListWidget +-- CustomUxmlFactory
"UxmlFactory`2" "<SpriteBoneInfluenceListWidget,CustomUxmlTraits>" <|-- CustomUxmlFactory
SpriteBoneInfluenceListWidget +-- CustomUxmlTraits
UxmlTraits <|-- CustomUxmlTraits
class SpriteBoneInflueceToolController {
    + SpriteBoneInflueceToolController(model:ISpriteBoneInfluenceToolModel, events:SkinningEvents)
    + Activate() : void
    + Deactivate() : void
    + OnViewCreated() : void
    + GetSelectedSpriteBoneInfluence() : BoneCache[]
    + GetSelectedBoneForList(bones:IEnumerable<BoneCache>) : int[]
    + ShouldEnableAddButton(bones:IEnumerable<BoneCache>) : bool
    + InCharacterMode() : bool
}
interface ISpriteBoneInfluenceToolModel {
    hasCharacter : bool <<get>>
    UndoScope(description:string) : UndoScope
    GetSpriteCharacterPart(sprite:SpriteCache) : CharacterPartCache
}
class SpriteBoneInfluenceTool {
    <<internal>> <<override>> OnCreate() : void
    hasCharacter : bool <<get>>
    UndoScope(description:string) : UndoScope
    + <<override>> Initialize(layout:LayoutOverlay) : void
    + GetSpriteCharacterPart(sprite:SpriteCache) : CharacterPartCache
}
class "IEnumerable`1"<T> {
}
SpriteBoneInflueceToolController --> "m_Events" SkinningEvents
SpriteBoneInflueceToolController --> "m_Model" ISpriteBoneInfluenceToolModel
ISpriteBoneInfluenceToolModel --> "view" ISpriteBoneInfluenceWindow
ISpriteBoneInfluenceToolModel --> "selectedBones<BoneCache>" "IEnumerable`1"
ISpriteBoneInfluenceToolModel --> "selectedSprite" SpriteCache
ISpriteBoneInfluenceToolModel --> "skinningMode" SkinningMode
ISpriteBoneInfluenceToolModel --> "characterSkeleton" SkeletonCache
BaseTool <|-- SpriteBoneInfluenceTool
ISpriteBoneInfluenceToolModel <|-- SpriteBoneInfluenceTool
SpriteBoneInfluenceTool --> "m_Controller" SpriteBoneInflueceToolController
SpriteBoneInfluenceTool --> "skeletonTool" SkeletonTool
SpriteBoneInfluenceTool --> "previewBehaviour" IMeshPreviewBehaviour
SpriteBoneInfluenceTool --> "view" ISpriteBoneInfluenceWindow
SpriteBoneInfluenceTool --> "selectedBones<BoneCache>" "IEnumerable`1"
SpriteBoneInfluenceTool --> "selectedSprite" SpriteCache
SpriteBoneInfluenceTool --> "skinningMode" SkinningMode
SpriteBoneInfluenceTool --> "characterSkeleton" SkeletonCache
interface ISpriteBoneInfluenceWindow {
    headerText : string <<get>> <<set>>
    SetHiddenFromLayout(hide:bool) : void
    OnSpriteSelectionChanged() : void
    OnSkeletonChanged() : void
    OnMeshChanged() : void
    visible : bool <<get>>
    OnBoneSelectionChanged() : void
     <<event>> onAddBone : Action 
     <<event>> onRemoveBone : Action 
     <<event>> onReordered : Action<IEnumerable<BoneCache>> 
     <<event>> onSelectionChanged : Action<IEnumerable<BoneCache>> 
    SetController(controller:SpriteBoneInflueceToolController) : void
}
class SpriteBoneInfluenceWindow {
    +  <<event>> onAddBone : Action 
    +  <<event>> onRemoveBone : Action 
    +  <<event>> onReordered : Action<IEnumerable<BoneCache>> 
    +  <<event>> onSelectionChanged : Action<IEnumerable<BoneCache>> 
    + headerText : string <<get>> <<set>>
    {static} <<internal>> CreateFromUXML() : SpriteBoneInfluenceWindow
    <<internal>> BindElements() : void
    InternalGetController() : SpriteBoneInflueceToolController
    + OnSpriteSelectionChanged() : void
    + OnMeshChanged() : void
    + OnSkeletonChanged() : void
    + OnBoneSelectionChanged() : void
    SetController(controller:SpriteBoneInflueceToolController) : void
    SetHiddenFromLayout(hide:bool) : void
}
class CustomUxmlFactory {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- SpriteBoneInfluenceWindow
ISpriteBoneInfluenceWindow <|-- SpriteBoneInfluenceWindow
SpriteBoneInfluenceWindow --> "m_Controller" SpriteBoneInflueceToolController
SpriteBoneInfluenceWindow +-- CustomUxmlFactory
"UxmlFactory`2" "<SpriteBoneInfluenceWindow,UxmlTraits>" <|-- CustomUxmlFactory
class BoneWeightExtensions <<static>> {
    + {static} GetBoneIndex(boneWeight:BoneWeight, channelIndex:int) : int
    + {static} SetBoneIndex(boneWeight:BoneWeight, channelIndex:int, boneIndex:int) : void
    + {static} GetWeight(boneWeight:BoneWeight, channelIndex:int) : float
    + {static} SetWeight(boneWeight:BoneWeight, channelIndex:int, weight:float) : void
    + {static} Sum(boneWeight:BoneWeight) : float
    + {static} Normalized(boneWeight:BoneWeight) : BoneWeight
}
class Edge <<struct>> {
    m_Index1 : int
    m_Index2 : int
    + index1 : int <<get>> <<set>>
    + index2 : int <<get>> <<set>>
    + Edge(inIndex1:int, inIndex2:int)
    + Contains(index:int) : bool
    + <<override>> Equals(obj:System.Object) : bool
    + <<override>> GetHashCode() : int
}
class BoneWeightChannel {
    + enabled : bool <<get>> <<set>>
    + boneIndex : int <<get>> <<set>>
    + weight : float <<get>> <<set>>
    + BoneWeightChannel()
    + BoneWeightChannel(i:int, w:float, e:bool)
    + CompareTo(other:BoneWeightChannel) : int
}
class EditableBoneWeight {
    + Count : int <<get>>
    + Clear() : void
    + AddChannel(boneIndex:int, weight:float, enabled:bool) : void
    + RemoveChannel(channelIndex:int) : void
    + Sort() : void
    + GetEnumerator() : IEnumerator<BoneWeightChannel>
    GetEnumerator() : IEnumerator
}
class "IComparable`1"<T> {
}
class "IEnumerable`1"<T> {
}
"IComparable`1" "<BoneWeightChannel>" <|-- BoneWeightChannel
"IEnumerable`1" "<BoneWeightChannel>" <|-- EditableBoneWeight
class BoneWeightData <<struct>> {
    + boneIndex : int
    + weight : float
    + CompareTo(other:BoneWeightData) : int
}
class EditableBoneWeightUtility <<static>> {
    + {static} CreateFromBoneWeight(boneWeight:BoneWeight) : EditableBoneWeight
    + {static} SetFromBoneWeight(editableBoneWeight:EditableBoneWeight, boneWeight:BoneWeight) : void
    + {static} ToBoneWeight(editableBoneWeight:EditableBoneWeight, sortByWeight:bool) : BoneWeight
    + {static} ContainsBoneIndex(editableBoneWeight:EditableBoneWeight, boneIndex:int) : bool
    + {static} GetChannelFromBoneIndex(editableBoneWeight:EditableBoneWeight, boneIndex:int) : int
    + {static} Clamp(editableBoneWeight:EditableBoneWeight, numChannels:int, sortChannels:bool) : void
    + {static} ValidateChannels(editableBoneWeight:EditableBoneWeight) : void
    + {static} Sum(editableBoneWeight:EditableBoneWeight) : float
    + {static} Normalize(editableBoneWeight:EditableBoneWeight) : void
    + {static} CompensateOtherChannels(editableBoneWeight:EditableBoneWeight, masterChannel:int) : void
    + {static} UnifyChannelsWithSameBoneIndex(editableBoneWeight:EditableBoneWeight) : void
    + {static} FilterChannels(editableBoneWeight:EditableBoneWeight, weightTolerance:float) : void
    + {static} Lerp(first:BoneWeight, second:BoneWeight, t:float) : BoneWeight
}
class "IComparable`1"<T> {
}
"IComparable`1" "<BoneWeightData>" <|-- BoneWeightData
class SmoothingUtility {
    + {static} SmoothWeights(boneWeightIn:BoneWeight[], indices:IList<int>, boneCount:int, boneWeightOut:BoneWeight[]) : void
    + {static} SmoothWeights(boneWeightIn:BoneWeight[], indices:IList<int>, boneCount:int, iterations:int, boneWeightOut:BoneWeight[]) : void
    + {static} SmoothPerVertexData(indices:IList<int>, dataIn:float[,], dataOut:float[,]) : void
}
class SpriteBoneData {
    + name : string
    + parentId : int
    + depth : float
    + length : float
}
interface ISpriteMeshData {
    vertexCount : int <<get>>
    boneCount : int <<get>>
    GetPosition(index:int) : Vector2
    SetPosition(index:int, position:Vector2) : void
    GetWeight(index:int) : EditableBoneWeight
    SetWeight(index:int, weight:EditableBoneWeight) : void
    AddVertex(position:Vector2, weight:BoneWeight) : void
    RemoveVertex(index:int) : void
    GetBoneData(index:int) : SpriteBoneData
    GetBoneDepth(index:int) : float
    Clear() : void
}
class SpriteMeshData {
    + vertexCount : int <<get>>
    + boneCount : int <<get>>
    + GetPosition(index:int) : Vector2
    + SetPosition(index:int, position:Vector2) : void
    + GetWeight(index:int) : EditableBoneWeight
    + SetWeight(index:int, weight:EditableBoneWeight) : void
    + AddVertex(position:Vector2, weight:BoneWeight) : void
    + RemoveVertex(index:int) : void
    + GetBoneData(index:int) : SpriteBoneData
    + GetBoneDepth(index:int) : float
    + Clear() : void
}
class "List`1"<T> {
}
SpriteBoneData --> "localPosition" Vector2
SpriteBoneData o-> "localRotation" Quaternion
SpriteBoneData --> "position" Vector2
SpriteBoneData --> "endPosition" Vector2
ISpriteMeshData --> "frame" Rect
ISpriteMeshData --> "indices<int>" "List`1"
ISpriteMeshData --> "edges<Edge>" "List`1"
ISpriteMeshData <|-- SpriteMeshData
SpriteMeshData o-> "spriteID" GUID
SpriteMeshData o-> "pivot" Vector2
SpriteMeshData o-> "m_Bones<SpriteBoneData>" "List`1"
SpriteMeshData --> "frame" Rect
SpriteMeshData --> "vertices<Vertex2D>" "List`1"
SpriteMeshData --> "indices<int>" "List`1"
SpriteMeshData --> "edges<Edge>" "List`1"
SpriteMeshData --> "bones<SpriteBoneData>" "List`1"
class WeightedTriangle <<struct>> {
    + p1 : int
    + p2 : int
    + p3 : int
    + weight : float
    + CompareTo(other:WeightedTriangle) : int
}
class SpriteMeshDataController {
    + CreateVertex(position:Vector2) : void
    + CreateVertex(position:Vector2, edgeIndex:int) : void
    + CreateEdge(index1:int, index2:int) : void
    + RemoveVertex(index:int) : void
    + RemoveVertex(indices:IEnumerable<int>) : void
    + RemoveEdge(edge:Edge) : void
    + FindEdgesContainsIndex(index:int, result:List<Edge>) : bool
    + Triangulate(triangulator:ITriangulator) : void
    + Subdivide(triangulator:ITriangulator, largestAreaFactor:float) : void
    + ClearWeights(selection:ISelection<int>) : void
    + OutlineFromAlpha(outlineGenerator:IOutlineGenerator, textureDataProvider:ITextureDataProvider, outlineDetail:float, alphaTolerance:byte) : void
    + NormalizeWeights(selection:ISelection<int>) : void
    + CalculateWeights(weightsGenerator:IWeightsGenerator, selection:ISelection<int>, filterTolerance:float) : void
    + CalculateWeightsSafe(weightsGenerator:IWeightsGenerator, selection:ISelection<int>, filterTolerance:float) : void
    + SmoothWeights(iterations:int, selection:ISelection<int>) : void
    + FindTriangle(point:Vector2, indices:Vector3Int, barycentricCoords:Vector3) : bool
    + SortTrianglesByDepth() : void
    + GetMultiEditChannelData(selection:ISelection<int>, channel:int, enabled:bool, boneIndex:int, weight:float, isEnabledMixed:bool, isBoneIndexMixed:bool, isWeightMixed:bool) : void
    + SetMultiEditChannelData(selection:ISelection<int>, channel:int, oldEnabled:bool, newEnabled:bool, oldBoneIndex:int, newBoneIndex:int, oldWeight:float, newWeight:float) : void
    + GetControlPoints(points:Vector2[], edges:Edge[], pins:int[]) : void
    + SmoothFill() : void
}
class "IComparable`1"<T> {
}
"IComparable`1" "<WeightedTriangle>" <|-- WeightedTriangle
SpriteMeshDataController --> "spriteMeshData" ISpriteMeshData
class Vertex2D {
    + Vertex2D(position:Vector2)
    + Vertex2D(position:Vector2, weights:BoneWeight)
}
Vertex2D --> "position" Vector2
Vertex2D --> "editableBoneWeight" EditableBoneWeight
Vertex2D --> "m_Position" Vector2
Vertex2D --> "m_EditableBoneWeight" EditableBoneWeight
enum WeightEditorMode {
    AddAndSubtract,
    GrowAndShrink,
    Smooth,
}
class WeightEditor {
    + boneIndex : int <<get>> <<set>>
    + useRelativeValues : bool <<get>>
    + emptySelectionEditsAll : bool <<get>> <<set>>
    + autoNormalize : bool <<get>> <<set>>
    + WeightEditor()
    + OnEditStart(relative:bool) : void
    + OnEditEnd() : void
    + DoEdit(value:float) : void
}
class "ISelection`1"<T> {
}
WeightEditor --> "spriteMeshData" ISpriteMeshData
WeightEditor --> "cacheUndo" ICacheUndo
WeightEditor --> "mode" WeightEditorMode
WeightEditor --> "selection<int>" "ISelection`1"
WeightEditor --> "currentMode" WeightEditorMode
interface ITriangulator {
    Triangulate(vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
    Tessellate(minAngle:float, maxAngle:float, meshAreaFactor:float, largestTriangleAreaFactor:float, smoothIterations:int, vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
}
class TriangulationUtility {
    + {static} Triangulate(vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
    + {static} Tessellate(minAngle:float, maxAngle:float, meshAreaFactor:float, largestTriangleAreaFactor:float, smoothIterations:int, vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
}
class Triangulator {
    + Triangulate(vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
    + Tessellate(minAngle:float, maxAngle:float, meshAreaFactor:float, largestTriangleAreaFactor:float, smoothIterations:int, vertices:IList<Vector2>, edges:IList<Edge>, indices:IList<int>) : void
}
ITriangulator <|-- Triangulator
class BoneInspectorPanel {
    +  <<event>> onBoneDepthChanged : Action<BoneCache, int> 
    +  <<event>> onBoneNameChanged : Action<BoneCache, string> 
    + boneName : string <<get>> <<set>>
    + boneDepth : int <<get>> <<set>>
    + BoneInspectorPanel()
    + BindElements() : void
    + HidePanel() : void
    + {static} GenerateFromUXML() : BoneInspectorPanel
}
class BoneInspectorPanelFactory {
}
class BoneInspectorPanelUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- BoneInspectorPanel
BoneInspectorPanel --> "target" BoneCache
BoneInspectorPanel +-- BoneInspectorPanelFactory
"UxmlFactory`2" "<BoneInspectorPanel,BoneInspectorPanelUxmlTraits>" <|-- BoneInspectorPanelFactory
BoneInspectorPanel +-- BoneInspectorPanelUxmlTraits
UxmlTraits <|-- BoneInspectorPanelUxmlTraits
class BoneToolbar {
    +  <<event>> SetSkeletonTool : Action<Tools> 
    + BoneToolbar()
    + BindElements() : void
    + Setup(s:SkinningCache) : void
    + UpdateToggleState() : void
    + {static} GenerateFromUXML() : BoneToolbar
}
class BoneToolbarFactory {
}
class BoneToolbarUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
Toolbar <|-- BoneToolbar
BoneToolbar --> "skinningCache" SkinningCache
BoneToolbar +-- BoneToolbarFactory
"UxmlFactory`2" "<BoneToolbar,BoneToolbarUxmlTraits>" <|-- BoneToolbarFactory
BoneToolbar +-- BoneToolbarUxmlTraits
UxmlTraits <|-- BoneToolbarUxmlTraits
class CopyToolbar {
    +  <<event>> onDoCopy : Action 
    +  <<event>> onDoPaste : Action 
    + CopyToolbar()
    + DoCopy() : void
    + DoPaste() : void
    + BindElements() : void
    + {static} GenerateFromUXML() : CopyToolbar
}
class CopyToolbarFactory {
}
class CopyToolbarUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
Toolbar <|-- CopyToolbar
CopyToolbar +-- CopyToolbarFactory
"UxmlFactory`2" "<CopyToolbar,CopyToolbarUxmlTraits>" <|-- CopyToolbarFactory
CopyToolbar +-- CopyToolbarUxmlTraits
UxmlTraits <|-- CopyToolbarUxmlTraits
class GenerateGeometryPanel {
    +  <<event>> onAutoGenerateGeometry : Action<float, byte, float> 
    +  <<event>> onAutoGenerateGeometryAll : Action<float, byte, float> 
    + generateWeights : bool <<get>> <<set>>
    + GenerateGeometryPanel()
    + SetMode(mode:GenerateMode) : void
    + GenerateGeometry() : void
    + GenerateGeometryAll() : void
    + {static} GenerateFromUXML() : GenerateGeometryPanel
}
class GenerateGeometryPanelFactory {
}
class GenerateGeometryPanelUxmlTraits {
}
enum GenerateMode {
    Single,
    Multiple,
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- GenerateGeometryPanel
GenerateGeometryPanel --> "skinningCache" SkinningCache
GenerateGeometryPanel +-- GenerateGeometryPanelFactory
"UxmlFactory`2" "<GenerateGeometryPanel,GenerateGeometryPanelUxmlTraits>" <|-- GenerateGeometryPanelFactory
GenerateGeometryPanel +-- GenerateGeometryPanelUxmlTraits
UxmlTraits <|-- GenerateGeometryPanelUxmlTraits
GenerateGeometryPanel +-- GenerateMode
class GenerateWeightsPanel {
    +  <<event>> onGenerateWeights : Action 
    +  <<event>> onNormalizeWeights : Action 
    +  <<event>> onClearWeights : Action 
    + associateBones : bool <<get>> <<set>>
    + GenerateWeightsPanel()
    + BindElements() : void
    + generateButtonText : string <<set>>
    + Update(enableAssociateBones:bool) : void
    + OnGenerateWeights() : void
    + OnNormalizeWeights() : void
    + OnClearWeights() : void
    + {static} GenerateFromUXML() : GenerateWeightsPanel
}
class GenerateWeightsPanelFactory {
}
class GenerateWeightsPanelUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- GenerateWeightsPanel
GenerateWeightsPanel --> "m_GenerateWeightsButton" Button
GenerateWeightsPanel +-- GenerateWeightsPanelFactory
"UxmlFactory`2" "<GenerateWeightsPanel,GenerateWeightsPanelUxmlTraits>" <|-- GenerateWeightsPanelFactory
GenerateWeightsPanel +-- GenerateWeightsPanelUxmlTraits
UxmlTraits <|-- GenerateWeightsPanelUxmlTraits
class MeshToolbar {
    +  <<event>> SetMeshTool : Action<Tools> 
    + MeshToolbar()
    + BindElements() : void
    + UpdateToggleState() : void
    + {static} GenerateFromUXML() : MeshToolbar
}
class MeshToolbarFactory {
}
class MeshToolbarUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
Toolbar <|-- MeshToolbar
MeshToolbar --> "skinningCache" SkinningCache
MeshToolbar +-- MeshToolbarFactory
"UxmlFactory`2" "<MeshToolbar,MeshToolbarUxmlTraits>" <|-- MeshToolbarFactory
MeshToolbar +-- MeshToolbarUxmlTraits
UxmlTraits <|-- MeshToolbarUxmlTraits
class PastePanel {
    +  <<event>> onPasteActivated : Action<bool, bool, bool, bool> 
    + bones : bool <<get>> <<set>>
    + mesh : bool <<get>> <<set>>
    + flipX : bool <<get>> <<set>>
    + flipY : bool <<get>> <<set>>
    + PastePanel()
    + BindElements() : void
    + OnPasteActivated() : void
    + {static} GenerateFromUXML() : PastePanel
}
class PastePanelFactory {
}
class PastePanelUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- PastePanel
PastePanel +-- PastePanelFactory
"UxmlFactory`2" "<PastePanel,PastePanelUxmlTraits>" <|-- PastePanelFactory
PastePanel +-- PastePanelUxmlTraits
UxmlTraits <|-- PastePanelUxmlTraits
class Toolbar {
    + Toolbar()
    + SetButtonChecked(toCheck:Button) : void
    + CollapseToolBar(collapse:bool) : void
}
class ToolbarFactory {
}
class ToolbarUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- Toolbar
Toolbar +-- ToolbarFactory
"UxmlFactory`2" "<Toolbar,ToolbarUxmlTraits>" <|-- ToolbarFactory
Toolbar +-- ToolbarUxmlTraits
UxmlTraits <|-- ToolbarUxmlTraits
class VisualElementExtensions <<static>> {
    + {static} SetHiddenFromLayout(element:VisualElement, isHidden:bool) : void
}
class WeightInspectorIMGUIPanel {
    +  <<event>> weightsChanged : Action 
    + WeightInspectorIMGUIPanel()
}
class CustomUXMLFactor {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- WeightInspectorIMGUIPanel
WeightInspectorIMGUIPanel --> "weightInspector" WeightInspector
WeightInspectorIMGUIPanel +-- CustomUXMLFactor
"UxmlFactory`2" "<WeightInspectorIMGUIPanel,UxmlTraits>" <|-- CustomUXMLFactor
class WeightPainterPanel {
    + {static} <<readonly>> kNone : string = "None"
    +  <<event>> bonePopupChanged : Action<int> 
    +  <<event>> sliderStarted : Action 
    +  <<event>> sliderChanged : Action<float> 
    +  <<event>> sliderEnded : Action 
    +  <<event>> weightsChanged : Action 
    + title : string <<set>>
    + boneIndex : int <<get>>
    + size : int <<get>> <<set>>
    + hardness : int <<get>> <<set>>
    + step : int <<get>> <<set>>
    + normalize : bool <<get>> <<set>>
    + amount : float <<get>> <<set>>
    + WeightPainterPanel()
    + BindElements() : void
    + SetActive(active:bool) : void
    + UpdateWeightInspector(spriteMeshData:ISpriteMeshData, boneNames:string[], selection:ISelection<int>, cacheUndo:ICacheUndo) : void
    + UpdatePanel(boneNames:string[]) : void
    <<internal>> SetBoneSelectionByName(boneName:string) : void
    + {static} GenerateFromUXML() : WeightPainterPanel
}
class WeightPainterPanelFactory {
}
class WeightPainterPanelUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- WeightPainterPanel
WeightPainterPanel --> "paintMode" WeightPainterMode
WeightPainterPanel --> "mode" WeightEditorMode
WeightPainterPanel +-- WeightPainterPanelFactory
"UxmlFactory`2" "<WeightPainterPanel,WeightPainterPanelUxmlTraits>" <|-- WeightPainterPanelFactory
WeightPainterPanel +-- WeightPainterPanelUxmlTraits
UxmlTraits <|-- WeightPainterPanelUxmlTraits
class WeightToolbar {
    +  <<event>> SetWeightTool : Action<Tools> 
    + WeightToolbar()
    + EnableBoneInfluenceWidget() : void
    + DisableBoneInfluenceWidget() : void
    + BindElements() : void
    + {static} GenerateFromUXML() : WeightToolbar
    + UpdateToggleState() : void
}
class CustomUXMLFactor {
}
class "UxmlFactory`2"<T1,T2> {
}
Toolbar <|-- WeightToolbar
WeightToolbar --> "skinningCache" SkinningCache
WeightToolbar +-- CustomUXMLFactor
"UxmlFactory`2" "<WeightToolbar,UxmlTraits>" <|-- CustomUXMLFactor
class DisabledUndo {
    + RecordObject(o:object, name:string) : void
    + RegisterCompleteObjectUndo(o:object, name:string) : void
    + RegisterCompleteObjectUndo(o:object[], name:string) : void
    + RegisterCreatedObjectUndo(o:object, name:string) : void
    + DestroyObjectImmediate(o:object) : void
    + ClearUndo(o:object) : void
    + IncrementCurrentGroup() : void
}
IUndo <|-- DisabledUndo
class DisableUndoScope {
    + DisableUndoScope(cacheUndo:ICacheUndo)
    + Dispose() : void
}
IDisposable <|-- DisableUndoScope
interface ICacheUndo {
    isUndoOperationSet : bool <<get>>
    IncrementCurrentGroup() : void
    BeginUndoOperation(name:string) : void
    EndUndoOperation() : void
}
ICacheUndo --> "undoOverride" IUndo
interface IUndo {
    RecordObject(o:object, name:string) : void
    RegisterCompleteObjectUndo(o:object, name:string) : void
    RegisterCompleteObjectUndo(o:object[], name:string) : void
    RegisterCreatedObjectUndo(o:object, name:string) : void
    DestroyObjectImmediate(o:object) : void
    ClearUndo(o:object) : void
    IncrementCurrentGroup() : void
}
class UndoScope {
    + UndoScope(cacheUndo:ICacheUndo, operationName:string, incrementGroup:bool)
    + Dispose() : void
}
IDisposable <|-- UndoScope
class UnityEngineUndo {
    + RecordObject(o:object, name:string) : void
    + RegisterCompleteObjectUndo(o:object, name:string) : void
    + RegisterCompleteObjectUndo(o:object[], name:string) : void
    + RegisterCreatedObjectUndo(o:object, name:string) : void
    + DestroyObjectImmediate(o:object) : void
    + ClearUndo(o:object) : void
    + IncrementCurrentGroup() : void
}
IUndo <|-- UnityEngineUndo
class BoneReparentToolController {
    + BoneReparentToolController(model:IBoneTreeViewModel, eventSystem:SkinningEvents)
    + <<override>> CanDrag() : bool
    + <<override>> CanRename() : bool
}
class BoneReparentToolModel {
    + BoneReparentToolModel(cache:SkinningCache, view:IBoneVisibilityToolView)
}
class BoneReparentTool {
    + <<override>> Initialize(layout:LayoutOverlay) : void
}
class BoneReparentToolWindow {
    {static} <<internal>> CreateFromUXML() : BoneReparentToolWindow
    <<internal>> BindElements() : void
    InternalGetModel() : IBoneTreeViewModel
    InternalGetController() : BoneTreeWidgetController
    + OnBoneSelectionChange(skeleton:SkeletonSelection) : void
    + OnBoneExpandedChange(bones:BoneCache[]) : void
    + OnBoneNameChanged(bone:BoneCache) : void
    + OnSelectionChange(skeleton:SkeletonCache) : void
    + Deactivate() : void
}
class BoneReparentToolView {
}
class CustomUxmlFactory {
}
class "Func`1"<T> {
}
class CustomUxmlFactory {
}
class CustomUxmlTraits {
}
class "UxmlFactory`2"<T1,T2> {
}
BoneTreeWidgetController <|-- BoneReparentToolController
BoneTreeWidgetModel <|-- BoneReparentToolModel
SkeletonToolWrapper <|-- BoneReparentTool
BoneReparentTool --> "m_View" BoneReparentToolWindow
BoneReparentTool --> "m_Model" BoneReparentToolModel
VisualElement <|-- BoneReparentToolWindow
IBoneVisibilityToolView <|-- BoneReparentToolWindow
BoneReparentToolWindow --> "m_ToolView" BoneReparentToolView
BoneReparentToolWindow o-> "GetModel<IBoneTreeViewModel>" "Func`1"
BoneReparentToolWindow o-> "GetController<BoneTreeWidgetController>" "Func`1"
BoneReparentToolWindow --> "toolView" BoneReparentToolView
BoneVisibilityToolView <|-- BoneReparentToolView
BoneReparentToolWindow +-- CustomUxmlFactory
"UxmlFactory`2" "<BoneReparentToolWindow,UxmlTraits>" <|-- CustomUxmlFactory
BoneReparentToolView +-- CustomUxmlFactory
"UxmlFactory`2" "<BoneReparentToolView,CustomUxmlTraits>" <|-- CustomUxmlFactory
BoneReparentToolView +-- CustomUxmlTraits
UxmlTraits <|-- CustomUxmlTraits
class BoneTreeWidgetController {
    + BoneTreeWidgetController(model:IBoneTreeViewModel, eventSystem:SkinningEvents)
    + Activate() : void
    + Deactivate() : void
    + SetAllVisibility(visibility:bool) : void
    + BuildTreeView() : List<TreeViewItem>
    + GetIDsToExpand(bones:BoneCache[]) : List<int>
    + GetIDsToSelect(bones:BoneCache[]) : int[]
    + SelectBones(selectedIds:IList<int>, items:IList<TreeViewItem>) : void
    + ExpandBones(expandedIds:IList<int>, items:IList<TreeViewItem>) : void
    + GetTreeItemVisibility(item:TreeViewItemBase<BoneCache>) : bool
    + SetTreeItemVisibility(item:TreeViewItemBase<BoneCache>, visible:bool, includeChildren:bool) : void
    SetChildrenVisibility(bone:TreeViewItemBase<BoneCache>, visible:bool) : void
    + GetTreeItemDepthValue(bone:TreeViewItemBase<BoneCache>) : int
    + SetTreeItemDepthValue(bone:TreeViewItemBase<BoneCache>, value:int) : void
    + SetTreeViewBoneName(items:IList<TreeViewItem>, bone:BoneCache) : void
    + TreeViewItemRename(rows:IList<TreeViewItem>, itemID:int, newName:string) : void
    + CanReparent(parent:TreeViewItemBase<BoneCache>, draggedItems:List<TreeViewItem>) : bool
    + ReparentItems(newParent:TreeViewItemBase<BoneCache>, draggedItems:List<TreeViewItem>, insertAtIndex:int) : void
    + <<virtual>> CanDrag() : bool
    + <<virtual>> CanRename() : bool
}
class BoneVisibilityToolData {
    m_AllVisibility : bool = true
    m_PreviousVisibility : bool = true
    + allVisibility : bool <<get>> <<set>>
    + previousVisiblity : bool <<get>> <<set>>
}
class BoneTreeWidgetModel {
    + <<virtual>> GetAllVisibility() : bool
    + GetBoneSelection() : SkeletonSelection
    + GetExpandedBones() : BoneCache[]
    + GetDepth(bone:BoneCache) : int
    + GetSelectedSkeleton() : SkeletonCache
    + GetVisibility(bone:BoneCache) : bool
    + SelectBones(bones:BoneCache[]) : void
    + SetExpandedBones(bones:BoneCache[]) : void
    + <<virtual>> SetAllVisibility(skeleton:SkeletonCache, visibility:bool) : void
    + {static} SetAllBoneVisibility(skeleton:SkeletonCache, visibility:bool) : void
    + SetBoneParent(newParent:BoneCache, bone:BoneCache, insertAtIndex:int) : void
    + SetDepth(bone:BoneCache, depth:int) : void
    + SetName(bone:BoneCache, name:string) : void
    + SetVisibility(bone:BoneCache, visibility:bool) : void
    + UndoScope(value:string) : UndoScope
    + hasCharacter : bool <<get>>
}
interface IBoneTreeViewModel {
    SetVisibility(bone:BoneCache, visibility:bool) : void
    GetVisibility(bone:BoneCache) : bool
    SetName(bone:BoneCache, name:string) : void
    SetBoneParent(newParent:BoneCache, bone:BoneCache, insertAtIndex:int) : void
    GetDepth(bone:BoneCache) : int
    SetDepth(bone:BoneCache, depth:int) : void
    SetAllVisibility(skeleton:SkeletonCache, visibility:bool) : void
    GetAllVisibility() : bool
    SelectBones(bones:BoneCache[]) : void
    SetExpandedBones(bones:BoneCache[]) : void
    GetBoneSelection() : SkeletonSelection
    GetExpandedBones() : BoneCache[]
    GetSelectedSkeleton() : SkeletonCache
    hasCharacter : bool <<get>>
    UndoScope(value:string) : UndoScope
}
CacheObject <|-- BoneVisibilityToolData
IBoneTreeViewModel <|-- BoneTreeWidgetModel
BoneTreeWidgetModel --> "skinningCache" SkinningCache
BoneTreeWidgetModel --> "view" IBoneVisibilityToolView
BoneTreeWidgetModel --> "mode" SkinningMode
IBoneTreeViewModel --> "view" IBoneVisibilityToolView
IBoneTreeViewModel --> "mode" SkinningMode
class BoneVisibilityTool {
    + name : string <<get>>
    + isAvailable : bool <<get>>
    + BoneVisibilityTool(s:SkinningCache)
    + Setup() : void
    + Dispose() : void
    + Activate() : void
    + Deactivate() : void
    + SetAvailabilityChangeCallback(callback:Action) : void
}
class BoneVisibilityToolView {
    + BoneVisibilityToolView()
    InternalGetController() : BoneTreeWidgetController
    + OnSelectionChange(skeleton:SkeletonCache) : void
    + OnBoneSelectionChange(bones:SkeletonSelection) : void
    + OnBoneExpandedChange(bones:BoneCache[]) : void
    + OnBoneNameChanged(bone:BoneCache) : void
    + Deactivate() : void
}
class BoneTreeView {
    + BoneTreeView(treeViewState:TreeViewState, columnHeader:MultiColumnHeader)
    + SetupHierarchy() : void
    + OnBoneSelectionChanged(boneSelection:SkeletonSelection) : void
    + OnBoneExpandedChanged(bones:BoneCache[]) : void
    + OnBoneNameChanged(bone:BoneCache) : void
    CellGUI(cellRect:Rect, item:TreeViewItem, column:int, args:RowGUIArgs) : void
    DrawDepthCell(cellRect:Rect, item:TreeViewItem) : void
    DrawVisibilityCell(cellRect:Rect, item:TreeViewItem) : void
    DrawNameCell(cellRect:Rect, item:TreeViewItem, args:RowGUIArgs) : void
    <<const>> k_GenericDragID : string = "GenericDragColumnDragging"
}
class "Func`1"<T> {
}
BoneTreeWidgetModel <|-- BoneVisibilityTool
IVisibilityTool <|-- BoneVisibilityTool
BoneVisibilityTool --> "view" VisualElement
VisibilityToolViewBase <|-- BoneVisibilityToolView
IBoneVisibilityToolView <|-- BoneVisibilityToolView
BoneVisibilityToolView o-> "GetController<BoneTreeWidgetController>" "Func`1"
BoneVisibilityToolView o-> "GetModel<IBoneTreeViewModel>" "Func`1"
VisibilityTreeViewBase <|-- BoneTreeView
BoneTreeView o-> "GetController<BoneTreeWidgetController>" "Func`1"
interface IBoneVisibilityToolView {
    OnBoneSelectionChange(skeleton:SkeletonSelection) : void
    OnBoneExpandedChange(bones:BoneCache[]) : void
    OnBoneNameChanged(bone:BoneCache) : void
    OnSelectionChange(skeleton:SkeletonCache) : void
    Deactivate() : void
}
class MeshVisibilityTool {
    + MeshVisibilityTool(s:SkinningCache)
    + Setup() : void
    + Dispose() : void
    + name : string <<get>>
    + Activate() : void
    + Deactivate() : void
    + isAvailable : bool <<get>>
    + SetAvailabilityChangeCallback(callback:Action) : void
    SetAllVisibility(visibility:bool) : void
    SetAllMeshVisibility() : void
    GetAllVisibility() : bool
}
class MeshVisibilityToolModel {
    m_AllVisibility : bool = true
    m_PreviousVisibility : bool = true
    + allVisibility : bool <<get>> <<set>>
    + SetMeshVisibility(sprite:SpriteCache, visibility:bool) : void
    + GetMeshVisibility(sprite:SpriteCache) : bool
    + ShouldDisable(sprite:SpriteCache) : bool
    + previousVisiblity : bool <<get>> <<set>>
}
class MeshVisibilityToolView {
    + MeshVisibilityToolView(s:SkinningCache)
    InternalGetModel() : MeshVisibilityToolModel
    + Setup(sprites:SpriteCache[]) : void
    InternalGetAllVisibility() : bool
    InternalSetAllVisibility(visibility:bool) : void
}
class MeshTreeView {
    + MeshTreeView(treeViewState:TreeViewState, header:MultiColumnHeader)
    + Setup(sprites:SpriteCache[]) : void
    + SetSelection(sprite:SpriteCache) : void
}
class "Func`1"<T> {
}
class "Action`1"<T> {
}
IVisibilityTool <|-- MeshVisibilityTool
MeshVisibilityTool --> "skinningCache" SkinningCache
MeshVisibilityTool --> "view" VisualElement
SkinningObject <|-- MeshVisibilityToolModel
VisibilityToolViewBase <|-- MeshVisibilityToolView
MeshVisibilityToolView o-> "GetModel<MeshVisibilityToolModel>" "Func`1"
MeshVisibilityToolView o-> "SetAllVisibility<bool>" "Action`1"
MeshVisibilityToolView o-> "GetAllVisibility<bool>" "Func`1"
MeshVisibilityToolView --> "skinningCache" SkinningCache
VisibilityTreeViewBase <|-- MeshTreeView
MeshTreeView o-> "GetModel<MeshVisibilityToolModel>" "Func`1"
interface ISpriteVisibilityToolModel {
    previousVisibility : bool <<get>> <<set>>
    allVisibility : bool <<get>> <<set>>
    hasCharacter : bool <<get>>
    UndoScope(description:string) : UndoScope
}
interface ISpriteVisibilityToolView {
    Setup() : void
    SetSelection(sprite:SpriteCache) : void
    SetSelectionIds(selectedIds:IList<int>) : void
}
class SpriteVisibilityToolData {
    m_AllVisibility : bool = true
    m_PreviousVisibility : bool = true
    + allVisibility : bool <<get>> <<set>>
    + previousVisibility : bool <<get>> <<set>>
}
class SpriteVisibilityToolController {
    m_UpdateViewOnSelection : bool = true
    +  <<event>> OnAvailabilityChangeListeners : Action 
    + SpriteVisibilityToolController(model:ISpriteVisibilityToolModel, events:SkinningEvents)
    + Activate() : void
    + Deactivate() : void
    + Dispose() : void
    OnViewModeChanged(mode:SkinningMode) : void
    + isAvailable : bool <<get>>
    SetAllCharacterSpriteVisibility() : void
    + SetAllVisibility(visibility:bool) : void
    + GetAllVisibility() : bool
    + BuildTreeView() : List<TreeViewItem>
    SpriteVisibilityItemOrderSort(x:ISpriteVisibilityItem, y:ISpriteVisibilityItem) : int
    + GetCharacterPartVisibility(item:TreeViewItem) : bool
    + SetCharacterPartVisibility(item:TreeViewItem, visible:bool, isolate:bool) : void
    + SetSelectedSprite(rows:IList<TreeViewItem>, selectedIds:IList<int>) : void
    + GetTreeViewSelectionID(sprite:SpriteCache) : int
    + GetCategoryForSprite(treeViewItem:TreeViewItem) : SpriteCategory
    + GetCategoryStrings() : string[]
    + GetSpriteLabelName(category:SpriteCategory, treeViewItem:TreeViewItem) : string
    GetCategoryIndexForSprite(category:SpriteCategory, treeViewItem:TreeViewItem) : int
    + RemoveSpriteFromCategory(treeViewItem:TreeViewItem) : void
    + SetCategoryForSprite(categoryName:string, treeViewItem:TreeViewItem) : void
    + SetCategoryForSprite(categoryName:string, labelName:string, treeViewItem:TreeViewItem) : void
    SetCategoryForSprite(categoryName:string, labelName:string, spriteVisibilityItem:ISpriteVisibilityItem) : void
    + IsLabelDuplicate(category:SpriteCategory, labelName:string) : bool
    + SetCategoryLabelName(labelname:string, treeViewItem:TreeViewItem) : void
    + SupportCateogry(treeViewItem:TreeViewItem) : bool
    + SupportConvertToCatgory(treeViewItem:TreeViewItem) : bool
    + ClearCategory(treeViewItem:TreeViewItem) : void
    + ConvertLayerToCategory(treeViewItem:TreeViewItem) : void
    + ConvertToCategory(treeViewItem:TreeViewItem) : void
    AddGroupToCategory(categoryName:string, groupItem:SpriteVisibilityGroupItem) : void
    + RemoveUnusedCategory() : void
}
class SpriteVisibilityTool {
    + SpriteVisibilityTool(s:SkinningCache)
    + Setup() : void
    + Dispose() : void
    + name : string <<get>>
    + Activate() : void
    + Deactivate() : void
    + isAvailable : bool <<get>>
    + SetAvailabilityChangeCallback(callback:Action) : void
    hasCharacter : bool <<get>>
    previousVisibility : bool <<get>> <<set>>
    allVisibility : bool <<get>> <<set>>
    UndoScope(description:string) : UndoScope
}
class SpriteVisibilityToolView {
    + SpriteVisibilityToolView()
    InternalGetController() : SpriteVisibilityToolController
    InternalGetAllVisibility() : bool
    InternalSetAllVisibility(visibility:bool) : void
    + Setup() : void
    + SetSelection(sprite:SpriteCache) : void
    + SetSelectionIds(selectedIds:IList<int>) : void
}
class SpriteTreeView {
    m_SpriteCategoryRenameID : int
    + SpriteTreeView(treeViewState:TreeViewState, multiColumnHeader:MultiColumnHeader)
    SkinInit() : void
    + Setup() : void
    + <<override>> OnGUI(rect:Rect) : void
    ConvertGroupToCategory() : void
    ClearAllCategory() : void
    ConvertLayerToCategory() : void
    CellGUI(cellRect:Rect, item:TreeViewItem, column:int, args:RowGUIArgs) : void
    DrawVisibilityCell(cellRect:Rect, item:TreeViewItem) : void
    DrawNameCell(cellRect:Rect, item:TreeViewItem, args:RowGUIArgs) : void
    DrawCategoryCell(cellRect:Rect, item:TreeViewItem, args:RowGUIArgs) : void
    DrawCategoryNameControl(cellRect:Rect, item:TreeViewItem) : void
    DrawIndexCell(cellRect:Rect, item:TreeViewItem, args:RowGUIArgs) : void
    + SetSelectionIds(selectedIds:IList<int>) : void
    + SetSelection(sprite:SpriteCache) : void
}
interface ISpriteVisibilityItem {
    visibility : bool <<get>> <<set>>
}
class SpriteVisibilityGroupItem {
    visibility : bool <<get>> <<set>>
}
class SpriteVisibilitySpriteItem {
    visibility : bool <<get>> <<set>>
}
class "Func`1"<T> {
}
ISpriteVisibilityToolModel --> "view" ISpriteVisibilityToolView
ISpriteVisibilityToolModel --> "character" CharacterCache
ISpriteVisibilityToolModel --> "mode" SkinningMode
ISpriteVisibilityToolModel --> "selectedSprite" SpriteCache
ISpriteVisibilityToolModel --> "spriteCategoryList" SpriteCategoryListCacheObject
CacheObject <|-- SpriteVisibilityToolData
SpriteVisibilityToolController --> "m_Model" ISpriteVisibilityToolModel
SpriteVisibilityToolController --> "m_Events" SkinningEvents
IVisibilityTool <|-- SpriteVisibilityTool
ISpriteVisibilityToolModel <|-- SpriteVisibilityTool
SpriteVisibilityTool --> "m_View" SpriteVisibilityToolView
SpriteVisibilityTool --> "m_Controller" SpriteVisibilityToolController
SpriteVisibilityTool --> "skinningCache" SkinningCache
SpriteVisibilityTool --> "view" VisualElement
SpriteVisibilityTool --> "view" ISpriteVisibilityToolView
SpriteVisibilityTool --> "selectedSprite" SpriteCache
SpriteVisibilityTool --> "character" CharacterCache
SpriteVisibilityTool --> "mode" SkinningMode
SpriteVisibilityTool --> "spriteCategoryList" SpriteCategoryListCacheObject
VisibilityToolViewBase <|-- SpriteVisibilityToolView
ISpriteVisibilityToolView <|-- SpriteVisibilityToolView
SpriteVisibilityToolView o-> "GetController<SpriteVisibilityToolController>" "Func`1"
VisibilityTreeViewBase <|-- SpriteTreeView
SpriteTreeView o-> "GetController<SpriteVisibilityToolController>" "Func`1"
SpriteTreeView --> "m_Style" GUIStyle
SpriteTreeView --> "m_WarningIcon" GUIContent
SpriteVisibilityToolController +-- ISpriteVisibilityItem
ISpriteVisibilityItem --> "characterOrder" ICharacterOrder
SpriteVisibilityToolController +-- SpriteVisibilityGroupItem
ISpriteVisibilityItem <|-- SpriteVisibilityGroupItem
SpriteVisibilityGroupItem --> "group" CharacterGroupCache
SpriteVisibilityGroupItem --> "characterOrder" ICharacterOrder
SpriteVisibilityToolController +-- SpriteVisibilitySpriteItem
ISpriteVisibilityItem <|-- SpriteVisibilitySpriteItem
SpriteVisibilitySpriteItem --> "sprite" CharacterPartCache
SpriteVisibilitySpriteItem --> "characterOrder" ICharacterOrder
class VisibilityToolWindow {
    m_CurrentSelectedTab : int = 0
    +  <<event>> onBoneOpacitySliderChange : Action<float> 
    +  <<event>> onMeshOpacitySliderChange : Action<float> 
    +  <<event>> onBoneOpacitySliderChangeBegin : Action 
    +  <<event>> onBoneOpacitySliderChangeEnd : Action 
    +  <<event>> onMeshOpacitySliderChangeBegin : Action 
    +  <<event>> onMeshOpacitySliderChangeEnd : Action 
    + {static} CreateFromUXML() : VisibilityToolWindow
    + BindElements() : void
    + Initialize(layout:LayoutOverlay) : void
    + Show() : void
    + Hide() : void
    IsOpacityTarget(target:IEventHandler, opacityTarget:VisualElement) : bool
    OpacityChangeBegin(evt:MouseDownEvent) : void
    OpacityChangeEnd(evt:MouseCaptureOutEvent) : void
    OnBoneOpacitySliderValueChangd(evt:ChangeEvent<float>) : void
    OnMeshOpacitySliderValueChangd(evt:ChangeEvent<float>) : void
    + SetBoneOpacitySliderValue(value:float) : void
    + SetMeshOpacitySliderValue(value:float) : void
    + AddToolTab(name:string, onClick:Action) : void
    + SetActiveTab(toolIndex:int) : void
    + SetContent(content:VisualElement) : void
    + SetToolAvailable(toolIndex:int, available:bool) : void
}
class VisibilityTool {
    <<internal>> <<override>> OnCreate() : void
    + <<override>> Initialize(layout:LayoutOverlay) : void
    currentToolIndex : int <<get>> <<set>>
    boneOpacityValue : float <<get>> <<set>>
    meshOpacityValue : float <<get>> <<set>>
    UndoScope(value:string) : UndoScope
    BeginUndoOperation(value:string) : void
}
interface IVisibilityToolModel {
    currentToolIndex : int <<get>> <<set>>
    meshOpacityValue : float <<get>> <<set>>
    boneOpacityValue : float <<get>> <<set>>
    UndoScope(value:string) : UndoScope
    BeginUndoOperation(value:string) : void
}
interface IVisibilityToolWindow {
    AddToolTab(name:string, callback:Action) : void
    SetToolAvailable(i:int, available:bool) : void
    SetBoneOpacitySliderValue(value:float) : void
    SetMeshOpacitySliderValue(value:float) : void
     <<event>> onBoneOpacitySliderChange : Action<float> 
     <<event>> onMeshOpacitySliderChange : Action<float> 
     <<event>> onBoneOpacitySliderChangeBegin : Action 
     <<event>> onBoneOpacitySliderChangeEnd : Action 
     <<event>> onMeshOpacitySliderChangeBegin : Action 
     <<event>> onMeshOpacitySliderChangeEnd : Action 
    Show() : void
    Hide() : void
    SetActiveTab(index:int) : void
    SetContent(content:VisualElement) : void
}
class VisibilityToolController {
    m_DeactivateBoneaTool : bool = false
    + VisibilityToolController(model:IVisibilityToolModel, tools:IVisibilityTool[], skeletonTool:Func<SkeletonTool>, meshPreviewBehaviour:Func<IMeshPreviewBehaviour>)
    + Activate() : void
    + Deactivate() : void
    OnBoneOpacityChangeBegin() : void
    OnBoneOpacityChangeEnd() : void
    OnMeshOpacityChangeBegin() : void
    OnMeshOpacityChangeEnd() : void
}
class CustomUxmlFactory {
}
class "List`1"<T> {
}
class "Func`1"<T> {
}
class "UxmlFactory`2"<T1,T2> {
}
VisualElement <|-- VisibilityToolWindow
IVisibilityToolWindow <|-- VisibilityToolWindow
VisibilityToolWindow --> "m_SelectorContainer" VisualElement
VisibilityToolWindow --> "m_Container" VisualElement
VisibilityToolWindow --> "m_BoneOpacitySlider" Slider
VisibilityToolWindow --> "m_MeshOpacitySlider" Slider
VisibilityToolWindow --> "m_Tabs<Button>" "List`1"
BaseTool <|-- VisibilityTool
IVisibilityToolModel <|-- VisibilityTool
VisibilityTool --> "skeletonTool" SkeletonTool
VisibilityTool --> "m_Controller" VisibilityToolController
VisibilityTool --> "previewBehaviour" IMeshPreviewBehaviour
VisibilityTool --> "view" IVisibilityToolWindow
VisibilityTool --> "skinningCache" SkinningCache
IVisibilityToolModel --> "view" IVisibilityToolWindow
IVisibilityToolModel --> "skinningCache" SkinningCache
VisibilityToolController --> "m_Model" IVisibilityToolModel
VisibilityToolController --> "m_SkeletonTool<SkeletonTool>" "Func`1"
VisibilityToolController --> "m_MeshPreviewBehaviour<IMeshPreviewBehaviour>" "Func`1"
VisibilityToolWindow +-- CustomUxmlFactory
"UxmlFactory`2" "<VisibilityToolWindow,UxmlTraits>" <|-- CustomUxmlFactory
interface IVisibilityTool {
    name : string <<get>>
    Activate() : void
    Deactivate() : void
    isAvailable : bool <<get>>
    SetAvailabilityChangeCallback(callback:Action) : void
    Setup() : void
    Dispose() : void
}
class VisibilityToolViewBase {
    + VisibilityToolViewBase()
    DoSearchField() : void
    DoOpacitySlider() : void
    OnGUI() : void
}
class "TreeViewItemBase`1"<T> {
    + customData : T
    + TreeViewItemBase(id:int, depth:int, name:string, data:T)
}
class VisibilityTreeViewBase {
    + VisibilityTreeViewBase(treeViewState:TreeViewState, multiColumn:MultiColumnHeader)
    + VisibilityTreeViewBase(treeViewState:TreeViewState)
    Init() : void
}
class "Action`1"<T> {
}
class "Func`1"<T> {
}
class Styles <<static>> {
}
class VisibilityIconStyle <<static>> {
}
IVisibilityTool --> "view" VisualElement
VisualElement <|-- VisibilityToolViewBase
VisibilityToolViewBase --> "m_Container" IMGUIContainer
VisibilityToolViewBase --> "m_SearchField" SearchField
VisibilityToolViewBase o-> "SetOpacityValue<float>" "Action`1"
VisibilityToolViewBase o-> "GetOpacityValue<float>" "Func`1"
TreeViewItem <|-- "TreeViewItemBase`1"
TreeView <|-- VisibilityTreeViewBase
VisibilityToolViewBase +-- Styles
Styles o-> "preLabel" GUIStyle
Styles o-> "preSlider" GUIStyle
Styles o-> "preSliderThumb" GUIStyle
VisibilityTreeViewBase +-- VisibilityIconStyle
VisibilityIconStyle o-> "visibilityOnIcon" GUIContent
VisibilityIconStyle o-> "visibilityOffIcon" GUIContent
class VisibilityToolColumnHeader {
    + VisibilityToolColumnHeader(state:MultiColumnHeaderState)
    + visibilityColumn : int <<set>>
}
class "Action`1"<T> {
}
class "Func`1"<T> {
}
MultiColumnHeader <|-- VisibilityToolColumnHeader
VisibilityToolColumnHeader o-> "SetAllVisibility<bool>" "Action`1"
VisibilityToolColumnHeader o-> "GetAllVisibility<bool>" "Func`1"
class VisibilityToolResizer {
    + VisibilityToolResizer()
}
MouseManipulator <|-- VisibilityToolResizer
class BoundedBiharmonicWeightsGenerator {
    + Calculate(vertices:Vector2[], edges:Edge[], controlPoints:Vector2[], bones:Edge[], pins:int[]) : BoneWeight[]
    + DebugMesh(spriteMeshData:ISpriteMeshData, vertices:Vector2[], edges:Edge[], controlPoints:Vector2[], bones:Edge[], pins:int[]) : void
}
IWeightsGenerator <|-- BoundedBiharmonicWeightsGenerator
BoundedBiharmonicWeightsGenerator o-> "defaultWeight" BoneWeight
interface IWeightsGenerator {
    Calculate(vertices:Vector2[], edges:Edge[], controlPoints:Vector2[], bones:Edge[], pins:int[]) : BoneWeight[]
}
class Contour {
    marker : int
    convex : bool
    + Contour(points:IEnumerable<Vertex>)
    + Contour(points:IEnumerable<Vertex>, marker:int)
    + Contour(points:IEnumerable<Vertex>, marker:int, convex:bool)
    + GetSegments() : List<ISegment>
    + FindInteriorPoint(limit:int, eps:double) : Point
}
class "List`1"<T> {
}
Contour --> "Points<Vertex>" "List`1"
class Edge {
    + P0 : int <<get>>
    + P1 : int <<get>>
    + Label : int <<get>>
    + Edge(p0:int, p1:int)
    + Edge(p0:int, p1:int, label:int)
}
IEdge <|-- Edge
class ExtensionMethods <<static>> {
    <<internal>> {static} Triangulate(polygon:IPolygon) : IMesh
    <<internal>> {static} Triangulate(polygon:IPolygon, options:ConstraintOptions) : IMesh
    <<internal>> {static} Triangulate(polygon:IPolygon, quality:QualityOptions) : IMesh
    <<internal>> {static} Triangulate(polygon:IPolygon, options:ConstraintOptions, quality:QualityOptions) : IMesh
    <<internal>> {static} Triangulate(polygon:IPolygon, options:ConstraintOptions, quality:QualityOptions, triangulator:ITriangulator) : IMesh
    <<internal>> {static} Contains(triangle:ITriangle, p:Point) : bool
    <<internal>> {static} Contains(triangle:ITriangle, x:double, y:double) : bool
    <<internal>> {static} Bounds(triangle:ITriangle) : Rectangle
    <<internal>> {static} DotProduct(p:Point, q:Point) : double
}
interface IEdge {
    P0 : int <<get>>
    P1 : int <<get>>
    Label : int <<get>>
}
interface IPolygon {
    HasPointMarkers : bool <<get>> <<set>>
    HasSegmentMarkers : bool <<get>> <<set>>
    AddContour(points:IEnumerable<Vertex>, marker:int, hole:bool, convex:bool) : void
    AddContour(points:IEnumerable<Vertex>, marker:int, hole:Point) : void
    Bounds() : Rectangle
    Add(vertex:Vertex) : void
    Add(segment:ISegment, insert:bool) : void
    Add(segment:ISegment, index:int) : void
    Add(contour:Contour, hole:bool) : void
    Add(contour:Contour, hole:Point) : void
}
class "List`1"<T> {
}
IPolygon --> "Points<Vertex>" "List`1"
IPolygon --> "Segments<ISegment>" "List`1"
IPolygon --> "Holes<Point>" "List`1"
IPolygon --> "Regions<RegionPointer>" "List`1"
interface ISegment {
    GetVertex(index:int) : Vertex
    GetTriangle(index:int) : ITriangle
}
IEdge <|-- ISegment
interface ITriangle {
    ID : int <<get>> <<set>>
    Label : int <<get>> <<set>>
    Area : double <<get>> <<set>>
    GetVertex(index:int) : Vertex
    GetVertexID(index:int) : int
    GetNeighbor(index:int) : ITriangle
    GetNeighborID(index:int) : int
    GetSegment(index:int) : ISegment
}
class Point {
    <<internal>> id : int
    <<internal>> label : int
    <<internal>> x : double
    <<internal>> y : double
    + Point()
    + Point(x:double, y:double)
    + Point(x:double, y:double, label:int)
    + ID : int <<get>> <<set>>
    + X : double <<get>> <<set>>
    + Y : double <<get>> <<set>>
    + Label : int <<get>> <<set>>
    + <<override>> Equals(obj:object) : bool
    + Equals(p:Point) : bool
    + CompareTo(other:Point) : int
    + <<override>> GetHashCode() : int
}
class "IComparable`1"<T> {
}
class "IEquatable`1"<T> {
}
"IComparable`1" "<Point>" <|-- Point
"IEquatable`1" "<Point>" <|-- Point
class Polygon {
    + HasPointMarkers : bool <<get>> <<set>>
    + HasSegmentMarkers : bool <<get>> <<set>>
    + Count : int <<get>>
    + Polygon()
    + Polygon(capacity:int)
    + Polygon(capacity:int, markers:bool)
    + AddContour(points:IEnumerable<Vertex>, marker:int, hole:bool, convex:bool) : void
    + AddContour(points:IEnumerable<Vertex>, marker:int, hole:Point) : void
    + Bounds() : Rectangle
    + Add(vertex:Vertex) : void
    + Add(segment:ISegment, insert:bool) : void
    + Add(segment:ISegment, index:int) : void
    + Add(contour:Contour, hole:bool) : void
    + Add(contour:Contour, hole:Point) : void
}
class "List`1"<T> {
}
IPolygon <|-- Polygon
Polygon --> "points<Vertex>" "List`1"
Polygon --> "holes<Point>" "List`1"
Polygon --> "regions<RegionPointer>" "List`1"
Polygon --> "segments<ISegment>" "List`1"
Polygon --> "Points<Vertex>" "List`1"
Polygon --> "Holes<Point>" "List`1"
Polygon --> "Regions<RegionPointer>" "List`1"
Polygon --> "Segments<ISegment>" "List`1"
class Rectangle {
    xmin : double
    ymin : double
    xmax : double
    ymax : double
    + Rectangle()
    + Rectangle(other:Rectangle)
    + Rectangle(x:double, y:double, width:double, height:double)
    + Left : double <<get>>
    + Right : double <<get>>
    + Bottom : double <<get>>
    + Top : double <<get>>
    + Width : double <<get>>
    + Height : double <<get>>
    + Resize(dx:double, dy:double) : void
    + Expand(p:Point) : void
    + Expand(points:IEnumerable<Point>) : void
    + Expand(other:Rectangle) : void
    + Contains(x:double, y:double) : bool
    + Contains(pt:Point) : bool
    + Contains(other:Rectangle) : bool
    + Intersects(other:Rectangle) : bool
}
class RegionPointer {
    <<internal>> id : int
    <<internal>> area : double
    + Area : double <<get>> <<set>>
    + RegionPointer(x:double, y:double, id:int)
    + RegionPointer(x:double, y:double, id:int, area:double)
}
RegionPointer --> "point" Point
class Segment {
    label : int
    + Label : int <<get>> <<set>>
    + P0 : int <<get>>
    + P1 : int <<get>>
    + Segment(v0:Vertex, v1:Vertex)
    + Segment(v0:Vertex, v1:Vertex, label:int)
    + GetVertex(index:int) : Vertex
    + GetTriangle(index:int) : ITriangle
}
ISegment <|-- Segment
Segment --> "v0" Vertex
Segment --> "v1" Vertex
class Vertex {
    <<internal>> hash : int
    + Vertex()
    + Vertex(x:double, y:double)
    + Vertex(x:double, y:double, mark:int)
    + <<override>> GetHashCode() : int
}
Point <|-- Vertex
Vertex --> "type" VertexType
Vertex --> "tri" Otri
Vertex --> "Type" VertexType
class DebugWriter {
    iteration : int
    session : string
    tmpFile : string
    triangles : int
    {static} DebugWriter()
    + Start(session:string) : void
    + Write(mesh:Mesh, skip:bool) : void
    + Finish() : void
}
DebugWriter o-> "nfi" NumberFormatInfo
DebugWriter --> "stream" StreamWriter
DebugWriter --> "Session" DebugWriter
class FileProcessor <<static>> {
    {static} FileProcessor()
    <<internal>> {static} Add(format:IFileFormat) : void
    <<internal>> {static} IsSupported(file:string) : bool
    <<internal>> {static} Read(filename:string) : IPolygon
    <<internal>> {static} Write(polygon:IPolygon, filename:string) : void
    <<internal>> {static} Import(filename:string) : IMesh
    <<internal>> {static} Write(mesh:IMesh, filename:string) : void
}
class "List`1"<T> {
}
FileProcessor --> "formats<IFileFormat>" "List`1"
interface IFileFormat {
    IsSupported(file:string) : bool
}
interface IMeshFormat {
    Import(filename:string) : IMesh
    Write(mesh:IMesh, filename:string) : void
    Write(mesh:IMesh, stream:Stream) : void
}
IFileFormat <|-- IMeshFormat
class InputTriangle {
    <<internal>> label : int
    <<internal>> area : double
    + InputTriangle(p0:int, p1:int, p2:int)
    + ID : int <<get>> <<set>>
    + Label : int <<get>> <<set>>
    + Area : double <<get>> <<set>>
    + GetVertex(index:int) : Vertex
    + GetVertexID(index:int) : int
    + GetNeighbor(index:int) : ITriangle
    + GetNeighborID(index:int) : int
    + GetSegment(index:int) : ISegment
}
ITriangle <|-- InputTriangle
interface IPolygonFormat {
    Read(filename:string) : IPolygon
    Write(polygon:IPolygon, filename:string) : void
    Write(polygon:IPolygon, stream:Stream) : void
}
IFileFormat <|-- IPolygonFormat
class TriangleFormat {
    + IsSupported(file:string) : bool
    + Import(filename:string) : IMesh
    + Write(mesh:IMesh, filename:string) : void
    + Write(mesh:IMesh, stream:Stream) : void
    + Read(filename:string) : IPolygon
    + Write(polygon:IPolygon, filename:string) : void
    + Write(polygon:IPolygon, stream:Stream) : void
}
IPolygonFormat <|-- TriangleFormat
IMeshFormat <|-- TriangleFormat
class TriangleReader {
    startIndex : int = 0
    + Read(filename:string, polygon:Polygon) : void
    + Read(filename:string, geometry:Polygon, triangles:List<ITriangle>) : void
    + Read(filename:string) : IPolygon
    + ReadNodeFile(nodefilename:string) : Polygon
    + ReadNodeFile(nodefilename:string, readElements:bool) : Polygon
    + ReadPolyFile(polyfilename:string) : Polygon
    + ReadPolyFile(polyfilename:string, readElements:bool) : Polygon
    + ReadPolyFile(polyfilename:string, readElements:bool, readArea:bool) : Polygon
    + ReadEleFile(elefilename:string) : List<ITriangle>
    + ReadEdgeFile(edgeFile:string, invertices:int) : List<Edge>
    IsStringNullOrWhiteSpace(value:string) : bool
}
TriangleReader o-> "nfi" NumberFormatInfo
class TriangleWriter {
    + Write(mesh:Mesh, filename:string) : void
    + WriteNodes(mesh:Mesh, filename:string) : void
    + WriteElements(mesh:Mesh, filename:string) : void
    + WritePoly(polygon:IPolygon, filename:string) : void
    + WritePoly(mesh:Mesh, filename:string) : void
    + WritePoly(mesh:Mesh, filename:string, writeNodes:bool) : void
    + WriteEdges(mesh:Mesh, filename:string) : void
    + WriteNeighbors(mesh:Mesh, filename:string) : void
}
TriangleWriter o-> "nfi" NumberFormatInfo
enum LogLevel {
    Info= 0,
    Warning= 1,
    Error= 2,
}
interface "ILog`1"<T> {
    Add(item:T) : void
    Clear() : void
    Info(message:string) : void
    Error(message:string, info:string) : void
    Warning(message:string, info:string) : void
}
class "IList`1"<T> {
}
"ILog`1" --> "Data<T>" "IList`1"
"ILog`1" --> "Level" LogLevel
interface ILogItem {
    Message : string <<get>>
    Info : string <<get>>
}
ILogItem --> "Time" DateTime
ILogItem --> "Level" LogLevel
class LogItem {
    message : string
    info : string
    + Message : string <<get>>
    + Info : string <<get>>
    + LogItem(level:LogLevel, message:string)
    + LogItem(level:LogLevel, message:string, info:string)
}
ILogItem <|-- LogItem
LogItem --> "time" DateTime
LogItem --> "level" LogLevel
LogItem --> "Time" DateTime
LogItem --> "Level" LogLevel
class ConstraintMesher {
    + ConstraintMesher(mesh:Mesh, config:Configuration)
    + Apply(input:IPolygon, options:ConstraintOptions) : void
    Plague() : void
}
class "List`1"<T> {
}
class "ILog`1"<T> {
}
ConstraintMesher --> "predicates" IPredicates
ConstraintMesher --> "mesh" Mesh
ConstraintMesher --> "behavior" Behavior
ConstraintMesher --> "locator" TriangleLocator
ConstraintMesher --> "viri<Triangle>" "List`1"
ConstraintMesher --> "logger<LogItem>" "ILog`1"
class ConstraintOptions {
    + UseRegions : bool <<get>> <<set>>
    + ConformingDelaunay : bool <<get>> <<set>>
    + Convex : bool <<get>> <<set>>
    + SegmentSplitting : int <<get>> <<set>>
}
class Converter <<static>> {
    <<internal>> {static} ToMesh(polygon:Polygon, triangles:IList<ITriangle>) : Mesh
    <<internal>> {static} ToMesh(polygon:Polygon, triangles:ITriangle[]) : Mesh
    <<internal>> {static} ToDCEL(mesh:Mesh) : DcelMesh
}
class GenericMesher {
    + GenericMesher()
    + GenericMesher(triangulator:ITriangulator)
    + GenericMesher(config:Configuration)
    + GenericMesher(triangulator:ITriangulator, config:Configuration)
    + Triangulate(points:IList<Vertex>) : IMesh
    + Triangulate(polygon:IPolygon) : IMesh
    + Triangulate(polygon:IPolygon, options:ConstraintOptions) : IMesh
    + Triangulate(polygon:IPolygon, quality:QualityOptions) : IMesh
    + Triangulate(polygon:IPolygon, options:ConstraintOptions, quality:QualityOptions) : IMesh
    <<internal>> {static} StructuredMesh(width:double, height:double, nx:int, ny:int) : IMesh
    <<internal>> {static} StructuredMesh(bounds:Rectangle, nx:int, ny:int) : IMesh
}
GenericMesher --> "config" Configuration
GenericMesher --> "triangulator" ITriangulator
interface IConstraintMesher {
    Triangulate(polygon:IPolygon) : IMesh
    Triangulate(polygon:IPolygon, options:ConstraintOptions) : IMesh
}
interface IMesh {
    Renumber() : void
    Refine(quality:QualityOptions, delaunay:bool) : void
}
class "ICollection`1"<T> {
}
class "IEnumerable`1"<T> {
}
class "IList`1"<T> {
}
IMesh --> "Vertices<Vertex>" "ICollection`1"
IMesh --> "Edges<Edge>" "IEnumerable`1"
IMesh --> "Segments<SubSegment>" "ICollection`1"
IMesh --> "Triangles<Triangle>" "ICollection`1"
IMesh --> "Holes<Point>" "IList`1"
IMesh --> "Bounds" Rectangle
interface IQualityMesher {
    Triangulate(polygon:IPolygon, quality:QualityOptions) : IMesh
    Triangulate(polygon:IPolygon, options:ConstraintOptions, quality:QualityOptions) : IMesh
}
interface ITriangulator {
    Triangulate(points:IList<Vertex>, config:Configuration) : IMesh
}
class QualityMesher {
    + QualityMesher(mesh:Mesh, config:Configuration)
    + Apply(quality:QualityOptions, delaunay:bool) : void
    + AddBadSubseg(badseg:BadSubseg) : void
    + CheckSeg4Encroach(testsubseg:Osub) : int
    + TestTriangle(testtri:Otri) : void
}
class "Queue`1"<T> {
}
class "ILog`1"<T> {
}
QualityMesher --> "predicates" IPredicates
QualityMesher --> "badsubsegs<BadSubseg>" "Queue`1"
QualityMesher --> "queue" BadTriQueue
QualityMesher --> "mesh" Mesh
QualityMesher --> "behavior" Behavior
QualityMesher --> "newLocation" NewLocation
QualityMesher --> "logger<LogItem>" "ILog`1"
QualityMesher --> "newvertex_tri" Triangle
class QualityOptions {
    + MaximumAngle : double <<get>> <<set>>
    + MinimumAngle : double <<get>> <<set>>
    + MaximumArea : double <<get>> <<set>>
    + VariableArea : bool <<get>> <<set>>
    + SteinerPoints : int <<get>> <<set>>
}
class "Func`3"<T1,T2,T3> {
}
QualityOptions --> "UserTest<ITriangle,double,bool>" "Func`3"
interface ISmoother {
    Smooth(mesh:IMesh) : void
    Smooth(mesh:IMesh, limit:int) : void
}
class SimpleSmoother {
    + SimpleSmoother()
    + SimpleSmoother(factory:IVoronoiFactory)
    + SimpleSmoother(factory:IVoronoiFactory, config:Configuration)
    + Smooth(mesh:IMesh) : void
    + Smooth(mesh:IMesh, limit:int) : void
}
ISmoother <|-- SimpleSmoother
SimpleSmoother --> "pool" TrianglePool
SimpleSmoother --> "config" Configuration
SimpleSmoother --> "factory" IVoronoiFactory
SimpleSmoother --> "options" ConstraintOptions
class VoronoiFactory {
    + VoronoiFactory()
    + Initialize(vertexCount:int, edgeCount:int, faceCount:int) : void
    + Reset() : void
    + CreateVertex(x:double, y:double) : Vertex
    + CreateHalfEdge(origin:Vertex, face:Face) : HalfEdge
    + CreateFace(vertex:Geometry.Vertex) : Face
}
class "ObjectPool`1"<T> {
}
class "ObjectPool`1"<T> {
    index : int
    count : int
    + Count : int <<get>>
    + Capacity : int <<get>> <<set>>
    + ObjectPool(capacity:int)
    + ObjectPool(pool:T[])
    + TryGet(obj:T) : bool
    + Put(obj:T) : void
    + Release() : void
}
IVoronoiFactory <|-- VoronoiFactory
VoronoiFactory --> "vertices<Vertex>" "ObjectPool`1"
VoronoiFactory --> "edges<HalfEdge>" "ObjectPool`1"
VoronoiFactory --> "faces<Face>" "ObjectPool`1"
VoronoiFactory +-- "ObjectPool`1"
class AdjacencyMatrix {
    nnz : int
    + <<readonly>> N : int
    + AdjacencyMatrix(mesh:Mesh)
    + AdjacencyMatrix(pcol:int[], irow:int[])
    + Bandwidth() : int
    AdjacencyCount(mesh:Mesh) : int[]
    AdjacencySet(mesh:Mesh, pcol:int[]) : int[]
    + SortIndices() : void
}
class CuthillMcKee {
    + Renumber(mesh:Mesh) : int[]
    + Renumber(matrix:AdjacencyMatrix) : int[]
    GenerateRcm() : int[]
    Rcm(root:int, mask:int[], perm:int[], offset:int, iccsze:int) : void
    FindRoot(root:int, mask:int[], level_num:int, level_row:int[], level:int[], offset:int) : void
    GetLevelSet(root:int, mask:int[], level_num:int, level_row:int[], level:int[], offset:int) : void
    Degree(root:int, mask:int[], deg:int[], iccsze:int, ls:int[], offset:int) : void
    PermBandwidth(perm:int[], perm_inv:int[]) : int
    PermInverse(perm:int[]) : int[]
    ReverseVector(a:int[], offset:int, size:int) : void
    Shift(a:int[], up:bool) : void
}
CuthillMcKee --> "matrix" AdjacencyMatrix
class Interpolation <<static>> {
}
class IntersectionHelper <<static>> {
    <<internal>> {static} IntersectSegments(p0:Point, p1:Point, q0:Point, q1:Point, c0:Point) : void
    <<internal>> {static} LiangBarsky(rect:Rectangle, p0:Point, p1:Point, c0:Point, c1:Point) : bool
    <<internal>> {static} BoxRayIntersection(rect:Rectangle, p0:Point, p1:Point, c1:Point) : bool
    <<internal>> {static} BoxRayIntersection(rect:Rectangle, p:Point, dx:double, dy:double) : Point
    <<internal>> {static} BoxRayIntersection(rect:Rectangle, p:Point, dx:double, dy:double, c:Point) : bool
}
class PolygonValidator <<static>> {
    <<internal>> {static} IsConsistent(poly:IPolygon) : bool
    <<internal>> {static} HasDuplicateVertices(poly:IPolygon) : bool
    <<internal>> {static} HasBadAngles(poly:IPolygon, threshold:double) : bool
}
class QualityMeasure {
    + QualityMeasure()
    + AreaMinimum : double <<get>>
    + AreaMaximum : double <<get>>
    + AreaRatio : double <<get>>
    + AlphaMinimum : double <<get>>
    + AlphaMaximum : double <<get>>
    + AlphaAverage : double <<get>>
    + AlphaArea : double <<get>>
    + Q_Minimum : double <<get>>
    + Q_Maximum : double <<get>>
    + Q_Average : double <<get>>
    + Q_Area : double <<get>>
    + Update(mesh:Mesh) : void
    + Bandwidth() : int
}
class AreaMeasure {
    + area_min : double
    + area_max : double
    + area_total : double = 0
    + area_zero : int = 0
    + Reset() : void
    + Measure(a:Point, b:Point, c:Point) : double
}
class AlphaMeasure {
    + alpha_min : double
    + alpha_max : double
    + alpha_ave : double
    + alpha_area : double
    + Reset() : void
    acos(c:double) : double
    + Measure(ab:double, bc:double, ca:double, area:double) : double
    + Normalize(n:int, area_total:double) : void
}
class Q_Measure {
    + q_min : double
    + q_max : double
    + q_ave : double
    + q_area : double
    + Reset() : void
    + Measure(ab:double, bc:double, ca:double, area:double) : double
    + Normalize(n:int, area_total:double) : void
}
QualityMeasure --> "areaMeasure" AreaMeasure
QualityMeasure --> "alphaMeasure" AlphaMeasure
QualityMeasure --> "qMeasure" Q_Measure
QualityMeasure --> "mesh" Mesh
QualityMeasure +-- AreaMeasure
QualityMeasure +-- AlphaMeasure
QualityMeasure +-- Q_Measure
class Statistic {
    <<internal>> {static} InCircleCount : long = 0
    <<internal>> {static} InCircleAdaptCount : long = 0
    <<internal>> {static} CounterClockwiseCount : long = 0
    <<internal>> {static} CounterClockwiseAdaptCount : long = 0
    <<internal>> {static} Orient3dCount : long = 0
    <<internal>> {static} HyperbolaCount : long = 0
    <<internal>> {static} CircumcenterCount : long = 0
    <<internal>> {static} CircleTopCount : long = 0
    <<internal>> {static} RelocationCount : long = 0
    minEdge : double = 0
    + ShortestEdge : double <<get>>
    maxEdge : double = 0
    + LongestEdge : double <<get>>
    minAspect : double = 0
    + ShortestAltitude : double <<get>>
    maxAspect : double = 0
    + LargestAspectRatio : double <<get>>
    minArea : double = 0
    + SmallestArea : double <<get>>
    maxArea : double = 0
    + LargestArea : double <<get>>
    minAngle : double = 0
    + SmallestAngle : double <<get>>
    maxAngle : double = 0
    + LargestAngle : double <<get>>
    meshArea : double = 0
    + MeshArea : double <<get>>
    + Update(mesh:Mesh, sampleDegrees:int) : void
    <<internal>> {static} ComputeAngles(triangle:ITriangle, data:double[]) : void
}
class TriangleQuadTree {
    <<internal>> sizeBound : int
    <<internal>> maxDepth : int
    + TriangleQuadTree(mesh:Mesh, maxDepth:int, sizeBound:int)
    + Query(x:double, y:double) : ITriangle
    <<internal>> {static} IsPointInTriangle(p:Point, t0:Point, t1:Point, t2:Point) : bool
    <<internal>> {static} DotProduct(p:Point, q:Point) : double
}
class QuadNode {
    <<const>> SW : int = 0
    <<const>> SE : int = 1
    <<const>> NW : int = 2
    <<const>> NE : int = 3
    <<const>> EPS : double = 1e-6
    bitRegions : byte
    + QuadNode(box:Rectangle, tree:TriangleQuadTree)
    + QuadNode(box:Rectangle, tree:TriangleQuadTree, init:bool)
    + FindTriangles(searchPoint:Point) : List<int>
    + CreateSubRegion(currentDepth:int) : void
    AddTriangleToRegion(triangle:Point[], index:int) : void
    FindTriangleIntersections(triangle:Point[], index:int) : void
    FindIntersectionsWithX(dx:double, dy:double, triangle:Point[], index:int, k:int) : void
    FindIntersectionsWithY(dx:double, dy:double, triangle:Point[], index:int, k:int) : void
    FindRegion(point:Point) : int
    AddToRegion(index:int, region:int) : void
}
class "List`1"<T> {
}
TriangleQuadTree --> "root" QuadNode
TriangleQuadTree +-- QuadNode
QuadNode --> "bounds" Rectangle
QuadNode --> "pivot" Point
QuadNode --> "tree" TriangleQuadTree
QuadNode --> "triangles<int>" "List`1"
class VertexSorter {
    VertexSorter(points:Vertex[], seed:int)
    <<internal>> {static} Sort(array:Vertex[], seed:int) : void
    <<internal>> {static} Alternate(array:Vertex[], length:int, seed:int) : void
}
VertexSorter --> "rand" Random
class Osub <<struct>> {
    <<internal>> orient : int
    + <<override>> ToString() : string
    + Sym(os:Osub) : void
    + Sym() : void
    + Pivot(os:Osub) : void
    <<internal>> Pivot(ot:Otri) : void
    + Next(ot:Osub) : void
    + Next() : void
    + Org() : Vertex
    + Dest() : Vertex
    <<internal>> SetOrg(vertex:Vertex) : void
    <<internal>> SetDest(vertex:Vertex) : void
    <<internal>> SegOrg() : Vertex
    <<internal>> SegDest() : Vertex
    <<internal>> SetSegOrg(vertex:Vertex) : void
    <<internal>> SetSegDest(vertex:Vertex) : void
    <<internal>> Bond(os:Osub) : void
    <<internal>> Dissolve(dummy:SubSegment) : void
    <<internal>> Equal(os:Osub) : bool
    <<internal>> TriDissolve(dummy:Triangle) : void
    <<internal>> {static} IsDead(sub:SubSegment) : bool
    <<internal>> {static} Kill(sub:SubSegment) : void
}
Osub --> "seg" SubSegment
Osub --> "Segment" SubSegment
class Otri <<struct>> {
    <<internal>> orient : int
    + <<override>> ToString() : string
    + Sym(ot:Otri) : void
    + Sym() : void
    + Lnext(ot:Otri) : void
    + Lnext() : void
    + Lprev(ot:Otri) : void
    + Lprev() : void
    + Onext(ot:Otri) : void
    + Onext() : void
    + Oprev(ot:Otri) : void
    + Oprev() : void
    + Dnext(ot:Otri) : void
    + Dnext() : void
    + Dprev(ot:Otri) : void
    + Dprev() : void
    + Rnext(ot:Otri) : void
    + Rnext() : void
    + Rprev(ot:Otri) : void
    + Rprev() : void
    + Org() : Vertex
    + Dest() : Vertex
    + Apex() : Vertex
    + Copy(ot:Otri) : void
    + Equals(ot:Otri) : bool
    <<internal>> SetOrg(v:Vertex) : void
    <<internal>> SetDest(v:Vertex) : void
    <<internal>> SetApex(v:Vertex) : void
    <<internal>> Bond(ot:Otri) : void
    <<internal>> Dissolve(dummy:Triangle) : void
    <<internal>> Infect() : void
    <<internal>> Uninfect() : void
    <<internal>> IsInfected() : bool
    <<internal>> Pivot(os:Osub) : void
    <<internal>> SegBond(os:Osub) : void
    <<internal>> SegDissolve(dummy:SubSegment) : void
    <<internal>> {static} IsDead(tria:Triangle) : bool
    <<internal>> {static} Kill(tri:Triangle) : void
}
Otri --> "tri" Triangle
Otri --> "Triangle" Triangle
class SubSegment {
    <<internal>> hash : int
    <<internal>> boundary : int
    + SubSegment()
    + P0 : int <<get>>
    + P1 : int <<get>>
    + Label : int <<get>>
    + GetVertex(index:int) : Vertex
    + GetTriangle(index:int) : ITriangle
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
ISegment <|-- SubSegment
class Triangle {
    <<internal>> hash : int
    <<internal>> id : int
    <<internal>> label : int
    <<internal>> area : double
    <<internal>> infected : bool
    + Triangle()
    + ID : int <<get>> <<set>>
    + Label : int <<get>> <<set>>
    + Area : double <<get>> <<set>>
    + GetVertex(index:int) : Vertex
    + GetVertexID(index:int) : int
    + GetNeighbor(index:int) : ITriangle
    + GetNeighborID(index:int) : int
    + GetSegment(index:int) : ISegment
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
ITriangle <|-- Triangle
class BoundedVoronoi {
    offset : int
    + BoundedVoronoi(mesh:Mesh)
    + BoundedVoronoi(mesh:Mesh, factory:IVoronoiFactory, predicates:IPredicates)
}
VoronoiBase <|-- BoundedVoronoi
class DefaultVoronoiFactory {
    + Initialize(vertexCount:int, edgeCount:int, faceCount:int) : void
    + Reset() : void
    + CreateVertex(x:double, y:double) : Vertex
    + CreateHalfEdge(origin:Vertex, face:Face) : HalfEdge
    + CreateFace(vertex:Geometry.Vertex) : Face
}
IVoronoiFactory <|-- DefaultVoronoiFactory
interface IVoronoiFactory {
    Initialize(vertexCount:int, edgeCount:int, faceCount:int) : void
    Reset() : void
    CreateVertex(x:double, y:double) : Vertex
    CreateHalfEdge(origin:Vertex, face:Face) : HalfEdge
    CreateFace(vertex:Geometry.Vertex) : Face
}
class StandardVoronoi {
    + StandardVoronoi(mesh:Mesh)
    + StandardVoronoi(mesh:Mesh, box:Rectangle)
    + StandardVoronoi(mesh:Mesh, box:Rectangle, factory:IVoronoiFactory, predicates:IPredicates)
}
VoronoiBase <|-- StandardVoronoi
abstract class VoronoiBase {
}
DcelMesh <|-- VoronoiBase
class AnimationSampleDependency {
    Update() : void
}
MonoBehaviour <|-- AnimationSampleDependency
AnimationSampleDependency o-> "gameCanvas" GameObject
class FindTightRectJob <<struct>> {
    m_Width : int
    m_Height : int
    + <<unsafe>> Execute(index:int) : void
    + {static} <<unsafe>> Execute(buffers:NativeArray<Color32>[], width:int, height:int) : RectInt[]
}
class "NativeArray`1"<T> {
}
IJobParallelFor <|-- FindTightRectJob
FindTightRectJob --> "m_Buffers<IntPtr>" "NativeArray`1"
FindTightRectJob --> "m_Output<RectInt>" "NativeArray`1"
class ClickAction {
    + clickCount : int = 1
    + ClickAction(control:Control, button:int, useEvent:bool)
}
class "Action`2"<T1,T2> {
}
HoveredControlAction <|-- ClickAction
ClickAction --> "onClick<IGUIState,Control>" "Action`2"
class CommandAction {
    + CommandAction(commandName:string)
}
class "Action`1"<T> {
}
GUIAction <|-- CommandAction
CommandAction --> "onCommand<IGUIState>" "Action`1"
abstract class Control {
    + name : string <<get>>
    + ID : int <<get>>
    + actionID : int <<get>>
    + Control(name:string)
    + GetControl(guiState:IGUIState) : void
    <<internal>> SetActionID(actionID:int) : void
    + BeginLayout(guiState:IGUIState) : void
    + Layout(guiState:IGUIState) : void
    + EndLayout(guiState:IGUIState) : void
    + Repaint(guiState:IGUIState) : void
}
Control --> "layoutData" LayoutData
Control --> "hotLayoutData" LayoutData
abstract class DefaultControl {
    + {static} <<readonly>> kPickDistance : float = 5f
    + DefaultControl(name:string)
}
Control <|-- DefaultControl
class GenericControl {
    + GenericControl(name:string)
}
class "Func`2"<T1,T2> {
}
class "Action`1"<T> {
}
class "Action`3"<T1,T2,T3> {
}
class "Func`1"<T> {
}
class "Func`3"<T1,T2,T3> {
}
Control <|-- GenericControl
GenericControl --> "onBeginLayout<IGUIState,LayoutData>" "Func`2"
GenericControl --> "onEndLayout<IGUIState>" "Action`1"
GenericControl --> "onRepaint<IGUIState,Control,int>" "Action`3"
GenericControl --> "count<int>" "Func`1"
GenericControl --> "position<int,Vector3>" "Func`2"
GenericControl --> "distance<IGUIState,int,float>" "Func`3"
GenericControl --> "forward<int,Vector3>" "Func`2"
GenericControl --> "up<int,Vector3>" "Func`2"
GenericControl --> "right<int,Vector3>" "Func`2"
GenericControl --> "userData<int,object>" "Func`2"
class GenericDefaultControl {
    + GenericDefaultControl(name:string)
}
class "Func`2"<T1,T2> {
}
DefaultControl <|-- GenericDefaultControl
GenericDefaultControl --> "position<IGUIState,Vector3>" "Func`2"
GenericDefaultControl --> "forward<IGUIState,Vector3>" "Func`2"
GenericDefaultControl --> "up<IGUIState,Vector3>" "Func`2"
GenericDefaultControl --> "right<IGUIState,Vector3>" "Func`2"
GenericDefaultControl --> "userData<IGUIState,object>" "Func`2"
abstract class GUIAction {
    + ID : int <<get>>
    + OnGUI(guiState:IGUIState) : void
    + IsEnabled(guiState:IGUIState) : bool
    + IsRepaintEnabled(guiState:IGUIState) : bool
    + PreRepaint(guiState:IGUIState) : void
    <<internal>> IsRepaintOnMouseMoveEnabled(guiState:IGUIState) : bool
}
class "Func`3"<T1,T2,T3> {
}
class "Action`2"<T1,T2> {
}
GUIAction --> "enable<IGUIState,GUIAction,bool>" "Func`3"
GUIAction --> "enableRepaint<IGUIState,GUIAction,bool>" "Func`3"
GUIAction --> "repaintOnMouseMove<IGUIState,GUIAction,bool>" "Func`3"
GUIAction --> "onPreRepaint<IGUIState,GUIAction>" "Action`2"
GUIAction --> "onRepaint<IGUIState,GUIAction>" "Action`2"
class GUIState {
    + mouseButton : int <<get>>
    + clickCount : int <<get>> <<set>>
    + isShiftDown : bool <<get>>
    + isAltDown : bool <<get>>
    + isActionKeyDown : bool <<get>>
    + commandName : string <<get>>
    + nearestControl : int <<get>> <<set>>
    + hotControl : int <<get>> <<set>>
    + changed : bool <<get>> <<set>>
    + GetControlID(hint:int, focusType:FocusType) : int
    + AddControl(controlID:int, distance:float) : void
    + Slider(id:int, sliderData:SliderData, newPosition:Vector3) : bool
    + UseEvent() : void
    + Repaint() : void
    + HasCurrentCamera() : bool
    + GetHandleSize(position:Vector3) : float
    + DistanceToSegment(p1:Vector3, p2:Vector3) : float
    + DistanceToCircle(center:Vector3, radius:float) : float
    + GUIToWorld(guiPosition:Vector2, planeNormal:Vector3, planePos:Vector3) : Vector3
}
IGUIState <|-- GUIState
GUIState --> "mousePosition" Vector2
GUIState --> "keyCode" KeyCode
GUIState --> "eventType" EventType
class GUISystem {
    + GUISystem(guiState:IGUIState)
    + AddControl(control:Control) : void
    + RemoveControl(control:Control) : void
    + AddAction(action:GUIAction) : void
    + RemoveAction(action:GUIAction) : void
    + OnGUI() : void
}
abstract class HoveredControlAction {
    + HoveredControlAction(control:Control)
}
GUIAction <|-- HoveredControlAction
HoveredControlAction --> "hoveredControl" Control
class SliderData <<struct>> {
}
interface IGUIState {
    mouseButton : int <<get>>
    clickCount : int <<get>> <<set>>
    isShiftDown : bool <<get>>
    isAltDown : bool <<get>>
    isActionKeyDown : bool <<get>>
    commandName : string <<get>>
    nearestControl : int <<get>> <<set>>
    hotControl : int <<get>> <<set>>
    changed : bool <<get>> <<set>>
    GetControlID(hint:int, focusType:FocusType) : int
    AddControl(controlID:int, distance:float) : void
    Slider(id:int, sliderData:SliderData, newPosition:Vector3) : bool
    UseEvent() : void
    Repaint() : void
    HasCurrentCamera() : bool
    GetHandleSize(position:Vector3) : float
    DistanceToSegment(p1:Vector3, p2:Vector3) : float
    DistanceToCircle(center:Vector3, radius:float) : float
    GUIToWorld(guiPosition:Vector2, planeNormal:Vector3, planePos:Vector3) : Vector3
}
SliderData --> "position" Vector3
SliderData --> "forward" Vector3
SliderData --> "up" Vector3
SliderData --> "right" Vector3
SliderData o-> "zero" SliderData
IGUIState --> "mousePosition" Vector2
IGUIState --> "keyCode" KeyCode
IGUIState --> "eventType" EventType
class LayoutData <<struct>> {
    + index : int
    + distance : float
    + userData : object
    + {static} Nearest(currentData:LayoutData, newData:LayoutData) : LayoutData
}
LayoutData --> "position" Vector3
LayoutData --> "forward" Vector3
LayoutData --> "up" Vector3
LayoutData --> "right" Vector3
LayoutData o-> "zero" LayoutData
class SliderAction {
    + SliderAction(control:Control)
}
class "Action`3"<T1,T2,T3> {
}
ClickAction <|-- SliderAction
SliderAction --> "onSliderBegin<IGUIState,Control,Vector3>" "Action`3"
SliderAction --> "onSliderChanged<IGUIState,Control,Vector3>" "Action`3"
SliderAction --> "onSliderEnd<IGUIState,Control,Vector3>" "Action`3"
class Layer <<static>> {
    + {static} CreateBackgroundLayer(w:int, h:int) : BitmapLayer
}
class BitmapLayer {
    width : int
    height : int
    + Dispose() : void
    + BitmapLayer(w:int, h:int)
    + LayerID : int <<get>> <<set>>
    + IsGroup : bool <<get>> <<set>>
    + Name : string <<get>> <<set>>
    + Opacity : byte <<get>> <<set>>
    + Visible : bool <<get>> <<set>>
}
class "List`1"<T> {
}
BitmapLayer --> "Bounds" Rectangle
BitmapLayer --> "ParentLayer" BitmapLayer
BitmapLayer --> "ChildLayer<BitmapLayer>" "List`1"
BitmapLayer --> "BlendMode" LayerBlendMode
BitmapLayer --> "Surface" Surface
class Document {
    + width : int
    + height : int
    + Document(w:int, h:int)
    + Dispose() : void
    + DpuX : double <<get>> <<set>>
    + DpuY : double <<get>> <<set>>
}
class "List`1"<T> {
}
Document --> "Layers<BitmapLayer>" "List`1"
Document --> "DpuUnit" MeasurementUnit
enum MeasurementUnit {
    Pixel= 1,
    Inch= 2,
    Centimeter= 3,
}
enum LayerBlendMode {
    Normal= 0,
    Multiply= 1,
    Additive= 2,
    ColorBurn= 3,
    ColorDodge= 4,
    Reflect= 5,
    Glow= 6,
    Overlay= 7,
    Difference= 8,
    Negation= 9,
    Lighten= 10,
    Darken= 11,
    Screen= 12,
    Xor= 13,
}
class PDNDecoderData <<struct>> {
    + SurfaceWidth : int
    + SurfaceHeight : int
    + SurfaceByteDepth : int
}
class PDNDecoderJob <<struct>> {
    + Execute(index:int) : void
}
class PDNAlphaMaskData <<struct>> {
    + SurfaceWidth : int
    + SurfaceHeight : int
    + SurfaceByteDepth : int
    + HasAlphaChannel : int
    + HasUserAlphaMask : int
    + UserMaskInvertOnBlend : int
    + HasLayerAlphaMask : int
    + LayerMaskInvertOnBlend : int
    + UserMaskBackgroundColor : byte
    + LayerMaskBackgroundColor : byte
}
class PDNAlphaMaskJob <<struct>> {
    + Execute() : void
}
class "NativeArray`1"<T> {
}
PDNDecoderData --> "DecoderType" DecodeType
PDNDecoderData --> "ColorChannel0<byte>" "NativeArray`1"
PDNDecoderData --> "ColorChannel1<byte>" "NativeArray`1"
PDNDecoderData --> "ColorChannel2<byte>" "NativeArray`1"
PDNDecoderData --> "ColorChannel3<byte>" "NativeArray`1"
PDNDecoderData --> "ColorModeData<byte>" "NativeArray`1"
PDNDecoderData --> "DecodedImage<Color32>" "NativeArray`1"
IJobParallelFor <|-- PDNDecoderJob
PDNDecoderJob --> "Data" PDNDecoderData
PDNAlphaMaskData --> "AlphaChannel0<byte>" "NativeArray`1"
PDNAlphaMaskData --> "UserMask<byte>" "NativeArray`1"
PDNAlphaMaskData --> "UserAlphaMask<byte>" "NativeArray`1"
PDNAlphaMaskData --> "UserAlphaMaskEmpty<byte>" "NativeArray`1"
PDNAlphaMaskData --> "LayerMask<byte>" "NativeArray`1"
PDNAlphaMaskData --> "LayerAlphaMask<byte>" "NativeArray`1"
PDNAlphaMaskData --> "LayerAlphaMaskEmpty<byte>" "NativeArray`1"
PDNAlphaMaskData --> "DecodedImage<Color32>" "NativeArray`1"
IJob <|-- PDNAlphaMaskJob
PDNAlphaMaskJob --> "Data" PDNAlphaMaskData
class Rectangle <<struct>> {
    + Rectangle(x:int, y:int, width:int, height:int)
    + {static} FromLTRB(left:int, top:int, right:int, bottom:int) : Rectangle
    + X : int <<get>> <<set>>
    + Y : int <<get>> <<set>>
    + Width : int <<get>> <<set>>
    + Height : int <<get>> <<set>>
    + Left : int <<get>>
    + Top : int <<get>>
    + Right : int <<get>>
    + Bottom : int <<get>>
    + IsEmpty : bool <<get>>
    + <<override>> Equals(obj:object) : bool
    + Contains(x:int, y:int) : bool
    + Contains(rect:Rectangle) : bool
    + <<override>> GetHashCode() : int
    + Inflate(width:int, height:int) : void
    + Inflate(size:Size) : void
    + {static} Inflate(rect:Rectangle, x:int, y:int) : Rectangle
    + Intersect(rect:Rectangle) : void
    + {static} Intersect(a:Rectangle, b:Rectangle) : Rectangle
    + IntersectsWith(rect:Rectangle) : bool
    + {static} Union(a:Rectangle, b:Rectangle) : Rectangle
    + Offset(x:int, y:int) : void
    + <<override>> ToString() : string
}
Rectangle o-> "Empty" Rectangle
Rectangle --> "Size" Size
class Size <<struct>> {
    + Size(width:int, height:int)
    + IsEmpty : bool <<get>>
    + Width : int <<get>> <<set>>
    + Height : int <<get>> <<set>>
}
Size o-> "Empty" Size
class Surface {
    + Surface(w:int, h:int)
    + Dispose() : void
    + width : int <<get>>
    + height : int <<get>>
}
class "NativeArray`1"<T> {
}
Surface --> "m_Color<Color32>" "NativeArray`1"
Surface --> "color<Color32>" "NativeArray`1"
class BlendModeMapping <<static>> {
    + {static} ToPsdBlendMode(pdnBlendMode:LayerBlendMode) : string
    + {static} FromPsdBlendMode(blendModeKey:string) : LayerBlendMode
}
class DocumentLoadContext {
    + DocumentLoadContext()
    + <<override>> OnLoadLayersHeader(psdFile:PsdFile) : void
    + <<override>> OnLoadLayerHeader(layer:PhotoshopFile.Layer) : void
}
LoadContext <|-- DocumentLoadContext
enum DecodeType {
    RGB32= 0,
    Grayscale32= 1,
    RGB= 2,
    CMYK= 3,
    Bitmap= 4,
    Grayscale= 5,
    Indexed= 6,
    Lab= 7,
}
class ImageDecoderPdn <<static>> {
    <<internal>> {static} RGBByteFromHDRFloat(ptr:float) : byte
    + {static} DecodeImage(pdnLayer:BitmapLayer, psdLayer:PhotoshopFile.Layer, inputDeps:JobHandle) : JobHandle
    + {static} DecodeImage(pdnLayer:BitmapLayer, psdLayer:PhotoshopFile.Layer) : void
}
class DecodeContext {
    + ByteDepth : int <<get>>
    + HasAlphaChannel : int <<get>>
    + DecodeContext(layer:PhotoshopFile.Layer, bounds:Rectangle)
    <<internal>> Cleanup() : void
}
class MaskDecodeContext {
    + MaskDecodeContext(mask:Mask, layerContext:DecodeContext)
    + IsRowEmpty(row:int) : bool
}
class "NativeArray`1"<T> {
}
ImageDecoderPdn +-- DecodeContext
DecodeContext --> "AlphaChannel<byte>" "NativeArray`1"
DecodeContext --> "ColorMode" PsdColorMode
DecodeContext --> "ColorModeData<byte>" "NativeArray`1"
DecodeContext --> "Rectangle" Rectangle
DecodeContext --> "LayerMaskContext" MaskDecodeContext
DecodeContext --> "UserMaskContext" MaskDecodeContext
ImageDecoderPdn +-- MaskDecodeContext
MaskDecodeContext --> "Mask" Mask
MaskDecodeContext --> "Rectangle" Rectangle
class PsdLoad <<static>> {
    + {static} Load(input:System.IO.Stream, loadFlag:ELoadFlag) : PsdFile
    + {static} Load(input:System.IO.Stream) : Document
    <<internal>> {static} DecodeToPdnLayer(psdLayer:PhotoshopFile.Layer, inputDeps:JobHandle, pdnLayer:BitmapLayer) : JobHandle
    <<internal>> {static} CheckSufficientMemory(psdFile:PsdFile) : void
}
class PsdInvalidException {
    + PsdInvalidException()
    + PsdInvalidException(message:string)
}
class RleException {
    + RleException()
    + RleException(message:string)
}
Exception <|-- PsdInvalidException
Exception <|-- RleException
enum ResourceID {
    Undefined= 0,
    MacPrintInfo= 1001,
    ResolutionInfo= 1005,
    AlphaChannelNames= 1006,
    DisplayInfo= 1007,
    Caption= 1008,
    BorderInfo= 1009,
    BackgroundColor= 1010,
    PrintFlags= 1011,
    MultichannelHalftoneInfo= 1012,
    ColorHalftoneInfo= 1013,
    DuotoneHalftoneInfo= 1014,
    MultichannelTransferFunctions= 1015,
    ColorTransferFunctions= 1016,
    DuotoneTransferFunctions= 1017,
    DuotoneImageInfo= 1018,
    BlackWhiteRange= 1019,
    EpsOptions= 1021,
    QuickMaskInfo= 1022,
    LayerStateInfo= 1024,
    WorkingPathUnsaved= 1025,
    LayersGroupInfo= 1026,
    IptcNaa= 1028,
    RawFormatImageMode= 1029,
    JpegQuality= 1030,
    GridGuidesInfo= 1032,
    ThumbnailBgr= 1033,
    CopyrightInfo= 1034,
    Url= 1035,
    ThumbnailRgb= 1036,
    GlobalAngle= 1037,
    ColorSamplersObsolete= 1038,
    IccProfile= 1039,
    Watermark= 1040,
    IccUntagged= 1041,
    EffectsVisible= 1042,
    SpotHalftone= 1043,
    DocumentSpecific= 1044,
    UnicodeAlphaNames= 1045,
    IndexedColorTableCount= 1046,
    TransparentIndex= 1047,
    GlobalAltitude= 1049,
    Slices= 1050,
    WorkflowUrl= 1051,
    JumpToXpep= 1052,
    AlphaIdentifiers= 1053,
    UrlList= 1054,
    VersionInfo= 1057,
    ExifData1= 1058,
    ExifData3= 1059,
    XmpMetadata= 1060,
    CaptionDigest= 1061,
    PrintScale= 1062,
    PixelAspectRatio= 1064,
    LayerComps= 1065,
    AlternateDuotoneColors= 1066,
    AlternateSpotColors= 1067,
    LayerSelectionIDs= 1069,
    HdrToningInfo= 1070,
    PrintInfo= 1071,
    LayerGroupsEnabled= 1072,
    ColorSamplers= 1073,
    MeasurementScale= 1074,
    TimelineInfo= 1075,
    SheetDisclosure= 1076,
    FloatDisplayInfo= 1077,
    OnionSkins= 1078,
    CountInfo= 1080,
    PrintSettingsInfo= 1082,
    PrintStyle= 1083,
    MacNSPrintInfo= 1084,
    WinDevMode= 1085,
    AutoSaveFilePath= 1086,
    AutoSaveFormat= 1087,
    PathInfo= 2000,
    ClippingPathName= 2999,
    LightroomWorkflow= 8000,
    PrintFlagsInfo= 10000,
}
abstract class ImageResource {
    + Signature : string <<get>> <<set>>
    + Name : string <<get>> <<set>>
}
class ImageResourceFactory <<static>> {
    + {static} CreateImageResource(reader:PsdBinaryReader) : ImageResource
}
class ImageResources {
    + ImageResources()
    + Get(id:ResourceID) : ImageResource
    + Set(resource:ImageResource) : void
}
class "List`1"<T> {
}
ImageResource --> "ID" ResourceID
"List`1" "<ImageResource>" <|-- ImageResources
class LoadContext {
    + LoadContext()
    + <<virtual>> OnLoadLayersHeader(psdFile:PsdFile) : void
    + <<virtual>> OnLoadLayerHeader(layer:Layer) : void
}
LoadContext --> "Encoding" Encoding
class PsdBinaryReader {
    + PsdBinaryReader(stream:Stream, reader:PsdBinaryReader)
    + PsdBinaryReader(stream:Stream, encoding:Encoding)
    + ReadByte() : byte
    + ReadBytes(count:int) : byte[]
    + ReadBoolean() : bool
    + ReadInt16() : Int16
    + ReadInt32() : Int32
    + ReadInt64() : Int64
    + ReadUInt16() : UInt16
    + ReadUInt32() : UInt32
    + ReadUInt64() : UInt64
    + ReadPadding(startPosition:long, padMultiple:int) : void
    + ReadRectangle() : Rectangle
    + ReadAsciiChars(count:int) : string
    + ReadPascalString(padMultiple:int) : string
    + ReadUnicodeString() : string
    + Dispose() : void
}
IDisposable <|-- PsdBinaryReader
PsdBinaryReader --> "BaseStream" Stream
class PsdBlendMode <<static>> {
    + <<const>> Normal : string = "norm"
    + <<const>> Darken : string = "dark"
    + <<const>> Lighten : string = "lite"
    + <<const>> Hue : string = "hue "
    + <<const>> Saturation : string = "sat "
    + <<const>> Color : string = "colr"
    + <<const>> Luminosity : string = "lum "
    + <<const>> Multiply : string = "mul "
    + <<const>> Screen : string = "scrn"
    + <<const>> Dissolve : string = "diss"
    + <<const>> Overlay : string = "over"
    + <<const>> HardLight : string = "hLit"
    + <<const>> SoftLight : string = "sLit"
    + <<const>> Difference : string = "diff"
    + <<const>> Exclusion : string = "smud"
    + <<const>> ColorDodge : string = "div "
    + <<const>> ColorBurn : string = "idiv"
    + <<const>> LinearBurn : string = "lbrn"
    + <<const>> LinearDodge : string = "lddg"
    + <<const>> VividLight : string = "vLit"
    + <<const>> LinearLight : string = "lLit"
    + <<const>> PinLight : string = "pLit"
    + <<const>> HardMix : string = "hMix"
    + <<const>> PassThrough : string = "pass"
    + <<const>> DarkerColor : string = "dkCl"
    + <<const>> LighterColor : string = "lgCl"
    + <<const>> Subtract : string = "fsub"
    + <<const>> Divide : string = "fdiv"
}
enum ELoadFlag {
    Header= 1,
    ColorMode= Header | 1 << 2,
    ImageData= ColorMode | 1 << 3,
    All= Header | ColorMode | ImageData,
}
enum PsdColorMode {
    Bitmap= 0,
    Grayscale= 1,
    Indexed= 2,
    RGB= 3,
    CMYK= 4,
    Multichannel= 7,
    Duotone= 8,
    Lab= 9,
}
enum PsdFileVersion {
    Psd= 1,
    PsbLargeDocument= 2,
}
class PsdFile {
    + PsdFile(version:PsdFileVersion)
    + PsdFile(filename:string, loadContext:LoadContext, loadFlag:ELoadFlag)
    + PsdFile(stream:Stream, loadContext:LoadContext, loadFlag:ELoadFlag)
    + IsLargeDocument : bool <<get>>
    + RowCount : int <<get>> <<set>>
    + ColumnCount : int <<get>> <<set>>
    + BitDepth : int <<get>> <<set>>
    + AbsoluteAlpha : bool <<get>> <<set>>
    <<internal>> LoadLayers(reader:PsdBinaryReader, hasHeader:bool) : void
    + Cleanup() : void
    <<internal>> VerifyLayerSections() : void
    + SetVersionInfo() : void
}
enum ImageCompression {
    Raw= 0,
    Rle= 1,
    Zip= 2,
    ZipPrediction= 3,
}
class "List`1"<T> {
}
PsdFile --> "m_LoadFlag" ELoadFlag
PsdFile --> "LoadContext" LoadContext
PsdFile --> "Version" PsdFileVersion
PsdFile --> "ChannelCount" Int16
PsdFile --> "ColorMode" PsdColorMode
PsdFile --> "ImageResources" ImageResources
PsdFile --> "Resolution" ResolutionInfo
PsdFile --> "Layers<Layer>" "List`1"
PsdFile --> "AdditionalInfo<LayerInfo>" "List`1"
PsdFile --> "BaseLayer" Layer
PsdFile --> "ImageCompression" ImageCompression
class RleReader {
    + RleReader(stream:Stream)
    + Read(buffer:byte[], offset:int, count:int) : int
}
class RleRowLengths {
    + Total : long <<get>>
    + RleRowLengths(rowCount:int)
    + RleRowLengths(reader:PsdBinaryReader, rowCount:int, isLargeDocument:bool)
}
class RleWriter {
    + RleWriter(stream:Stream)
    + Write(data:byte[], offset:int, count:int) : int
}
class Util <<static>> {
    + {static} IntersectWith(thisRect:Rectangle, rect:Rectangle) : Rectangle
    {static} + Fill(ptr:byte[], start:int, end:int, value:byte) : void
    {static} + Invert(ptr:byte[], ptrStart:int, ptrEnd:int) : void
    {static} + Fill(ptr:NativeArray<byte>, start:int, end:int, value:byte) : void
    {static} + Invert(ptr:NativeArray<byte>, ptrStart:int, ptrEnd:int) : void
    {static} + SwapBytes2(ptr:byte[], start:int) : void
    {static} + SwapBytes4(ptr:byte[], start:int) : void
    {static} + SwapBytes(ptr:byte[], start:int, nLength:int) : void
    + {static} SwapByteArray(bitDepth:int, byteArray:byte[], startIdx:int, count:int) : void
    + {static} SwapByteArray2(byteArray:byte[], startIdx:int, count:int) : void
    + {static} SwapByteArray4(byteArray:byte[], startIdx:int, count:int) : void
    + {static} BytesPerRow(size:Size, bitDepth:int) : int
    + {static} RoundUp(value:int, multiple:int) : int
    + {static} GetPadding(length:int, padMultiple:int) : int
    + {static} BytesFromBitDepth(depth:int) : int
    + {static} MinChannelCount(colorMode:PsdColorMode) : short
    + {static} CheckBufferBounds(data:byte[], offset:int, count:int) : bool
    + {static} CheckByteArrayLength(length:long) : void
    + {static} DebugMessage(stream:Stream, message:string, args:object[]) : void
}
class UFixed16_16 {
    + UFixed16_16(integer:UInt16, fraction:UInt16)
    + UFixed16_16(value:UInt32)
    + UFixed16_16(value:double)
}
class RectanglePosition <<struct>> {
    + Top : int <<get>> <<set>>
    + Bottom : int <<get>> <<set>>
    + Left : int <<get>> <<set>>
    + Right : int <<get>> <<set>>
}
UFixed16_16 --> "Integer" UInt16
UFixed16_16 --> "Fraction" UInt16
Util +-- RectanglePosition
class "Dict`1"<TValue> {
    + Dict(leq:LessOrEqual)
    + Insert(key:TValue) : Node
    + InsertBefore(node:Node, key:TValue) : Node
    + Find(key:TValue) : Node
    + Min() : Node
    + Remove(node:Node) : void
}
class Node {
}
"Dict`1" --> "_head" Node
"Dict`1" +-- Node
Node --> "_key" TValue
Node --> "_prev" Node
Node --> "_next" Node
Node --> "Key" TValue
Node --> "Prev" Node
Node --> "Next" Node
class Geom <<static>> {
    + {static} IsWindingInside(rule:WindingRule, n:int) : bool
    + {static} VertCCW(u:MeshUtils.Vertex, v:MeshUtils.Vertex, w:MeshUtils.Vertex) : bool
    + {static} VertEq(lhs:MeshUtils.Vertex, rhs:MeshUtils.Vertex) : bool
    + {static} VertLeq(lhs:MeshUtils.Vertex, rhs:MeshUtils.Vertex) : bool
    + {static} EdgeEval(u:MeshUtils.Vertex, v:MeshUtils.Vertex, w:MeshUtils.Vertex) : Real
    + {static} EdgeSign(u:MeshUtils.Vertex, v:MeshUtils.Vertex, w:MeshUtils.Vertex) : Real
    + {static} TransLeq(lhs:MeshUtils.Vertex, rhs:MeshUtils.Vertex) : bool
    + {static} TransEval(u:MeshUtils.Vertex, v:MeshUtils.Vertex, w:MeshUtils.Vertex) : Real
    + {static} TransSign(u:MeshUtils.Vertex, v:MeshUtils.Vertex, w:MeshUtils.Vertex) : Real
    + {static} EdgeGoesLeft(e:MeshUtils.Edge) : bool
    + {static} EdgeGoesRight(e:MeshUtils.Edge) : bool
    + {static} VertL1dist(u:MeshUtils.Vertex, v:MeshUtils.Vertex) : Real
    + {static} AddWinding(eDst:MeshUtils.Edge, eSrc:MeshUtils.Edge) : void
    + {static} Interpolate(a:Real, x:Real, b:Real, y:Real) : Real
    {static} Swap(a:MeshUtils.Vertex, b:MeshUtils.Vertex) : void
    + {static} EdgeIntersect(o1:MeshUtils.Vertex, d1:MeshUtils.Vertex, o2:MeshUtils.Vertex, d2:MeshUtils.Vertex, v:MeshUtils.Vertex) : void
}
class Mesh {
    + Mesh()
    + <<override>> Reset() : void
    + <<override>> OnFree() : void
    + MakeEdge() : MeshUtils.Edge
    + Splice(eOrg:MeshUtils.Edge, eDst:MeshUtils.Edge) : void
    + Delete(eDel:MeshUtils.Edge) : void
    + AddEdgeVertex(eOrg:MeshUtils.Edge) : MeshUtils.Edge
    + SplitEdge(eOrg:MeshUtils.Edge) : MeshUtils.Edge
    + Connect(eOrg:MeshUtils.Edge, eDst:MeshUtils.Edge) : MeshUtils.Edge
    + ZapFace(fZap:MeshUtils.Face) : void
    + MergeConvexFaces(maxVertsPerFace:int) : void
    + Check() : void
}
class "Pooled`1"<T> {
}
class Vec3 <<struct>> {
    + {static} Sub(lhs:Vec3, rhs:Vec3, result:Vec3) : void
    + {static} Neg(v:Vec3) : void
    + {static} Dot(u:Vec3, v:Vec3, dot:Real) : void
    + {static} Normalize(v:Vec3) : void
    + {static} LongAxis(v:Vec3) : int
    + <<override>> ToString() : string
}
class MeshUtils <<static>> {
    + <<const>> Undef : int
    + {static} MakeEdge(eNext:Edge) : Edge
    + {static} Splice(a:Edge, b:Edge) : void
    + {static} MakeVertex(eOrig:Edge, vNext:Vertex) : void
    + {static} MakeFace(eOrig:Edge, fNext:Face) : void
    + {static} KillEdge(eDel:Edge) : void
    + {static} KillVertex(vDel:Vertex, newOrg:Vertex) : void
    + {static} KillFace(fDel:Face, newLFace:Face) : void
    + {static} FaceArea(f:Face) : Real
}
abstract class "Pooled`1"<T> {
    + {abstract} Reset() : void
    + <<virtual>> OnFree() : void
    + {static} Create() : T
    + Free() : void
}
class Vertex {
    <<internal>> _n : int
    <<internal>> _data : object
    + <<override>> Reset() : void
}
class Face {
    <<internal>> _n : int
    <<internal>> _marked : bool
    <<internal>> _inside : bool
    <<internal>> VertsCount : int <<get>>
    + <<override>> Reset() : void
}
class EdgePair <<struct>> {
    + {static} Create() : EdgePair
    + Reset() : void
}
class Edge {
    <<internal>> _winding : int
    <<internal>> {static} EnsureFirst(e:Edge) : void
    + <<override>> Reset() : void
}
Vec3 o-> "Zero" Vec3
Vec3 --> "X" Real
Vec3 --> "Y" Real
Vec3 --> "Z" Real
MeshUtils +-- "Pooled`1"
MeshUtils +-- Vertex
"Pooled`1" "<Vertex>" <|-- Vertex
Vertex --> "_prev" Vertex
Vertex --> "_next" Vertex
Vertex --> "_anEdge" Edge
Vertex --> "_coords" Vec3
Vertex --> "_s" Real
Vertex --> "_t" Real
Vertex --> "_pqHandle" PQHandle
MeshUtils +-- Face
"Pooled`1" "<Face>" <|-- Face
Face --> "_prev" Face
Face --> "_next" Face
Face --> "_anEdge" Edge
Face --> "_trail" Face
MeshUtils +-- EdgePair
EdgePair --> "_e" Edge
EdgePair --> "_eSym" Edge
MeshUtils +-- Edge
"Pooled`1" "<Edge>" <|-- Edge
Edge --> "_pair" EdgePair
Edge --> "_next" Edge
Edge --> "_Sym" Edge
Edge --> "_Onext" Edge
Edge --> "_Lnext" Edge
Edge --> "_Org" Vertex
Edge --> "_Lface" Face
Edge --> "_Rface" Face
Edge --> "_Dst" Vertex
Edge --> "_Oprev" Edge
Edge --> "_Lprev" Edge
Edge --> "_Dprev" Edge
Edge --> "_Rprev" Edge
Edge --> "_Dnext" Edge
Edge --> "_Rnext" Edge
class PQHandle <<struct>> {
    + {static} <<readonly>> Invalid : int = 0x0fffffff
    <<internal>> _handle : int
}
class "PriorityHeap`1"<TValue> {
    + Empty : bool <<get>>
    + PriorityHeap(initialSize:int, leq:LessOrEqual)
    + Init() : void
    + Insert(value:TValue) : PQHandle
    + ExtractMin() : TValue
    + Minimum() : TValue
    + Remove(handle:PQHandle) : void
}
class HandleElem {
    <<internal>> _node : int
}
"PriorityHeap`1" +-- HandleElem
HandleElem --> "_key" TValue
class "PriorityQueue`1"<TValue> {
    + Empty : bool <<get>>
    + PriorityQueue(initialSize:int, leq:PriorityHeap<TValue>.LessOrEqual)
    {static} Swap(a:int, b:int) : void
    + Init() : void
    + Insert(value:TValue) : PQHandle
    + ExtractMin() : TValue
    + Minimum() : TValue
    + Remove(handle:PQHandle) : void
}
class StackItem {
    <<internal>> p : int
    <<internal>> r : int
}
"PriorityQueue`1" +-- StackItem
class Tess <<partial>> {
}
class ActiveRegion {
    <<internal>> _windingNumber : int
    <<internal>> _inside : bool
    <<internal>> _sentinel : bool
    <<internal>> _dirty : bool
    <<internal>> _fixUpperEdge : bool
}
Tess +-- ActiveRegion
enum WindingRule {
    EvenOdd,
    NonZero,
    Positive,
    Negative,
    AbsGeqTwo,
}
enum ElementType {
    Polygons,
    ConnectedPolygons,
    BoundaryContours,
}
enum ContourOrientation {
    Original,
    Clockwise,
    CounterClockwise,
}
class ContourVertex <<struct>> {
    + Data : object
    + <<override>> ToString() : string
}
class Tess <<partial>> {
    + NoEmptyPolygons : bool = false
    + UsePooling : bool = false
    + VertexCount : int <<get>>
    + ElementCount : int <<get>>
    + Tess()
    + AddContour(vertices:ContourVertex[]) : void
    + AddContour(vertices:ContourVertex[], forceOrientation:ContourOrientation) : void
    + Tessellate(windingRule:WindingRule, elementType:ElementType, polySize:int) : void
    + Tessellate(windingRule:WindingRule, elementType:ElementType, polySize:int, combineCallback:CombineCallback) : void
}
ContourVertex --> "Position" Vec3
Tess --> "Normal" Vec3
Tess o-> "SUnitX" Real
Tess o-> "SUnitY" Real
Tess o-> "SentinelCoord" Real
class DoublePoint <<struct>> {
    + X : double
    + Y : double
    + DoublePoint(x:double, y:double)
    + DoublePoint(dp:DoublePoint)
    + DoublePoint(ip:IntPoint)
}
class PolyTree {
    + Clear() : void
    + GetFirst() : PolyNode
    + Total : int <<get>>
}
class PolyNode {
    <<internal>> m_Index : int
    + ChildCount : int <<get>>
    <<internal>> AddChild(Child:PolyNode) : void
    + GetNext() : PolyNode
    <<internal>> GetNextSiblingUp() : PolyNode
    + IsHole : bool <<get>>
    + IsOpen : bool <<get>> <<set>>
}
class Int128 <<struct>> {
    + Int128(_lo:Int64)
    + Int128(_hi:Int64, _lo:UInt64)
    + Int128(val:Int128)
    + IsNegative() : bool
    + <<override>> Equals(obj:System.Object) : bool
    + <<override>> GetHashCode() : int
    + {static} Int128Mul(lhs:Int64, rhs:Int64) : Int128
}
class IntPoint <<struct>> {
    + IntPoint(X:cInt, Y:cInt)
    + IntPoint(x:double, y:double)
    + IntPoint(pt:IntPoint)
    + <<override>> Equals(obj:object) : bool
    + <<override>> GetHashCode() : int
}
class IntRect <<struct>> {
    + IntRect(l:cInt, t:cInt, r:cInt, b:cInt)
    + IntRect(ir:IntRect)
}
enum ClipType {
    ctIntersection,
    ctUnion,
    ctDifference,
    ctXor,
}
enum PolyType {
    ptSubject,
    ptClip,
}
enum PolyFillType {
    pftEvenOdd,
    pftNonZero,
    pftPositive,
    pftNegative,
}
enum JoinType {
    jtSquare,
    jtRound,
    jtMiter,
}
enum EndType {
    etClosedPolygon,
    etClosedLine,
    etOpenButt,
    etOpenSquare,
    etOpenRound,
}
enum EdgeSide {
    esLeft,
    esRight,
}
enum Direction {
    dRightToLeft,
    dLeftToRight,
}
class TEdge {
    <<internal>> Dx : double
    <<internal>> WindDelta : int
    <<internal>> WindCnt : int
    <<internal>> WindCnt2 : int
    <<internal>> OutIdx : int
}
class IntersectNode {
}
class MyIntersectNodeSort {
    + Compare(node1:IntersectNode, node2:IntersectNode) : int
}
class LocalMinima {
}
class Scanbeam {
}
class Maxima {
}
class OutRec {
    <<internal>> Idx : int
    <<internal>> IsHole : bool
    <<internal>> IsOpen : bool
}
class OutPt {
    <<internal>> Idx : int
}
class Join {
}
class ClipperBase {
    <<internal>> <<const>> horizontal : double
    <<internal>> <<const>> Skip : int
    <<internal>> <<const>> Unassigned : int
    <<internal>> <<const>> tolerance : double = 1.0E-20
    <<internal>> {static} near_zero(val:double) : bool
    <<internal>> m_UseFullRange : bool
    <<internal>> m_HasOpenPaths : bool
    + PreserveCollinear : bool <<get>> <<set>>
    + Swap(val1:cInt, val2:cInt) : void
    <<internal>> {static} IsHorizontal(e:TEdge) : bool
    <<internal>> PointIsVertex(pt:IntPoint, pp:OutPt) : bool
    <<internal>> PointOnLineSegment(pt:IntPoint, linePt1:IntPoint, linePt2:IntPoint, UseFullRange:bool) : bool
    <<internal>> PointOnPolygon(pt:IntPoint, pp:OutPt, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(e1:TEdge, e2:TEdge, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint, UseFullRange:bool) : bool
    <<internal>> {static} SlopesEqual(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint, pt4:IntPoint, UseFullRange:bool) : bool
    <<internal>> ClipperBase()
    + <<virtual>> Clear() : void
    RangeTest(Pt:IntPoint, useFullRange:bool) : void
    + AddPath(pg:Path, polyType:PolyType, Closed:bool) : bool
    + AddPaths(ppg:Paths, polyType:PolyType, closed:bool) : bool
    <<internal>> Pt2IsBetweenPt1AndPt3(pt1:IntPoint, pt2:IntPoint, pt3:IntPoint) : bool
    RemoveEdge(e:TEdge) : TEdge
    <<internal>> PopLocalMinima(Y:cInt, current:LocalMinima) : Boolean
    <<internal>> <<virtual>> Reset() : void
    + {static} GetBounds(paths:Paths) : IntRect
    <<internal>> InsertScanbeam(Y:cInt) : void
    <<internal>> PopScanbeam(Y:cInt) : Boolean
    <<internal>> LocalMinimaPending() : Boolean
    <<internal>> CreateOutRec() : OutRec
    <<internal>> DisposeOutRec(index:int) : void
    <<internal>> UpdateEdgeIntoAEL(e:TEdge) : void
    <<internal>> SwapPositionsInAEL(edge1:TEdge, edge2:TEdge) : void
    <<internal>> DeleteFromAEL(e:TEdge) : void
}
class Clipper {
    + <<const>> ioReverseSolution : int = 1
    + <<const>> ioStrictlySimple : int = 2
    + <<const>> ioPreserveCollinear : int = 4
    + Clipper(InitOptions:int)
    + ReverseSolution : bool <<get>> <<set>>
    + StrictlySimple : bool <<get>> <<set>>
    + Execute(clipType:ClipType, solution:Paths, FillType:PolyFillType) : bool
    + Execute(clipType:ClipType, polytree:PolyTree, FillType:PolyFillType) : bool
    + Execute(clipType:ClipType, solution:Paths, subjFillType:PolyFillType, clipFillType:PolyFillType) : bool
    + Execute(clipType:ClipType, polytree:PolyTree, subjFillType:PolyFillType, clipFillType:PolyFillType) : bool
    <<internal>> FixHoleLinkage(outRec:OutRec) : void
    <<internal>> PopEdgeFromSEL(e:TEdge) : Boolean
    <<internal>> SwapPoints(pt1:IntPoint, pt2:IntPoint) : void
    OutRec1RightOfOutRec2(outRec1:OutRec, outRec2:OutRec) : bool
    GetHorzDirection(HorzEdge:TEdge, Dir:Direction, Left:cInt, Right:cInt) : void
    <<internal>> GetMaximaPair(e:TEdge) : TEdge
    <<internal>> GetMaximaPairEx(e:TEdge) : TEdge
    <<internal>> {static} Round(value:double) : cInt
    + {static} ReversePaths(polys:Paths) : void
    + {static} Orientation(poly:Path) : bool
    DupOutPt(outPt:OutPt, InsertAfter:bool) : OutPt
    GetOverlap(a1:cInt, a2:cInt, b1:cInt, b2:cInt, Left:cInt, Right:cInt) : bool
    JoinHorz(op1:OutPt, op1b:OutPt, op2:OutPt, op2b:OutPt, Pt:IntPoint, DiscardLeft:bool) : bool
    + {static} PointInPolygon(pt:IntPoint, path:Path) : int
    + {static} Area(poly:Path) : double
    <<internal>> Area(outRec:OutRec) : double
    <<internal>> Area(op:OutPt) : double
    + {static} SimplifyPolygon(poly:Path, fillType:PolyFillType) : Paths
    + {static} SimplifyPolygons(polys:Paths, fillType:PolyFillType) : Paths
    + {static} CleanPolygon(path:Path, distance:double) : Path
    + {static} CleanPolygons(polys:Paths, distance:double) : Paths
    <<internal>> {static} Minkowski(pattern:Path, path:Path, IsSum:bool, IsClosed:bool) : Paths
    + {static} MinkowskiSum(pattern:Path, path:Path, pathIsClosed:bool) : Paths
    + {static} MinkowskiSum(pattern:Path, paths:Paths, pathIsClosed:bool) : Paths
    + {static} MinkowskiDiff(poly1:Path, poly2:Path) : Paths
    + {static} PolyTreeToPaths(polytree:PolyTree) : Paths
    <<internal>> {static} AddPolyNodeToPaths(polynode:PolyNode, nt:NodeType, paths:Paths) : void
    + {static} OpenPathsFromPolyTree(polytree:PolyTree) : Paths
    + {static} ClosedPathsFromPolyTree(polytree:PolyTree) : Paths
}
class ClipperOffset {
    + ArcTolerance : double <<get>> <<set>>
    + MiterLimit : double <<get>> <<set>>
    + ClipperOffset(miterLimit:double, arcTolerance:double)
    + Clear() : void
    <<internal>> {static} Round(value:double) : cInt
    + AddPath(path:Path, joinType:JoinType, endType:EndType) : void
    + AddPaths(paths:Paths, joinType:JoinType, endType:EndType) : void
    <<internal>> {static} GetUnitNormal(pt1:IntPoint, pt2:IntPoint) : DoublePoint
    + Execute(solution:Paths, delta:double) : void
    + Execute(solution:PolyTree, delta:double) : void
    OffsetPoint(j:int, k:int, jointype:JoinType) : void
    <<internal>> DoSquare(j:int, k:int) : void
    <<internal>> DoMiter(j:int, k:int, r:double) : void
    <<internal>> DoRound(j:int, k:int) : void
}
class ClipperException {
    + ClipperException(description:string)
}
class "List`1"<T> {
}
class "IComparer`1"<T> {
}
enum NodeType {
    ntAny,
    ntOpen,
    ntClosed,
}
PolyNode <|-- PolyTree
PolyTree o-> "m_AllPolys<PolyNode>" "List`1"
PolyNode --> "m_Parent" PolyNode
PolyNode o-> "m_polygon" Path
PolyNode --> "m_jointype" JoinType
PolyNode --> "m_endtype" EndType
PolyNode o-> "m_Childs<PolyNode>" "List`1"
PolyNode --> "Contour" Path
PolyNode --> "Childs<PolyNode>" "List`1"
PolyNode --> "Parent" PolyNode
IntPoint --> "X" cInt
IntPoint --> "Y" cInt
IntRect --> "left" cInt
IntRect --> "top" cInt
IntRect --> "right" cInt
IntRect --> "bottom" cInt
TEdge --> "Bot" IntPoint
TEdge --> "Curr" IntPoint
TEdge --> "Top" IntPoint
TEdge --> "Delta" IntPoint
TEdge --> "PolyTyp" PolyType
TEdge --> "Side" EdgeSide
TEdge --> "Next" TEdge
TEdge --> "Prev" TEdge
TEdge --> "NextInLML" TEdge
TEdge --> "NextInAEL" TEdge
TEdge --> "PrevInAEL" TEdge
TEdge --> "NextInSEL" TEdge
TEdge --> "PrevInSEL" TEdge
IntersectNode --> "Edge1" TEdge
IntersectNode --> "Edge2" TEdge
IntersectNode --> "Pt" IntPoint
"IComparer`1" "<IntersectNode>" <|-- MyIntersectNodeSort
LocalMinima --> "Y" cInt
LocalMinima --> "LeftBound" TEdge
LocalMinima --> "RightBound" TEdge
LocalMinima --> "Next" LocalMinima
Scanbeam --> "Y" cInt
Scanbeam --> "Next" Scanbeam
Maxima --> "X" cInt
Maxima --> "Next" Maxima
Maxima --> "Prev" Maxima
OutRec --> "FirstLeft" OutRec
OutRec --> "Pts" OutPt
OutRec --> "BottomPt" OutPt
OutRec --> "PolyNode" PolyNode
OutPt --> "Pt" IntPoint
OutPt --> "Next" OutPt
OutPt --> "Prev" OutPt
Join --> "OutPt1" OutPt
Join --> "OutPt2" OutPt
Join --> "OffPt" IntPoint
ClipperBase o-> "loRange" cInt
ClipperBase o-> "hiRange" cInt
ClipperBase --> "m_MinimaList" LocalMinima
ClipperBase --> "m_CurrentLM" LocalMinima
ClipperBase o-> "m_edges<List<TEdge>>" "List`1"
ClipperBase --> "m_Scanbeam" Scanbeam
ClipperBase --> "m_PolyOuts<OutRec>" "List`1"
ClipperBase --> "m_ActiveEdges" TEdge
ClipperBase <|-- Clipper
Clipper --> "m_IntersectNodeComparer<IntersectNode>" "IComparer`1"
Exception <|-- ClipperException
Clipper +-- NodeType
class ConformingSpline {
    Start() : void
    Update() : void
}
MonoBehaviour <|-- ConformingSpline
ConformingSpline --> "m_ParentObject" GameObject
class GenerateSpriteShapes {
    + destroyOnCompletion : bool = true
    OnGUI() : void
}
MonoBehaviour <|-- GenerateSpriteShapes
class GeometryCollider {
    m_UpdateCollider : bool = false
    m_HashCode : int = 0
    Start() : void
    Update() : void
    {static} + Bake(go:GameObject, forced:bool) : void
    {static} OuterEdges(polygonCollider:PolygonCollider2D, triangles:NativeArray<ushort>, vertices:NativeSlice<Vector3>, triangleCount:int) : void
}
MonoBehaviour <|-- GeometryCollider
enum ColliderCornerType {
    Square,
    Round,
    Sharp,
}
class LegacyCollider {
    m_ColliderOffset : float = 1.0f
    m_UpdateCollider : bool = false
    <<const>> s_ClipperScale : float = 100000.0f
    m_HashCode : int = 0
    Start() : void
    Update() : void
    {static} SampleCurve(colliderDetail:float, startPoint:Vector3, startTangent:Vector3, endPoint:Vector3, endTangent:Vector3, path:List<IntPoint>) : void
    + {static} Bake(go:GameObject, forced:bool) : void
}
MonoBehaviour <|-- LegacyCollider
LegacyCollider o-> "m_ColliderCornerType" ColliderCornerType
class SimpleDraw {
    + minimumDistance : float = 1.0f
    Start() : void
    Update() : void
}
MonoBehaviour <|-- SimpleDraw
class Sprinkler {
    + m_RandomFactor : float = 10.0f
    + m_UseNormals : bool = false
    Angle(a:Vector3, b:Vector3) : float
    Start() : void
    Update() : void
}
MonoBehaviour <|-- Sprinkler
Sprinkler --> "m_Prefab" GameObject
class CollabHistoryPresenter {
    + <<const>> ItemsPerPage : int = 5
    m_IsCollabError : bool
    m_TotalRevisions : int
    m_CurrentPage : int
    m_RequestedPage : int
    m_FetchInProgress : bool
    m_ProgressRevision : string
    + BuildServiceEnabled : bool <<get>> <<set>>
    + CollabHistoryPresenter(window:ICollabHistoryWindow, factory:ICollabHistoryItemFactory, service:IRevisionsService)
    + OnWindowEnabled() : void
    + OnWindowDisabled() : void
    + UpdateBuildServiceStatus() : void
    + ShowBuildForCommit(revisionID:string) : void
    + ShowServicePage() : void
    + OnUpdatePage(page:int) : void
}
CollabHistoryPresenter --> "m_Window" ICollabHistoryWindow
CollabHistoryPresenter --> "m_Factory" ICollabHistoryItemFactory
CollabHistoryPresenter --> "m_Service" IRevisionsService
CollabHistoryPresenter --> "m_ConnectState" ConnectInfo
CollabHistoryPresenter --> "m_CollabState" CollabInfo
CollabHistoryPresenter --> "m_BuildAccess" BuildAccess
class BuildStatusButton {
    + BuildStatusButton(clickEvent:Action)
    + BuildStatusButton(clickEvent:Action, state:BuildState, failures:int)
}
Button <|-- BuildStatusButton
BuildStatusButton o-> "labelElement" Label
BuildStatusButton o-> "iconElement" Image
class CollabHistoryDropDown {
    + CollabHistoryDropDown(changes:ICollection<ChangeData>, changesTotal:int, changesTruncated:bool, revisionId:string)
}
VisualElement <|-- CollabHistoryDropDown
class CollabHistoryDropDownItem {
    + CollabHistoryDropDownItem(path:string, action:string)
}
VisualElement <|-- CollabHistoryDropDownItem
class CollabHistoryItem {
    + RevisionActionsEnabled : bool <<set>>
    + CollabHistoryItem(data:RevisionData)
    + {static} SetUpCallbacks(Restore:RevisionAction, GoBack:RevisionAction, Update:RevisionAction) : void
    + SetInProgressStatus(revisionIdInProgress:string) : void
    ShowBuildForCommit() : void
    ShowServicePage() : void
    Restore() : void
    GoBackTo() : void
    UpdateTo() : void
    UpdateTimeAgo() : void
    ShouldTruncateDescription(description:string) : bool
    GetTruncatedDescription(description:string) : string
    ToggleDescription() : void
}
VisualElement <|-- CollabHistoryItem
CollabHistoryItem --> "s_OnRestore" RevisionAction
CollabHistoryItem --> "s_OnGoBack" RevisionAction
CollabHistoryItem --> "s_OnUpdate" RevisionAction
CollabHistoryItem --> "s_OnShowBuild" ShowBuildAction
CollabHistoryItem --> "s_OnShowServices" Action
CollabHistoryItem --> "timeStamp" DateTime
class CollabHistoryItemFactory {
    <<const>> k_MaxChangesPerRevision : int = 10
    + GenerateElements(revisions:IEnumerable<Revision>, totalRevisions:int, startIndex:int, tipRev:string, inProgressRevision:string, revisionActionsEnabled:bool, buildServiceEnabled:bool, currentUser:string) : IEnumerable<RevisionData>
}
ICollabHistoryItemFactory <|-- CollabHistoryItemFactory
class CollabHistoryRevisionLine {
    + CollabHistoryRevisionLine(number:int)
    + CollabHistoryRevisionLine(date:DateTime, isFullDateObtained:bool)
}
VisualElement <|-- CollabHistoryRevisionLine
class HistoryProgressSpinner {
    + ProgressEnabled : bool <<set>>
    + HistoryProgressSpinner()
}
Image <|-- HistoryProgressSpinner
interface ICollabHistoryItemFactory {
    GenerateElements(revsRevisions:IEnumerable<Revision>, mTotalRevisions:int, startIndex:int, tipRev:string, inProgressRevision:string, revisionActionsEnabled:bool, buildServiceEnabled:bool, currentUser:string) : IEnumerable<RevisionData>
}
interface IPagerData {
    curPage : int <<get>>
    totalPages : int <<get>>
}
class PagerElement {
    + PagerElement(dataSource:IPagerData)
    OnPageDownClicked() : void
    OnPageUpClicked() : void
    + Refresh() : void
    UpdateControls() : void
}
enum PagerLocation {
    Top,
    Bottom,
}
class PagedListView {
    + <<const>> DefaultItemsPerPage : int = 10
    m_PageSize : int
    m_TotalItems : int
    m_CurPage : int
    + pageSize : int <<set>>
    + totalItems : int <<set>>
    + PagedListView()
    LayoutItems() : void
    UpdatePager() : void
    pageCount : int <<get>>
    + curPage : int <<get>> <<set>>
    + totalPages : int <<get>>
}
class "IEnumerable`1"<T> {
}
IPagerData --> "OnPageChanged" PageChangeAction
VisualElement <|-- PagerElement
PagerElement --> "m_Data" IPagerData
PagerElement --> "m_PageText" Label
PagerElement --> "m_DownButton" Button
PagerElement --> "m_UpButton" Button
VisualElement <|-- PagedListView
IPagerData <|-- PagedListView
PagedListView --> "m_ItemContainer" VisualElement
PagedListView --> "m_PagerTop" PagerElement
PagedListView --> "m_PagerBottom" PagerElement
PagedListView --> "m_Items<VisualElement>" "IEnumerable`1"
PagedListView --> "items<VisualElement>" "IEnumerable`1"
PagedListView --> "OnPageChanged" PageChangeAction
class StatusView {
    + message : string <<get>> <<set>>
    + buttonText : string <<get>> <<set>>
    + StatusView()
}
VisualElement <|-- StatusView
StatusView --> "m_Image" Image
StatusView --> "m_Message" Label
StatusView --> "m_Button" Button
StatusView --> "m_Callback" Action
StatusView --> "icon" Texture
StatusView --> "callback" Action
class RiderAssetPostprocessor {
    + {static} OnPreGeneratingCSProjectFiles() : bool
}
AssetPostprocessor <|-- RiderAssetPostprocessor
class FileIOProvider {
    + Exists(fileName:string) : bool
    + ReadAllText(fileName:string) : string
    + WriteAllText(fileName:string, content:string) : void
}
IFileIO <|-- FileIOProvider
class GUIDProvider {
    + ProjectGuid(projectName:string, assemblyName:string) : string
    + SolutionGuid(projectName:string, extension:string) : string
}
IGUIDGenerator <|-- GUIDProvider
interface IGenerator {
    SyncIfNeeded(affectedFiles:IEnumerable<string>, reimportedFiles:IEnumerable<string>) : bool
    Sync() : void
    HasSolutionBeenGenerated() : bool
    SolutionFile() : string
    ProjectDirectory : string <<get>>
    GenerateAll(generateAll:bool) : void
}
interface IFileIO {
    Exists(fileName:string) : bool
    ReadAllText(fileName:string) : string
    WriteAllText(fileName:string, content:string) : void
}
interface IGUIDGenerator {
    ProjectGuid(projectName:string, assemblyName:string) : string
    SolutionGuid(projectName:string, extension:string) : string
}
interface IAssemblyNameProvider {
    GetAssemblyNameFromScriptPath(path:string) : string
    GetAssemblies(shouldFileBePartOfSolution:Func<string, bool>) : IEnumerable<Assembly>
    GetAllAssetPaths() : IEnumerable<string>
    FindForAssetPath(assetPath:string) : UnityEditor.PackageManager.PackageInfo
    ParseResponseFile(responseFilePath:string, projectDirectory:string, systemReferenceDirectories:string[]) : ResponseFileData
}
class AssemblyNameProvider {
    + GetAssemblyNameFromScriptPath(path:string) : string
    + GetAssemblies(shouldFileBePartOfSolution:Func<string, bool>) : IEnumerable<Assembly>
    + GetAllAssetPaths() : IEnumerable<string>
    + FindForAssetPath(assetPath:string) : UnityEditor.PackageManager.PackageInfo
    + ParseResponseFile(responseFilePath:string, projectDirectory:string, systemReferenceDirectories:string[]) : ResponseFileData
}
class ProjectGeneration {
    + {static} <<readonly>> MSBuildNamespaceUri : string = "http://schemas.microsoft.com/developer/msbuild/2003"
    m_SolutionProjectEntryTemplate : string
    m_SolutionProjectConfigurationTemplate : string
    m_ShouldGenerateAll : bool
    + ProjectDirectory : string <<get>>
    + GenerateAll(generateAll:bool) : void
    <<readonly>> m_ProjectName : string
    <<internal>> {static} isRiderProjectGeneration : bool
    <<const>> k_ToolsVersion : string = "4.0"
    <<const>> k_ProductVersion : string = "10.0.20506"
    <<const>> k_BaseDirectory : string = "."
    <<const>> k_TargetFrameworkVersion : string = "v4.7.1"
    <<const>> k_TargetLanguageVersion : string = "latest"
    + ProjectGeneration()
    + ProjectGeneration(tempDirectory:string)
    + ProjectGeneration(tempDirectory:string, assemblyNameProvider:IAssemblyNameProvider, fileIoProvider:IFileIO, guidGenerator:IGUIDGenerator)
    + SyncIfNeeded(affectedFiles:IEnumerable<string>, reimportedFiles:IEnumerable<string>) : bool
    HasFilesBeenModified(affectedFiles:IEnumerable<string>, reimportedFiles:IEnumerable<string>) : bool
    {static} ShouldSyncOnReimportedAsset(asset:string) : bool
    + Sync() : void
    + HasSolutionBeenGenerated() : bool
    SetupProjectSupportedExtensions() : void
    ShouldFileBePartOfSolution(file:string) : bool
    IsSupportedExtension(extension:string) : bool
    {static} ScriptingLanguageFor(island:Assembly) : ScriptingLanguage
    {static} GetExtensionOfSourceFiles(files:string[]) : string
    {static} GetExtensionOfSourceFile(file:string) : string
    {static} ScriptingLanguageFor(extension:string) : ScriptingLanguage
    + GenerateAndWriteSolutionAndProjects(types:Type[]) : void
    ParseResponseFileData(assembly:Assembly) : IEnumerable<ResponseFileData>
    GenerateAllAssetProjectParts() : Dictionary<string, string>
    IsInternalizedPackagePath(file:string) : bool
    SyncProject(island:Assembly, allAssetsProjectParts:Dictionary<string, string>, responseFilesData:IEnumerable<ResponseFileData>, allProjectIslands:List<Assembly>, types:Type[]) : void
    SyncProjectFileIfNotChanged(path:string, newContents:string, types:Type[]) : void
    SyncSolutionFileIfNotChanged(path:string, newContents:string, types:Type[]) : void
    {static} SafeGetTypes(a:System.Reflection.Assembly) : List<Type>
    {static} OnGeneratedCSProjectFiles(types:Type[]) : void
    + {static} GetAssetPostprocessorTypes() : Type[]
    {static} OnPreGeneratingCSProjectFiles(types:Type[]) : bool
    {static} OnGeneratedCSProject(path:string, content:string, types:Type[]) : string
    {static} OnGeneratedSlnSolution(path:string, content:string, types:Type[]) : string
    SyncFileIfNotChanged(filename:string, newContents:string) : void
    ProjectText(assembly:Assembly, allAssetsProjectParts:Dictionary<string, string>, responseFilesData:List<ResponseFileData>, allProjectIslands:List<Assembly>) : string
    {static} AppendReference(fullReference:string, projectBuilder:StringBuilder) : void
    + ProjectFile(assembly:Assembly) : string
    + SolutionFile() : string
    ProjectHeader(assembly:Assembly, responseFilesData:List<ResponseFileData>) : string
    {static} GetSolutionText() : string
    {static} GetProjectFooterTemplate() : string
    {static} GetProjectHeaderTemplate() : string
    SyncSolution(islands:IEnumerable<Assembly>, types:Type[]) : void
    SolutionText(islands:IEnumerable<Assembly>) : string
    {static} RelevantIslandsForMode(islands:IEnumerable<Assembly>) : IEnumerable<Assembly>
    GetProjectEntries(islands:IEnumerable<Assembly>) : string
    GetProjectActiveConfigurations(projectGuid:string) : string
    EscapedRelativePathFor(file:string) : string
    {static} SkipPathPrefix(path:string, prefix:string) : string
    {static} NormalizePath(path:string) : string
    {static} ProjectFooter() : string
    {static} GetProjectExtension() : string
}
class SolutionGuidGenerator <<static>> {
    + {static} GuidForProject(projectName:string) : string
    + {static} GuidForSolution(projectName:string, sourceFileExtension:string) : string
    {static} ComputeGuidHashFor(input:string) : string
    {static} HashAsGuid(hash:string) : string
    {static} HashToString(bs:byte[]) : string
}
enum ScriptingLanguage {
    None,
    CSharp,
}
class "Dictionary`2"<T1,T2> {
}
IAssemblyNameProvider <|-- AssemblyNameProvider
IGenerator <|-- ProjectGeneration
ProjectGeneration o-> "k_BuiltinSupportedExtensions<string,ScriptingLanguage>" "Dictionary`2"
ProjectGeneration o-> "k_ScriptReferenceExpression" Regex
ProjectGeneration --> "m_AssemblyNameProvider" IAssemblyNameProvider
ProjectGeneration --> "m_FileIOProvider" IFileIO
ProjectGeneration --> "m_GUIDGenerator" IGUIDGenerator
ProjectGeneration o-> "scriptReferenceExpression" Regex
ProjectGeneration +-- ScriptingLanguage
class CallbackData {
    + isRider : bool
    + {static}  <<event>> Changed : EventHandler 
    <<internal>> RaiseChangedEvent() : void
    + Clear() : void
}
class "ScriptableSingleton`1"<T> {
}
class "List`1"<T> {
}
"ScriptableSingleton`1" "<CallbackData>" <|-- CallbackData
CallbackData o-> "events<TestEvent>" "List`1"
class RiderTestRunner <<static>> {
    + {static} RunTests(testMode:int, assemblyNames:string[], testNames:string[], categoryNames:string[], groupNames:string[], buildTarget:int?) : void
}
enum EventType {
    TestStarted,
    TestFinished,
    RunFinished,
}
class TestEvent {
    + id : string
    + assemblyName : string
    + output : string
    + duration : double
    + parentId : string
    + TestEvent(type:EventType, id:string, assemblyName:string, output:string, duration:double, testStatus:TestStatus, parentID:string)
}
TestEvent --> "type" EventType
TestEvent --> "testStatus" TestStatus
class CommandLineParser {
    + CommandLineParser(args:string[])
}
class "Dictionary`2"<T1,T2> {
}
CommandLineParser o-> "Options<string,string>" "Dictionary`2"
class FileSystemUtil <<static>> {
    + {static} GetFinalPathName(path:string) : string
    + {static} FileNameWithoutExtension(path:string) : string
    + {static} EditorPathExists(editorPath:string) : bool
}
class LibcNativeInterop <<static>> {
    + {static} <<extern>> realpath(path:string, resolved_path:StringBuilder) : IntPtr
}
class RiderMenu <<static>> {
    + {static} MenuOpenProject() : void
}
class UnityUtils <<static>> {
    <<internal>> {static} <<readonly>> UnityApplicationVersion : string
}
UnityUtils --> "UnityVersion" Version
class TestBitmanipulation {
    + {static} bitmask_bool4() : void
    + {static} countbits_int1() : void
    + {static} countbits_int2() : void
    + {static} countbits_int3() : void
    + {static} countbits_int4() : void
    + {static} countbits_uint() : void
    + {static} countbits_uint2() : void
    + {static} countbits_uint3() : void
    + {static} countbits_uint4() : void
    + {static} countbits_long() : void
    + {static} countbits_ulong() : void
    + {static} lzcnt_int() : void
    + {static} lzcnt_int2() : void
    + {static} lzcnt_int3() : void
    + {static} lzcnt_int4() : void
    + {static} lzcnt_uint() : void
    + {static} lzcnt_uint2() : void
    + {static} lzcnt_uint3() : void
    + {static} lzcnt_uint4() : void
    + {static} lzcnt_long() : void
    + {static} lzcnt_ulong() : void
    + {static} tzcnt_int() : void
    + {static} tzcnt_int2() : void
    + {static} tzcnt_int3() : void
    + {static} tzcnt_int4() : void
    + {static} tzcnt_uint() : void
    + {static} tzcnt_uint2() : void
    + {static} tzcnt_uint3() : void
    + {static} tzcnt_uint4() : void
    + {static} tzcnt_long() : void
    + {static} tzcnt_ulong() : void
    + {static} reversebits_int() : void
    + {static} reversebits_int2() : void
    + {static} reversebits_int3() : void
    + {static} reversebits_int4() : void
    + {static} reversebits_uint() : void
    + {static} reversebits_uint2() : void
    + {static} reversebits_uint3() : void
    + {static} reversebits_uint4() : void
    + {static} reversebits_long() : void
    + {static} reversebits_ulong() : void
    + {static} rol_int() : void
    + {static} rol_int2() : void
    + {static} rol_int3() : void
    + {static} rol_int4() : void
    + {static} rol_uint() : void
    + {static} rol_uint2() : void
    + {static} rol_uint3() : void
    + {static} rol_uint4() : void
    + {static} rol_long() : void
    + {static} rol_ulong() : void
    + {static} ror_int() : void
    + {static} ror_int2() : void
    + {static} ror_int3() : void
    + {static} ror_int4() : void
    + {static} ror_uint() : void
    + {static} ror_uint2() : void
    + {static} ror_uint3() : void
    + {static} ror_uint4() : void
    + {static} ror_long() : void
    + {static} ror_ulong() : void
}
class Assert2 {
    + {static} AreEqual(a:object, b:object) : void
}
class TestBool2 {
    + {static} bool2_constructor() : void
    + {static} bool2_scalar_constructor() : void
    + {static} bool2_static_constructor() : void
    + {static} bool2_static_scalar_constructor() : void
    + {static} bool2_operator_equal_wide_wide() : void
    + {static} bool2_operator_equal_wide_scalar() : void
    + {static} bool2_operator_equal_scalar_wide() : void
    + {static} bool2_operator_not_equal_wide_wide() : void
    + {static} bool2_operator_not_equal_wide_scalar() : void
    + {static} bool2_operator_not_equal_scalar_wide() : void
    + {static} bool2_operator_bitwise_and_wide_wide() : void
    + {static} bool2_operator_bitwise_and_wide_scalar() : void
    + {static} bool2_operator_bitwise_and_scalar_wide() : void
    + {static} bool2_operator_bitwise_or_wide_wide() : void
    + {static} bool2_operator_bitwise_or_wide_scalar() : void
    + {static} bool2_operator_bitwise_or_scalar_wide() : void
    + {static} bool2_operator_bitwise_xor_wide_wide() : void
    + {static} bool2_operator_bitwise_xor_wide_scalar() : void
    + {static} bool2_operator_bitwise_xor_scalar_wide() : void
    + {static} bool2_operator_logical_not() : void
}
class TestBool2x2 {
    + {static} bool2x2_operator_equal_wide_wide() : void
    + {static} bool2x2_operator_equal_wide_scalar() : void
    + {static} bool2x2_operator_equal_scalar_wide() : void
    + {static} bool2x2_operator_not_equal_wide_wide() : void
    + {static} bool2x2_operator_not_equal_wide_scalar() : void
    + {static} bool2x2_operator_not_equal_scalar_wide() : void
    + {static} bool2x2_operator_bitwise_and_wide_wide() : void
    + {static} bool2x2_operator_bitwise_and_wide_scalar() : void
    + {static} bool2x2_operator_bitwise_and_scalar_wide() : void
    + {static} bool2x2_operator_bitwise_or_wide_wide() : void
    + {static} bool2x2_operator_bitwise_or_wide_scalar() : void
    + {static} bool2x2_operator_bitwise_or_scalar_wide() : void
    + {static} bool2x2_operator_bitwise_xor_wide_wide() : void
    + {static} bool2x2_operator_bitwise_xor_wide_scalar() : void
    + {static} bool2x2_operator_bitwise_xor_scalar_wide() : void
    + {static} bool2x2_operator_logical_not() : void
}
class TestBool2x3 {
    + {static} bool2x3_operator_equal_wide_wide() : void
    + {static} bool2x3_operator_equal_wide_scalar() : void
    + {static} bool2x3_operator_equal_scalar_wide() : void
    + {static} bool2x3_operator_not_equal_wide_wide() : void
    + {static} bool2x3_operator_not_equal_wide_scalar() : void
    + {static} bool2x3_operator_not_equal_scalar_wide() : void
    + {static} bool2x3_operator_bitwise_and_wide_wide() : void
    + {static} bool2x3_operator_bitwise_and_wide_scalar() : void
    + {static} bool2x3_operator_bitwise_and_scalar_wide() : void
    + {static} bool2x3_operator_bitwise_or_wide_wide() : void
    + {static} bool2x3_operator_bitwise_or_wide_scalar() : void
    + {static} bool2x3_operator_bitwise_or_scalar_wide() : void
    + {static} bool2x3_operator_bitwise_xor_wide_wide() : void
    + {static} bool2x3_operator_bitwise_xor_wide_scalar() : void
    + {static} bool2x3_operator_bitwise_xor_scalar_wide() : void
    + {static} bool2x3_operator_logical_not() : void
}
class TestBool2x4 {
    + {static} bool2x4_operator_equal_wide_wide() : void
    + {static} bool2x4_operator_equal_wide_scalar() : void
    + {static} bool2x4_operator_equal_scalar_wide() : void
    + {static} bool2x4_operator_not_equal_wide_wide() : void
    + {static} bool2x4_operator_not_equal_wide_scalar() : void
    + {static} bool2x4_operator_not_equal_scalar_wide() : void
    + {static} bool2x4_operator_bitwise_and_wide_wide() : void
    + {static} bool2x4_operator_bitwise_and_wide_scalar() : void
    + {static} bool2x4_operator_bitwise_and_scalar_wide() : void
    + {static} bool2x4_operator_bitwise_or_wide_wide() : void
    + {static} bool2x4_operator_bitwise_or_wide_scalar() : void
    + {static} bool2x4_operator_bitwise_or_scalar_wide() : void
    + {static} bool2x4_operator_bitwise_xor_wide_wide() : void
    + {static} bool2x4_operator_bitwise_xor_wide_scalar() : void
    + {static} bool2x4_operator_bitwise_xor_scalar_wide() : void
    + {static} bool2x4_operator_logical_not() : void
}
class TestBool3 {
    + {static} bool3_constructor() : void
    + {static} bool3_scalar_constructor() : void
    + {static} bool3_static_constructor() : void
    + {static} bool3_static_scalar_constructor() : void
    + {static} bool3_operator_equal_wide_wide() : void
    + {static} bool3_operator_equal_wide_scalar() : void
    + {static} bool3_operator_equal_scalar_wide() : void
    + {static} bool3_operator_not_equal_wide_wide() : void
    + {static} bool3_operator_not_equal_wide_scalar() : void
    + {static} bool3_operator_not_equal_scalar_wide() : void
    + {static} bool3_operator_bitwise_and_wide_wide() : void
    + {static} bool3_operator_bitwise_and_wide_scalar() : void
    + {static} bool3_operator_bitwise_and_scalar_wide() : void
    + {static} bool3_operator_bitwise_or_wide_wide() : void
    + {static} bool3_operator_bitwise_or_wide_scalar() : void
    + {static} bool3_operator_bitwise_or_scalar_wide() : void
    + {static} bool3_operator_bitwise_xor_wide_wide() : void
    + {static} bool3_operator_bitwise_xor_wide_scalar() : void
    + {static} bool3_operator_bitwise_xor_scalar_wide() : void
    + {static} bool3_operator_logical_not() : void
}
class TestBool3x2 {
    + {static} bool3x2_operator_equal_wide_wide() : void
    + {static} bool3x2_operator_equal_wide_scalar() : void
    + {static} bool3x2_operator_equal_scalar_wide() : void
    + {static} bool3x2_operator_not_equal_wide_wide() : void
    + {static} bool3x2_operator_not_equal_wide_scalar() : void
    + {static} bool3x2_operator_not_equal_scalar_wide() : void
    + {static} bool3x2_operator_bitwise_and_wide_wide() : void
    + {static} bool3x2_operator_bitwise_and_wide_scalar() : void
    + {static} bool3x2_operator_bitwise_and_scalar_wide() : void
    + {static} bool3x2_operator_bitwise_or_wide_wide() : void
    + {static} bool3x2_operator_bitwise_or_wide_scalar() : void
    + {static} bool3x2_operator_bitwise_or_scalar_wide() : void
    + {static} bool3x2_operator_bitwise_xor_wide_wide() : void
    + {static} bool3x2_operator_bitwise_xor_wide_scalar() : void
    + {static} bool3x2_operator_bitwise_xor_scalar_wide() : void
    + {static} bool3x2_operator_logical_not() : void
}
class TestBool3x3 {
    + {static} bool3x3_operator_equal_wide_wide() : void
    + {static} bool3x3_operator_equal_wide_scalar() : void
    + {static} bool3x3_operator_equal_scalar_wide() : void
    + {static} bool3x3_operator_not_equal_wide_wide() : void
    + {static} bool3x3_operator_not_equal_wide_scalar() : void
    + {static} bool3x3_operator_not_equal_scalar_wide() : void
    + {static} bool3x3_operator_bitwise_and_wide_wide() : void
    + {static} bool3x3_operator_bitwise_and_wide_scalar() : void
    + {static} bool3x3_operator_bitwise_and_scalar_wide() : void
    + {static} bool3x3_operator_bitwise_or_wide_wide() : void
    + {static} bool3x3_operator_bitwise_or_wide_scalar() : void
    + {static} bool3x3_operator_bitwise_or_scalar_wide() : void
    + {static} bool3x3_operator_bitwise_xor_wide_wide() : void
    + {static} bool3x3_operator_bitwise_xor_wide_scalar() : void
    + {static} bool3x3_operator_bitwise_xor_scalar_wide() : void
    + {static} bool3x3_operator_logical_not() : void
}
class TestBool3x4 {
    + {static} bool3x4_operator_equal_wide_wide() : void
    + {static} bool3x4_operator_equal_wide_scalar() : void
    + {static} bool3x4_operator_equal_scalar_wide() : void
    + {static} bool3x4_operator_not_equal_wide_wide() : void
    + {static} bool3x4_operator_not_equal_wide_scalar() : void
    + {static} bool3x4_operator_not_equal_scalar_wide() : void
    + {static} bool3x4_operator_bitwise_and_wide_wide() : void
    + {static} bool3x4_operator_bitwise_and_wide_scalar() : void
    + {static} bool3x4_operator_bitwise_and_scalar_wide() : void
    + {static} bool3x4_operator_bitwise_or_wide_wide() : void
    + {static} bool3x4_operator_bitwise_or_wide_scalar() : void
    + {static} bool3x4_operator_bitwise_or_scalar_wide() : void
    + {static} bool3x4_operator_bitwise_xor_wide_wide() : void
    + {static} bool3x4_operator_bitwise_xor_wide_scalar() : void
    + {static} bool3x4_operator_bitwise_xor_scalar_wide() : void
    + {static} bool3x4_operator_logical_not() : void
}
class TestBool4 {
    + {static} bool4_constructor() : void
    + {static} bool4_scalar_constructor() : void
    + {static} bool4_static_constructor() : void
    + {static} bool4_static_scalar_constructor() : void
    + {static} bool4_operator_equal_wide_wide() : void
    + {static} bool4_operator_equal_wide_scalar() : void
    + {static} bool4_operator_equal_scalar_wide() : void
    + {static} bool4_operator_not_equal_wide_wide() : void
    + {static} bool4_operator_not_equal_wide_scalar() : void
    + {static} bool4_operator_not_equal_scalar_wide() : void
    + {static} bool4_operator_bitwise_and_wide_wide() : void
    + {static} bool4_operator_bitwise_and_wide_scalar() : void
    + {static} bool4_operator_bitwise_and_scalar_wide() : void
    + {static} bool4_operator_bitwise_or_wide_wide() : void
    + {static} bool4_operator_bitwise_or_wide_scalar() : void
    + {static} bool4_operator_bitwise_or_scalar_wide() : void
    + {static} bool4_operator_bitwise_xor_wide_wide() : void
    + {static} bool4_operator_bitwise_xor_wide_scalar() : void
    + {static} bool4_operator_bitwise_xor_scalar_wide() : void
    + {static} bool4_operator_logical_not() : void
}
class TestBool4x2 {
    + {static} bool4x2_operator_equal_wide_wide() : void
    + {static} bool4x2_operator_equal_wide_scalar() : void
    + {static} bool4x2_operator_equal_scalar_wide() : void
    + {static} bool4x2_operator_not_equal_wide_wide() : void
    + {static} bool4x2_operator_not_equal_wide_scalar() : void
    + {static} bool4x2_operator_not_equal_scalar_wide() : void
    + {static} bool4x2_operator_bitwise_and_wide_wide() : void
    + {static} bool4x2_operator_bitwise_and_wide_scalar() : void
    + {static} bool4x2_operator_bitwise_and_scalar_wide() : void
    + {static} bool4x2_operator_bitwise_or_wide_wide() : void
    + {static} bool4x2_operator_bitwise_or_wide_scalar() : void
    + {static} bool4x2_operator_bitwise_or_scalar_wide() : void
    + {static} bool4x2_operator_bitwise_xor_wide_wide() : void
    + {static} bool4x2_operator_bitwise_xor_wide_scalar() : void
    + {static} bool4x2_operator_bitwise_xor_scalar_wide() : void
    + {static} bool4x2_operator_logical_not() : void
}
class TestBool4x3 {
    + {static} bool4x3_operator_equal_wide_wide() : void
    + {static} bool4x3_operator_equal_wide_scalar() : void
    + {static} bool4x3_operator_equal_scalar_wide() : void
    + {static} bool4x3_operator_not_equal_wide_wide() : void
    + {static} bool4x3_operator_not_equal_wide_scalar() : void
    + {static} bool4x3_operator_not_equal_scalar_wide() : void
    + {static} bool4x3_operator_bitwise_and_wide_wide() : void
    + {static} bool4x3_operator_bitwise_and_wide_scalar() : void
    + {static} bool4x3_operator_bitwise_and_scalar_wide() : void
    + {static} bool4x3_operator_bitwise_or_wide_wide() : void
    + {static} bool4x3_operator_bitwise_or_wide_scalar() : void
    + {static} bool4x3_operator_bitwise_or_scalar_wide() : void
    + {static} bool4x3_operator_bitwise_xor_wide_wide() : void
    + {static} bool4x3_operator_bitwise_xor_wide_scalar() : void
    + {static} bool4x3_operator_bitwise_xor_scalar_wide() : void
    + {static} bool4x3_operator_logical_not() : void
}
class TestBool4x4 {
    + {static} bool4x4_operator_equal_wide_wide() : void
    + {static} bool4x4_operator_equal_wide_scalar() : void
    + {static} bool4x4_operator_equal_scalar_wide() : void
    + {static} bool4x4_operator_not_equal_wide_wide() : void
    + {static} bool4x4_operator_not_equal_wide_scalar() : void
    + {static} bool4x4_operator_not_equal_scalar_wide() : void
    + {static} bool4x4_operator_bitwise_and_wide_wide() : void
    + {static} bool4x4_operator_bitwise_and_wide_scalar() : void
    + {static} bool4x4_operator_bitwise_and_scalar_wide() : void
    + {static} bool4x4_operator_bitwise_or_wide_wide() : void
    + {static} bool4x4_operator_bitwise_or_wide_scalar() : void
    + {static} bool4x4_operator_bitwise_or_scalar_wide() : void
    + {static} bool4x4_operator_bitwise_xor_wide_wide() : void
    + {static} bool4x4_operator_bitwise_xor_wide_scalar() : void
    + {static} bool4x4_operator_bitwise_xor_scalar_wide() : void
    + {static} bool4x4_operator_logical_not() : void
}
class TestDouble2 {
    + {static} double2_zero() : void
    + {static} double2_constructor() : void
    + {static} double2_scalar_constructor() : void
    + {static} double2_static_constructor() : void
    + {static} double2_static_scalar_constructor() : void
    + {static} double2_operator_equal_wide_wide() : void
    + {static} double2_operator_equal_wide_scalar() : void
    + {static} double2_operator_equal_scalar_wide() : void
    + {static} double2_operator_not_equal_wide_wide() : void
    + {static} double2_operator_not_equal_wide_scalar() : void
    + {static} double2_operator_not_equal_scalar_wide() : void
    + {static} double2_operator_less_wide_wide() : void
    + {static} double2_operator_less_wide_scalar() : void
    + {static} double2_operator_less_scalar_wide() : void
    + {static} double2_operator_greater_wide_wide() : void
    + {static} double2_operator_greater_wide_scalar() : void
    + {static} double2_operator_greater_scalar_wide() : void
    + {static} double2_operator_less_equal_wide_wide() : void
    + {static} double2_operator_less_equal_wide_scalar() : void
    + {static} double2_operator_less_equal_scalar_wide() : void
    + {static} double2_operator_greater_equal_wide_wide() : void
    + {static} double2_operator_greater_equal_wide_scalar() : void
    + {static} double2_operator_greater_equal_scalar_wide() : void
    + {static} double2_operator_add_wide_wide() : void
    + {static} double2_operator_add_wide_scalar() : void
    + {static} double2_operator_add_scalar_wide() : void
    + {static} double2_operator_sub_wide_wide() : void
    + {static} double2_operator_sub_wide_scalar() : void
    + {static} double2_operator_sub_scalar_wide() : void
    + {static} double2_operator_mul_wide_wide() : void
    + {static} double2_operator_mul_wide_scalar() : void
    + {static} double2_operator_mul_scalar_wide() : void
    + {static} double2_operator_div_wide_wide() : void
    + {static} double2_operator_div_wide_scalar() : void
    + {static} double2_operator_div_scalar_wide() : void
    + {static} double2_operator_mod_wide_wide() : void
    + {static} double2_operator_mod_wide_scalar() : void
    + {static} double2_operator_mod_scalar_wide() : void
    + {static} double2_operator_plus() : void
    + {static} double2_operator_neg() : void
    + {static} double2_operator_prefix_inc() : void
    + {static} double2_operator_postfix_inc() : void
    + {static} double2_operator_prefix_dec() : void
    + {static} double2_operator_postfix_dec() : void
    + {static} double2_shuffle_result_1() : void
    + {static} double2_shuffle_result_2() : void
    + {static} double2_shuffle_result_3() : void
    + {static} double2_shuffle_result_4() : void
}
class TestDouble2x2 {
    + {static} double2x2_zero() : void
    + {static} double2x2_identity() : void
    + {static} double2x2_operator_equal_wide_wide() : void
    + {static} double2x2_operator_equal_wide_scalar() : void
    + {static} double2x2_operator_equal_scalar_wide() : void
    + {static} double2x2_operator_not_equal_wide_wide() : void
    + {static} double2x2_operator_not_equal_wide_scalar() : void
    + {static} double2x2_operator_not_equal_scalar_wide() : void
    + {static} double2x2_operator_less_wide_wide() : void
    + {static} double2x2_operator_less_wide_scalar() : void
    + {static} double2x2_operator_less_scalar_wide() : void
    + {static} double2x2_operator_greater_wide_wide() : void
    + {static} double2x2_operator_greater_wide_scalar() : void
    + {static} double2x2_operator_greater_scalar_wide() : void
    + {static} double2x2_operator_less_equal_wide_wide() : void
    + {static} double2x2_operator_less_equal_wide_scalar() : void
    + {static} double2x2_operator_less_equal_scalar_wide() : void
    + {static} double2x2_operator_greater_equal_wide_wide() : void
    + {static} double2x2_operator_greater_equal_wide_scalar() : void
    + {static} double2x2_operator_greater_equal_scalar_wide() : void
    + {static} double2x2_operator_add_wide_wide() : void
    + {static} double2x2_operator_add_wide_scalar() : void
    + {static} double2x2_operator_add_scalar_wide() : void
    + {static} double2x2_operator_sub_wide_wide() : void
    + {static} double2x2_operator_sub_wide_scalar() : void
    + {static} double2x2_operator_sub_scalar_wide() : void
    + {static} double2x2_operator_mul_wide_wide() : void
    + {static} double2x2_operator_mul_wide_scalar() : void
    + {static} double2x2_operator_mul_scalar_wide() : void
    + {static} double2x2_operator_div_wide_wide() : void
    + {static} double2x2_operator_div_wide_scalar() : void
    + {static} double2x2_operator_div_scalar_wide() : void
    + {static} double2x2_operator_mod_wide_wide() : void
    + {static} double2x2_operator_mod_wide_scalar() : void
    + {static} double2x2_operator_mod_scalar_wide() : void
    + {static} double2x2_operator_plus() : void
    + {static} double2x2_operator_neg() : void
    + {static} double2x2_operator_prefix_inc() : void
    + {static} double2x2_operator_postfix_inc() : void
    + {static} double2x2_operator_prefix_dec() : void
    + {static} double2x2_operator_postfix_dec() : void
}
class TestDouble2x3 {
    + {static} double2x3_zero() : void
    + {static} double2x3_operator_equal_wide_wide() : void
    + {static} double2x3_operator_equal_wide_scalar() : void
    + {static} double2x3_operator_equal_scalar_wide() : void
    + {static} double2x3_operator_not_equal_wide_wide() : void
    + {static} double2x3_operator_not_equal_wide_scalar() : void
    + {static} double2x3_operator_not_equal_scalar_wide() : void
    + {static} double2x3_operator_less_wide_wide() : void
    + {static} double2x3_operator_less_wide_scalar() : void
    + {static} double2x3_operator_less_scalar_wide() : void
    + {static} double2x3_operator_greater_wide_wide() : void
    + {static} double2x3_operator_greater_wide_scalar() : void
    + {static} double2x3_operator_greater_scalar_wide() : void
    + {static} double2x3_operator_less_equal_wide_wide() : void
    + {static} double2x3_operator_less_equal_wide_scalar() : void
    + {static} double2x3_operator_less_equal_scalar_wide() : void
    + {static} double2x3_operator_greater_equal_wide_wide() : void
    + {static} double2x3_operator_greater_equal_wide_scalar() : void
    + {static} double2x3_operator_greater_equal_scalar_wide() : void
    + {static} double2x3_operator_add_wide_wide() : void
    + {static} double2x3_operator_add_wide_scalar() : void
    + {static} double2x3_operator_add_scalar_wide() : void
    + {static} double2x3_operator_sub_wide_wide() : void
    + {static} double2x3_operator_sub_wide_scalar() : void
    + {static} double2x3_operator_sub_scalar_wide() : void
    + {static} double2x3_operator_mul_wide_wide() : void
    + {static} double2x3_operator_mul_wide_scalar() : void
    + {static} double2x3_operator_mul_scalar_wide() : void
    + {static} double2x3_operator_div_wide_wide() : void
    + {static} double2x3_operator_div_wide_scalar() : void
    + {static} double2x3_operator_div_scalar_wide() : void
    + {static} double2x3_operator_mod_wide_wide() : void
    + {static} double2x3_operator_mod_wide_scalar() : void
    + {static} double2x3_operator_mod_scalar_wide() : void
    + {static} double2x3_operator_plus() : void
    + {static} double2x3_operator_neg() : void
    + {static} double2x3_operator_prefix_inc() : void
    + {static} double2x3_operator_postfix_inc() : void
    + {static} double2x3_operator_prefix_dec() : void
    + {static} double2x3_operator_postfix_dec() : void
}
class TestDouble2x4 {
    + {static} double2x4_zero() : void
    + {static} double2x4_operator_equal_wide_wide() : void
    + {static} double2x4_operator_equal_wide_scalar() : void
    + {static} double2x4_operator_equal_scalar_wide() : void
    + {static} double2x4_operator_not_equal_wide_wide() : void
    + {static} double2x4_operator_not_equal_wide_scalar() : void
    + {static} double2x4_operator_not_equal_scalar_wide() : void
    + {static} double2x4_operator_less_wide_wide() : void
    + {static} double2x4_operator_less_wide_scalar() : void
    + {static} double2x4_operator_less_scalar_wide() : void
    + {static} double2x4_operator_greater_wide_wide() : void
    + {static} double2x4_operator_greater_wide_scalar() : void
    + {static} double2x4_operator_greater_scalar_wide() : void
    + {static} double2x4_operator_less_equal_wide_wide() : void
    + {static} double2x4_operator_less_equal_wide_scalar() : void
    + {static} double2x4_operator_less_equal_scalar_wide() : void
    + {static} double2x4_operator_greater_equal_wide_wide() : void
    + {static} double2x4_operator_greater_equal_wide_scalar() : void
    + {static} double2x4_operator_greater_equal_scalar_wide() : void
    + {static} double2x4_operator_add_wide_wide() : void
    + {static} double2x4_operator_add_wide_scalar() : void
    + {static} double2x4_operator_add_scalar_wide() : void
    + {static} double2x4_operator_sub_wide_wide() : void
    + {static} double2x4_operator_sub_wide_scalar() : void
    + {static} double2x4_operator_sub_scalar_wide() : void
    + {static} double2x4_operator_mul_wide_wide() : void
    + {static} double2x4_operator_mul_wide_scalar() : void
    + {static} double2x4_operator_mul_scalar_wide() : void
    + {static} double2x4_operator_div_wide_wide() : void
    + {static} double2x4_operator_div_wide_scalar() : void
    + {static} double2x4_operator_div_scalar_wide() : void
    + {static} double2x4_operator_mod_wide_wide() : void
    + {static} double2x4_operator_mod_wide_scalar() : void
    + {static} double2x4_operator_mod_scalar_wide() : void
    + {static} double2x4_operator_plus() : void
    + {static} double2x4_operator_neg() : void
    + {static} double2x4_operator_prefix_inc() : void
    + {static} double2x4_operator_postfix_inc() : void
    + {static} double2x4_operator_prefix_dec() : void
    + {static} double2x4_operator_postfix_dec() : void
}
class TestDouble3 {
    + {static} double3_zero() : void
    + {static} double3_constructor() : void
    + {static} double3_scalar_constructor() : void
    + {static} double3_static_constructor() : void
    + {static} double3_static_scalar_constructor() : void
    + {static} double3_operator_equal_wide_wide() : void
    + {static} double3_operator_equal_wide_scalar() : void
    + {static} double3_operator_equal_scalar_wide() : void
    + {static} double3_operator_not_equal_wide_wide() : void
    + {static} double3_operator_not_equal_wide_scalar() : void
    + {static} double3_operator_not_equal_scalar_wide() : void
    + {static} double3_operator_less_wide_wide() : void
    + {static} double3_operator_less_wide_scalar() : void
    + {static} double3_operator_less_scalar_wide() : void
    + {static} double3_operator_greater_wide_wide() : void
    + {static} double3_operator_greater_wide_scalar() : void
    + {static} double3_operator_greater_scalar_wide() : void
    + {static} double3_operator_less_equal_wide_wide() : void
    + {static} double3_operator_less_equal_wide_scalar() : void
    + {static} double3_operator_less_equal_scalar_wide() : void
    + {static} double3_operator_greater_equal_wide_wide() : void
    + {static} double3_operator_greater_equal_wide_scalar() : void
    + {static} double3_operator_greater_equal_scalar_wide() : void
    + {static} double3_operator_add_wide_wide() : void
    + {static} double3_operator_add_wide_scalar() : void
    + {static} double3_operator_add_scalar_wide() : void
    + {static} double3_operator_sub_wide_wide() : void
    + {static} double3_operator_sub_wide_scalar() : void
    + {static} double3_operator_sub_scalar_wide() : void
    + {static} double3_operator_mul_wide_wide() : void
    + {static} double3_operator_mul_wide_scalar() : void
    + {static} double3_operator_mul_scalar_wide() : void
    + {static} double3_operator_div_wide_wide() : void
    + {static} double3_operator_div_wide_scalar() : void
    + {static} double3_operator_div_scalar_wide() : void
    + {static} double3_operator_mod_wide_wide() : void
    + {static} double3_operator_mod_wide_scalar() : void
    + {static} double3_operator_mod_scalar_wide() : void
    + {static} double3_operator_plus() : void
    + {static} double3_operator_neg() : void
    + {static} double3_operator_prefix_inc() : void
    + {static} double3_operator_postfix_inc() : void
    + {static} double3_operator_prefix_dec() : void
    + {static} double3_operator_postfix_dec() : void
    + {static} double3_shuffle_result_1() : void
    + {static} double3_shuffle_result_2() : void
    + {static} double3_shuffle_result_3() : void
    + {static} double3_shuffle_result_4() : void
}
class TestDouble3x2 {
    + {static} double3x2_zero() : void
    + {static} double3x2_operator_equal_wide_wide() : void
    + {static} double3x2_operator_equal_wide_scalar() : void
    + {static} double3x2_operator_equal_scalar_wide() : void
    + {static} double3x2_operator_not_equal_wide_wide() : void
    + {static} double3x2_operator_not_equal_wide_scalar() : void
    + {static} double3x2_operator_not_equal_scalar_wide() : void
    + {static} double3x2_operator_less_wide_wide() : void
    + {static} double3x2_operator_less_wide_scalar() : void
    + {static} double3x2_operator_less_scalar_wide() : void
    + {static} double3x2_operator_greater_wide_wide() : void
    + {static} double3x2_operator_greater_wide_scalar() : void
    + {static} double3x2_operator_greater_scalar_wide() : void
    + {static} double3x2_operator_less_equal_wide_wide() : void
    + {static} double3x2_operator_less_equal_wide_scalar() : void
    + {static} double3x2_operator_less_equal_scalar_wide() : void
    + {static} double3x2_operator_greater_equal_wide_wide() : void
    + {static} double3x2_operator_greater_equal_wide_scalar() : void
    + {static} double3x2_operator_greater_equal_scalar_wide() : void
    + {static} double3x2_operator_add_wide_wide() : void
    + {static} double3x2_operator_add_wide_scalar() : void
    + {static} double3x2_operator_add_scalar_wide() : void
    + {static} double3x2_operator_sub_wide_wide() : void
    + {static} double3x2_operator_sub_wide_scalar() : void
    + {static} double3x2_operator_sub_scalar_wide() : void
    + {static} double3x2_operator_mul_wide_wide() : void
    + {static} double3x2_operator_mul_wide_scalar() : void
    + {static} double3x2_operator_mul_scalar_wide() : void
    + {static} double3x2_operator_div_wide_wide() : void
    + {static} double3x2_operator_div_wide_scalar() : void
    + {static} double3x2_operator_div_scalar_wide() : void
    + {static} double3x2_operator_mod_wide_wide() : void
    + {static} double3x2_operator_mod_wide_scalar() : void
    + {static} double3x2_operator_mod_scalar_wide() : void
    + {static} double3x2_operator_plus() : void
    + {static} double3x2_operator_neg() : void
    + {static} double3x2_operator_prefix_inc() : void
    + {static} double3x2_operator_postfix_inc() : void
    + {static} double3x2_operator_prefix_dec() : void
    + {static} double3x2_operator_postfix_dec() : void
}
class TestDouble3x3 {
    + {static} double3x3_zero() : void
    + {static} double3x3_identity() : void
    + {static} double3x3_operator_equal_wide_wide() : void
    + {static} double3x3_operator_equal_wide_scalar() : void
    + {static} double3x3_operator_equal_scalar_wide() : void
    + {static} double3x3_operator_not_equal_wide_wide() : void
    + {static} double3x3_operator_not_equal_wide_scalar() : void
    + {static} double3x3_operator_not_equal_scalar_wide() : void
    + {static} double3x3_operator_less_wide_wide() : void
    + {static} double3x3_operator_less_wide_scalar() : void
    + {static} double3x3_operator_less_scalar_wide() : void
    + {static} double3x3_operator_greater_wide_wide() : void
    + {static} double3x3_operator_greater_wide_scalar() : void
    + {static} double3x3_operator_greater_scalar_wide() : void
    + {static} double3x3_operator_less_equal_wide_wide() : void
    + {static} double3x3_operator_less_equal_wide_scalar() : void
    + {static} double3x3_operator_less_equal_scalar_wide() : void
    + {static} double3x3_operator_greater_equal_wide_wide() : void
    + {static} double3x3_operator_greater_equal_wide_scalar() : void
    + {static} double3x3_operator_greater_equal_scalar_wide() : void
    + {static} double3x3_operator_add_wide_wide() : void
    + {static} double3x3_operator_add_wide_scalar() : void
    + {static} double3x3_operator_add_scalar_wide() : void
    + {static} double3x3_operator_sub_wide_wide() : void
    + {static} double3x3_operator_sub_wide_scalar() : void
    + {static} double3x3_operator_sub_scalar_wide() : void
    + {static} double3x3_operator_mul_wide_wide() : void
    + {static} double3x3_operator_mul_wide_scalar() : void
    + {static} double3x3_operator_mul_scalar_wide() : void
    + {static} double3x3_operator_div_wide_wide() : void
    + {static} double3x3_operator_div_wide_scalar() : void
    + {static} double3x3_operator_div_scalar_wide() : void
    + {static} double3x3_operator_mod_wide_wide() : void
    + {static} double3x3_operator_mod_wide_scalar() : void
    + {static} double3x3_operator_mod_scalar_wide() : void
    + {static} double3x3_operator_plus() : void
    + {static} double3x3_operator_neg() : void
    + {static} double3x3_operator_prefix_inc() : void
    + {static} double3x3_operator_postfix_inc() : void
    + {static} double3x3_operator_prefix_dec() : void
    + {static} double3x3_operator_postfix_dec() : void
}
class TestDouble3x4 {
    + {static} double3x4_zero() : void
    + {static} double3x4_operator_equal_wide_wide() : void
    + {static} double3x4_operator_equal_wide_scalar() : void
    + {static} double3x4_operator_equal_scalar_wide() : void
    + {static} double3x4_operator_not_equal_wide_wide() : void
    + {static} double3x4_operator_not_equal_wide_scalar() : void
    + {static} double3x4_operator_not_equal_scalar_wide() : void
    + {static} double3x4_operator_less_wide_wide() : void
    + {static} double3x4_operator_less_wide_scalar() : void
    + {static} double3x4_operator_less_scalar_wide() : void
    + {static} double3x4_operator_greater_wide_wide() : void
    + {static} double3x4_operator_greater_wide_scalar() : void
    + {static} double3x4_operator_greater_scalar_wide() : void
    + {static} double3x4_operator_less_equal_wide_wide() : void
    + {static} double3x4_operator_less_equal_wide_scalar() : void
    + {static} double3x4_operator_less_equal_scalar_wide() : void
    + {static} double3x4_operator_greater_equal_wide_wide() : void
    + {static} double3x4_operator_greater_equal_wide_scalar() : void
    + {static} double3x4_operator_greater_equal_scalar_wide() : void
    + {static} double3x4_operator_add_wide_wide() : void
    + {static} double3x4_operator_add_wide_scalar() : void
    + {static} double3x4_operator_add_scalar_wide() : void
    + {static} double3x4_operator_sub_wide_wide() : void
    + {static} double3x4_operator_sub_wide_scalar() : void
    + {static} double3x4_operator_sub_scalar_wide() : void
    + {static} double3x4_operator_mul_wide_wide() : void
    + {static} double3x4_operator_mul_wide_scalar() : void
    + {static} double3x4_operator_mul_scalar_wide() : void
    + {static} double3x4_operator_div_wide_wide() : void
    + {static} double3x4_operator_div_wide_scalar() : void
    + {static} double3x4_operator_div_scalar_wide() : void
    + {static} double3x4_operator_mod_wide_wide() : void
    + {static} double3x4_operator_mod_wide_scalar() : void
    + {static} double3x4_operator_mod_scalar_wide() : void
    + {static} double3x4_operator_plus() : void
    + {static} double3x4_operator_neg() : void
    + {static} double3x4_operator_prefix_inc() : void
    + {static} double3x4_operator_postfix_inc() : void
    + {static} double3x4_operator_prefix_dec() : void
    + {static} double3x4_operator_postfix_dec() : void
}
class TestDouble4 {
    + {static} double4_zero() : void
    + {static} double4_constructor() : void
    + {static} double4_scalar_constructor() : void
    + {static} double4_static_constructor() : void
    + {static} double4_static_scalar_constructor() : void
    + {static} double4_operator_equal_wide_wide() : void
    + {static} double4_operator_equal_wide_scalar() : void
    + {static} double4_operator_equal_scalar_wide() : void
    + {static} double4_operator_not_equal_wide_wide() : void
    + {static} double4_operator_not_equal_wide_scalar() : void
    + {static} double4_operator_not_equal_scalar_wide() : void
    + {static} double4_operator_less_wide_wide() : void
    + {static} double4_operator_less_wide_scalar() : void
    + {static} double4_operator_less_scalar_wide() : void
    + {static} double4_operator_greater_wide_wide() : void
    + {static} double4_operator_greater_wide_scalar() : void
    + {static} double4_operator_greater_scalar_wide() : void
    + {static} double4_operator_less_equal_wide_wide() : void
    + {static} double4_operator_less_equal_wide_scalar() : void
    + {static} double4_operator_less_equal_scalar_wide() : void
    + {static} double4_operator_greater_equal_wide_wide() : void
    + {static} double4_operator_greater_equal_wide_scalar() : void
    + {static} double4_operator_greater_equal_scalar_wide() : void
    + {static} double4_operator_add_wide_wide() : void
    + {static} double4_operator_add_wide_scalar() : void
    + {static} double4_operator_add_scalar_wide() : void
    + {static} double4_operator_sub_wide_wide() : void
    + {static} double4_operator_sub_wide_scalar() : void
    + {static} double4_operator_sub_scalar_wide() : void
    + {static} double4_operator_mul_wide_wide() : void
    + {static} double4_operator_mul_wide_scalar() : void
    + {static} double4_operator_mul_scalar_wide() : void
    + {static} double4_operator_div_wide_wide() : void
    + {static} double4_operator_div_wide_scalar() : void
    + {static} double4_operator_div_scalar_wide() : void
    + {static} double4_operator_mod_wide_wide() : void
    + {static} double4_operator_mod_wide_scalar() : void
    + {static} double4_operator_mod_scalar_wide() : void
    + {static} double4_operator_plus() : void
    + {static} double4_operator_neg() : void
    + {static} double4_operator_prefix_inc() : void
    + {static} double4_operator_postfix_inc() : void
    + {static} double4_operator_prefix_dec() : void
    + {static} double4_operator_postfix_dec() : void
    + {static} double4_shuffle_result_1() : void
    + {static} double4_shuffle_result_2() : void
    + {static} double4_shuffle_result_3() : void
    + {static} double4_shuffle_result_4() : void
}
class TestDouble4x2 {
    + {static} double4x2_zero() : void
    + {static} double4x2_operator_equal_wide_wide() : void
    + {static} double4x2_operator_equal_wide_scalar() : void
    + {static} double4x2_operator_equal_scalar_wide() : void
    + {static} double4x2_operator_not_equal_wide_wide() : void
    + {static} double4x2_operator_not_equal_wide_scalar() : void
    + {static} double4x2_operator_not_equal_scalar_wide() : void
    + {static} double4x2_operator_less_wide_wide() : void
    + {static} double4x2_operator_less_wide_scalar() : void
    + {static} double4x2_operator_less_scalar_wide() : void
    + {static} double4x2_operator_greater_wide_wide() : void
    + {static} double4x2_operator_greater_wide_scalar() : void
    + {static} double4x2_operator_greater_scalar_wide() : void
    + {static} double4x2_operator_less_equal_wide_wide() : void
    + {static} double4x2_operator_less_equal_wide_scalar() : void
    + {static} double4x2_operator_less_equal_scalar_wide() : void
    + {static} double4x2_operator_greater_equal_wide_wide() : void
    + {static} double4x2_operator_greater_equal_wide_scalar() : void
    + {static} double4x2_operator_greater_equal_scalar_wide() : void
    + {static} double4x2_operator_add_wide_wide() : void
    + {static} double4x2_operator_add_wide_scalar() : void
    + {static} double4x2_operator_add_scalar_wide() : void
    + {static} double4x2_operator_sub_wide_wide() : void
    + {static} double4x2_operator_sub_wide_scalar() : void
    + {static} double4x2_operator_sub_scalar_wide() : void
    + {static} double4x2_operator_mul_wide_wide() : void
    + {static} double4x2_operator_mul_wide_scalar() : void
    + {static} double4x2_operator_mul_scalar_wide() : void
    + {static} double4x2_operator_div_wide_wide() : void
    + {static} double4x2_operator_div_wide_scalar() : void
    + {static} double4x2_operator_div_scalar_wide() : void
    + {static} double4x2_operator_mod_wide_wide() : void
    + {static} double4x2_operator_mod_wide_scalar() : void
    + {static} double4x2_operator_mod_scalar_wide() : void
    + {static} double4x2_operator_plus() : void
    + {static} double4x2_operator_neg() : void
    + {static} double4x2_operator_prefix_inc() : void
    + {static} double4x2_operator_postfix_inc() : void
    + {static} double4x2_operator_prefix_dec() : void
    + {static} double4x2_operator_postfix_dec() : void
}
class TestDouble4x3 {
    + {static} double4x3_zero() : void
    + {static} double4x3_operator_equal_wide_wide() : void
    + {static} double4x3_operator_equal_wide_scalar() : void
    + {static} double4x3_operator_equal_scalar_wide() : void
    + {static} double4x3_operator_not_equal_wide_wide() : void
    + {static} double4x3_operator_not_equal_wide_scalar() : void
    + {static} double4x3_operator_not_equal_scalar_wide() : void
    + {static} double4x3_operator_less_wide_wide() : void
    + {static} double4x3_operator_less_wide_scalar() : void
    + {static} double4x3_operator_less_scalar_wide() : void
    + {static} double4x3_operator_greater_wide_wide() : void
    + {static} double4x3_operator_greater_wide_scalar() : void
    + {static} double4x3_operator_greater_scalar_wide() : void
    + {static} double4x3_operator_less_equal_wide_wide() : void
    + {static} double4x3_operator_less_equal_wide_scalar() : void
    + {static} double4x3_operator_less_equal_scalar_wide() : void
    + {static} double4x3_operator_greater_equal_wide_wide() : void
    + {static} double4x3_operator_greater_equal_wide_scalar() : void
    + {static} double4x3_operator_greater_equal_scalar_wide() : void
    + {static} double4x3_operator_add_wide_wide() : void
    + {static} double4x3_operator_add_wide_scalar() : void
    + {static} double4x3_operator_add_scalar_wide() : void
    + {static} double4x3_operator_sub_wide_wide() : void
    + {static} double4x3_operator_sub_wide_scalar() : void
    + {static} double4x3_operator_sub_scalar_wide() : void
    + {static} double4x3_operator_mul_wide_wide() : void
    + {static} double4x3_operator_mul_wide_scalar() : void
    + {static} double4x3_operator_mul_scalar_wide() : void
    + {static} double4x3_operator_div_wide_wide() : void
    + {static} double4x3_operator_div_wide_scalar() : void
    + {static} double4x3_operator_div_scalar_wide() : void
    + {static} double4x3_operator_mod_wide_wide() : void
    + {static} double4x3_operator_mod_wide_scalar() : void
    + {static} double4x3_operator_mod_scalar_wide() : void
    + {static} double4x3_operator_plus() : void
    + {static} double4x3_operator_neg() : void
    + {static} double4x3_operator_prefix_inc() : void
    + {static} double4x3_operator_postfix_inc() : void
    + {static} double4x3_operator_prefix_dec() : void
    + {static} double4x3_operator_postfix_dec() : void
}
class TestDouble4x4 {
    + {static} double4x4_zero() : void
    + {static} double4x4_identity() : void
    + {static} double4x4_operator_equal_wide_wide() : void
    + {static} double4x4_operator_equal_wide_scalar() : void
    + {static} double4x4_operator_equal_scalar_wide() : void
    + {static} double4x4_operator_not_equal_wide_wide() : void
    + {static} double4x4_operator_not_equal_wide_scalar() : void
    + {static} double4x4_operator_not_equal_scalar_wide() : void
    + {static} double4x4_operator_less_wide_wide() : void
    + {static} double4x4_operator_less_wide_scalar() : void
    + {static} double4x4_operator_less_scalar_wide() : void
    + {static} double4x4_operator_greater_wide_wide() : void
    + {static} double4x4_operator_greater_wide_scalar() : void
    + {static} double4x4_operator_greater_scalar_wide() : void
    + {static} double4x4_operator_less_equal_wide_wide() : void
    + {static} double4x4_operator_less_equal_wide_scalar() : void
    + {static} double4x4_operator_less_equal_scalar_wide() : void
    + {static} double4x4_operator_greater_equal_wide_wide() : void
    + {static} double4x4_operator_greater_equal_wide_scalar() : void
    + {static} double4x4_operator_greater_equal_scalar_wide() : void
    + {static} double4x4_operator_add_wide_wide() : void
    + {static} double4x4_operator_add_wide_scalar() : void
    + {static} double4x4_operator_add_scalar_wide() : void
    + {static} double4x4_operator_sub_wide_wide() : void
    + {static} double4x4_operator_sub_wide_scalar() : void
    + {static} double4x4_operator_sub_scalar_wide() : void
    + {static} double4x4_operator_mul_wide_wide() : void
    + {static} double4x4_operator_mul_wide_scalar() : void
    + {static} double4x4_operator_mul_scalar_wide() : void
    + {static} double4x4_operator_div_wide_wide() : void
    + {static} double4x4_operator_div_wide_scalar() : void
    + {static} double4x4_operator_div_scalar_wide() : void
    + {static} double4x4_operator_mod_wide_wide() : void
    + {static} double4x4_operator_mod_wide_scalar() : void
    + {static} double4x4_operator_mod_scalar_wide() : void
    + {static} double4x4_operator_plus() : void
    + {static} double4x4_operator_neg() : void
    + {static} double4x4_operator_prefix_inc() : void
    + {static} double4x4_operator_postfix_inc() : void
    + {static} double4x4_operator_prefix_dec() : void
    + {static} double4x4_operator_postfix_dec() : void
}
class TestFloat2 {
    + {static} float2_zero() : void
    + {static} float2_constructor() : void
    + {static} float2_scalar_constructor() : void
    + {static} float2_static_constructor() : void
    + {static} float2_static_scalar_constructor() : void
    + {static} float2_operator_equal_wide_wide() : void
    + {static} float2_operator_equal_wide_scalar() : void
    + {static} float2_operator_equal_scalar_wide() : void
    + {static} float2_operator_not_equal_wide_wide() : void
    + {static} float2_operator_not_equal_wide_scalar() : void
    + {static} float2_operator_not_equal_scalar_wide() : void
    + {static} float2_operator_less_wide_wide() : void
    + {static} float2_operator_less_wide_scalar() : void
    + {static} float2_operator_less_scalar_wide() : void
    + {static} float2_operator_greater_wide_wide() : void
    + {static} float2_operator_greater_wide_scalar() : void
    + {static} float2_operator_greater_scalar_wide() : void
    + {static} float2_operator_less_equal_wide_wide() : void
    + {static} float2_operator_less_equal_wide_scalar() : void
    + {static} float2_operator_less_equal_scalar_wide() : void
    + {static} float2_operator_greater_equal_wide_wide() : void
    + {static} float2_operator_greater_equal_wide_scalar() : void
    + {static} float2_operator_greater_equal_scalar_wide() : void
    + {static} float2_operator_add_wide_wide() : void
    + {static} float2_operator_add_wide_scalar() : void
    + {static} float2_operator_add_scalar_wide() : void
    + {static} float2_operator_sub_wide_wide() : void
    + {static} float2_operator_sub_wide_scalar() : void
    + {static} float2_operator_sub_scalar_wide() : void
    + {static} float2_operator_mul_wide_wide() : void
    + {static} float2_operator_mul_wide_scalar() : void
    + {static} float2_operator_mul_scalar_wide() : void
    + {static} float2_operator_div_wide_wide() : void
    + {static} float2_operator_div_wide_scalar() : void
    + {static} float2_operator_div_scalar_wide() : void
    + {static} float2_operator_mod_wide_wide() : void
    + {static} float2_operator_mod_wide_scalar() : void
    + {static} float2_operator_mod_scalar_wide() : void
    + {static} float2_operator_plus() : void
    + {static} float2_operator_neg() : void
    + {static} float2_operator_prefix_inc() : void
    + {static} float2_operator_postfix_inc() : void
    + {static} float2_operator_prefix_dec() : void
    + {static} float2_operator_postfix_dec() : void
    + {static} float2_shuffle_result_1() : void
    + {static} float2_shuffle_result_2() : void
    + {static} float2_shuffle_result_3() : void
    + {static} float2_shuffle_result_4() : void
}
class TestFloat2x2 {
    + {static} float2x2_zero() : void
    + {static} float2x2_identity() : void
    + {static} float2x2_operator_equal_wide_wide() : void
    + {static} float2x2_operator_equal_wide_scalar() : void
    + {static} float2x2_operator_equal_scalar_wide() : void
    + {static} float2x2_operator_not_equal_wide_wide() : void
    + {static} float2x2_operator_not_equal_wide_scalar() : void
    + {static} float2x2_operator_not_equal_scalar_wide() : void
    + {static} float2x2_operator_less_wide_wide() : void
    + {static} float2x2_operator_less_wide_scalar() : void
    + {static} float2x2_operator_less_scalar_wide() : void
    + {static} float2x2_operator_greater_wide_wide() : void
    + {static} float2x2_operator_greater_wide_scalar() : void
    + {static} float2x2_operator_greater_scalar_wide() : void
    + {static} float2x2_operator_less_equal_wide_wide() : void
    + {static} float2x2_operator_less_equal_wide_scalar() : void
    + {static} float2x2_operator_less_equal_scalar_wide() : void
    + {static} float2x2_operator_greater_equal_wide_wide() : void
    + {static} float2x2_operator_greater_equal_wide_scalar() : void
    + {static} float2x2_operator_greater_equal_scalar_wide() : void
    + {static} float2x2_operator_add_wide_wide() : void
    + {static} float2x2_operator_add_wide_scalar() : void
    + {static} float2x2_operator_add_scalar_wide() : void
    + {static} float2x2_operator_sub_wide_wide() : void
    + {static} float2x2_operator_sub_wide_scalar() : void
    + {static} float2x2_operator_sub_scalar_wide() : void
    + {static} float2x2_operator_mul_wide_wide() : void
    + {static} float2x2_operator_mul_wide_scalar() : void
    + {static} float2x2_operator_mul_scalar_wide() : void
    + {static} float2x2_operator_div_wide_wide() : void
    + {static} float2x2_operator_div_wide_scalar() : void
    + {static} float2x2_operator_div_scalar_wide() : void
    + {static} float2x2_operator_mod_wide_wide() : void
    + {static} float2x2_operator_mod_wide_scalar() : void
    + {static} float2x2_operator_mod_scalar_wide() : void
    + {static} float2x2_operator_plus() : void
    + {static} float2x2_operator_neg() : void
    + {static} float2x2_operator_prefix_inc() : void
    + {static} float2x2_operator_postfix_inc() : void
    + {static} float2x2_operator_prefix_dec() : void
    + {static} float2x2_operator_postfix_dec() : void
}
class TestFloat2x3 {
    + {static} float2x3_zero() : void
    + {static} float2x3_operator_equal_wide_wide() : void
    + {static} float2x3_operator_equal_wide_scalar() : void
    + {static} float2x3_operator_equal_scalar_wide() : void
    + {static} float2x3_operator_not_equal_wide_wide() : void
    + {static} float2x3_operator_not_equal_wide_scalar() : void
    + {static} float2x3_operator_not_equal_scalar_wide() : void
    + {static} float2x3_operator_less_wide_wide() : void
    + {static} float2x3_operator_less_wide_scalar() : void
    + {static} float2x3_operator_less_scalar_wide() : void
    + {static} float2x3_operator_greater_wide_wide() : void
    + {static} float2x3_operator_greater_wide_scalar() : void
    + {static} float2x3_operator_greater_scalar_wide() : void
    + {static} float2x3_operator_less_equal_wide_wide() : void
    + {static} float2x3_operator_less_equal_wide_scalar() : void
    + {static} float2x3_operator_less_equal_scalar_wide() : void
    + {static} float2x3_operator_greater_equal_wide_wide() : void
    + {static} float2x3_operator_greater_equal_wide_scalar() : void
    + {static} float2x3_operator_greater_equal_scalar_wide() : void
    + {static} float2x3_operator_add_wide_wide() : void
    + {static} float2x3_operator_add_wide_scalar() : void
    + {static} float2x3_operator_add_scalar_wide() : void
    + {static} float2x3_operator_sub_wide_wide() : void
    + {static} float2x3_operator_sub_wide_scalar() : void
    + {static} float2x3_operator_sub_scalar_wide() : void
    + {static} float2x3_operator_mul_wide_wide() : void
    + {static} float2x3_operator_mul_wide_scalar() : void
    + {static} float2x3_operator_mul_scalar_wide() : void
    + {static} float2x3_operator_div_wide_wide() : void
    + {static} float2x3_operator_div_wide_scalar() : void
    + {static} float2x3_operator_div_scalar_wide() : void
    + {static} float2x3_operator_mod_wide_wide() : void
    + {static} float2x3_operator_mod_wide_scalar() : void
    + {static} float2x3_operator_mod_scalar_wide() : void
    + {static} float2x3_operator_plus() : void
    + {static} float2x3_operator_neg() : void
    + {static} float2x3_operator_prefix_inc() : void
    + {static} float2x3_operator_postfix_inc() : void
    + {static} float2x3_operator_prefix_dec() : void
    + {static} float2x3_operator_postfix_dec() : void
}
class TestFloat2x4 {
    + {static} float2x4_zero() : void
    + {static} float2x4_operator_equal_wide_wide() : void
    + {static} float2x4_operator_equal_wide_scalar() : void
    + {static} float2x4_operator_equal_scalar_wide() : void
    + {static} float2x4_operator_not_equal_wide_wide() : void
    + {static} float2x4_operator_not_equal_wide_scalar() : void
    + {static} float2x4_operator_not_equal_scalar_wide() : void
    + {static} float2x4_operator_less_wide_wide() : void
    + {static} float2x4_operator_less_wide_scalar() : void
    + {static} float2x4_operator_less_scalar_wide() : void
    + {static} float2x4_operator_greater_wide_wide() : void
    + {static} float2x4_operator_greater_wide_scalar() : void
    + {static} float2x4_operator_greater_scalar_wide() : void
    + {static} float2x4_operator_less_equal_wide_wide() : void
    + {static} float2x4_operator_less_equal_wide_scalar() : void
    + {static} float2x4_operator_less_equal_scalar_wide() : void
    + {static} float2x4_operator_greater_equal_wide_wide() : void
    + {static} float2x4_operator_greater_equal_wide_scalar() : void
    + {static} float2x4_operator_greater_equal_scalar_wide() : void
    + {static} float2x4_operator_add_wide_wide() : void
    + {static} float2x4_operator_add_wide_scalar() : void
    + {static} float2x4_operator_add_scalar_wide() : void
    + {static} float2x4_operator_sub_wide_wide() : void
    + {static} float2x4_operator_sub_wide_scalar() : void
    + {static} float2x4_operator_sub_scalar_wide() : void
    + {static} float2x4_operator_mul_wide_wide() : void
    + {static} float2x4_operator_mul_wide_scalar() : void
    + {static} float2x4_operator_mul_scalar_wide() : void
    + {static} float2x4_operator_div_wide_wide() : void
    + {static} float2x4_operator_div_wide_scalar() : void
    + {static} float2x4_operator_div_scalar_wide() : void
    + {static} float2x4_operator_mod_wide_wide() : void
    + {static} float2x4_operator_mod_wide_scalar() : void
    + {static} float2x4_operator_mod_scalar_wide() : void
    + {static} float2x4_operator_plus() : void
    + {static} float2x4_operator_neg() : void
    + {static} float2x4_operator_prefix_inc() : void
    + {static} float2x4_operator_postfix_inc() : void
    + {static} float2x4_operator_prefix_dec() : void
    + {static} float2x4_operator_postfix_dec() : void
}
class TestFloat3 {
    + {static} float3_zero() : void
    + {static} float3_constructor() : void
    + {static} float3_scalar_constructor() : void
    + {static} float3_static_constructor() : void
    + {static} float3_static_scalar_constructor() : void
    + {static} float3_operator_equal_wide_wide() : void
    + {static} float3_operator_equal_wide_scalar() : void
    + {static} float3_operator_equal_scalar_wide() : void
    + {static} float3_operator_not_equal_wide_wide() : void
    + {static} float3_operator_not_equal_wide_scalar() : void
    + {static} float3_operator_not_equal_scalar_wide() : void
    + {static} float3_operator_less_wide_wide() : void
    + {static} float3_operator_less_wide_scalar() : void
    + {static} float3_operator_less_scalar_wide() : void
    + {static} float3_operator_greater_wide_wide() : void
    + {static} float3_operator_greater_wide_scalar() : void
    + {static} float3_operator_greater_scalar_wide() : void
    + {static} float3_operator_less_equal_wide_wide() : void
    + {static} float3_operator_less_equal_wide_scalar() : void
    + {static} float3_operator_less_equal_scalar_wide() : void
    + {static} float3_operator_greater_equal_wide_wide() : void
    + {static} float3_operator_greater_equal_wide_scalar() : void
    + {static} float3_operator_greater_equal_scalar_wide() : void
    + {static} float3_operator_add_wide_wide() : void
    + {static} float3_operator_add_wide_scalar() : void
    + {static} float3_operator_add_scalar_wide() : void
    + {static} float3_operator_sub_wide_wide() : void
    + {static} float3_operator_sub_wide_scalar() : void
    + {static} float3_operator_sub_scalar_wide() : void
    + {static} float3_operator_mul_wide_wide() : void
    + {static} float3_operator_mul_wide_scalar() : void
    + {static} float3_operator_mul_scalar_wide() : void
    + {static} float3_operator_div_wide_wide() : void
    + {static} float3_operator_div_wide_scalar() : void
    + {static} float3_operator_div_scalar_wide() : void
    + {static} float3_operator_mod_wide_wide() : void
    + {static} float3_operator_mod_wide_scalar() : void
    + {static} float3_operator_mod_scalar_wide() : void
    + {static} float3_operator_plus() : void
    + {static} float3_operator_neg() : void
    + {static} float3_operator_prefix_inc() : void
    + {static} float3_operator_postfix_inc() : void
    + {static} float3_operator_prefix_dec() : void
    + {static} float3_operator_postfix_dec() : void
    + {static} float3_shuffle_result_1() : void
    + {static} float3_shuffle_result_2() : void
    + {static} float3_shuffle_result_3() : void
    + {static} float3_shuffle_result_4() : void
}
class TestFloat3x2 {
    + {static} float3x2_zero() : void
    + {static} float3x2_operator_equal_wide_wide() : void
    + {static} float3x2_operator_equal_wide_scalar() : void
    + {static} float3x2_operator_equal_scalar_wide() : void
    + {static} float3x2_operator_not_equal_wide_wide() : void
    + {static} float3x2_operator_not_equal_wide_scalar() : void
    + {static} float3x2_operator_not_equal_scalar_wide() : void
    + {static} float3x2_operator_less_wide_wide() : void
    + {static} float3x2_operator_less_wide_scalar() : void
    + {static} float3x2_operator_less_scalar_wide() : void
    + {static} float3x2_operator_greater_wide_wide() : void
    + {static} float3x2_operator_greater_wide_scalar() : void
    + {static} float3x2_operator_greater_scalar_wide() : void
    + {static} float3x2_operator_less_equal_wide_wide() : void
    + {static} float3x2_operator_less_equal_wide_scalar() : void
    + {static} float3x2_operator_less_equal_scalar_wide() : void
    + {static} float3x2_operator_greater_equal_wide_wide() : void
    + {static} float3x2_operator_greater_equal_wide_scalar() : void
    + {static} float3x2_operator_greater_equal_scalar_wide() : void
    + {static} float3x2_operator_add_wide_wide() : void
    + {static} float3x2_operator_add_wide_scalar() : void
    + {static} float3x2_operator_add_scalar_wide() : void
    + {static} float3x2_operator_sub_wide_wide() : void
    + {static} float3x2_operator_sub_wide_scalar() : void
    + {static} float3x2_operator_sub_scalar_wide() : void
    + {static} float3x2_operator_mul_wide_wide() : void
    + {static} float3x2_operator_mul_wide_scalar() : void
    + {static} float3x2_operator_mul_scalar_wide() : void
    + {static} float3x2_operator_div_wide_wide() : void
    + {static} float3x2_operator_div_wide_scalar() : void
    + {static} float3x2_operator_div_scalar_wide() : void
    + {static} float3x2_operator_mod_wide_wide() : void
    + {static} float3x2_operator_mod_wide_scalar() : void
    + {static} float3x2_operator_mod_scalar_wide() : void
    + {static} float3x2_operator_plus() : void
    + {static} float3x2_operator_neg() : void
    + {static} float3x2_operator_prefix_inc() : void
    + {static} float3x2_operator_postfix_inc() : void
    + {static} float3x2_operator_prefix_dec() : void
    + {static} float3x2_operator_postfix_dec() : void
}
class TestFloat3x3 {
    + {static} float3x3_zero() : void
    + {static} float3x3_identity() : void
    + {static} float3x3_operator_equal_wide_wide() : void
    + {static} float3x3_operator_equal_wide_scalar() : void
    + {static} float3x3_operator_equal_scalar_wide() : void
    + {static} float3x3_operator_not_equal_wide_wide() : void
    + {static} float3x3_operator_not_equal_wide_scalar() : void
    + {static} float3x3_operator_not_equal_scalar_wide() : void
    + {static} float3x3_operator_less_wide_wide() : void
    + {static} float3x3_operator_less_wide_scalar() : void
    + {static} float3x3_operator_less_scalar_wide() : void
    + {static} float3x3_operator_greater_wide_wide() : void
    + {static} float3x3_operator_greater_wide_scalar() : void
    + {static} float3x3_operator_greater_scalar_wide() : void
    + {static} float3x3_operator_less_equal_wide_wide() : void
    + {static} float3x3_operator_less_equal_wide_scalar() : void
    + {static} float3x3_operator_less_equal_scalar_wide() : void
    + {static} float3x3_operator_greater_equal_wide_wide() : void
    + {static} float3x3_operator_greater_equal_wide_scalar() : void
    + {static} float3x3_operator_greater_equal_scalar_wide() : void
    + {static} float3x3_operator_add_wide_wide() : void
    + {static} float3x3_operator_add_wide_scalar() : void
    + {static} float3x3_operator_add_scalar_wide() : void
    + {static} float3x3_operator_sub_wide_wide() : void
    + {static} float3x3_operator_sub_wide_scalar() : void
    + {static} float3x3_operator_sub_scalar_wide() : void
    + {static} float3x3_operator_mul_wide_wide() : void
    + {static} float3x3_operator_mul_wide_scalar() : void
    + {static} float3x3_operator_mul_scalar_wide() : void
    + {static} float3x3_operator_div_wide_wide() : void
    + {static} float3x3_operator_div_wide_scalar() : void
    + {static} float3x3_operator_div_scalar_wide() : void
    + {static} float3x3_operator_mod_wide_wide() : void
    + {static} float3x3_operator_mod_wide_scalar() : void
    + {static} float3x3_operator_mod_scalar_wide() : void
    + {static} float3x3_operator_plus() : void
    + {static} float3x3_operator_neg() : void
    + {static} float3x3_operator_prefix_inc() : void
    + {static} float3x3_operator_postfix_inc() : void
    + {static} float3x3_operator_prefix_dec() : void
    + {static} float3x3_operator_postfix_dec() : void
}
class TestFloat3x4 {
    + {static} float3x4_zero() : void
    + {static} float3x4_operator_equal_wide_wide() : void
    + {static} float3x4_operator_equal_wide_scalar() : void
    + {static} float3x4_operator_equal_scalar_wide() : void
    + {static} float3x4_operator_not_equal_wide_wide() : void
    + {static} float3x4_operator_not_equal_wide_scalar() : void
    + {static} float3x4_operator_not_equal_scalar_wide() : void
    + {static} float3x4_operator_less_wide_wide() : void
    + {static} float3x4_operator_less_wide_scalar() : void
    + {static} float3x4_operator_less_scalar_wide() : void
    + {static} float3x4_operator_greater_wide_wide() : void
    + {static} float3x4_operator_greater_wide_scalar() : void
    + {static} float3x4_operator_greater_scalar_wide() : void
    + {static} float3x4_operator_less_equal_wide_wide() : void
    + {static} float3x4_operator_less_equal_wide_scalar() : void
    + {static} float3x4_operator_less_equal_scalar_wide() : void
    + {static} float3x4_operator_greater_equal_wide_wide() : void
    + {static} float3x4_operator_greater_equal_wide_scalar() : void
    + {static} float3x4_operator_greater_equal_scalar_wide() : void
    + {static} float3x4_operator_add_wide_wide() : void
    + {static} float3x4_operator_add_wide_scalar() : void
    + {static} float3x4_operator_add_scalar_wide() : void
    + {static} float3x4_operator_sub_wide_wide() : void
    + {static} float3x4_operator_sub_wide_scalar() : void
    + {static} float3x4_operator_sub_scalar_wide() : void
    + {static} float3x4_operator_mul_wide_wide() : void
    + {static} float3x4_operator_mul_wide_scalar() : void
    + {static} float3x4_operator_mul_scalar_wide() : void
    + {static} float3x4_operator_div_wide_wide() : void
    + {static} float3x4_operator_div_wide_scalar() : void
    + {static} float3x4_operator_div_scalar_wide() : void
    + {static} float3x4_operator_mod_wide_wide() : void
    + {static} float3x4_operator_mod_wide_scalar() : void
    + {static} float3x4_operator_mod_scalar_wide() : void
    + {static} float3x4_operator_plus() : void
    + {static} float3x4_operator_neg() : void
    + {static} float3x4_operator_prefix_inc() : void
    + {static} float3x4_operator_postfix_inc() : void
    + {static} float3x4_operator_prefix_dec() : void
    + {static} float3x4_operator_postfix_dec() : void
}
class TestFloat4 {
    + {static} float4_zero() : void
    + {static} float4_constructor() : void
    + {static} float4_scalar_constructor() : void
    + {static} float4_static_constructor() : void
    + {static} float4_static_scalar_constructor() : void
    + {static} float4_operator_equal_wide_wide() : void
    + {static} float4_operator_equal_wide_scalar() : void
    + {static} float4_operator_equal_scalar_wide() : void
    + {static} float4_operator_not_equal_wide_wide() : void
    + {static} float4_operator_not_equal_wide_scalar() : void
    + {static} float4_operator_not_equal_scalar_wide() : void
    + {static} float4_operator_less_wide_wide() : void
    + {static} float4_operator_less_wide_scalar() : void
    + {static} float4_operator_less_scalar_wide() : void
    + {static} float4_operator_greater_wide_wide() : void
    + {static} float4_operator_greater_wide_scalar() : void
    + {static} float4_operator_greater_scalar_wide() : void
    + {static} float4_operator_less_equal_wide_wide() : void
    + {static} float4_operator_less_equal_wide_scalar() : void
    + {static} float4_operator_less_equal_scalar_wide() : void
    + {static} float4_operator_greater_equal_wide_wide() : void
    + {static} float4_operator_greater_equal_wide_scalar() : void
    + {static} float4_operator_greater_equal_scalar_wide() : void
    + {static} float4_operator_add_wide_wide() : void
    + {static} float4_operator_add_wide_scalar() : void
    + {static} float4_operator_add_scalar_wide() : void
    + {static} float4_operator_sub_wide_wide() : void
    + {static} float4_operator_sub_wide_scalar() : void
    + {static} float4_operator_sub_scalar_wide() : void
    + {static} float4_operator_mul_wide_wide() : void
    + {static} float4_operator_mul_wide_scalar() : void
    + {static} float4_operator_mul_scalar_wide() : void
    + {static} float4_operator_div_wide_wide() : void
    + {static} float4_operator_div_wide_scalar() : void
    + {static} float4_operator_div_scalar_wide() : void
    + {static} float4_operator_mod_wide_wide() : void
    + {static} float4_operator_mod_wide_scalar() : void
    + {static} float4_operator_mod_scalar_wide() : void
    + {static} float4_operator_plus() : void
    + {static} float4_operator_neg() : void
    + {static} float4_operator_prefix_inc() : void
    + {static} float4_operator_postfix_inc() : void
    + {static} float4_operator_prefix_dec() : void
    + {static} float4_operator_postfix_dec() : void
    + {static} float4_shuffle_result_1() : void
    + {static} float4_shuffle_result_2() : void
    + {static} float4_shuffle_result_3() : void
    + {static} float4_shuffle_result_4() : void
}
class TestFloat4x2 {
    + {static} float4x2_zero() : void
    + {static} float4x2_operator_equal_wide_wide() : void
    + {static} float4x2_operator_equal_wide_scalar() : void
    + {static} float4x2_operator_equal_scalar_wide() : void
    + {static} float4x2_operator_not_equal_wide_wide() : void
    + {static} float4x2_operator_not_equal_wide_scalar() : void
    + {static} float4x2_operator_not_equal_scalar_wide() : void
    + {static} float4x2_operator_less_wide_wide() : void
    + {static} float4x2_operator_less_wide_scalar() : void
    + {static} float4x2_operator_less_scalar_wide() : void
    + {static} float4x2_operator_greater_wide_wide() : void
    + {static} float4x2_operator_greater_wide_scalar() : void
    + {static} float4x2_operator_greater_scalar_wide() : void
    + {static} float4x2_operator_less_equal_wide_wide() : void
    + {static} float4x2_operator_less_equal_wide_scalar() : void
    + {static} float4x2_operator_less_equal_scalar_wide() : void
    + {static} float4x2_operator_greater_equal_wide_wide() : void
    + {static} float4x2_operator_greater_equal_wide_scalar() : void
    + {static} float4x2_operator_greater_equal_scalar_wide() : void
    + {static} float4x2_operator_add_wide_wide() : void
    + {static} float4x2_operator_add_wide_scalar() : void
    + {static} float4x2_operator_add_scalar_wide() : void
    + {static} float4x2_operator_sub_wide_wide() : void
    + {static} float4x2_operator_sub_wide_scalar() : void
    + {static} float4x2_operator_sub_scalar_wide() : void
    + {static} float4x2_operator_mul_wide_wide() : void
    + {static} float4x2_operator_mul_wide_scalar() : void
    + {static} float4x2_operator_mul_scalar_wide() : void
    + {static} float4x2_operator_div_wide_wide() : void
    + {static} float4x2_operator_div_wide_scalar() : void
    + {static} float4x2_operator_div_scalar_wide() : void
    + {static} float4x2_operator_mod_wide_wide() : void
    + {static} float4x2_operator_mod_wide_scalar() : void
    + {static} float4x2_operator_mod_scalar_wide() : void
    + {static} float4x2_operator_plus() : void
    + {static} float4x2_operator_neg() : void
    + {static} float4x2_operator_prefix_inc() : void
    + {static} float4x2_operator_postfix_inc() : void
    + {static} float4x2_operator_prefix_dec() : void
    + {static} float4x2_operator_postfix_dec() : void
}
class TestFloat4x3 {
    + {static} float4x3_zero() : void
    + {static} float4x3_operator_equal_wide_wide() : void
    + {static} float4x3_operator_equal_wide_scalar() : void
    + {static} float4x3_operator_equal_scalar_wide() : void
    + {static} float4x3_operator_not_equal_wide_wide() : void
    + {static} float4x3_operator_not_equal_wide_scalar() : void
    + {static} float4x3_operator_not_equal_scalar_wide() : void
    + {static} float4x3_operator_less_wide_wide() : void
    + {static} float4x3_operator_less_wide_scalar() : void
    + {static} float4x3_operator_less_scalar_wide() : void
    + {static} float4x3_operator_greater_wide_wide() : void
    + {static} float4x3_operator_greater_wide_scalar() : void
    + {static} float4x3_operator_greater_scalar_wide() : void
    + {static} float4x3_operator_less_equal_wide_wide() : void
    + {static} float4x3_operator_less_equal_wide_scalar() : void
    + {static} float4x3_operator_less_equal_scalar_wide() : void
    + {static} float4x3_operator_greater_equal_wide_wide() : void
    + {static} float4x3_operator_greater_equal_wide_scalar() : void
    + {static} float4x3_operator_greater_equal_scalar_wide() : void
    + {static} float4x3_operator_add_wide_wide() : void
    + {static} float4x3_operator_add_wide_scalar() : void
    + {static} float4x3_operator_add_scalar_wide() : void
    + {static} float4x3_operator_sub_wide_wide() : void
    + {static} float4x3_operator_sub_wide_scalar() : void
    + {static} float4x3_operator_sub_scalar_wide() : void
    + {static} float4x3_operator_mul_wide_wide() : void
    + {static} float4x3_operator_mul_wide_scalar() : void
    + {static} float4x3_operator_mul_scalar_wide() : void
    + {static} float4x3_operator_div_wide_wide() : void
    + {static} float4x3_operator_div_wide_scalar() : void
    + {static} float4x3_operator_div_scalar_wide() : void
    + {static} float4x3_operator_mod_wide_wide() : void
    + {static} float4x3_operator_mod_wide_scalar() : void
    + {static} float4x3_operator_mod_scalar_wide() : void
    + {static} float4x3_operator_plus() : void
    + {static} float4x3_operator_neg() : void
    + {static} float4x3_operator_prefix_inc() : void
    + {static} float4x3_operator_postfix_inc() : void
    + {static} float4x3_operator_prefix_dec() : void
    + {static} float4x3_operator_postfix_dec() : void
}
class TestFloat4x4 {
    + {static} float4x4_zero() : void
    + {static} float4x4_identity() : void
    + {static} float4x4_operator_equal_wide_wide() : void
    + {static} float4x4_operator_equal_wide_scalar() : void
    + {static} float4x4_operator_equal_scalar_wide() : void
    + {static} float4x4_operator_not_equal_wide_wide() : void
    + {static} float4x4_operator_not_equal_wide_scalar() : void
    + {static} float4x4_operator_not_equal_scalar_wide() : void
    + {static} float4x4_operator_less_wide_wide() : void
    + {static} float4x4_operator_less_wide_scalar() : void
    + {static} float4x4_operator_less_scalar_wide() : void
    + {static} float4x4_operator_greater_wide_wide() : void
    + {static} float4x4_operator_greater_wide_scalar() : void
    + {static} float4x4_operator_greater_scalar_wide() : void
    + {static} float4x4_operator_less_equal_wide_wide() : void
    + {static} float4x4_operator_less_equal_wide_scalar() : void
    + {static} float4x4_operator_less_equal_scalar_wide() : void
    + {static} float4x4_operator_greater_equal_wide_wide() : void
    + {static} float4x4_operator_greater_equal_wide_scalar() : void
    + {static} float4x4_operator_greater_equal_scalar_wide() : void
    + {static} float4x4_operator_add_wide_wide() : void
    + {static} float4x4_operator_add_wide_scalar() : void
    + {static} float4x4_operator_add_scalar_wide() : void
    + {static} float4x4_operator_sub_wide_wide() : void
    + {static} float4x4_operator_sub_wide_scalar() : void
    + {static} float4x4_operator_sub_scalar_wide() : void
    + {static} float4x4_operator_mul_wide_wide() : void
    + {static} float4x4_operator_mul_wide_scalar() : void
    + {static} float4x4_operator_mul_scalar_wide() : void
    + {static} float4x4_operator_div_wide_wide() : void
    + {static} float4x4_operator_div_wide_scalar() : void
    + {static} float4x4_operator_div_scalar_wide() : void
    + {static} float4x4_operator_mod_wide_wide() : void
    + {static} float4x4_operator_mod_wide_scalar() : void
    + {static} float4x4_operator_mod_scalar_wide() : void
    + {static} float4x4_operator_plus() : void
    + {static} float4x4_operator_neg() : void
    + {static} float4x4_operator_prefix_inc() : void
    + {static} float4x4_operator_postfix_inc() : void
    + {static} float4x4_operator_prefix_dec() : void
    + {static} float4x4_operator_postfix_dec() : void
}
class TestHalf <<partial>> {
    + {static} half_zero() : void
    + {static} half2_zero() : void
    + {static} half3_zero() : void
    + {static} half4_zero() : void
    + {static} half_from_float_construction() : void
    + {static} half_from_float_construction_signed_zero() : void
    + {static} half2_from_float2_construction() : void
    + {static} half2_from_float2_construction_signed_zero() : void
    + {static} half3_from_float3_construction() : void
    + {static} half3_from_float3_construction_signed_zero() : void
    + {static} half4_from_float4_construction() : void
    + {static} half4_from_float4_construction_signed_zero() : void
    + {static} half_from_double_construction() : void
    + {static} half_from_double_construction_signed_zero() : void
    + {static} half2_from_double2_construction() : void
    + {static} half2_from_double2_construction_signed_zero() : void
    + {static} half3_from_double3_construction() : void
    + {static} half3_from_double3_construction_signed_zero() : void
    + {static} half4_from_double4_construction() : void
    + {static} half4_from_double4_construction_signed_zero() : void
    + {static} half_to_float() : void
    + {static} half2_to_float2() : void
    + {static} half3_to_float3() : void
    + {static} half4_to_float4() : void
    + {static} half_to_double() : void
    + {static} half_from_float_explicit_conversion() : void
    + {static} half2_from_float2_explicit_conversion() : void
    + {static} half3_from_float3_explicit_conversion() : void
    + {static} half4_from_float4_explicit_conversion() : void
    + {static} half_from_double_explicit_conversion() : void
    + {static} half_to_float_implicit_conversion() : void
    + {static} half2_to_float2_implicit_conversion() : void
    + {static} half3_to_float3_implicit_conversion() : void
    + {static} half4_to_float4_implicit_conversion() : void
    + {static} half_to_double_implicit_conversion() : void
}
class TestInt2 {
    + {static} int2_zero() : void
    + {static} int2_constructor() : void
    + {static} int2_scalar_constructor() : void
    + {static} int2_static_constructor() : void
    + {static} int2_static_scalar_constructor() : void
    + {static} int2_operator_equal_wide_wide() : void
    + {static} int2_operator_equal_wide_scalar() : void
    + {static} int2_operator_equal_scalar_wide() : void
    + {static} int2_operator_not_equal_wide_wide() : void
    + {static} int2_operator_not_equal_wide_scalar() : void
    + {static} int2_operator_not_equal_scalar_wide() : void
    + {static} int2_operator_less_wide_wide() : void
    + {static} int2_operator_less_wide_scalar() : void
    + {static} int2_operator_less_scalar_wide() : void
    + {static} int2_operator_greater_wide_wide() : void
    + {static} int2_operator_greater_wide_scalar() : void
    + {static} int2_operator_greater_scalar_wide() : void
    + {static} int2_operator_less_equal_wide_wide() : void
    + {static} int2_operator_less_equal_wide_scalar() : void
    + {static} int2_operator_less_equal_scalar_wide() : void
    + {static} int2_operator_greater_equal_wide_wide() : void
    + {static} int2_operator_greater_equal_wide_scalar() : void
    + {static} int2_operator_greater_equal_scalar_wide() : void
    + {static} int2_operator_add_wide_wide() : void
    + {static} int2_operator_add_wide_scalar() : void
    + {static} int2_operator_add_scalar_wide() : void
    + {static} int2_operator_sub_wide_wide() : void
    + {static} int2_operator_sub_wide_scalar() : void
    + {static} int2_operator_sub_scalar_wide() : void
    + {static} int2_operator_mul_wide_wide() : void
    + {static} int2_operator_mul_wide_scalar() : void
    + {static} int2_operator_mul_scalar_wide() : void
    + {static} int2_operator_div_wide_wide() : void
    + {static} int2_operator_div_wide_scalar() : void
    + {static} int2_operator_div_scalar_wide() : void
    + {static} int2_operator_mod_wide_wide() : void
    + {static} int2_operator_mod_wide_scalar() : void
    + {static} int2_operator_mod_scalar_wide() : void
    + {static} int2_operator_plus() : void
    + {static} int2_operator_neg() : void
    + {static} int2_operator_prefix_inc() : void
    + {static} int2_operator_postfix_inc() : void
    + {static} int2_operator_prefix_dec() : void
    + {static} int2_operator_postfix_dec() : void
    + {static} int2_operator_bitwise_and_wide_wide() : void
    + {static} int2_operator_bitwise_and_wide_scalar() : void
    + {static} int2_operator_bitwise_and_scalar_wide() : void
    + {static} int2_operator_bitwise_or_wide_wide() : void
    + {static} int2_operator_bitwise_or_wide_scalar() : void
    + {static} int2_operator_bitwise_or_scalar_wide() : void
    + {static} int2_operator_bitwise_xor_wide_wide() : void
    + {static} int2_operator_bitwise_xor_wide_scalar() : void
    + {static} int2_operator_bitwise_xor_scalar_wide() : void
    + {static} int2_operator_left_shift() : void
    + {static} int2_operator_right_shift() : void
    + {static} int2_operator_bitwise_not() : void
    + {static} int2_shuffle_result_1() : void
    + {static} int2_shuffle_result_2() : void
    + {static} int2_shuffle_result_3() : void
    + {static} int2_shuffle_result_4() : void
}
class TestInt2x2 {
    + {static} int2x2_zero() : void
    + {static} int2x2_identity() : void
    + {static} int2x2_operator_equal_wide_wide() : void
    + {static} int2x2_operator_equal_wide_scalar() : void
    + {static} int2x2_operator_equal_scalar_wide() : void
    + {static} int2x2_operator_not_equal_wide_wide() : void
    + {static} int2x2_operator_not_equal_wide_scalar() : void
    + {static} int2x2_operator_not_equal_scalar_wide() : void
    + {static} int2x2_operator_less_wide_wide() : void
    + {static} int2x2_operator_less_wide_scalar() : void
    + {static} int2x2_operator_less_scalar_wide() : void
    + {static} int2x2_operator_greater_wide_wide() : void
    + {static} int2x2_operator_greater_wide_scalar() : void
    + {static} int2x2_operator_greater_scalar_wide() : void
    + {static} int2x2_operator_less_equal_wide_wide() : void
    + {static} int2x2_operator_less_equal_wide_scalar() : void
    + {static} int2x2_operator_less_equal_scalar_wide() : void
    + {static} int2x2_operator_greater_equal_wide_wide() : void
    + {static} int2x2_operator_greater_equal_wide_scalar() : void
    + {static} int2x2_operator_greater_equal_scalar_wide() : void
    + {static} int2x2_operator_add_wide_wide() : void
    + {static} int2x2_operator_add_wide_scalar() : void
    + {static} int2x2_operator_add_scalar_wide() : void
    + {static} int2x2_operator_sub_wide_wide() : void
    + {static} int2x2_operator_sub_wide_scalar() : void
    + {static} int2x2_operator_sub_scalar_wide() : void
    + {static} int2x2_operator_mul_wide_wide() : void
    + {static} int2x2_operator_mul_wide_scalar() : void
    + {static} int2x2_operator_mul_scalar_wide() : void
    + {static} int2x2_operator_div_wide_wide() : void
    + {static} int2x2_operator_div_wide_scalar() : void
    + {static} int2x2_operator_div_scalar_wide() : void
    + {static} int2x2_operator_mod_wide_wide() : void
    + {static} int2x2_operator_mod_wide_scalar() : void
    + {static} int2x2_operator_mod_scalar_wide() : void
    + {static} int2x2_operator_plus() : void
    + {static} int2x2_operator_neg() : void
    + {static} int2x2_operator_prefix_inc() : void
    + {static} int2x2_operator_postfix_inc() : void
    + {static} int2x2_operator_prefix_dec() : void
    + {static} int2x2_operator_postfix_dec() : void
    + {static} int2x2_operator_bitwise_and_wide_wide() : void
    + {static} int2x2_operator_bitwise_and_wide_scalar() : void
    + {static} int2x2_operator_bitwise_and_scalar_wide() : void
    + {static} int2x2_operator_bitwise_or_wide_wide() : void
    + {static} int2x2_operator_bitwise_or_wide_scalar() : void
    + {static} int2x2_operator_bitwise_or_scalar_wide() : void
    + {static} int2x2_operator_bitwise_xor_wide_wide() : void
    + {static} int2x2_operator_bitwise_xor_wide_scalar() : void
    + {static} int2x2_operator_bitwise_xor_scalar_wide() : void
    + {static} int2x2_operator_left_shift() : void
    + {static} int2x2_operator_right_shift() : void
    + {static} int2x2_operator_bitwise_not() : void
}
class TestInt2x3 {
    + {static} int2x3_zero() : void
    + {static} int2x3_operator_equal_wide_wide() : void
    + {static} int2x3_operator_equal_wide_scalar() : void
    + {static} int2x3_operator_equal_scalar_wide() : void
    + {static} int2x3_operator_not_equal_wide_wide() : void
    + {static} int2x3_operator_not_equal_wide_scalar() : void
    + {static} int2x3_operator_not_equal_scalar_wide() : void
    + {static} int2x3_operator_less_wide_wide() : void
    + {static} int2x3_operator_less_wide_scalar() : void
    + {static} int2x3_operator_less_scalar_wide() : void
    + {static} int2x3_operator_greater_wide_wide() : void
    + {static} int2x3_operator_greater_wide_scalar() : void
    + {static} int2x3_operator_greater_scalar_wide() : void
    + {static} int2x3_operator_less_equal_wide_wide() : void
    + {static} int2x3_operator_less_equal_wide_scalar() : void
    + {static} int2x3_operator_less_equal_scalar_wide() : void
    + {static} int2x3_operator_greater_equal_wide_wide() : void
    + {static} int2x3_operator_greater_equal_wide_scalar() : void
    + {static} int2x3_operator_greater_equal_scalar_wide() : void
    + {static} int2x3_operator_add_wide_wide() : void
    + {static} int2x3_operator_add_wide_scalar() : void
    + {static} int2x3_operator_add_scalar_wide() : void
    + {static} int2x3_operator_sub_wide_wide() : void
    + {static} int2x3_operator_sub_wide_scalar() : void
    + {static} int2x3_operator_sub_scalar_wide() : void
    + {static} int2x3_operator_mul_wide_wide() : void
    + {static} int2x3_operator_mul_wide_scalar() : void
    + {static} int2x3_operator_mul_scalar_wide() : void
    + {static} int2x3_operator_div_wide_wide() : void
    + {static} int2x3_operator_div_wide_scalar() : void
    + {static} int2x3_operator_div_scalar_wide() : void
    + {static} int2x3_operator_mod_wide_wide() : void
    + {static} int2x3_operator_mod_wide_scalar() : void
    + {static} int2x3_operator_mod_scalar_wide() : void
    + {static} int2x3_operator_plus() : void
    + {static} int2x3_operator_neg() : void
    + {static} int2x3_operator_prefix_inc() : void
    + {static} int2x3_operator_postfix_inc() : void
    + {static} int2x3_operator_prefix_dec() : void
    + {static} int2x3_operator_postfix_dec() : void
    + {static} int2x3_operator_bitwise_and_wide_wide() : void
    + {static} int2x3_operator_bitwise_and_wide_scalar() : void
    + {static} int2x3_operator_bitwise_and_scalar_wide() : void
    + {static} int2x3_operator_bitwise_or_wide_wide() : void
    + {static} int2x3_operator_bitwise_or_wide_scalar() : void
    + {static} int2x3_operator_bitwise_or_scalar_wide() : void
    + {static} int2x3_operator_bitwise_xor_wide_wide() : void
    + {static} int2x3_operator_bitwise_xor_wide_scalar() : void
    + {static} int2x3_operator_bitwise_xor_scalar_wide() : void
    + {static} int2x3_operator_left_shift() : void
    + {static} int2x3_operator_right_shift() : void
    + {static} int2x3_operator_bitwise_not() : void
}
class TestInt2x4 {
    + {static} int2x4_zero() : void
    + {static} int2x4_operator_equal_wide_wide() : void
    + {static} int2x4_operator_equal_wide_scalar() : void
    + {static} int2x4_operator_equal_scalar_wide() : void
    + {static} int2x4_operator_not_equal_wide_wide() : void
    + {static} int2x4_operator_not_equal_wide_scalar() : void
    + {static} int2x4_operator_not_equal_scalar_wide() : void
    + {static} int2x4_operator_less_wide_wide() : void
    + {static} int2x4_operator_less_wide_scalar() : void
    + {static} int2x4_operator_less_scalar_wide() : void
    + {static} int2x4_operator_greater_wide_wide() : void
    + {static} int2x4_operator_greater_wide_scalar() : void
    + {static} int2x4_operator_greater_scalar_wide() : void
    + {static} int2x4_operator_less_equal_wide_wide() : void
    + {static} int2x4_operator_less_equal_wide_scalar() : void
    + {static} int2x4_operator_less_equal_scalar_wide() : void
    + {static} int2x4_operator_greater_equal_wide_wide() : void
    + {static} int2x4_operator_greater_equal_wide_scalar() : void
    + {static} int2x4_operator_greater_equal_scalar_wide() : void
    + {static} int2x4_operator_add_wide_wide() : void
    + {static} int2x4_operator_add_wide_scalar() : void
    + {static} int2x4_operator_add_scalar_wide() : void
    + {static} int2x4_operator_sub_wide_wide() : void
    + {static} int2x4_operator_sub_wide_scalar() : void
    + {static} int2x4_operator_sub_scalar_wide() : void
    + {static} int2x4_operator_mul_wide_wide() : void
    + {static} int2x4_operator_mul_wide_scalar() : void
    + {static} int2x4_operator_mul_scalar_wide() : void
    + {static} int2x4_operator_div_wide_wide() : void
    + {static} int2x4_operator_div_wide_scalar() : void
    + {static} int2x4_operator_div_scalar_wide() : void
    + {static} int2x4_operator_mod_wide_wide() : void
    + {static} int2x4_operator_mod_wide_scalar() : void
    + {static} int2x4_operator_mod_scalar_wide() : void
    + {static} int2x4_operator_plus() : void
    + {static} int2x4_operator_neg() : void
    + {static} int2x4_operator_prefix_inc() : void
    + {static} int2x4_operator_postfix_inc() : void
    + {static} int2x4_operator_prefix_dec() : void
    + {static} int2x4_operator_postfix_dec() : void
    + {static} int2x4_operator_bitwise_and_wide_wide() : void
    + {static} int2x4_operator_bitwise_and_wide_scalar() : void
    + {static} int2x4_operator_bitwise_and_scalar_wide() : void
    + {static} int2x4_operator_bitwise_or_wide_wide() : void
    + {static} int2x4_operator_bitwise_or_wide_scalar() : void
    + {static} int2x4_operator_bitwise_or_scalar_wide() : void
    + {static} int2x4_operator_bitwise_xor_wide_wide() : void
    + {static} int2x4_operator_bitwise_xor_wide_scalar() : void
    + {static} int2x4_operator_bitwise_xor_scalar_wide() : void
    + {static} int2x4_operator_left_shift() : void
    + {static} int2x4_operator_right_shift() : void
    + {static} int2x4_operator_bitwise_not() : void
}
class TestInt3 {
    + {static} int3_zero() : void
    + {static} int3_constructor() : void
    + {static} int3_scalar_constructor() : void
    + {static} int3_static_constructor() : void
    + {static} int3_static_scalar_constructor() : void
    + {static} int3_operator_equal_wide_wide() : void
    + {static} int3_operator_equal_wide_scalar() : void
    + {static} int3_operator_equal_scalar_wide() : void
    + {static} int3_operator_not_equal_wide_wide() : void
    + {static} int3_operator_not_equal_wide_scalar() : void
    + {static} int3_operator_not_equal_scalar_wide() : void
    + {static} int3_operator_less_wide_wide() : void
    + {static} int3_operator_less_wide_scalar() : void
    + {static} int3_operator_less_scalar_wide() : void
    + {static} int3_operator_greater_wide_wide() : void
    + {static} int3_operator_greater_wide_scalar() : void
    + {static} int3_operator_greater_scalar_wide() : void
    + {static} int3_operator_less_equal_wide_wide() : void
    + {static} int3_operator_less_equal_wide_scalar() : void
    + {static} int3_operator_less_equal_scalar_wide() : void
    + {static} int3_operator_greater_equal_wide_wide() : void
    + {static} int3_operator_greater_equal_wide_scalar() : void
    + {static} int3_operator_greater_equal_scalar_wide() : void
    + {static} int3_operator_add_wide_wide() : void
    + {static} int3_operator_add_wide_scalar() : void
    + {static} int3_operator_add_scalar_wide() : void
    + {static} int3_operator_sub_wide_wide() : void
    + {static} int3_operator_sub_wide_scalar() : void
    + {static} int3_operator_sub_scalar_wide() : void
    + {static} int3_operator_mul_wide_wide() : void
    + {static} int3_operator_mul_wide_scalar() : void
    + {static} int3_operator_mul_scalar_wide() : void
    + {static} int3_operator_div_wide_wide() : void
    + {static} int3_operator_div_wide_scalar() : void
    + {static} int3_operator_div_scalar_wide() : void
    + {static} int3_operator_mod_wide_wide() : void
    + {static} int3_operator_mod_wide_scalar() : void
    + {static} int3_operator_mod_scalar_wide() : void
    + {static} int3_operator_plus() : void
    + {static} int3_operator_neg() : void
    + {static} int3_operator_prefix_inc() : void
    + {static} int3_operator_postfix_inc() : void
    + {static} int3_operator_prefix_dec() : void
    + {static} int3_operator_postfix_dec() : void
    + {static} int3_operator_bitwise_and_wide_wide() : void
    + {static} int3_operator_bitwise_and_wide_scalar() : void
    + {static} int3_operator_bitwise_and_scalar_wide() : void
    + {static} int3_operator_bitwise_or_wide_wide() : void
    + {static} int3_operator_bitwise_or_wide_scalar() : void
    + {static} int3_operator_bitwise_or_scalar_wide() : void
    + {static} int3_operator_bitwise_xor_wide_wide() : void
    + {static} int3_operator_bitwise_xor_wide_scalar() : void
    + {static} int3_operator_bitwise_xor_scalar_wide() : void
    + {static} int3_operator_left_shift() : void
    + {static} int3_operator_right_shift() : void
    + {static} int3_operator_bitwise_not() : void
    + {static} int3_shuffle_result_1() : void
    + {static} int3_shuffle_result_2() : void
    + {static} int3_shuffle_result_3() : void
    + {static} int3_shuffle_result_4() : void
}
class TestInt3x2 {
    + {static} int3x2_zero() : void
    + {static} int3x2_operator_equal_wide_wide() : void
    + {static} int3x2_operator_equal_wide_scalar() : void
    + {static} int3x2_operator_equal_scalar_wide() : void
    + {static} int3x2_operator_not_equal_wide_wide() : void
    + {static} int3x2_operator_not_equal_wide_scalar() : void
    + {static} int3x2_operator_not_equal_scalar_wide() : void
    + {static} int3x2_operator_less_wide_wide() : void
    + {static} int3x2_operator_less_wide_scalar() : void
    + {static} int3x2_operator_less_scalar_wide() : void
    + {static} int3x2_operator_greater_wide_wide() : void
    + {static} int3x2_operator_greater_wide_scalar() : void
    + {static} int3x2_operator_greater_scalar_wide() : void
    + {static} int3x2_operator_less_equal_wide_wide() : void
    + {static} int3x2_operator_less_equal_wide_scalar() : void
    + {static} int3x2_operator_less_equal_scalar_wide() : void
    + {static} int3x2_operator_greater_equal_wide_wide() : void
    + {static} int3x2_operator_greater_equal_wide_scalar() : void
    + {static} int3x2_operator_greater_equal_scalar_wide() : void
    + {static} int3x2_operator_add_wide_wide() : void
    + {static} int3x2_operator_add_wide_scalar() : void
    + {static} int3x2_operator_add_scalar_wide() : void
    + {static} int3x2_operator_sub_wide_wide() : void
    + {static} int3x2_operator_sub_wide_scalar() : void
    + {static} int3x2_operator_sub_scalar_wide() : void
    + {static} int3x2_operator_mul_wide_wide() : void
    + {static} int3x2_operator_mul_wide_scalar() : void
    + {static} int3x2_operator_mul_scalar_wide() : void
    + {static} int3x2_operator_div_wide_wide() : void
    + {static} int3x2_operator_div_wide_scalar() : void
    + {static} int3x2_operator_div_scalar_wide() : void
    + {static} int3x2_operator_mod_wide_wide() : void
    + {static} int3x2_operator_mod_wide_scalar() : void
    + {static} int3x2_operator_mod_scalar_wide() : void
    + {static} int3x2_operator_plus() : void
    + {static} int3x2_operator_neg() : void
    + {static} int3x2_operator_prefix_inc() : void
    + {static} int3x2_operator_postfix_inc() : void
    + {static} int3x2_operator_prefix_dec() : void
    + {static} int3x2_operator_postfix_dec() : void
    + {static} int3x2_operator_bitwise_and_wide_wide() : void
    + {static} int3x2_operator_bitwise_and_wide_scalar() : void
    + {static} int3x2_operator_bitwise_and_scalar_wide() : void
    + {static} int3x2_operator_bitwise_or_wide_wide() : void
    + {static} int3x2_operator_bitwise_or_wide_scalar() : void
    + {static} int3x2_operator_bitwise_or_scalar_wide() : void
    + {static} int3x2_operator_bitwise_xor_wide_wide() : void
    + {static} int3x2_operator_bitwise_xor_wide_scalar() : void
    + {static} int3x2_operator_bitwise_xor_scalar_wide() : void
    + {static} int3x2_operator_left_shift() : void
    + {static} int3x2_operator_right_shift() : void
    + {static} int3x2_operator_bitwise_not() : void
}
class TestInt3x3 {
    + {static} int3x3_zero() : void
    + {static} int3x3_identity() : void
    + {static} int3x3_operator_equal_wide_wide() : void
    + {static} int3x3_operator_equal_wide_scalar() : void
    + {static} int3x3_operator_equal_scalar_wide() : void
    + {static} int3x3_operator_not_equal_wide_wide() : void
    + {static} int3x3_operator_not_equal_wide_scalar() : void
    + {static} int3x3_operator_not_equal_scalar_wide() : void
    + {static} int3x3_operator_less_wide_wide() : void
    + {static} int3x3_operator_less_wide_scalar() : void
    + {static} int3x3_operator_less_scalar_wide() : void
    + {static} int3x3_operator_greater_wide_wide() : void
    + {static} int3x3_operator_greater_wide_scalar() : void
    + {static} int3x3_operator_greater_scalar_wide() : void
    + {static} int3x3_operator_less_equal_wide_wide() : void
    + {static} int3x3_operator_less_equal_wide_scalar() : void
    + {static} int3x3_operator_less_equal_scalar_wide() : void
    + {static} int3x3_operator_greater_equal_wide_wide() : void
    + {static} int3x3_operator_greater_equal_wide_scalar() : void
    + {static} int3x3_operator_greater_equal_scalar_wide() : void
    + {static} int3x3_operator_add_wide_wide() : void
    + {static} int3x3_operator_add_wide_scalar() : void
    + {static} int3x3_operator_add_scalar_wide() : void
    + {static} int3x3_operator_sub_wide_wide() : void
    + {static} int3x3_operator_sub_wide_scalar() : void
    + {static} int3x3_operator_sub_scalar_wide() : void
    + {static} int3x3_operator_mul_wide_wide() : void
    + {static} int3x3_operator_mul_wide_scalar() : void
    + {static} int3x3_operator_mul_scalar_wide() : void
    + {static} int3x3_operator_div_wide_wide() : void
    + {static} int3x3_operator_div_wide_scalar() : void
    + {static} int3x3_operator_div_scalar_wide() : void
    + {static} int3x3_operator_mod_wide_wide() : void
    + {static} int3x3_operator_mod_wide_scalar() : void
    + {static} int3x3_operator_mod_scalar_wide() : void
    + {static} int3x3_operator_plus() : void
    + {static} int3x3_operator_neg() : void
    + {static} int3x3_operator_prefix_inc() : void
    + {static} int3x3_operator_postfix_inc() : void
    + {static} int3x3_operator_prefix_dec() : void
    + {static} int3x3_operator_postfix_dec() : void
    + {static} int3x3_operator_bitwise_and_wide_wide() : void
    + {static} int3x3_operator_bitwise_and_wide_scalar() : void
    + {static} int3x3_operator_bitwise_and_scalar_wide() : void
    + {static} int3x3_operator_bitwise_or_wide_wide() : void
    + {static} int3x3_operator_bitwise_or_wide_scalar() : void
    + {static} int3x3_operator_bitwise_or_scalar_wide() : void
    + {static} int3x3_operator_bitwise_xor_wide_wide() : void
    + {static} int3x3_operator_bitwise_xor_wide_scalar() : void
    + {static} int3x3_operator_bitwise_xor_scalar_wide() : void
    + {static} int3x3_operator_left_shift() : void
    + {static} int3x3_operator_right_shift() : void
    + {static} int3x3_operator_bitwise_not() : void
}
class TestInt3x4 {
    + {static} int3x4_zero() : void
    + {static} int3x4_operator_equal_wide_wide() : void
    + {static} int3x4_operator_equal_wide_scalar() : void
    + {static} int3x4_operator_equal_scalar_wide() : void
    + {static} int3x4_operator_not_equal_wide_wide() : void
    + {static} int3x4_operator_not_equal_wide_scalar() : void
    + {static} int3x4_operator_not_equal_scalar_wide() : void
    + {static} int3x4_operator_less_wide_wide() : void
    + {static} int3x4_operator_less_wide_scalar() : void
    + {static} int3x4_operator_less_scalar_wide() : void
    + {static} int3x4_operator_greater_wide_wide() : void
    + {static} int3x4_operator_greater_wide_scalar() : void
    + {static} int3x4_operator_greater_scalar_wide() : void
    + {static} int3x4_operator_less_equal_wide_wide() : void
    + {static} int3x4_operator_less_equal_wide_scalar() : void
    + {static} int3x4_operator_less_equal_scalar_wide() : void
    + {static} int3x4_operator_greater_equal_wide_wide() : void
    + {static} int3x4_operator_greater_equal_wide_scalar() : void
    + {static} int3x4_operator_greater_equal_scalar_wide() : void
    + {static} int3x4_operator_add_wide_wide() : void
    + {static} int3x4_operator_add_wide_scalar() : void
    + {static} int3x4_operator_add_scalar_wide() : void
    + {static} int3x4_operator_sub_wide_wide() : void
    + {static} int3x4_operator_sub_wide_scalar() : void
    + {static} int3x4_operator_sub_scalar_wide() : void
    + {static} int3x4_operator_mul_wide_wide() : void
    + {static} int3x4_operator_mul_wide_scalar() : void
    + {static} int3x4_operator_mul_scalar_wide() : void
    + {static} int3x4_operator_div_wide_wide() : void
    + {static} int3x4_operator_div_wide_scalar() : void
    + {static} int3x4_operator_div_scalar_wide() : void
    + {static} int3x4_operator_mod_wide_wide() : void
    + {static} int3x4_operator_mod_wide_scalar() : void
    + {static} int3x4_operator_mod_scalar_wide() : void
    + {static} int3x4_operator_plus() : void
    + {static} int3x4_operator_neg() : void
    + {static} int3x4_operator_prefix_inc() : void
    + {static} int3x4_operator_postfix_inc() : void
    + {static} int3x4_operator_prefix_dec() : void
    + {static} int3x4_operator_postfix_dec() : void
    + {static} int3x4_operator_bitwise_and_wide_wide() : void
    + {static} int3x4_operator_bitwise_and_wide_scalar() : void
    + {static} int3x4_operator_bitwise_and_scalar_wide() : void
    + {static} int3x4_operator_bitwise_or_wide_wide() : void
    + {static} int3x4_operator_bitwise_or_wide_scalar() : void
    + {static} int3x4_operator_bitwise_or_scalar_wide() : void
    + {static} int3x4_operator_bitwise_xor_wide_wide() : void
    + {static} int3x4_operator_bitwise_xor_wide_scalar() : void
    + {static} int3x4_operator_bitwise_xor_scalar_wide() : void
    + {static} int3x4_operator_left_shift() : void
    + {static} int3x4_operator_right_shift() : void
    + {static} int3x4_operator_bitwise_not() : void
}
class TestInt4 {
    + {static} int4_zero() : void
    + {static} int4_constructor() : void
    + {static} int4_scalar_constructor() : void
    + {static} int4_static_constructor() : void
    + {static} int4_static_scalar_constructor() : void
    + {static} int4_operator_equal_wide_wide() : void
    + {static} int4_operator_equal_wide_scalar() : void
    + {static} int4_operator_equal_scalar_wide() : void
    + {static} int4_operator_not_equal_wide_wide() : void
    + {static} int4_operator_not_equal_wide_scalar() : void
    + {static} int4_operator_not_equal_scalar_wide() : void
    + {static} int4_operator_less_wide_wide() : void
    + {static} int4_operator_less_wide_scalar() : void
    + {static} int4_operator_less_scalar_wide() : void
    + {static} int4_operator_greater_wide_wide() : void
    + {static} int4_operator_greater_wide_scalar() : void
    + {static} int4_operator_greater_scalar_wide() : void
    + {static} int4_operator_less_equal_wide_wide() : void
    + {static} int4_operator_less_equal_wide_scalar() : void
    + {static} int4_operator_less_equal_scalar_wide() : void
    + {static} int4_operator_greater_equal_wide_wide() : void
    + {static} int4_operator_greater_equal_wide_scalar() : void
    + {static} int4_operator_greater_equal_scalar_wide() : void
    + {static} int4_operator_add_wide_wide() : void
    + {static} int4_operator_add_wide_scalar() : void
    + {static} int4_operator_add_scalar_wide() : void
    + {static} int4_operator_sub_wide_wide() : void
    + {static} int4_operator_sub_wide_scalar() : void
    + {static} int4_operator_sub_scalar_wide() : void
    + {static} int4_operator_mul_wide_wide() : void
    + {static} int4_operator_mul_wide_scalar() : void
    + {static} int4_operator_mul_scalar_wide() : void
    + {static} int4_operator_div_wide_wide() : void
    + {static} int4_operator_div_wide_scalar() : void
    + {static} int4_operator_div_scalar_wide() : void
    + {static} int4_operator_mod_wide_wide() : void
    + {static} int4_operator_mod_wide_scalar() : void
    + {static} int4_operator_mod_scalar_wide() : void
    + {static} int4_operator_plus() : void
    + {static} int4_operator_neg() : void
    + {static} int4_operator_prefix_inc() : void
    + {static} int4_operator_postfix_inc() : void
    + {static} int4_operator_prefix_dec() : void
    + {static} int4_operator_postfix_dec() : void
    + {static} int4_operator_bitwise_and_wide_wide() : void
    + {static} int4_operator_bitwise_and_wide_scalar() : void
    + {static} int4_operator_bitwise_and_scalar_wide() : void
    + {static} int4_operator_bitwise_or_wide_wide() : void
    + {static} int4_operator_bitwise_or_wide_scalar() : void
    + {static} int4_operator_bitwise_or_scalar_wide() : void
    + {static} int4_operator_bitwise_xor_wide_wide() : void
    + {static} int4_operator_bitwise_xor_wide_scalar() : void
    + {static} int4_operator_bitwise_xor_scalar_wide() : void
    + {static} int4_operator_left_shift() : void
    + {static} int4_operator_right_shift() : void
    + {static} int4_operator_bitwise_not() : void
    + {static} int4_shuffle_result_1() : void
    + {static} int4_shuffle_result_2() : void
    + {static} int4_shuffle_result_3() : void
    + {static} int4_shuffle_result_4() : void
}
class TestInt4x2 {
    + {static} int4x2_zero() : void
    + {static} int4x2_operator_equal_wide_wide() : void
    + {static} int4x2_operator_equal_wide_scalar() : void
    + {static} int4x2_operator_equal_scalar_wide() : void
    + {static} int4x2_operator_not_equal_wide_wide() : void
    + {static} int4x2_operator_not_equal_wide_scalar() : void
    + {static} int4x2_operator_not_equal_scalar_wide() : void
    + {static} int4x2_operator_less_wide_wide() : void
    + {static} int4x2_operator_less_wide_scalar() : void
    + {static} int4x2_operator_less_scalar_wide() : void
    + {static} int4x2_operator_greater_wide_wide() : void
    + {static} int4x2_operator_greater_wide_scalar() : void
    + {static} int4x2_operator_greater_scalar_wide() : void
    + {static} int4x2_operator_less_equal_wide_wide() : void
    + {static} int4x2_operator_less_equal_wide_scalar() : void
    + {static} int4x2_operator_less_equal_scalar_wide() : void
    + {static} int4x2_operator_greater_equal_wide_wide() : void
    + {static} int4x2_operator_greater_equal_wide_scalar() : void
    + {static} int4x2_operator_greater_equal_scalar_wide() : void
    + {static} int4x2_operator_add_wide_wide() : void
    + {static} int4x2_operator_add_wide_scalar() : void
    + {static} int4x2_operator_add_scalar_wide() : void
    + {static} int4x2_operator_sub_wide_wide() : void
    + {static} int4x2_operator_sub_wide_scalar() : void
    + {static} int4x2_operator_sub_scalar_wide() : void
    + {static} int4x2_operator_mul_wide_wide() : void
    + {static} int4x2_operator_mul_wide_scalar() : void
    + {static} int4x2_operator_mul_scalar_wide() : void
    + {static} int4x2_operator_div_wide_wide() : void
    + {static} int4x2_operator_div_wide_scalar() : void
    + {static} int4x2_operator_div_scalar_wide() : void
    + {static} int4x2_operator_mod_wide_wide() : void
    + {static} int4x2_operator_mod_wide_scalar() : void
    + {static} int4x2_operator_mod_scalar_wide() : void
    + {static} int4x2_operator_plus() : void
    + {static} int4x2_operator_neg() : void
    + {static} int4x2_operator_prefix_inc() : void
    + {static} int4x2_operator_postfix_inc() : void
    + {static} int4x2_operator_prefix_dec() : void
    + {static} int4x2_operator_postfix_dec() : void
    + {static} int4x2_operator_bitwise_and_wide_wide() : void
    + {static} int4x2_operator_bitwise_and_wide_scalar() : void
    + {static} int4x2_operator_bitwise_and_scalar_wide() : void
    + {static} int4x2_operator_bitwise_or_wide_wide() : void
    + {static} int4x2_operator_bitwise_or_wide_scalar() : void
    + {static} int4x2_operator_bitwise_or_scalar_wide() : void
    + {static} int4x2_operator_bitwise_xor_wide_wide() : void
    + {static} int4x2_operator_bitwise_xor_wide_scalar() : void
    + {static} int4x2_operator_bitwise_xor_scalar_wide() : void
    + {static} int4x2_operator_left_shift() : void
    + {static} int4x2_operator_right_shift() : void
    + {static} int4x2_operator_bitwise_not() : void
}
class TestInt4x3 {
    + {static} int4x3_zero() : void
    + {static} int4x3_operator_equal_wide_wide() : void
    + {static} int4x3_operator_equal_wide_scalar() : void
    + {static} int4x3_operator_equal_scalar_wide() : void
    + {static} int4x3_operator_not_equal_wide_wide() : void
    + {static} int4x3_operator_not_equal_wide_scalar() : void
    + {static} int4x3_operator_not_equal_scalar_wide() : void
    + {static} int4x3_operator_less_wide_wide() : void
    + {static} int4x3_operator_less_wide_scalar() : void
    + {static} int4x3_operator_less_scalar_wide() : void
    + {static} int4x3_operator_greater_wide_wide() : void
    + {static} int4x3_operator_greater_wide_scalar() : void
    + {static} int4x3_operator_greater_scalar_wide() : void
    + {static} int4x3_operator_less_equal_wide_wide() : void
    + {static} int4x3_operator_less_equal_wide_scalar() : void
    + {static} int4x3_operator_less_equal_scalar_wide() : void
    + {static} int4x3_operator_greater_equal_wide_wide() : void
    + {static} int4x3_operator_greater_equal_wide_scalar() : void
    + {static} int4x3_operator_greater_equal_scalar_wide() : void
    + {static} int4x3_operator_add_wide_wide() : void
    + {static} int4x3_operator_add_wide_scalar() : void
    + {static} int4x3_operator_add_scalar_wide() : void
    + {static} int4x3_operator_sub_wide_wide() : void
    + {static} int4x3_operator_sub_wide_scalar() : void
    + {static} int4x3_operator_sub_scalar_wide() : void
    + {static} int4x3_operator_mul_wide_wide() : void
    + {static} int4x3_operator_mul_wide_scalar() : void
    + {static} int4x3_operator_mul_scalar_wide() : void
    + {static} int4x3_operator_div_wide_wide() : void
    + {static} int4x3_operator_div_wide_scalar() : void
    + {static} int4x3_operator_div_scalar_wide() : void
    + {static} int4x3_operator_mod_wide_wide() : void
    + {static} int4x3_operator_mod_wide_scalar() : void
    + {static} int4x3_operator_mod_scalar_wide() : void
    + {static} int4x3_operator_plus() : void
    + {static} int4x3_operator_neg() : void
    + {static} int4x3_operator_prefix_inc() : void
    + {static} int4x3_operator_postfix_inc() : void
    + {static} int4x3_operator_prefix_dec() : void
    + {static} int4x3_operator_postfix_dec() : void
    + {static} int4x3_operator_bitwise_and_wide_wide() : void
    + {static} int4x3_operator_bitwise_and_wide_scalar() : void
    + {static} int4x3_operator_bitwise_and_scalar_wide() : void
    + {static} int4x3_operator_bitwise_or_wide_wide() : void
    + {static} int4x3_operator_bitwise_or_wide_scalar() : void
    + {static} int4x3_operator_bitwise_or_scalar_wide() : void
    + {static} int4x3_operator_bitwise_xor_wide_wide() : void
    + {static} int4x3_operator_bitwise_xor_wide_scalar() : void
    + {static} int4x3_operator_bitwise_xor_scalar_wide() : void
    + {static} int4x3_operator_left_shift() : void
    + {static} int4x3_operator_right_shift() : void
    + {static} int4x3_operator_bitwise_not() : void
}
class TestInt4x4 {
    + {static} int4x4_zero() : void
    + {static} int4x4_identity() : void
    + {static} int4x4_operator_equal_wide_wide() : void
    + {static} int4x4_operator_equal_wide_scalar() : void
    + {static} int4x4_operator_equal_scalar_wide() : void
    + {static} int4x4_operator_not_equal_wide_wide() : void
    + {static} int4x4_operator_not_equal_wide_scalar() : void
    + {static} int4x4_operator_not_equal_scalar_wide() : void
    + {static} int4x4_operator_less_wide_wide() : void
    + {static} int4x4_operator_less_wide_scalar() : void
    + {static} int4x4_operator_less_scalar_wide() : void
    + {static} int4x4_operator_greater_wide_wide() : void
    + {static} int4x4_operator_greater_wide_scalar() : void
    + {static} int4x4_operator_greater_scalar_wide() : void
    + {static} int4x4_operator_less_equal_wide_wide() : void
    + {static} int4x4_operator_less_equal_wide_scalar() : void
    + {static} int4x4_operator_less_equal_scalar_wide() : void
    + {static} int4x4_operator_greater_equal_wide_wide() : void
    + {static} int4x4_operator_greater_equal_wide_scalar() : void
    + {static} int4x4_operator_greater_equal_scalar_wide() : void
    + {static} int4x4_operator_add_wide_wide() : void
    + {static} int4x4_operator_add_wide_scalar() : void
    + {static} int4x4_operator_add_scalar_wide() : void
    + {static} int4x4_operator_sub_wide_wide() : void
    + {static} int4x4_operator_sub_wide_scalar() : void
    + {static} int4x4_operator_sub_scalar_wide() : void
    + {static} int4x4_operator_mul_wide_wide() : void
    + {static} int4x4_operator_mul_wide_scalar() : void
    + {static} int4x4_operator_mul_scalar_wide() : void
    + {static} int4x4_operator_div_wide_wide() : void
    + {static} int4x4_operator_div_wide_scalar() : void
    + {static} int4x4_operator_div_scalar_wide() : void
    + {static} int4x4_operator_mod_wide_wide() : void
    + {static} int4x4_operator_mod_wide_scalar() : void
    + {static} int4x4_operator_mod_scalar_wide() : void
    + {static} int4x4_operator_plus() : void
    + {static} int4x4_operator_neg() : void
    + {static} int4x4_operator_prefix_inc() : void
    + {static} int4x4_operator_postfix_inc() : void
    + {static} int4x4_operator_prefix_dec() : void
    + {static} int4x4_operator_postfix_dec() : void
    + {static} int4x4_operator_bitwise_and_wide_wide() : void
    + {static} int4x4_operator_bitwise_and_wide_scalar() : void
    + {static} int4x4_operator_bitwise_and_scalar_wide() : void
    + {static} int4x4_operator_bitwise_or_wide_wide() : void
    + {static} int4x4_operator_bitwise_or_wide_scalar() : void
    + {static} int4x4_operator_bitwise_or_scalar_wide() : void
    + {static} int4x4_operator_bitwise_xor_wide_wide() : void
    + {static} int4x4_operator_bitwise_xor_wide_scalar() : void
    + {static} int4x4_operator_bitwise_xor_scalar_wide() : void
    + {static} int4x4_operator_left_shift() : void
    + {static} int4x4_operator_right_shift() : void
    + {static} int4x4_operator_bitwise_not() : void
}
class TestMath <<partial>> {
    + {static} asint_uint() : void
    + {static} asint_uint2() : void
    + {static} asint_uint3() : void
    + {static} asint_uint4() : void
    + {static} asint_float() : void
    + {static} asint_float_signed_zero() : void
    + {static} asint_float2() : void
    + {static} asint_float2_signed_zero() : void
    + {static} asint_float3() : void
    + {static} asint_float3_signed_zero() : void
    + {static} asint_float4() : void
    + {static} asint_float4_signed_zero() : void
    + {static} asuint_int() : void
    + {static} asuint_int2() : void
    + {static} asuint_int3() : void
    + {static} asuint_int4() : void
    + {static} asuint_float() : void
    + {static} asuint_float_signed_zero() : void
    + {static} asuint_float2() : void
    + {static} asuint_float2_signed_zero() : void
    + {static} asuint_float3() : void
    + {static} asuint_float3_signed_zero() : void
    + {static} asuint_float4() : void
    + {static} asuint_float4_singed_zero() : void
    + {static} aslong_ulong() : void
    + {static} aslong_double() : void
    + {static} aslong_double_signed_zero() : void
    + {static} asulong_long() : void
    + {static} asulong_double() : void
    + {static} asulong_double_signed_zero() : void
    + {static} asfloat_int() : void
    + {static} asfloat_int2() : void
    + {static} asfloat_int3() : void
    + {static} asfloat_int4() : void
    + {static} asfloat_uint() : void
    + {static} asfloat_uint2() : void
    + {static} asfloat_uint3() : void
    + {static} asfloat_uint4() : void
    + {static} asdouble_long() : void
    + {static} asdouble_ulong() : void
    + {static} faceforward_float2() : void
    + {static} faceforward_float3() : void
    + {static} faceforward_float4() : void
    + {static} faceforward_double2() : void
    + {static} faceforward_double3() : void
    + {static} faceforward_double4() : void
    + {static} modf_float() : void
    + {static} modf_float2() : void
    + {static} modf_float3() : void
    + {static} modf_float4() : void
    + {static} modf_double() : void
    + {static} modf_double2() : void
    + {static} modf_double3() : void
    + {static} modf_double4() : void
    + {static} normalize_float2() : void
    + {static} normalize_float3() : void
    + {static} normalize_float4() : void
    + {static} normalize_double2() : void
    + {static} normalize_double3() : void
    + {static} normalize_double4() : void
    + {static} normalize_quaternion() : void
    + {static} normalizesafe_float2() : void
    + {static} normalizesafe_float3() : void
    + {static} normalizesafe_float4() : void
    + {static} normalizesafe_double2() : void
    + {static} normalizesafe_double3() : void
    + {static} normalizesafe_double4() : void
    + {static} normalizesafe_quaternion() : void
    + {static} f16tof32_float() : void
    + {static} f16tof32_float2() : void
    + {static} f16tof32_float3() : void
    + {static} f16tof32_float4() : void
    + {static} f32tof16_float() : void
    + {static} f32tof16_float_signed_zero() : void
    + {static} f32tof16_float2() : void
    + {static} f32tof16_float2_signed_zero() : void
    + {static} f32tof16_float3() : void
    + {static} f32tof16_float3_signed_zero() : void
    + {static} f32tof16_float4() : void
    + {static} f32tof16_float4_signed_zero() : void
    + {static} reflect_float2() : void
    + {static} reflect_float3() : void
    + {static} reflect_float4() : void
    + {static} reflect_double2() : void
    + {static} reflect_double3() : void
    + {static} reflect_double4() : void
    + {static} refract_float2() : void
    + {static} refract_float3() : void
    + {static} refract_float4() : void
    + {static} refract_double2() : void
    + {static} refract_double3() : void
    + {static} refract_double4() : void
    + {static} sincos_float() : void
    + {static} sincos_float2() : void
    + {static} sincos_float3() : void
    + {static} sincos_float4() : void
    + {static} sincos_double() : void
    + {static} sincos_double2() : void
    + {static} sincos_double3() : void
    + {static} sincos_double4() : void
    + {static} select_int() : void
    + {static} select_int2() : void
    + {static} select_int3() : void
    + {static} select_int4() : void
    + {static} select_uint() : void
    + {static} select_uint2() : void
    + {static} select_uint3() : void
    + {static} select_uint4() : void
    + {static} select_long() : void
    + {static} select_ulong() : void
    + {static} select_float() : void
    + {static} select_float2() : void
    + {static} select_float3() : void
    + {static} select_float4() : void
    + {static} select_double() : void
    + {static} select_double2() : void
    + {static} select_double3() : void
    + {static} select_double4() : void
    + {static} dot_int() : void
    + {static} dot_int2() : void
    + {static} dot_int3() : void
    + {static} dot_int4() : void
    + {static} dot_uint() : void
    + {static} dot_uint2() : void
    + {static} dot_uint3() : void
    + {static} dot_uint4() : void
    + {static} dot_float() : void
    + {static} dot_float2() : void
    + {static} dot_float3() : void
    + {static} dot_float4() : void
    + {static} dot_double() : void
    + {static} dot_double2() : void
    + {static} dot_double3() : void
    + {static} dot_double4() : void
    + {static} cmin_int2() : void
    + {static} cmin_int3() : void
    + {static} cmin_int4() : void
    + {static} cmin_uint2() : void
    + {static} cmin_uint3() : void
    + {static} cmin_uint4() : void
    + {static} cmin_float2() : void
    + {static} cmin_float3() : void
    + {static} cmin_float4() : void
    + {static} cmin_double2() : void
    + {static} cmin_double3() : void
    + {static} cmin_double4() : void
    + {static} cmax_int2() : void
    + {static} cmax_int3() : void
    + {static} cmax_int4() : void
    + {static} cmax_uint2() : void
    + {static} cmax_uint3() : void
    + {static} cmax_uint4() : void
    + {static} cmax_float2() : void
    + {static} cmax_float3() : void
    + {static} cmax_float4() : void
    + {static} cmax_double2() : void
    + {static} cmax_double3() : void
    + {static} cmax_double4() : void
    + {static} csum_int2() : void
    + {static} csum_int3() : void
    + {static} csum_int4() : void
    + {static} csum_uint2() : void
    + {static} csum_uint3() : void
    + {static} csum_uint4() : void
    + {static} csum_float2() : void
    + {static} csum_float3() : void
    + {static} csum_float4() : void
    + {static} csum_double2() : void
    + {static} csum_double3() : void
    + {static} csum_double4() : void
    + {static} any_bool2() : void
    + {static} any_bool3() : void
    + {static} any_bool4() : void
    + {static} any_int2() : void
    + {static} any_int3() : void
    + {static} any_int4() : void
    + {static} any_uint2() : void
    + {static} any_uint3() : void
    + {static} any_uint4() : void
    + {static} any_float2() : void
    + {static} any_float3() : void
    + {static} any_float4() : void
    + {static} any_double2() : void
    + {static} any_double3() : void
    + {static} any_double4() : void
    + {static} all_bool2() : void
    + {static} all_bool3() : void
    + {static} all_bool4() : void
    + {static} all_int2() : void
    + {static} all_int3() : void
    + {static} all_int4() : void
    + {static} all_uint2() : void
    + {static} all_uint3() : void
    + {static} all_uint4() : void
    + {static} all_float2() : void
    + {static} all_float3() : void
    + {static} all_float4() : void
    + {static} all_double2() : void
    + {static} all_double3() : void
    + {static} all_double4() : void
    + {static} length_float2() : void
    + {static} length_float3() : void
    + {static} length_float4() : void
    + {static} length_double2() : void
    + {static} length_double3() : void
    + {static} length_double4() : void
    + {static} lengthsq_float2() : void
    + {static} lengthsq_float3() : void
    + {static} lengthsq_float4() : void
    + {static} lengthsq_double2() : void
    + {static} lengthsq_double3() : void
    + {static} lengthsq_double4() : void
    + {static} distance_float2() : void
    + {static} distance_float3() : void
    + {static} distance_float4() : void
    + {static} distance_double2() : void
    + {static} distance_double3() : void
    + {static} distance_double4() : void
    + {static} distancesq_float2() : void
    + {static} distancesq_float3() : void
    + {static} distancesq_float4() : void
    + {static} distancesq_double2() : void
    + {static} distancesq_double3() : void
    + {static} distancesq_double4() : void
    + {static} rcp_float_signed_zero() : void
    + {static} rcp_float2_signed_zero() : void
    + {static} rcp_float3_signed_zero() : void
    + {static} rcp_float4_signed_zero() : void
    + {static} rcp_double_signed_zero() : void
    + {static} rcp_double2_signed_zero() : void
    + {static} rcp_double3_signed_zero() : void
    + {static} rcp_double4_signed_zero() : void
    <<unsafe>> + {static} compress_test() : void
}
class TestMath <<partial>> {
    + {static} abs_int() : void
    + {static} abs_int2() : void
    + {static} abs_int3() : void
    + {static} abs_int4() : void
    + {static} abs_float() : void
    + {static} abs_float2() : void
    + {static} abs_float3() : void
    + {static} abs_float4() : void
    + {static} abs_double() : void
    + {static} abs_double2() : void
    + {static} abs_double3() : void
    + {static} abs_double4() : void
    + {static} isfinite_float() : void
    + {static} isfinite_float2() : void
    + {static} isfinite_float3() : void
    + {static} isfinite_float4() : void
    + {static} isfinite_double() : void
    + {static} isfinite_double2() : void
    + {static} isfinite_double3() : void
    + {static} isfinite_double4() : void
    + {static} isinf_float() : void
    + {static} isinf_float2() : void
    + {static} isinf_float3() : void
    + {static} isinf_float4() : void
    + {static} isinf_double() : void
    + {static} isinf_double2() : void
    + {static} isinf_double3() : void
    + {static} isinf_double4() : void
    + {static} isnan_float() : void
    + {static} isnan_float2() : void
    + {static} isnan_float3() : void
    + {static} isnan_float4() : void
    + {static} isnan_double() : void
    + {static} isnan_double2() : void
    + {static} isnan_double3() : void
    + {static} isnan_double4() : void
    + {static} sin_float() : void
    + {static} sin_float2() : void
    + {static} sin_float3() : void
    + {static} sin_float4() : void
    + {static} sin_double() : void
    + {static} sin_double2() : void
    + {static} sin_double3() : void
    + {static} sin_double4() : void
    + {static} cos_float() : void
    + {static} cos_float2() : void
    + {static} cos_float3() : void
    + {static} cos_float4() : void
    + {static} cos_double() : void
    + {static} cos_double2() : void
    + {static} cos_double3() : void
    + {static} cos_double4() : void
    + {static} tan_float() : void
    + {static} tan_float2() : void
    + {static} tan_float3() : void
    + {static} tan_float4() : void
    + {static} tan_double() : void
    + {static} tan_double2() : void
    + {static} tan_double3() : void
    + {static} tan_double4() : void
    + {static} atan_float() : void
    + {static} atan_float2() : void
    + {static} atan_float3() : void
    + {static} atan_float4() : void
    + {static} atan_double() : void
    + {static} atan_double2() : void
    + {static} atan_double3() : void
    + {static} atan_double4() : void
    + {static} atan2_float() : void
    + {static} atan2_float2() : void
    + {static} atan2_float3() : void
    + {static} atan2_float4() : void
    + {static} atan2_double() : void
    + {static} atan2_double2() : void
    + {static} atan2_double3() : void
    + {static} atan2_double4() : void
    + {static} sinh_float() : void
    + {static} sinh_float2() : void
    + {static} sinh_float3() : void
    + {static} sinh_float4() : void
    + {static} sinh_double() : void
    + {static} sinh_double2() : void
    + {static} sinh_double3() : void
    + {static} sinh_double4() : void
    + {static} cosh_float() : void
    + {static} cosh_float2() : void
    + {static} cosh_float3() : void
    + {static} cosh_float4() : void
    + {static} cosh_double() : void
    + {static} cosh_double2() : void
    + {static} cosh_double3() : void
    + {static} cosh_double4() : void
    + {static} tanh_float() : void
    + {static} tanh_float2() : void
    + {static} tanh_float3() : void
    + {static} tanh_float4() : void
    + {static} tanh_double() : void
    + {static} tanh_double2() : void
    + {static} tanh_double3() : void
    + {static} tanh_double4() : void
    + {static} exp_float() : void
    + {static} exp_float2() : void
    + {static} exp_float3() : void
    + {static} exp_float4() : void
    + {static} exp_double() : void
    + {static} exp_double2() : void
    + {static} exp_double3() : void
    + {static} exp_double4() : void
    + {static} exp2_float() : void
    + {static} exp2_float2() : void
    + {static} exp2_float3() : void
    + {static} exp2_float4() : void
    + {static} exp2_double() : void
    + {static} exp2_double2() : void
    + {static} exp2_double3() : void
    + {static} exp2_double4() : void
    + {static} exp10_float() : void
    + {static} exp10_float2() : void
    + {static} exp10_float3() : void
    + {static} exp10_float4() : void
    + {static} exp10_double() : void
    + {static} exp10_double2() : void
    + {static} exp10_double3() : void
    + {static} exp10_double4() : void
    + {static} log_float() : void
    + {static} log_float2() : void
    + {static} log_float3() : void
    + {static} log_float4() : void
    + {static} log_double() : void
    + {static} log_double2() : void
    + {static} log_double3() : void
    + {static} log_double4() : void
    + {static} log2_float() : void
    + {static} log2_float2() : void
    + {static} log2_float3() : void
    + {static} log2_float4() : void
    + {static} log2_double() : void
    + {static} log2_double2() : void
    + {static} log2_double3() : void
    + {static} log2_double4() : void
    + {static} log10_float() : void
    + {static} log10_float2() : void
    + {static} log10_float3() : void
    + {static} log10_float4() : void
    + {static} log10_double() : void
    + {static} log10_double2() : void
    + {static} log10_double3() : void
    + {static} log10_double4() : void
    + {static} radians_float() : void
    + {static} radians_float2() : void
    + {static} radians_float3() : void
    + {static} radians_float4() : void
    + {static} radians_double() : void
    + {static} radians_double2() : void
    + {static} radians_double3() : void
    + {static} radians_double4() : void
    + {static} degrees_float() : void
    + {static} degrees_float2() : void
    + {static} degrees_float3() : void
    + {static} degrees_float4() : void
    + {static} degrees_double() : void
    + {static} degrees_double2() : void
    + {static} degrees_double3() : void
    + {static} degrees_double4() : void
    + {static} sign_float() : void
    + {static} sign_float2() : void
    + {static} sign_float3() : void
    + {static} sign_float4() : void
    + {static} sign_double() : void
    + {static} sign_double2() : void
    + {static} sign_double3() : void
    + {static} sign_double4() : void
    + {static} sqrt_float() : void
    + {static} sqrt_float2() : void
    + {static} sqrt_float3() : void
    + {static} sqrt_float4() : void
    + {static} sqrt_double() : void
    + {static} sqrt_double2() : void
    + {static} sqrt_double3() : void
    + {static} sqrt_double4() : void
    + {static} rsqrt_float() : void
    + {static} rsqrt_float2() : void
    + {static} rsqrt_float3() : void
    + {static} rsqrt_float4() : void
    + {static} rsqrt_double() : void
    + {static} rsqrt_double2() : void
    + {static} rsqrt_double3() : void
    + {static} rsqrt_double4() : void
    + {static} rcp_float() : void
    + {static} rcp_float2() : void
    + {static} rcp_float3() : void
    + {static} rcp_float4() : void
    + {static} rcp_double() : void
    + {static} rcp_double2() : void
    + {static} rcp_double3() : void
    + {static} rcp_double4() : void
    + {static} floor_float() : void
    + {static} floor_float2() : void
    + {static} floor_float3() : void
    + {static} floor_float4() : void
    + {static} floor_double() : void
    + {static} floor_double2() : void
    + {static} floor_double3() : void
    + {static} floor_double4() : void
    + {static} ceil_float() : void
    + {static} ceil_float2() : void
    + {static} ceil_float3() : void
    + {static} ceil_float4() : void
    + {static} ceil_double() : void
    + {static} ceil_double2() : void
    + {static} ceil_double3() : void
    + {static} ceil_double4() : void
    + {static} round_float() : void
    + {static} round_float2() : void
    + {static} round_float3() : void
    + {static} round_float4() : void
    + {static} round_double() : void
    + {static} round_double2() : void
    + {static} round_double3() : void
    + {static} round_double4() : void
    + {static} trunc_float() : void
    + {static} trunc_float2() : void
    + {static} trunc_float3() : void
    + {static} trunc_float4() : void
    + {static} trunc_double() : void
    + {static} trunc_double2() : void
    + {static} trunc_double3() : void
    + {static} trunc_double4() : void
    + {static} frac_float() : void
    + {static} frac_float2() : void
    + {static} frac_float3() : void
    + {static} frac_float4() : void
    + {static} frac_double() : void
    + {static} frac_double2() : void
    + {static} frac_double3() : void
    + {static} frac_double4() : void
    + {static} lerp_float() : void
    + {static} lerp_float2() : void
    + {static} lerp_float3() : void
    + {static} lerp_float4() : void
    + {static} lerp_double() : void
    + {static} lerp_double2() : void
    + {static} lerp_double3() : void
    + {static} lerp_double4() : void
    + {static} unlerp_float() : void
    + {static} unlerp_float2() : void
    + {static} unlerp_float3() : void
    + {static} unlerp_float4() : void
    + {static} unlerp_double() : void
    + {static} unlerp_double2() : void
    + {static} unlerp_double3() : void
    + {static} unlerp_double4() : void
    + {static} remap_float() : void
    + {static} remap_float2() : void
    + {static} remap_float3() : void
    + {static} remap_float4() : void
    + {static} remap_double() : void
    + {static} remap_double2() : void
    + {static} remap_double3() : void
    + {static} remap_double4() : void
    + {static} clamp_int() : void
    + {static} clamp_int2() : void
    + {static} clamp_int3() : void
    + {static} clamp_int4() : void
    + {static} clamp_uint() : void
    + {static} clamp_uint2() : void
    + {static} clamp_uint3() : void
    + {static} clamp_uint4() : void
    + {static} clamp_long() : void
    + {static} clamp_ulong() : void
    + {static} clamp_float() : void
    + {static} clamp_float2() : void
    + {static} clamp_float3() : void
    + {static} clamp_float4() : void
    + {static} clamp_double() : void
    + {static} clamp_double2() : void
    + {static} clamp_double3() : void
    + {static} clamp_double4() : void
    + {static} saturate_float() : void
    + {static} saturate_float2() : void
    + {static} saturate_float3() : void
    + {static} saturate_float4() : void
    + {static} saturate_double() : void
    + {static} saturate_double2() : void
    + {static} saturate_double3() : void
    + {static} saturate_double4() : void
    + {static} step_float() : void
    + {static} step_float2() : void
    + {static} step_float3() : void
    + {static} step_float4() : void
    + {static} step_double() : void
    + {static} step_double2() : void
    + {static} step_double3() : void
    + {static} step_double4() : void
    + {static} min_int() : void
    + {static} min_int2() : void
    + {static} min_int3() : void
    + {static} min_int4() : void
    + {static} min_uint() : void
    + {static} min_uint2() : void
    + {static} min_uint3() : void
    + {static} min_uint4() : void
    + {static} min_long() : void
    + {static} min_ulong() : void
    + {static} min_float() : void
    + {static} min_float2() : void
    + {static} min_float3() : void
    + {static} min_float4() : void
    + {static} min_double() : void
    + {static} min_double2() : void
    + {static} min_double3() : void
    + {static} min_double4() : void
    + {static} max_int() : void
    + {static} max_int2() : void
    + {static} max_int3() : void
    + {static} max_int4() : void
    + {static} max_uint() : void
    + {static} max_uint2() : void
    + {static} max_uint3() : void
    + {static} max_uint4() : void
    + {static} max_long() : void
    + {static} max_ulong() : void
    + {static} max_float() : void
    + {static} max_float2() : void
    + {static} max_float3() : void
    + {static} max_float4() : void
    + {static} max_double() : void
    + {static} max_double2() : void
    + {static} max_double3() : void
    + {static} max_double4() : void
    + {static} smoothstep_float() : void
    + {static} smoothstep_float2() : void
    + {static} smoothstep_float3() : void
    + {static} smoothstep_float4() : void
    + {static} smoothstep_double() : void
    + {static} smoothstep_double2() : void
    + {static} smoothstep_double3() : void
    + {static} smoothstep_double4() : void
    + {static} mad_int() : void
    + {static} mad_int2() : void
    + {static} mad_int3() : void
    + {static} mad_int4() : void
    + {static} mad_uint() : void
    + {static} mad_uint2() : void
    + {static} mad_uint3() : void
    + {static} mad_uint4() : void
    + {static} mad_long() : void
    + {static} mad_ulong() : void
    + {static} mad_float() : void
    + {static} mad_float2() : void
    + {static} mad_float3() : void
    + {static} mad_float4() : void
    + {static} mad_double() : void
    + {static} mad_double2() : void
    + {static} mad_double3() : void
    + {static} mad_double4() : void
    + {static} fmod_float() : void
    + {static} fmod_float2() : void
    + {static} fmod_float3() : void
    + {static} fmod_float4() : void
    + {static} fmod_double() : void
    + {static} fmod_double2() : void
    + {static} fmod_double3() : void
    + {static} fmod_double4() : void
    + {static} pow_float() : void
    + {static} pow_float2() : void
    + {static} pow_float3() : void
    + {static} pow_float4() : void
    + {static} pow_double() : void
    + {static} pow_double2() : void
    + {static} pow_double3() : void
    + {static} pow_double4() : void
    + {static} ceilpow2_int() : void
    + {static} ceilpow2_int2() : void
    + {static} ceilpow2_int3() : void
    + {static} ceilpow2_int4() : void
    + {static} ceilpow2_uint() : void
    + {static} ceilpow2_uint2() : void
    + {static} ceilpow2_uint3() : void
    + {static} ceilpow2_uint4() : void
    + {static} ceilpow2_long() : void
    + {static} ceilpow2_ulong() : void
}
class TestMatrix {
    + {static} float2x2_constructor_columns() : void
    + {static} float3x3_constructor_columns() : void
    + {static} float4x4_constructor_columns() : void
    + {static} float2x2_constructor_scalars() : void
    + {static} float3x3_constructor_scalars() : void
    + {static} float4x4_constructor_scalars() : void
    + {static} float4x4_constructor_float3x3() : void
    + {static} float3x3_constructor_quaternion() : void
    + {static} float4x4_constructor_quaternion_position() : void
    + {static} float2x2_identity() : void
    + {static} float3x3_identity() : void
    + {static} float4x4_identity() : void
    + {static} float2x2_rotate() : void
    + {static} float3x3_axis_angle() : void
    + {static} float3x3_axis_angle_consistency() : void
    + {static} float3x3_rotate_x() : void
    + {static} float3x3_rotate_y() : void
    + {static} float3x3_rotate_z() : void
    + {static} float3x3_rotate_x_handedness() : void
    + {static} float3x3_rotate_y_handedness() : void
    + {static} float3x3_rotate_z_handedness() : void
    + {static} float4x4_axis_angle() : void
    + {static} float4x4_axis_angle_consistency() : void
    + {static} float4x4_rotate_x() : void
    + {static} float4x4_rotate_y() : void
    + {static} float4x4_rotate_z() : void
    + {static} float4x4_rotate_x_handedness() : void
    + {static} float4x4_rotate_y_handedness() : void
    + {static} float4x4_rotate_z_handedness() : void
    + {static} float3x3_euler() : void
    + {static} float4x4_euler() : void
    + {static} float2x2_scale() : void
    + {static} float3x3_scale() : void
    + {static} float4x4_scale() : void
    + {static} float2x2_matrix_mul() : void
    + {static} float3x3_matrix_mul() : void
    + {static} float4x4_matrix_mul() : void
    + {static} float2x2_transpose() : void
    + {static} float3x3_transpose() : void
    + {static} float4x4_transpose() : void
    + {static} float2x2_inverse() : void
    + {static} float3x3_inverse() : void
    + {static} float4x4_inverse() : void
    + {static} float3x4_fastinverse() : void
    + {static} float4x4_fastinverse() : void
    + {static} float2x2_determinant() : void
    + {static} float3x3_determinant() : void
    + {static} float4x4_determinant() : void
    + {static} float3x3_look_rotation() : void
    + {static} float3x3_look_rotation_safe() : void
    + {static} float4x4_lookat() : void
    + {static} float4x4_ortho() : void
    + {static} float4x4_orthoOffCenter() : void
    + {static} float4x4_perspective() : void
    + {static} float4x4_perspectiveOffCenter() : void
    + {static} float4x4_TRS() : void
}
TestMatrix o-> "test_angles" float3
TestMatrix o-> "test3x3_xyz" float3x3
TestMatrix o-> "test3x3_xzy" float3x3
TestMatrix o-> "test3x3_yxz" float3x3
TestMatrix o-> "test3x3_yzx" float3x3
TestMatrix o-> "test3x3_zxy" float3x3
TestMatrix o-> "test3x3_zyx" float3x3
TestMatrix o-> "test4x4_xyz" float4x4
TestMatrix o-> "test4x4_xzy" float4x4
TestMatrix o-> "test4x4_yxz" float4x4
TestMatrix o-> "test4x4_yzx" float4x4
TestMatrix o-> "test4x4_zxy" float4x4
TestMatrix o-> "test4x4_zyx" float4x4
class TestQuaternion {
    + {static} quaternion_basic_constructors() : void
    + {static} quaternion_construct_from_matrix() : void
    + {static} quaternion_construct_from_matrix3x3_torture() : void
    + {static} quaternion_construct_from_matrix4x4_torture() : void
    + {static} quaternion_axis_angle() : void
    + {static} quaternion_axis_angle_consistency() : void
    + {static} quaternion_euler() : void
    + {static} quaternion_rotateX() : void
    + {static} quaternion_rotateY() : void
    + {static} quaternion_rotateZ() : void
    + {static} quaternion_conjugate() : void
    + {static} quaternion_inverse() : void
    + {static} quaternion_dot() : void
    + {static} quaternion_nlerp() : void
    + {static} quaternion_slerp() : void
    + {static} quaternion_mul_vector() : void
    + {static} quaternion_log_exp_identity() : void
    + {static} quaternion_log_exp_rotation() : void
    + {static} quaternion_unitlog_unitexp_rotation() : void
    + {static} quaternion_look_rotation() : void
    + {static} quaternion_look_rotation_safe() : void
}
TestQuaternion o-> "test_q0" quaternion
TestQuaternion o-> "test_q1" quaternion
TestQuaternion o-> "test_q2" quaternion
TestQuaternion o-> "test_q3" quaternion
class TestRigidTransform {
    + {static} rigid_transform_construct_from_matrix() : void
    + {static} rigid_transform_axisAngle() : void
    + {static} rigid_transform_euler() : void
    + {static} rigid_transform_rotateX() : void
    + {static} rigid_transform_rotateY() : void
    + {static} rigid_transform_rotateZ() : void
    + {static} rigid_transform_inverse() : void
    + {static} rigid_transform_mul_vector() : void
}
TestRigidTransform o-> "test_q0" quaternion
TestRigidTransform o-> "test_q1" quaternion
TestRigidTransform o-> "test_q2" quaternion
TestRigidTransform o-> "test_q3" quaternion
class TestUint2 {
    + {static} uint2_zero() : void
    + {static} uint2_constructor() : void
    + {static} uint2_scalar_constructor() : void
    + {static} uint2_static_constructor() : void
    + {static} uint2_static_scalar_constructor() : void
    + {static} uint2_operator_equal_wide_wide() : void
    + {static} uint2_operator_equal_wide_scalar() : void
    + {static} uint2_operator_equal_scalar_wide() : void
    + {static} uint2_operator_not_equal_wide_wide() : void
    + {static} uint2_operator_not_equal_wide_scalar() : void
    + {static} uint2_operator_not_equal_scalar_wide() : void
    + {static} uint2_operator_less_wide_wide() : void
    + {static} uint2_operator_less_wide_scalar() : void
    + {static} uint2_operator_less_scalar_wide() : void
    + {static} uint2_operator_greater_wide_wide() : void
    + {static} uint2_operator_greater_wide_scalar() : void
    + {static} uint2_operator_greater_scalar_wide() : void
    + {static} uint2_operator_less_equal_wide_wide() : void
    + {static} uint2_operator_less_equal_wide_scalar() : void
    + {static} uint2_operator_less_equal_scalar_wide() : void
    + {static} uint2_operator_greater_equal_wide_wide() : void
    + {static} uint2_operator_greater_equal_wide_scalar() : void
    + {static} uint2_operator_greater_equal_scalar_wide() : void
    + {static} uint2_operator_add_wide_wide() : void
    + {static} uint2_operator_add_wide_scalar() : void
    + {static} uint2_operator_add_scalar_wide() : void
    + {static} uint2_operator_sub_wide_wide() : void
    + {static} uint2_operator_sub_wide_scalar() : void
    + {static} uint2_operator_sub_scalar_wide() : void
    + {static} uint2_operator_mul_wide_wide() : void
    + {static} uint2_operator_mul_wide_scalar() : void
    + {static} uint2_operator_mul_scalar_wide() : void
    + {static} uint2_operator_div_wide_wide() : void
    + {static} uint2_operator_div_wide_scalar() : void
    + {static} uint2_operator_div_scalar_wide() : void
    + {static} uint2_operator_mod_wide_wide() : void
    + {static} uint2_operator_mod_wide_scalar() : void
    + {static} uint2_operator_mod_scalar_wide() : void
    + {static} uint2_operator_plus() : void
    + {static} uint2_operator_neg() : void
    + {static} uint2_operator_prefix_inc() : void
    + {static} uint2_operator_postfix_inc() : void
    + {static} uint2_operator_prefix_dec() : void
    + {static} uint2_operator_postfix_dec() : void
    + {static} uint2_operator_bitwise_and_wide_wide() : void
    + {static} uint2_operator_bitwise_and_wide_scalar() : void
    + {static} uint2_operator_bitwise_and_scalar_wide() : void
    + {static} uint2_operator_bitwise_or_wide_wide() : void
    + {static} uint2_operator_bitwise_or_wide_scalar() : void
    + {static} uint2_operator_bitwise_or_scalar_wide() : void
    + {static} uint2_operator_bitwise_xor_wide_wide() : void
    + {static} uint2_operator_bitwise_xor_wide_scalar() : void
    + {static} uint2_operator_bitwise_xor_scalar_wide() : void
    + {static} uint2_operator_left_shift() : void
    + {static} uint2_operator_right_shift() : void
    + {static} uint2_operator_bitwise_not() : void
    + {static} uint2_shuffle_result_1() : void
    + {static} uint2_shuffle_result_2() : void
    + {static} uint2_shuffle_result_3() : void
    + {static} uint2_shuffle_result_4() : void
}
class TestUint2x2 {
    + {static} uint2x2_zero() : void
    + {static} uint2x2_identity() : void
    + {static} uint2x2_operator_equal_wide_wide() : void
    + {static} uint2x2_operator_equal_wide_scalar() : void
    + {static} uint2x2_operator_equal_scalar_wide() : void
    + {static} uint2x2_operator_not_equal_wide_wide() : void
    + {static} uint2x2_operator_not_equal_wide_scalar() : void
    + {static} uint2x2_operator_not_equal_scalar_wide() : void
    + {static} uint2x2_operator_less_wide_wide() : void
    + {static} uint2x2_operator_less_wide_scalar() : void
    + {static} uint2x2_operator_less_scalar_wide() : void
    + {static} uint2x2_operator_greater_wide_wide() : void
    + {static} uint2x2_operator_greater_wide_scalar() : void
    + {static} uint2x2_operator_greater_scalar_wide() : void
    + {static} uint2x2_operator_less_equal_wide_wide() : void
    + {static} uint2x2_operator_less_equal_wide_scalar() : void
    + {static} uint2x2_operator_less_equal_scalar_wide() : void
    + {static} uint2x2_operator_greater_equal_wide_wide() : void
    + {static} uint2x2_operator_greater_equal_wide_scalar() : void
    + {static} uint2x2_operator_greater_equal_scalar_wide() : void
    + {static} uint2x2_operator_add_wide_wide() : void
    + {static} uint2x2_operator_add_wide_scalar() : void
    + {static} uint2x2_operator_add_scalar_wide() : void
    + {static} uint2x2_operator_sub_wide_wide() : void
    + {static} uint2x2_operator_sub_wide_scalar() : void
    + {static} uint2x2_operator_sub_scalar_wide() : void
    + {static} uint2x2_operator_mul_wide_wide() : void
    + {static} uint2x2_operator_mul_wide_scalar() : void
    + {static} uint2x2_operator_mul_scalar_wide() : void
    + {static} uint2x2_operator_div_wide_wide() : void
    + {static} uint2x2_operator_div_wide_scalar() : void
    + {static} uint2x2_operator_div_scalar_wide() : void
    + {static} uint2x2_operator_mod_wide_wide() : void
    + {static} uint2x2_operator_mod_wide_scalar() : void
    + {static} uint2x2_operator_mod_scalar_wide() : void
    + {static} uint2x2_operator_plus() : void
    + {static} uint2x2_operator_neg() : void
    + {static} uint2x2_operator_prefix_inc() : void
    + {static} uint2x2_operator_postfix_inc() : void
    + {static} uint2x2_operator_prefix_dec() : void
    + {static} uint2x2_operator_postfix_dec() : void
    + {static} uint2x2_operator_bitwise_and_wide_wide() : void
    + {static} uint2x2_operator_bitwise_and_wide_scalar() : void
    + {static} uint2x2_operator_bitwise_and_scalar_wide() : void
    + {static} uint2x2_operator_bitwise_or_wide_wide() : void
    + {static} uint2x2_operator_bitwise_or_wide_scalar() : void
    + {static} uint2x2_operator_bitwise_or_scalar_wide() : void
    + {static} uint2x2_operator_bitwise_xor_wide_wide() : void
    + {static} uint2x2_operator_bitwise_xor_wide_scalar() : void
    + {static} uint2x2_operator_bitwise_xor_scalar_wide() : void
    + {static} uint2x2_operator_left_shift() : void
    + {static} uint2x2_operator_right_shift() : void
    + {static} uint2x2_operator_bitwise_not() : void
}
class TestUint2x3 {
    + {static} uint2x3_zero() : void
    + {static} uint2x3_operator_equal_wide_wide() : void
    + {static} uint2x3_operator_equal_wide_scalar() : void
    + {static} uint2x3_operator_equal_scalar_wide() : void
    + {static} uint2x3_operator_not_equal_wide_wide() : void
    + {static} uint2x3_operator_not_equal_wide_scalar() : void
    + {static} uint2x3_operator_not_equal_scalar_wide() : void
    + {static} uint2x3_operator_less_wide_wide() : void
    + {static} uint2x3_operator_less_wide_scalar() : void
    + {static} uint2x3_operator_less_scalar_wide() : void
    + {static} uint2x3_operator_greater_wide_wide() : void
    + {static} uint2x3_operator_greater_wide_scalar() : void
    + {static} uint2x3_operator_greater_scalar_wide() : void
    + {static} uint2x3_operator_less_equal_wide_wide() : void
    + {static} uint2x3_operator_less_equal_wide_scalar() : void
    + {static} uint2x3_operator_less_equal_scalar_wide() : void
    + {static} uint2x3_operator_greater_equal_wide_wide() : void
    + {static} uint2x3_operator_greater_equal_wide_scalar() : void
    + {static} uint2x3_operator_greater_equal_scalar_wide() : void
    + {static} uint2x3_operator_add_wide_wide() : void
    + {static} uint2x3_operator_add_wide_scalar() : void
    + {static} uint2x3_operator_add_scalar_wide() : void
    + {static} uint2x3_operator_sub_wide_wide() : void
    + {static} uint2x3_operator_sub_wide_scalar() : void
    + {static} uint2x3_operator_sub_scalar_wide() : void
    + {static} uint2x3_operator_mul_wide_wide() : void
    + {static} uint2x3_operator_mul_wide_scalar() : void
    + {static} uint2x3_operator_mul_scalar_wide() : void
    + {static} uint2x3_operator_div_wide_wide() : void
    + {static} uint2x3_operator_div_wide_scalar() : void
    + {static} uint2x3_operator_div_scalar_wide() : void
    + {static} uint2x3_operator_mod_wide_wide() : void
    + {static} uint2x3_operator_mod_wide_scalar() : void
    + {static} uint2x3_operator_mod_scalar_wide() : void
    + {static} uint2x3_operator_plus() : void
    + {static} uint2x3_operator_neg() : void
    + {static} uint2x3_operator_prefix_inc() : void
    + {static} uint2x3_operator_postfix_inc() : void
    + {static} uint2x3_operator_prefix_dec() : void
    + {static} uint2x3_operator_postfix_dec() : void
    + {static} uint2x3_operator_bitwise_and_wide_wide() : void
    + {static} uint2x3_operator_bitwise_and_wide_scalar() : void
    + {static} uint2x3_operator_bitwise_and_scalar_wide() : void
    + {static} uint2x3_operator_bitwise_or_wide_wide() : void
    + {static} uint2x3_operator_bitwise_or_wide_scalar() : void
    + {static} uint2x3_operator_bitwise_or_scalar_wide() : void
    + {static} uint2x3_operator_bitwise_xor_wide_wide() : void
    + {static} uint2x3_operator_bitwise_xor_wide_scalar() : void
    + {static} uint2x3_operator_bitwise_xor_scalar_wide() : void
    + {static} uint2x3_operator_left_shift() : void
    + {static} uint2x3_operator_right_shift() : void
    + {static} uint2x3_operator_bitwise_not() : void
}
class TestUint2x4 {
    + {static} uint2x4_zero() : void
    + {static} uint2x4_operator_equal_wide_wide() : void
    + {static} uint2x4_operator_equal_wide_scalar() : void
    + {static} uint2x4_operator_equal_scalar_wide() : void
    + {static} uint2x4_operator_not_equal_wide_wide() : void
    + {static} uint2x4_operator_not_equal_wide_scalar() : void
    + {static} uint2x4_operator_not_equal_scalar_wide() : void
    + {static} uint2x4_operator_less_wide_wide() : void
    + {static} uint2x4_operator_less_wide_scalar() : void
    + {static} uint2x4_operator_less_scalar_wide() : void
    + {static} uint2x4_operator_greater_wide_wide() : void
    + {static} uint2x4_operator_greater_wide_scalar() : void
    + {static} uint2x4_operator_greater_scalar_wide() : void
    + {static} uint2x4_operator_less_equal_wide_wide() : void
    + {static} uint2x4_operator_less_equal_wide_scalar() : void
    + {static} uint2x4_operator_less_equal_scalar_wide() : void
    + {static} uint2x4_operator_greater_equal_wide_wide() : void
    + {static} uint2x4_operator_greater_equal_wide_scalar() : void
    + {static} uint2x4_operator_greater_equal_scalar_wide() : void
    + {static} uint2x4_operator_add_wide_wide() : void
    + {static} uint2x4_operator_add_wide_scalar() : void
    + {static} uint2x4_operator_add_scalar_wide() : void
    + {static} uint2x4_operator_sub_wide_wide() : void
    + {static} uint2x4_operator_sub_wide_scalar() : void
    + {static} uint2x4_operator_sub_scalar_wide() : void
    + {static} uint2x4_operator_mul_wide_wide() : void
    + {static} uint2x4_operator_mul_wide_scalar() : void
    + {static} uint2x4_operator_mul_scalar_wide() : void
    + {static} uint2x4_operator_div_wide_wide() : void
    + {static} uint2x4_operator_div_wide_scalar() : void
    + {static} uint2x4_operator_div_scalar_wide() : void
    + {static} uint2x4_operator_mod_wide_wide() : void
    + {static} uint2x4_operator_mod_wide_scalar() : void
    + {static} uint2x4_operator_mod_scalar_wide() : void
    + {static} uint2x4_operator_plus() : void
    + {static} uint2x4_operator_neg() : void
    + {static} uint2x4_operator_prefix_inc() : void
    + {static} uint2x4_operator_postfix_inc() : void
    + {static} uint2x4_operator_prefix_dec() : void
    + {static} uint2x4_operator_postfix_dec() : void
    + {static} uint2x4_operator_bitwise_and_wide_wide() : void
    + {static} uint2x4_operator_bitwise_and_wide_scalar() : void
    + {static} uint2x4_operator_bitwise_and_scalar_wide() : void
    + {static} uint2x4_operator_bitwise_or_wide_wide() : void
    + {static} uint2x4_operator_bitwise_or_wide_scalar() : void
    + {static} uint2x4_operator_bitwise_or_scalar_wide() : void
    + {static} uint2x4_operator_bitwise_xor_wide_wide() : void
    + {static} uint2x4_operator_bitwise_xor_wide_scalar() : void
    + {static} uint2x4_operator_bitwise_xor_scalar_wide() : void
    + {static} uint2x4_operator_left_shift() : void
    + {static} uint2x4_operator_right_shift() : void
    + {static} uint2x4_operator_bitwise_not() : void
}
class TestUint3 {
    + {static} uint3_zero() : void
    + {static} uint3_constructor() : void
    + {static} uint3_scalar_constructor() : void
    + {static} uint3_static_constructor() : void
    + {static} uint3_static_scalar_constructor() : void
    + {static} uint3_operator_equal_wide_wide() : void
    + {static} uint3_operator_equal_wide_scalar() : void
    + {static} uint3_operator_equal_scalar_wide() : void
    + {static} uint3_operator_not_equal_wide_wide() : void
    + {static} uint3_operator_not_equal_wide_scalar() : void
    + {static} uint3_operator_not_equal_scalar_wide() : void
    + {static} uint3_operator_less_wide_wide() : void
    + {static} uint3_operator_less_wide_scalar() : void
    + {static} uint3_operator_less_scalar_wide() : void
    + {static} uint3_operator_greater_wide_wide() : void
    + {static} uint3_operator_greater_wide_scalar() : void
    + {static} uint3_operator_greater_scalar_wide() : void
    + {static} uint3_operator_less_equal_wide_wide() : void
    + {static} uint3_operator_less_equal_wide_scalar() : void
    + {static} uint3_operator_less_equal_scalar_wide() : void
    + {static} uint3_operator_greater_equal_wide_wide() : void
    + {static} uint3_operator_greater_equal_wide_scalar() : void
    + {static} uint3_operator_greater_equal_scalar_wide() : void
    + {static} uint3_operator_add_wide_wide() : void
    + {static} uint3_operator_add_wide_scalar() : void
    + {static} uint3_operator_add_scalar_wide() : void
    + {static} uint3_operator_sub_wide_wide() : void
    + {static} uint3_operator_sub_wide_scalar() : void
    + {static} uint3_operator_sub_scalar_wide() : void
    + {static} uint3_operator_mul_wide_wide() : void
    + {static} uint3_operator_mul_wide_scalar() : void
    + {static} uint3_operator_mul_scalar_wide() : void
    + {static} uint3_operator_div_wide_wide() : void
    + {static} uint3_operator_div_wide_scalar() : void
    + {static} uint3_operator_div_scalar_wide() : void
    + {static} uint3_operator_mod_wide_wide() : void
    + {static} uint3_operator_mod_wide_scalar() : void
    + {static} uint3_operator_mod_scalar_wide() : void
    + {static} uint3_operator_plus() : void
    + {static} uint3_operator_neg() : void
    + {static} uint3_operator_prefix_inc() : void
    + {static} uint3_operator_postfix_inc() : void
    + {static} uint3_operator_prefix_dec() : void
    + {static} uint3_operator_postfix_dec() : void
    + {static} uint3_operator_bitwise_and_wide_wide() : void
    + {static} uint3_operator_bitwise_and_wide_scalar() : void
    + {static} uint3_operator_bitwise_and_scalar_wide() : void
    + {static} uint3_operator_bitwise_or_wide_wide() : void
    + {static} uint3_operator_bitwise_or_wide_scalar() : void
    + {static} uint3_operator_bitwise_or_scalar_wide() : void
    + {static} uint3_operator_bitwise_xor_wide_wide() : void
    + {static} uint3_operator_bitwise_xor_wide_scalar() : void
    + {static} uint3_operator_bitwise_xor_scalar_wide() : void
    + {static} uint3_operator_left_shift() : void
    + {static} uint3_operator_right_shift() : void
    + {static} uint3_operator_bitwise_not() : void
    + {static} uint3_shuffle_result_1() : void
    + {static} uint3_shuffle_result_2() : void
    + {static} uint3_shuffle_result_3() : void
    + {static} uint3_shuffle_result_4() : void
}
class TestUint3x2 {
    + {static} uint3x2_zero() : void
    + {static} uint3x2_operator_equal_wide_wide() : void
    + {static} uint3x2_operator_equal_wide_scalar() : void
    + {static} uint3x2_operator_equal_scalar_wide() : void
    + {static} uint3x2_operator_not_equal_wide_wide() : void
    + {static} uint3x2_operator_not_equal_wide_scalar() : void
    + {static} uint3x2_operator_not_equal_scalar_wide() : void
    + {static} uint3x2_operator_less_wide_wide() : void
    + {static} uint3x2_operator_less_wide_scalar() : void
    + {static} uint3x2_operator_less_scalar_wide() : void
    + {static} uint3x2_operator_greater_wide_wide() : void
    + {static} uint3x2_operator_greater_wide_scalar() : void
    + {static} uint3x2_operator_greater_scalar_wide() : void
    + {static} uint3x2_operator_less_equal_wide_wide() : void
    + {static} uint3x2_operator_less_equal_wide_scalar() : void
    + {static} uint3x2_operator_less_equal_scalar_wide() : void
    + {static} uint3x2_operator_greater_equal_wide_wide() : void
    + {static} uint3x2_operator_greater_equal_wide_scalar() : void
    + {static} uint3x2_operator_greater_equal_scalar_wide() : void
    + {static} uint3x2_operator_add_wide_wide() : void
    + {static} uint3x2_operator_add_wide_scalar() : void
    + {static} uint3x2_operator_add_scalar_wide() : void
    + {static} uint3x2_operator_sub_wide_wide() : void
    + {static} uint3x2_operator_sub_wide_scalar() : void
    + {static} uint3x2_operator_sub_scalar_wide() : void
    + {static} uint3x2_operator_mul_wide_wide() : void
    + {static} uint3x2_operator_mul_wide_scalar() : void
    + {static} uint3x2_operator_mul_scalar_wide() : void
    + {static} uint3x2_operator_div_wide_wide() : void
    + {static} uint3x2_operator_div_wide_scalar() : void
    + {static} uint3x2_operator_div_scalar_wide() : void
    + {static} uint3x2_operator_mod_wide_wide() : void
    + {static} uint3x2_operator_mod_wide_scalar() : void
    + {static} uint3x2_operator_mod_scalar_wide() : void
    + {static} uint3x2_operator_plus() : void
    + {static} uint3x2_operator_neg() : void
    + {static} uint3x2_operator_prefix_inc() : void
    + {static} uint3x2_operator_postfix_inc() : void
    + {static} uint3x2_operator_prefix_dec() : void
    + {static} uint3x2_operator_postfix_dec() : void
    + {static} uint3x2_operator_bitwise_and_wide_wide() : void
    + {static} uint3x2_operator_bitwise_and_wide_scalar() : void
    + {static} uint3x2_operator_bitwise_and_scalar_wide() : void
    + {static} uint3x2_operator_bitwise_or_wide_wide() : void
    + {static} uint3x2_operator_bitwise_or_wide_scalar() : void
    + {static} uint3x2_operator_bitwise_or_scalar_wide() : void
    + {static} uint3x2_operator_bitwise_xor_wide_wide() : void
    + {static} uint3x2_operator_bitwise_xor_wide_scalar() : void
    + {static} uint3x2_operator_bitwise_xor_scalar_wide() : void
    + {static} uint3x2_operator_left_shift() : void
    + {static} uint3x2_operator_right_shift() : void
    + {static} uint3x2_operator_bitwise_not() : void
}
class TestUint3x3 {
    + {static} uint3x3_zero() : void
    + {static} uint3x3_identity() : void
    + {static} uint3x3_operator_equal_wide_wide() : void
    + {static} uint3x3_operator_equal_wide_scalar() : void
    + {static} uint3x3_operator_equal_scalar_wide() : void
    + {static} uint3x3_operator_not_equal_wide_wide() : void
    + {static} uint3x3_operator_not_equal_wide_scalar() : void
    + {static} uint3x3_operator_not_equal_scalar_wide() : void
    + {static} uint3x3_operator_less_wide_wide() : void
    + {static} uint3x3_operator_less_wide_scalar() : void
    + {static} uint3x3_operator_less_scalar_wide() : void
    + {static} uint3x3_operator_greater_wide_wide() : void
    + {static} uint3x3_operator_greater_wide_scalar() : void
    + {static} uint3x3_operator_greater_scalar_wide() : void
    + {static} uint3x3_operator_less_equal_wide_wide() : void
    + {static} uint3x3_operator_less_equal_wide_scalar() : void
    + {static} uint3x3_operator_less_equal_scalar_wide() : void
    + {static} uint3x3_operator_greater_equal_wide_wide() : void
    + {static} uint3x3_operator_greater_equal_wide_scalar() : void
    + {static} uint3x3_operator_greater_equal_scalar_wide() : void
    + {static} uint3x3_operator_add_wide_wide() : void
    + {static} uint3x3_operator_add_wide_scalar() : void
    + {static} uint3x3_operator_add_scalar_wide() : void
    + {static} uint3x3_operator_sub_wide_wide() : void
    + {static} uint3x3_operator_sub_wide_scalar() : void
    + {static} uint3x3_operator_sub_scalar_wide() : void
    + {static} uint3x3_operator_mul_wide_wide() : void
    + {static} uint3x3_operator_mul_wide_scalar() : void
    + {static} uint3x3_operator_mul_scalar_wide() : void
    + {static} uint3x3_operator_div_wide_wide() : void
    + {static} uint3x3_operator_div_wide_scalar() : void
    + {static} uint3x3_operator_div_scalar_wide() : void
    + {static} uint3x3_operator_mod_wide_wide() : void
    + {static} uint3x3_operator_mod_wide_scalar() : void
    + {static} uint3x3_operator_mod_scalar_wide() : void
    + {static} uint3x3_operator_plus() : void
    + {static} uint3x3_operator_neg() : void
    + {static} uint3x3_operator_prefix_inc() : void
    + {static} uint3x3_operator_postfix_inc() : void
    + {static} uint3x3_operator_prefix_dec() : void
    + {static} uint3x3_operator_postfix_dec() : void
    + {static} uint3x3_operator_bitwise_and_wide_wide() : void
    + {static} uint3x3_operator_bitwise_and_wide_scalar() : void
    + {static} uint3x3_operator_bitwise_and_scalar_wide() : void
    + {static} uint3x3_operator_bitwise_or_wide_wide() : void
    + {static} uint3x3_operator_bitwise_or_wide_scalar() : void
    + {static} uint3x3_operator_bitwise_or_scalar_wide() : void
    + {static} uint3x3_operator_bitwise_xor_wide_wide() : void
    + {static} uint3x3_operator_bitwise_xor_wide_scalar() : void
    + {static} uint3x3_operator_bitwise_xor_scalar_wide() : void
    + {static} uint3x3_operator_left_shift() : void
    + {static} uint3x3_operator_right_shift() : void
    + {static} uint3x3_operator_bitwise_not() : void
}
class TestUint3x4 {
    + {static} uint3x4_zero() : void
    + {static} uint3x4_operator_equal_wide_wide() : void
    + {static} uint3x4_operator_equal_wide_scalar() : void
    + {static} uint3x4_operator_equal_scalar_wide() : void
    + {static} uint3x4_operator_not_equal_wide_wide() : void
    + {static} uint3x4_operator_not_equal_wide_scalar() : void
    + {static} uint3x4_operator_not_equal_scalar_wide() : void
    + {static} uint3x4_operator_less_wide_wide() : void
    + {static} uint3x4_operator_less_wide_scalar() : void
    + {static} uint3x4_operator_less_scalar_wide() : void
    + {static} uint3x4_operator_greater_wide_wide() : void
    + {static} uint3x4_operator_greater_wide_scalar() : void
    + {static} uint3x4_operator_greater_scalar_wide() : void
    + {static} uint3x4_operator_less_equal_wide_wide() : void
    + {static} uint3x4_operator_less_equal_wide_scalar() : void
    + {static} uint3x4_operator_less_equal_scalar_wide() : void
    + {static} uint3x4_operator_greater_equal_wide_wide() : void
    + {static} uint3x4_operator_greater_equal_wide_scalar() : void
    + {static} uint3x4_operator_greater_equal_scalar_wide() : void
    + {static} uint3x4_operator_add_wide_wide() : void
    + {static} uint3x4_operator_add_wide_scalar() : void
    + {static} uint3x4_operator_add_scalar_wide() : void
    + {static} uint3x4_operator_sub_wide_wide() : void
    + {static} uint3x4_operator_sub_wide_scalar() : void
    + {static} uint3x4_operator_sub_scalar_wide() : void
    + {static} uint3x4_operator_mul_wide_wide() : void
    + {static} uint3x4_operator_mul_wide_scalar() : void
    + {static} uint3x4_operator_mul_scalar_wide() : void
    + {static} uint3x4_operator_div_wide_wide() : void
    + {static} uint3x4_operator_div_wide_scalar() : void
    + {static} uint3x4_operator_div_scalar_wide() : void
    + {static} uint3x4_operator_mod_wide_wide() : void
    + {static} uint3x4_operator_mod_wide_scalar() : void
    + {static} uint3x4_operator_mod_scalar_wide() : void
    + {static} uint3x4_operator_plus() : void
    + {static} uint3x4_operator_neg() : void
    + {static} uint3x4_operator_prefix_inc() : void
    + {static} uint3x4_operator_postfix_inc() : void
    + {static} uint3x4_operator_prefix_dec() : void
    + {static} uint3x4_operator_postfix_dec() : void
    + {static} uint3x4_operator_bitwise_and_wide_wide() : void
    + {static} uint3x4_operator_bitwise_and_wide_scalar() : void
    + {static} uint3x4_operator_bitwise_and_scalar_wide() : void
    + {static} uint3x4_operator_bitwise_or_wide_wide() : void
    + {static} uint3x4_operator_bitwise_or_wide_scalar() : void
    + {static} uint3x4_operator_bitwise_or_scalar_wide() : void
    + {static} uint3x4_operator_bitwise_xor_wide_wide() : void
    + {static} uint3x4_operator_bitwise_xor_wide_scalar() : void
    + {static} uint3x4_operator_bitwise_xor_scalar_wide() : void
    + {static} uint3x4_operator_left_shift() : void
    + {static} uint3x4_operator_right_shift() : void
    + {static} uint3x4_operator_bitwise_not() : void
}
class TestUint4 {
    + {static} uint4_zero() : void
    + {static} uint4_constructor() : void
    + {static} uint4_scalar_constructor() : void
    + {static} uint4_static_constructor() : void
    + {static} uint4_static_scalar_constructor() : void
    + {static} uint4_operator_equal_wide_wide() : void
    + {static} uint4_operator_equal_wide_scalar() : void
    + {static} uint4_operator_equal_scalar_wide() : void
    + {static} uint4_operator_not_equal_wide_wide() : void
    + {static} uint4_operator_not_equal_wide_scalar() : void
    + {static} uint4_operator_not_equal_scalar_wide() : void
    + {static} uint4_operator_less_wide_wide() : void
    + {static} uint4_operator_less_wide_scalar() : void
    + {static} uint4_operator_less_scalar_wide() : void
    + {static} uint4_operator_greater_wide_wide() : void
    + {static} uint4_operator_greater_wide_scalar() : void
    + {static} uint4_operator_greater_scalar_wide() : void
    + {static} uint4_operator_less_equal_wide_wide() : void
    + {static} uint4_operator_less_equal_wide_scalar() : void
    + {static} uint4_operator_less_equal_scalar_wide() : void
    + {static} uint4_operator_greater_equal_wide_wide() : void
    + {static} uint4_operator_greater_equal_wide_scalar() : void
    + {static} uint4_operator_greater_equal_scalar_wide() : void
    + {static} uint4_operator_add_wide_wide() : void
    + {static} uint4_operator_add_wide_scalar() : void
    + {static} uint4_operator_add_scalar_wide() : void
    + {static} uint4_operator_sub_wide_wide() : void
    + {static} uint4_operator_sub_wide_scalar() : void
    + {static} uint4_operator_sub_scalar_wide() : void
    + {static} uint4_operator_mul_wide_wide() : void
    + {static} uint4_operator_mul_wide_scalar() : void
    + {static} uint4_operator_mul_scalar_wide() : void
    + {static} uint4_operator_div_wide_wide() : void
    + {static} uint4_operator_div_wide_scalar() : void
    + {static} uint4_operator_div_scalar_wide() : void
    + {static} uint4_operator_mod_wide_wide() : void
    + {static} uint4_operator_mod_wide_scalar() : void
    + {static} uint4_operator_mod_scalar_wide() : void
    + {static} uint4_operator_plus() : void
    + {static} uint4_operator_neg() : void
    + {static} uint4_operator_prefix_inc() : void
    + {static} uint4_operator_postfix_inc() : void
    + {static} uint4_operator_prefix_dec() : void
    + {static} uint4_operator_postfix_dec() : void
    + {static} uint4_operator_bitwise_and_wide_wide() : void
    + {static} uint4_operator_bitwise_and_wide_scalar() : void
    + {static} uint4_operator_bitwise_and_scalar_wide() : void
    + {static} uint4_operator_bitwise_or_wide_wide() : void
    + {static} uint4_operator_bitwise_or_wide_scalar() : void
    + {static} uint4_operator_bitwise_or_scalar_wide() : void
    + {static} uint4_operator_bitwise_xor_wide_wide() : void
    + {static} uint4_operator_bitwise_xor_wide_scalar() : void
    + {static} uint4_operator_bitwise_xor_scalar_wide() : void
    + {static} uint4_operator_left_shift() : void
    + {static} uint4_operator_right_shift() : void
    + {static} uint4_operator_bitwise_not() : void
    + {static} uint4_shuffle_result_1() : void
    + {static} uint4_shuffle_result_2() : void
    + {static} uint4_shuffle_result_3() : void
    + {static} uint4_shuffle_result_4() : void
}
class TestUint4x2 {
    + {static} uint4x2_zero() : void
    + {static} uint4x2_operator_equal_wide_wide() : void
    + {static} uint4x2_operator_equal_wide_scalar() : void
    + {static} uint4x2_operator_equal_scalar_wide() : void
    + {static} uint4x2_operator_not_equal_wide_wide() : void
    + {static} uint4x2_operator_not_equal_wide_scalar() : void
    + {static} uint4x2_operator_not_equal_scalar_wide() : void
    + {static} uint4x2_operator_less_wide_wide() : void
    + {static} uint4x2_operator_less_wide_scalar() : void
    + {static} uint4x2_operator_less_scalar_wide() : void
    + {static} uint4x2_operator_greater_wide_wide() : void
    + {static} uint4x2_operator_greater_wide_scalar() : void
    + {static} uint4x2_operator_greater_scalar_wide() : void
    + {static} uint4x2_operator_less_equal_wide_wide() : void
    + {static} uint4x2_operator_less_equal_wide_scalar() : void
    + {static} uint4x2_operator_less_equal_scalar_wide() : void
    + {static} uint4x2_operator_greater_equal_wide_wide() : void
    + {static} uint4x2_operator_greater_equal_wide_scalar() : void
    + {static} uint4x2_operator_greater_equal_scalar_wide() : void
    + {static} uint4x2_operator_add_wide_wide() : void
    + {static} uint4x2_operator_add_wide_scalar() : void
    + {static} uint4x2_operator_add_scalar_wide() : void
    + {static} uint4x2_operator_sub_wide_wide() : void
    + {static} uint4x2_operator_sub_wide_scalar() : void
    + {static} uint4x2_operator_sub_scalar_wide() : void
    + {static} uint4x2_operator_mul_wide_wide() : void
    + {static} uint4x2_operator_mul_wide_scalar() : void
    + {static} uint4x2_operator_mul_scalar_wide() : void
    + {static} uint4x2_operator_div_wide_wide() : void
    + {static} uint4x2_operator_div_wide_scalar() : void
    + {static} uint4x2_operator_div_scalar_wide() : void
    + {static} uint4x2_operator_mod_wide_wide() : void
    + {static} uint4x2_operator_mod_wide_scalar() : void
    + {static} uint4x2_operator_mod_scalar_wide() : void
    + {static} uint4x2_operator_plus() : void
    + {static} uint4x2_operator_neg() : void
    + {static} uint4x2_operator_prefix_inc() : void
    + {static} uint4x2_operator_postfix_inc() : void
    + {static} uint4x2_operator_prefix_dec() : void
    + {static} uint4x2_operator_postfix_dec() : void
    + {static} uint4x2_operator_bitwise_and_wide_wide() : void
    + {static} uint4x2_operator_bitwise_and_wide_scalar() : void
    + {static} uint4x2_operator_bitwise_and_scalar_wide() : void
    + {static} uint4x2_operator_bitwise_or_wide_wide() : void
    + {static} uint4x2_operator_bitwise_or_wide_scalar() : void
    + {static} uint4x2_operator_bitwise_or_scalar_wide() : void
    + {static} uint4x2_operator_bitwise_xor_wide_wide() : void
    + {static} uint4x2_operator_bitwise_xor_wide_scalar() : void
    + {static} uint4x2_operator_bitwise_xor_scalar_wide() : void
    + {static} uint4x2_operator_left_shift() : void
    + {static} uint4x2_operator_right_shift() : void
    + {static} uint4x2_operator_bitwise_not() : void
}
class TestUint4x3 {
    + {static} uint4x3_zero() : void
    + {static} uint4x3_operator_equal_wide_wide() : void
    + {static} uint4x3_operator_equal_wide_scalar() : void
    + {static} uint4x3_operator_equal_scalar_wide() : void
    + {static} uint4x3_operator_not_equal_wide_wide() : void
    + {static} uint4x3_operator_not_equal_wide_scalar() : void
    + {static} uint4x3_operator_not_equal_scalar_wide() : void
    + {static} uint4x3_operator_less_wide_wide() : void
    + {static} uint4x3_operator_less_wide_scalar() : void
    + {static} uint4x3_operator_less_scalar_wide() : void
    + {static} uint4x3_operator_greater_wide_wide() : void
    + {static} uint4x3_operator_greater_wide_scalar() : void
    + {static} uint4x3_operator_greater_scalar_wide() : void
    + {static} uint4x3_operator_less_equal_wide_wide() : void
    + {static} uint4x3_operator_less_equal_wide_scalar() : void
    + {static} uint4x3_operator_less_equal_scalar_wide() : void
    + {static} uint4x3_operator_greater_equal_wide_wide() : void
    + {static} uint4x3_operator_greater_equal_wide_scalar() : void
    + {static} uint4x3_operator_greater_equal_scalar_wide() : void
    + {static} uint4x3_operator_add_wide_wide() : void
    + {static} uint4x3_operator_add_wide_scalar() : void
    + {static} uint4x3_operator_add_scalar_wide() : void
    + {static} uint4x3_operator_sub_wide_wide() : void
    + {static} uint4x3_operator_sub_wide_scalar() : void
    + {static} uint4x3_operator_sub_scalar_wide() : void
    + {static} uint4x3_operator_mul_wide_wide() : void
    + {static} uint4x3_operator_mul_wide_scalar() : void
    + {static} uint4x3_operator_mul_scalar_wide() : void
    + {static} uint4x3_operator_div_wide_wide() : void
    + {static} uint4x3_operator_div_wide_scalar() : void
    + {static} uint4x3_operator_div_scalar_wide() : void
    + {static} uint4x3_operator_mod_wide_wide() : void
    + {static} uint4x3_operator_mod_wide_scalar() : void
    + {static} uint4x3_operator_mod_scalar_wide() : void
    + {static} uint4x3_operator_plus() : void
    + {static} uint4x3_operator_neg() : void
    + {static} uint4x3_operator_prefix_inc() : void
    + {static} uint4x3_operator_postfix_inc() : void
    + {static} uint4x3_operator_prefix_dec() : void
    + {static} uint4x3_operator_postfix_dec() : void
    + {static} uint4x3_operator_bitwise_and_wide_wide() : void
    + {static} uint4x3_operator_bitwise_and_wide_scalar() : void
    + {static} uint4x3_operator_bitwise_and_scalar_wide() : void
    + {static} uint4x3_operator_bitwise_or_wide_wide() : void
    + {static} uint4x3_operator_bitwise_or_wide_scalar() : void
    + {static} uint4x3_operator_bitwise_or_scalar_wide() : void
    + {static} uint4x3_operator_bitwise_xor_wide_wide() : void
    + {static} uint4x3_operator_bitwise_xor_wide_scalar() : void
    + {static} uint4x3_operator_bitwise_xor_scalar_wide() : void
    + {static} uint4x3_operator_left_shift() : void
    + {static} uint4x3_operator_right_shift() : void
    + {static} uint4x3_operator_bitwise_not() : void
}
class TestUint4x4 {
    + {static} uint4x4_zero() : void
    + {static} uint4x4_identity() : void
    + {static} uint4x4_operator_equal_wide_wide() : void
    + {static} uint4x4_operator_equal_wide_scalar() : void
    + {static} uint4x4_operator_equal_scalar_wide() : void
    + {static} uint4x4_operator_not_equal_wide_wide() : void
    + {static} uint4x4_operator_not_equal_wide_scalar() : void
    + {static} uint4x4_operator_not_equal_scalar_wide() : void
    + {static} uint4x4_operator_less_wide_wide() : void
    + {static} uint4x4_operator_less_wide_scalar() : void
    + {static} uint4x4_operator_less_scalar_wide() : void
    + {static} uint4x4_operator_greater_wide_wide() : void
    + {static} uint4x4_operator_greater_wide_scalar() : void
    + {static} uint4x4_operator_greater_scalar_wide() : void
    + {static} uint4x4_operator_less_equal_wide_wide() : void
    + {static} uint4x4_operator_less_equal_wide_scalar() : void
    + {static} uint4x4_operator_less_equal_scalar_wide() : void
    + {static} uint4x4_operator_greater_equal_wide_wide() : void
    + {static} uint4x4_operator_greater_equal_wide_scalar() : void
    + {static} uint4x4_operator_greater_equal_scalar_wide() : void
    + {static} uint4x4_operator_add_wide_wide() : void
    + {static} uint4x4_operator_add_wide_scalar() : void
    + {static} uint4x4_operator_add_scalar_wide() : void
    + {static} uint4x4_operator_sub_wide_wide() : void
    + {static} uint4x4_operator_sub_wide_scalar() : void
    + {static} uint4x4_operator_sub_scalar_wide() : void
    + {static} uint4x4_operator_mul_wide_wide() : void
    + {static} uint4x4_operator_mul_wide_scalar() : void
    + {static} uint4x4_operator_mul_scalar_wide() : void
    + {static} uint4x4_operator_div_wide_wide() : void
    + {static} uint4x4_operator_div_wide_scalar() : void
    + {static} uint4x4_operator_div_scalar_wide() : void
    + {static} uint4x4_operator_mod_wide_wide() : void
    + {static} uint4x4_operator_mod_wide_scalar() : void
    + {static} uint4x4_operator_mod_scalar_wide() : void
    + {static} uint4x4_operator_plus() : void
    + {static} uint4x4_operator_neg() : void
    + {static} uint4x4_operator_prefix_inc() : void
    + {static} uint4x4_operator_postfix_inc() : void
    + {static} uint4x4_operator_prefix_dec() : void
    + {static} uint4x4_operator_postfix_dec() : void
    + {static} uint4x4_operator_bitwise_and_wide_wide() : void
    + {static} uint4x4_operator_bitwise_and_wide_scalar() : void
    + {static} uint4x4_operator_bitwise_and_scalar_wide() : void
    + {static} uint4x4_operator_bitwise_or_wide_wide() : void
    + {static} uint4x4_operator_bitwise_or_wide_scalar() : void
    + {static} uint4x4_operator_bitwise_or_scalar_wide() : void
    + {static} uint4x4_operator_bitwise_xor_wide_wide() : void
    + {static} uint4x4_operator_bitwise_xor_wide_scalar() : void
    + {static} uint4x4_operator_bitwise_xor_scalar_wide() : void
    + {static} uint4x4_operator_left_shift() : void
    + {static} uint4x4_operator_right_shift() : void
    + {static} uint4x4_operator_bitwise_not() : void
}
class TestUtils {
    + {static} AreEqual(a:bool, b:bool) : void
    + {static} AreEqual(a:int, b:int) : void
    + {static} AreEqual(a:uint, b:uint) : void
    + {static} AreEqual(a:long, b:long) : void
    + {static} AreEqual(a:ulong, b:ulong) : void
    + {static} AreEqual(a:float, b:float, delta:float) : void
    + {static} AreEqual(a:float, b:float, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double, b:double, delta:double) : void
    + {static} AreEqual(a:double, b:double, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:bool2, b:bool2) : void
    + {static} AreEqual(a:bool3, b:bool3) : void
    + {static} AreEqual(a:bool4, b:bool4) : void
    + {static} AreEqual(a:bool2x2, b:bool2x2) : void
    + {static} AreEqual(a:bool3x2, b:bool3x2) : void
    + {static} AreEqual(a:bool4x2, b:bool4x2) : void
    + {static} AreEqual(a:bool2x3, b:bool2x3) : void
    + {static} AreEqual(a:bool3x3, b:bool3x3) : void
    + {static} AreEqual(a:bool4x3, b:bool4x3) : void
    + {static} AreEqual(a:bool2x4, b:bool2x4) : void
    + {static} AreEqual(a:bool3x4, b:bool3x4) : void
    + {static} AreEqual(a:bool4x4, b:bool4x4) : void
    + {static} AreEqual(a:int2, b:int2) : void
    + {static} AreEqual(a:int3, b:int3) : void
    + {static} AreEqual(a:int4, b:int4) : void
    + {static} AreEqual(a:int2x2, b:int2x2) : void
    + {static} AreEqual(a:int3x2, b:int3x2) : void
    + {static} AreEqual(a:int4x2, b:int4x2) : void
    + {static} AreEqual(a:int2x3, b:int2x3) : void
    + {static} AreEqual(a:int3x3, b:int3x3) : void
    + {static} AreEqual(a:int4x3, b:int4x3) : void
    + {static} AreEqual(a:int2x4, b:int2x4) : void
    + {static} AreEqual(a:int3x4, b:int3x4) : void
    + {static} AreEqual(a:int4x4, b:int4x4) : void
    + {static} AreEqual(a:uint2, b:uint2) : void
    + {static} AreEqual(a:uint3, b:uint3) : void
    + {static} AreEqual(a:uint4, b:uint4) : void
    + {static} AreEqual(a:uint2x2, b:uint2x2) : void
    + {static} AreEqual(a:uint3x2, b:uint3x2) : void
    + {static} AreEqual(a:uint4x2, b:uint4x2) : void
    + {static} AreEqual(a:uint2x3, b:uint2x3) : void
    + {static} AreEqual(a:uint3x3, b:uint3x3) : void
    + {static} AreEqual(a:uint4x3, b:uint4x3) : void
    + {static} AreEqual(a:uint2x4, b:uint2x4) : void
    + {static} AreEqual(a:uint3x4, b:uint3x4) : void
    + {static} AreEqual(a:uint4x4, b:uint4x4) : void
    + {static} AreEqual(a:float2, b:float2, delta:float) : void
    + {static} AreEqual(a:float2, b:float2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float3, b:float3, delta:float) : void
    + {static} AreEqual(a:float3, b:float3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float4, b:float4, delta:float) : void
    + {static} AreEqual(a:float4, b:float4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float2x2, b:float2x2, delta:float) : void
    + {static} AreEqual(a:float2x2, b:float2x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float3x2, b:float3x2, delta:float) : void
    + {static} AreEqual(a:float3x2, b:float3x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float4x2, b:float4x2, delta:float) : void
    + {static} AreEqual(a:float4x2, b:float4x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float2x3, b:float2x3, delta:float) : void
    + {static} AreEqual(a:float2x3, b:float2x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float3x3, b:float3x3, delta:float) : void
    + {static} AreEqual(a:float3x3, b:float3x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float4x3, b:float4x3, delta:float) : void
    + {static} AreEqual(a:float4x3, b:float4x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float2x4, b:float2x4, delta:float) : void
    + {static} AreEqual(a:float2x4, b:float2x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float3x4, b:float3x4, delta:float) : void
    + {static} AreEqual(a:float3x4, b:float3x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:float4x4, b:float4x4, delta:float) : void
    + {static} AreEqual(a:float4x4, b:float4x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double2, b:double2, delta:double) : void
    + {static} AreEqual(a:double2, b:double2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double3, b:double3, delta:double) : void
    + {static} AreEqual(a:double3, b:double3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double4, b:double4, delta:double) : void
    + {static} AreEqual(a:double4, b:double4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double2x2, b:double2x2, delta:double) : void
    + {static} AreEqual(a:double2x2, b:double2x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double3x2, b:double3x2, delta:double) : void
    + {static} AreEqual(a:double3x2, b:double3x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double4x2, b:double4x2, delta:double) : void
    + {static} AreEqual(a:double4x2, b:double4x2, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double2x3, b:double2x3, delta:double) : void
    + {static} AreEqual(a:double2x3, b:double2x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double3x3, b:double3x3, delta:double) : void
    + {static} AreEqual(a:double3x3, b:double3x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double4x3, b:double4x3, delta:double) : void
    + {static} AreEqual(a:double4x3, b:double4x3, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double2x4, b:double2x4, delta:double) : void
    + {static} AreEqual(a:double2x4, b:double2x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double3x4, b:double3x4, delta:double) : void
    + {static} AreEqual(a:double3x4, b:double3x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:double4x4, b:double4x4, delta:double) : void
    + {static} AreEqual(a:double4x4, b:double4x4, maxUlp:int, signedZeroEqual:bool) : void
    + {static} AreEqual(a:quaternion, b:quaternion, delta:float) : void
    + {static} AreEqual(a:RigidTransform, b:RigidTransform, delta:float) : void
}
class RenderingOptions {
    + nameFilter : string
    + showSucceeded : bool
    + showFailed : bool
    + showIgnored : bool
    + showNotRunned : bool
}
class ResultSummarizer {
    + ResultSummarizer(results:IEnumerable<TestRunnerResult>)
    + success : bool <<get>>
    + ResultCount : int <<get>>
    + TestsRun : int <<get>>
    + Passed : int <<get>>
    + errors : int <<get>>
    + failures : int <<get>>
    + inconclusive : int <<get>>
    + notRunnable : int <<get>>
    + Skipped : int <<get>>
    + ignored : int <<get>>
    + duration : double <<get>>
    + testsNotRun : int <<get>>
    + Summarize(result:TestRunnerResult) : void
}
class TestFilterSettings {
    + showSucceeded : bool
    + showFailed : bool
    + showIgnored : bool
    + showNotRun : bool
    + filterByName : string
    + filterByCategory : int
    + TestFilterSettings(prefsKey:string)
    + Load() : void
    + Save() : void
    + UpdateCounters(results:IEnumerable<TestRunnerResult>) : void
    + GetSelectedCategories() : string[]
    + OnGUI() : void
    + BuildRenderingOptions() : RenderingOptions
}
class TestTreeViewBuilder {
    + TestTreeViewBuilder(tests:ITestAdaptor, oldTestResultResults:List<TestRunnerResult>, uiFilter:TestRunnerUIFilter)
    + BuildTreeView(settings:TestFilterSettings, sceneBased:bool, sceneName:string) : TreeViewItem
}
class "List`1"<T> {
}
TestTreeViewBuilder o-> "results<TestRunnerResult>" "List`1"
class Icons <<static>> {
    {static} Icons()
}
Icons --> "s_FailImg" Texture2D
Icons --> "s_IgnoreImg" Texture2D
Icons --> "s_SuccessImg" Texture2D
Icons --> "s_UnknownImg" Texture2D
Icons --> "s_InconclusiveImg" Texture2D
Icons --> "s_StopwatchImg" Texture2D
class TestListTreeViewDataSource {
    + TestListTreeViewDataSource(testListTree:TreeViewController, testListGUI:TestListGUI, rootTest:ITestAdaptor)
    + UpdateRootTest(rootTest:ITestAdaptor) : void
    + <<override>> FetchData() : void
    + <<override>> IsRenamingItemAllowed(item:TreeViewItem) : bool
    + ExpandTreeOnCreation() : void
    + <<override>> IsExpandable(item:TreeViewItem) : bool
}
TreeViewDataSource <|-- TestListTreeViewDataSource
class TestListTreeViewGUI {
    + TestListTreeViewGUI(testListTree:TreeViewController)
}
TreeViewGUI <|-- TestListTreeViewGUI
class TestTreeViewItem <<sealed>> {
    + IsGroupNode : bool <<get>>
    + FullName : string <<get>>
    + GetAssemblyName() : string
    + TestTreeViewItem(test:ITestAdaptor, depth:int, parent:TreeViewItem)
    + SetResult(testResult:TestRunnerResult) : void
    + GetResultText() : string
}
TreeViewItem <|-- TestTreeViewItem
TestTreeViewItem --> "result" TestRunnerResult
TestTreeViewItem --> "m_Test" ITestAdaptor
TestTreeViewItem --> "type" Type
TestTreeViewItem --> "method" MethodInfo
class EditModeTestListGUI {
    + <<override>> RenderNoTestsInfo() : void
    + <<override>> PrintHeadPanel() : void
}
TestListGUI <|-- EditModeTestListGUI
EditModeTestListGUI --> "TestMode" TestMode
EditModeTestListGUI --> "TestPlatform" TestPlatform
class PlayModeTestListGUI {
    + <<override>> PrintHeadPanel() : void
    + <<override>> RenderNoTestsInfo() : void
}
class PlayerMenuItem <<struct>> {
    + filterSelectedTestsOnly : bool
    + buildOnly : bool
}
TestListGUI <|-- PlayModeTestListGUI
PlayModeTestListGUI --> "TestMode" TestMode
PlayModeTestListGUI --> "TestPlatform" TestPlatform
PlayModeTestListGUI +-- PlayerMenuItem
PlayerMenuItem --> "name" GUIContent
abstract class TestListGUI {
    + <<virtual>> PrintHeadPanel() : void
    + HasTreeData() : bool
    + <<virtual>> RenderTestList() : void
    + <<virtual>> RenderNoTestsInfo() : void
    + RenderDetails() : void
    + Reload() : void
    + Repaint() : void
    + Init(window:TestRunnerWindow, rootTest:ITestAdaptor) : void
    + UpdateResult(result:TestRunnerResult) : void
    + UpdateTestTree(test:ITestAdaptor) : void
    <<internal>> TestSelectionCallback(selected:int[]) : void
    + RebuildUIFilter() : void
    + RepaintIfProjectPathChanged() : void
}
class "List`1"<T> {
}
TestListGUI o-> "newResultList<TestRunnerResult>" "List`1"
TestListGUI --> "m_TestListState" TreeViewState
TestListGUI o-> "m_TestRunnerUIFilter" TestRunnerUIFilter
TestListGUI --> "TestMode" TestMode
TestListGUI --> "TestPlatform" TestPlatform
class AssetPipelineIgnore <<static>> {
}
enum AssetPipelineBackend {
    V1,
    V2,
}
class IgnoreInV1 {
    + IgnoreInV1(ignoreReason:string)
}
class IgnoreInV2 {
    + IgnoreInV2(ignoreReason:string)
}
class AssetPipelineIgnoreAttribute {
    <<readonly>> m_IgnoreReason : string
    {static} ActiveBackendName : string
    + AssetPipelineIgnoreAttribute(backend:AssetPipelineBackend, ignoreReason:string)
    + ApplyToTest(test:Test) : void
}
AssetPipelineIgnore +-- AssetPipelineBackend
AssetPipelineIgnore +-- IgnoreInV1
AssetPipelineIgnoreAttribute <|-- IgnoreInV1
AssetPipelineIgnore +-- IgnoreInV2
AssetPipelineIgnoreAttribute <|-- IgnoreInV2
AssetPipelineIgnore +-- AssetPipelineIgnoreAttribute
NUnitAttribute <|-- AssetPipelineIgnoreAttribute
IApplyToTest <|-- AssetPipelineIgnoreAttribute
AssetPipelineIgnoreAttribute --> "m_IgnoredBackend" AssetPipelineBackend
AssetPipelineIgnoreAttribute o-> "k_ActiveBackend" AssetPipelineBackend
interface ITestPlayerBuildModifier {
    ModifyOptions(playerOptions:BuildPlayerOptions) : BuildPlayerOptions
}
class TestPlayerBuildModifierAttribute {
    + TestPlayerBuildModifierAttribute(type:Type)
    <<internal>> ConstructModifier() : ITestPlayerBuildModifier
}
Attribute <|-- TestPlayerBuildModifierAttribute
class AndroidPlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- AndroidPlatformSetup
class ApplePlatformSetup {
    + ApplePlatformSetup(buildTarget:BuildTarget)
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- ApplePlatformSetup
interface IPlatformSetup {
    Setup() : void
    PostBuildAction() : void
    PostSuccessfulBuildAction() : void
    PostSuccessfulLaunchAction() : void
    CleanUp() : void
}
class LuminPlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- LuminPlatformSetup
class PlatformSpecificSetup {
    + PlatformSpecificSetup()
    + PlatformSpecificSetup(target:BuildTarget)
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
class StadiaPlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- StadiaPlatformSetup
class SwitchPlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- SwitchPlatformSetup
class UwpPlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- UwpPlatformSetup
class XboxOnePlatformSetup {
    + Setup() : void
    + PostBuildAction() : void
    + PostSuccessfulBuildAction() : void
    + PostSuccessfulLaunchAction() : void
    + CleanUp() : void
}
IPlatformSetup <|-- XboxOnePlatformSetup
abstract class "BuildActionTaskBase`1"<T> {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
class "Action`1"<T> {
}
class "Func`1"<T> {
}
class "Func`2"<T1,T2> {
}
TestTaskBase <|-- "BuildActionTaskBase`1"
"BuildActionTaskBase`1" --> "attributeFinder" IAttributeFinder
"BuildActionTaskBase`1" o-> "targetPlatform" RuntimePlatform
"BuildActionTaskBase`1" o-> "logAction<string>" "Action`1"
"BuildActionTaskBase`1" o-> "logScopeProvider<ILogScope>" "Func`1"
"BuildActionTaskBase`1" o-> "createInstance<Type,object>" "Func`2"
class BuildTestTreeTask {
    + BuildTestTreeTask(testPlatform:TestPlatform)
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
TestTaskBase <|-- BuildTestTreeTask
BuildTestTreeTask o-> "m_testAssemblyProvider" IEditorLoadedTestAssemblyProvider
BuildTestTreeTask o-> "m_testAssemblyBuilder" IAsyncTestAssemblyBuilder
BuildTestTreeTask o-> "m_CallbacksDelegator" ICallbacksDelegator
class CleanupVerificationTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
class "Action`1"<T> {
}
FileCleanupVerifierTaskBase <|-- CleanupVerificationTask
CleanupVerificationTask o-> "logAction<object>" "Action`1"
abstract class FileCleanupVerifierTaskBase {
}
class "Func`1"<T> {
}
TestTaskBase <|-- FileCleanupVerifierTaskBase
FileCleanupVerifierTaskBase o-> "GetAllAssetPathsAction<string[]>" "Func`1"
class LegacyEditModeRunTask {
    + LegacyEditModeRunTask()
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
TestTaskBase <|-- LegacyEditModeRunTask
class LegacyPlayerRunTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
TestTaskBase <|-- LegacyPlayerRunTask
class LegacyPlayModeRunTask {
    + LegacyPlayModeRunTask()
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
TestTaskBase <|-- LegacyPlayModeRunTask
class PerformUndoTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
class "Action`1"<T> {
}
class "Action`3"<T1,T2,T3> {
}
class "Func`1"<T> {
}
TestTaskBase <|-- PerformUndoTask
PerformUndoTask o-> "RevertAllDownToGroup<int>" "Action`1"
PerformUndoTask o-> "LogWarning<string>" "Action`1"
PerformUndoTask o-> "DisplayProgressBar<string,string,float>" "Action`3"
PerformUndoTask o-> "ClearProgressBar" Action
PerformUndoTask o-> "TimeNow<DateTime>" "Func`1"
class PrebuildSetupTask {
    + PrebuildSetupTask()
}
class "BuildActionTaskBase`1"<T> {
}
"BuildActionTaskBase`1" "<IPrebuildSetup>" <|-- PrebuildSetupTask
class RegisterFilesForCleanupVerificationTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
FileCleanupVerifierTaskBase <|-- RegisterFilesForCleanupVerificationTask
class SaveModiedSceneTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
class "Func`1"<T> {
}
TestTaskBase <|-- SaveModiedSceneTask
SaveModiedSceneTask o-> "SaveCurrentModifiedScenesIfUserWantsTo<bool>" "Func`1"
class SaveUndoIndexTask {
    + <<override>> Execute(testJobData:TestJobData) : IEnumerator
}
class "Func`1"<T> {
}
TestTaskBase <|-- SaveUndoIndexTask
SaveUndoIndexTask o-> "GetUndoGroup<int>" "Func`1"
abstract class TestTaskBase {
    + SupportsResumingEnumerator : bool
    + {abstract} Execute(testJobData:TestJobData) : IEnumerator
}
class EditModeRunnerCallback {
    + OnDestroy() : void
    + RunStarted(testsToRun:ITest) : void
    + OnEnable() : void
    + RunFinished(result:ITestResult) : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
}
ScriptableObject <|-- EditModeRunnerCallback
ITestRunnerListener <|-- EditModeRunnerCallback
EditModeRunnerCallback --> "runner" EditModeRunner
class RerunCallback {
    + {static} useMockRunFilter : bool = false
    + RunFinished(result:ITestResultAdaptor) : void
    + TestStarted(test:ITestAdaptor) : void
    + TestFinished(result:ITestResultAdaptor) : void
    + RunStarted(testsToRun:ITestAdaptor) : void
}
ScriptableObject <|-- RerunCallback
ICallbacks <|-- RerunCallback
RerunCallback o-> "mockRunFilter" UITestRunnerFilter
class RerunCallbackData {
}
class "ScriptableSingleton`1"<T> {
}
"ScriptableSingleton`1" "<RerunCallbackData>" <|-- RerunCallbackData
RerunCallbackData --> "testMode" TestMode
class RerunCallbackInitializer <<static>> {
    {static} RerunCallbackInitializer()
}
class TestRunnerCallback {
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + TestStarted(testName:ITest) : void
    + TestFinished(test:ITestResult) : void
}
ScriptableObject <|-- TestRunnerCallback
ITestRunnerListener <|-- TestRunnerCallback
class WindowResultUpdater {
    + WindowResultUpdater()
    + RunStarted(testsToRun:ITestAdaptor) : void
    + RunFinished(testResults:ITestResultAdaptor) : void
    + TestStarted(testName:ITestAdaptor) : void
    + TestFinished(test:ITestResultAdaptor) : void
    + TestTreeRebuild(test:ITestAdaptor) : void
}
ICallbacks <|-- WindowResultUpdater
ITestTreeRebuildCallbacks <|-- WindowResultUpdater
class WindowResultUpdaterDataHolder {
}
class "ScriptableSingleton`1"<T> {
}
class "List`1"<T> {
}
"ScriptableSingleton`1" "<WindowResultUpdaterDataHolder>" <|-- WindowResultUpdaterDataHolder
WindowResultUpdaterDataHolder o-> "CachedResults<TestRunnerResult>" "List`1"
class EnterPlayMode {
    + ExpectDomainReload : bool <<get>>
    + ExpectedPlaymodeState : bool <<get>>
    + EnterPlayMode(expectDomainReload:bool)
    + Perform() : IEnumerator
}
IEditModeTestYieldInstruction <|-- EnterPlayMode
class ExitPlayMode {
    + ExpectDomainReload : bool <<get>>
    + ExpectedPlaymodeState : bool <<get>>
    + ExitPlayMode()
    + Perform() : IEnumerator
}
IEditModeTestYieldInstruction <|-- ExitPlayMode
class RecompileScripts {
    + RecompileScripts()
    + RecompileScripts(expectScriptCompilation:bool)
    + RecompileScripts(expectScriptCompilation:bool, expectScriptCompilationSuccess:bool)
    + ExpectDomainReload : bool <<get>>
    + ExpectedPlaymodeState : bool <<get>>
    + ExpectScriptCompilation : bool <<get>>
    + ExpectScriptCompilationSuccess : bool <<get>>
    + Perform() : IEnumerator
}
IEditModeTestYieldInstruction <|-- RecompileScripts
RecompileScripts --> "Current" RecompileScripts
class WaitForDomainReload {
    + WaitForDomainReload()
    + ExpectDomainReload : bool <<get>>
    + ExpectedPlaymodeState : bool <<get>>
    + Perform() : IEnumerator
}
IEditModeTestYieldInstruction <|-- WaitForDomainReload
class CachingTestListProvider {
    + CachingTestListProvider(innerTestListProvider:ITestListProvider, testListCache:ITestListCache, testAdaptorFactory:ITestAdaptorFactory)
    + GetTestListAsync(platform:TestPlatform) : IEnumerator<ITestAdaptor>
}
class EditorAssembliesProxy {
}
IEditorAssembliesProxy <|-- EditorAssembliesProxy
class EditorAssemblyWrapper {
    + EditorAssemblyWrapper(assembly:Assembly)
    + <<override>> GetReferencedAssemblies() : AssemblyName[]
    + <<override>> Location : string <<get>>
}
AssemblyWrapper <|-- EditorAssemblyWrapper
class EditorCompilationInterfaceProxy {
    + GetAllEditorScriptAssemblies() : ScriptAssembly[]
    + GetAllPrecompiledAssemblies() : PrecompiledAssembly[]
}
IEditorCompilationInterfaceProxy <|-- EditorCompilationInterfaceProxy
class EditorLoadedTestAssemblyProvider {
    <<internal>> <<const>> k_PerformanceTestingAssemblyName : string = "Unity.PerformanceTesting"
    + EditorLoadedTestAssemblyProvider(compilationInterfaceProxy:IEditorCompilationInterfaceProxy, editorAssembliesProxy:IEditorAssembliesProxy)
    + GetAssembliesGroupedByType(mode:TestPlatform) : List<IAssemblyWrapper>
    + GetAssembliesGroupedByTypeAsync(mode:TestPlatform) : IEnumerator<IDictionary<TestPlatform, List<IAssemblyWrapper>>>
}
IEditorLoadedTestAssemblyProvider <|-- EditorLoadedTestAssemblyProvider
interface IEditorAssembliesProxy {
}
interface IEditorCompilationInterfaceProxy {
    GetAllEditorScriptAssemblies() : ScriptAssembly[]
    GetAllPrecompiledAssemblies() : PrecompiledAssembly[]
}
interface IEditorLoadedTestAssemblyProvider {
    GetAssembliesGroupedByType(mode:TestPlatform) : List<IAssemblyWrapper>
    GetAssembliesGroupedByTypeAsync(mode:TestPlatform) : IEnumerator<IDictionary<TestPlatform, List<IAssemblyWrapper>>>
}
interface ITestListCache {
    CacheTest(platform:TestPlatform, test:ITest) : void
    GetTestFromCacheAsync(platform:TestPlatform) : IEnumerator<ITestAdaptor>
}
interface ITestListCacheData {
}
class "List`1"<T> {
}
ITestListCacheData --> "platforms<TestPlatform>" "List`1"
ITestListCacheData --> "cachedData<ITest>" "List`1"
interface ITestListProvider {
    GetTestListAsync(platform:TestPlatform) : IEnumerator<ITest>
}
class TestListCache {
    + TestListCache(testAdaptorFactory:ITestAdaptorFactory, testResultDataFactory:IRemoteTestResultDataFactory, testListCacheData:ITestListCacheData)
    + CacheTest(platform:TestPlatform, test:ITest) : void
    + GetTestFromCacheAsync(platform:TestPlatform) : IEnumerator<ITestAdaptor>
}
ITestListCache <|-- TestListCache
class TestListCacheData {
}
class "ScriptableSingleton`1"<T> {
}
class "List`1"<T> {
}
"ScriptableSingleton`1" "<TestListCacheData>" <|-- TestListCacheData
ITestListCacheData <|-- TestListCacheData
TestListCacheData --> "platforms<TestPlatform>" "List`1"
TestListCacheData --> "cachedData<ITest>" "List`1"
class TestListJob {
    + TestListJob(testListProvider:CachingTestListProvider, platform:TestPlatform, callback:Action<ITestAdaptor>)
    + Start() : void
}
class TestListProvider {
    + TestListProvider(assemblyProvider:EditorLoadedTestAssemblyProvider, assemblyBuilder:UnityTestAssemblyBuilder)
    + GetTestListAsync(platform:TestPlatform) : IEnumerator<ITest>
}
ITestListProvider <|-- TestListProvider
interface ILogScope {
    IgnoreFailingMessages : bool <<get>> <<set>>
    IsNUnitException : bool <<get>>
    IsNUnitSuccessException : bool <<get>>
    IsNUnitInconclusiveException : bool <<get>>
    IsNUnitIgnoreException : bool <<get>>
    NUnitExceptionMessage : string <<get>>
    AddLog(message:string, stacktrace:string, type:LogType) : void
    AnyFailingLogs() : bool
    ProcessExpectedLogs() : void
    NoUnexpectedReceived() : void
}
class "Queue`1"<T> {
}
class "List`1"<T> {
}
IDisposable <|-- ILogScope
ILogScope --> "ExpectedLogs<LogMatch>" "Queue`1"
ILogScope --> "AllLogs<LogEvent>" "List`1"
ILogScope --> "FailingLogs<LogEvent>" "List`1"
class LogEvent {
    + Message : string <<get>> <<set>>
    + StackTrace : string <<get>> <<set>>
    + IsHandled : bool <<get>> <<set>>
    + <<override>> ToString() : string
}
LogEvent --> "LogType" LogType
class LogMatch {
    + Message : string <<get>> <<set>>
    + LogType : LogType? <<get>> <<set>>
    + Matches(log:LogEvent) : bool
    + <<override>> ToString() : string
}
LogMatch --> "MessageRegex" Regex
class LogScope <<sealed>> {
    <<readonly>> m_Lock : object
    m_Disposed : bool
    m_NeedToProcessLogs : bool
    + IgnoreFailingMessages : bool <<get>> <<set>>
    + IsNUnitException : bool <<get>>
    + IsNUnitSuccessException : bool <<get>>
    + IsNUnitInconclusiveException : bool <<get>>
    + IsNUnitIgnoreException : bool <<get>>
    + NUnitExceptionMessage : string <<get>>
    + {static} HasCurrentLogScope() : bool
    + LogScope()
    Activate() : void
    Deactivate() : void
    {static} RegisterScope(logScope:LogScope) : void
    {static} UnregisterScope(logScope:LogScope) : void
    + AddLog(message:string, stacktrace:string, type:LogType) : void
    {static} IsNUnitResultStateException(stacktrace:string, logType:LogType) : bool
    {static} IsFailingLog(type:LogType) : bool
    + Dispose() : void
    Dispose(disposing:bool) : void
    + AnyFailingLogs() : bool
    + ProcessExpectedLogs() : void
    + NoUnexpectedReceived() : void
}
class "List`1"<T> {
}
class "Queue`1"<T> {
}
ILogScope <|-- LogScope
LogScope o-> "s_ActiveScopes<LogScope>" "List`1"
LogScope --> "ExpectedLogs<LogMatch>" "Queue`1"
LogScope --> "AllLogs<LogEvent>" "List`1"
LogScope --> "FailingLogs<LogEvent>" "List`1"
LogScope --> "Current" LogScope
class ConditionalIgnoreAttribute {
    m_ConditionKey : string
    m_IgnoreReason : string
    + ConditionalIgnoreAttribute(conditionKey:string, ignoreReason:string)
    + ApplyToTest(test:Test) : void
    + {static} AddConditionalIgnoreMapping(key:string, value:bool) : void
}
class "Dictionary`2"<T1,T2> {
}
NUnitAttribute <|-- ConditionalIgnoreAttribute
IApplyToTest <|-- ConditionalIgnoreAttribute
ConditionalIgnoreAttribute o-> "m_ConditionMap<string,bool>" "Dictionary`2"
class TestEnumerator {
    + {static} Reset() : void
    + TestEnumerator(context:ITestExecutionContext, testEnumerator:IEnumerator)
    + Execute() : IEnumerator
}
TestEnumerator --> "Enumerator" IEnumerator
class TestMustExpectAllLogsAttribute {
    + TestMustExpectAllLogsAttribute(mustExpect:bool)
    + MustExpect : bool <<get>>
}
Attribute <|-- TestMustExpectAllLogsAttribute
class UnityCombinatorialStrategy {
    + <<new>> GetTestCases(sources:IEnumerable[]) : IEnumerable<ITestCaseData>
}
CombinatorialStrategy <|-- UnityCombinatorialStrategy
ICombiningStrategy <|-- UnityCombinatorialStrategy
class UnityPlatformAttribute {
    + UnityPlatformAttribute()
    + UnityPlatformAttribute(include:RuntimePlatform[])
    + ApplyToTest(test:Test) : void
    <<internal>> IsPlatformSupported(testTargetPlatform:RuntimePlatform) : bool
}
NUnitAttribute <|-- UnityPlatformAttribute
IApplyToTest <|-- UnityPlatformAttribute
class UnitySetUpAttribute {
}
NUnitAttribute <|-- UnitySetUpAttribute
class UnityTearDownAttribute {
}
NUnitAttribute <|-- UnityTearDownAttribute
class UnityTestAttribute {
    + UnityTestAttribute()
    BuildFrom(method:IMethodInfo, suite:Test) : TestMethod
}
CombiningStrategyAttribute <|-- UnityTestAttribute
ISimpleTestBuilder <|-- UnityTestAttribute
IImplyFixture <|-- UnityTestAttribute
abstract class "BeforeAfterTestCommandBase`1"<T> {
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
}
class "Func`1"<T> {
}
DelegatingTestCommand <|-- "BeforeAfterTestCommandBase`1"
IEnumerableTestMethodCommand <|-- "BeforeAfterTestCommandBase`1"
"BeforeAfterTestCommandBase`1" o-> "GetUtcNow<long>" "Func`1"
"BeforeAfterTestCommandBase`1" --> "ActivePcHelper" TestCommandPcHelper
class BeforeAfterTestCommandState {
    + NextBeforeStepIndex : int
    + NextBeforeStepPc : int
    + NextAfterStepIndex : int
    + NextAfterStepPc : int
    + TestHasRun : bool
    + CurrentTestResultLabel : string
    + CurrentTestMessage : string
    + CurrentTestStrackTrace : string
    + TestAfterStarted : bool
    + Timestamp : long
    + Reset() : void
    + StoreTestResult(result:TestResult) : void
    + ApplyTestResult(result:TestResult) : void
}
ScriptableObject <|-- BeforeAfterTestCommandState
BeforeAfterTestCommandState --> "CurrentTestResultStatus" TestStatus
BeforeAfterTestCommandState --> "CurrentTestResultSite" FailureSite
class EnumerableApplyChangesToContextCommand {
    + EnumerableApplyChangesToContextCommand(innerCommand:TestCommand, changes:IEnumerable<IApplyToContext>)
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
}
ApplyChangesToContextCommand <|-- EnumerableApplyChangesToContextCommand
IEnumerableTestMethodCommand <|-- EnumerableApplyChangesToContextCommand
class EnumerableRepeatedTestCommand {
    + EnumerableRepeatedTestCommand(commandToReplace:RepeatAttribute.RepeatedTestCommand)
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
}
DelegatingTestCommand <|-- EnumerableRepeatedTestCommand
IEnumerableTestMethodCommand <|-- EnumerableRepeatedTestCommand
class EnumerableRetryTestCommand {
    + EnumerableRetryTestCommand(commandToReplace:RetryAttribute.RetryCommand)
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
}
DelegatingTestCommand <|-- EnumerableRetryTestCommand
IEnumerableTestMethodCommand <|-- EnumerableRetryTestCommand
class EnumerableSetUpTearDownCommand {
    + EnumerableSetUpTearDownCommand(innerCommand:TestCommand)
}
class "BeforeAfterTestCommandBase`1"<T> {
}
"BeforeAfterTestCommandBase`1" "<MethodInfo>" <|-- EnumerableSetUpTearDownCommand
class EnumerableTestMethodCommand {
    + EnumerableTestMethodCommand(testMethod:TestMethod)
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
}
TestCommand <|-- EnumerableTestMethodCommand
IEnumerableTestMethodCommand <|-- EnumerableTestMethodCommand
class ImmediateEnumerableCommand {
    + ImmediateEnumerableCommand(innerCommand:TestCommand)
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
}
DelegatingTestCommand <|-- ImmediateEnumerableCommand
class OuterUnityTestActionCommand {
    + OuterUnityTestActionCommand(innerCommand:TestCommand)
}
class "BeforeAfterTestCommandBase`1"<T> {
}
"BeforeAfterTestCommandBase`1" "<IOuterUnityTestAction>" <|-- OuterUnityTestActionCommand
class SetUpTearDownCommand {
    + SetUpTearDownCommand(innerCommand:TestCommand)
}
class "BeforeAfterTestCommandBase`1"<T> {
}
"BeforeAfterTestCommandBase`1" "<MethodInfo>" <|-- SetUpTearDownCommand
class TestActionCommand {
    + TestActionCommand(innerCommand:TestCommand)
}
class "BeforeAfterTestCommandBase`1"<T> {
}
"BeforeAfterTestCommandBase`1" "<ITestAction>" <|-- TestActionCommand
class TestCommandPcHelper {
    + <<virtual>> SetEnumeratorPC(enumerator:IEnumerator, pc:int) : void
    + <<virtual>> GetEnumeratorPC(enumerator:IEnumerator) : int
}
class AssemblyNameFilter {
    + AssemblyNameFilter(assemblyName:string)
    + <<override>> Match(test:ITest) : bool
}
ValueMatchFilter <|-- AssemblyNameFilter
class CategoryFilterExtended {
    + {static} k_DefaultCategory : string = "Uncategorized"
    + CategoryFilterExtended(name:string)
    + <<override>> Match(test:ITest) : bool
}
CategoryFilter <|-- CategoryFilterExtended
class CompositeWorkItem {
    + CompositeWorkItem(suite:TestSuite, childFilter:ITestFilter, factory:WorkItemFactory)
    + <<override>> Cancel(force:bool) : void
}
class "List`1"<T> {
}
class UnityWorkItemOrderComparer {
    + Compare(x:UnityWorkItem, y:UnityWorkItem) : int
}
class "IComparer`1"<T> {
}
UnityWorkItem <|-- CompositeWorkItem
CompositeWorkItem --> "Children<UnityWorkItem>" "List`1"
CompositeWorkItem +-- UnityWorkItemOrderComparer
"IComparer`1" "<UnityWorkItem>" <|-- UnityWorkItemOrderComparer
class CoroutineTestWorkItem {
    + CoroutineTestWorkItem(test:TestMethod, filter:ITestFilter)
}
UnityWorkItem <|-- CoroutineTestWorkItem
CoroutineTestWorkItem --> "monoBehaviourCoroutineRunner" MonoBehaviour
class EditModeTestCallbacks {
}
class DefaultTestWorkItem {
    + DefaultTestWorkItem(test:TestMethod, filter:ITestFilter)
}
EditModeTestCallbacks --> "RestoringTestContext" Action
UnityWorkItem <|-- DefaultTestWorkItem
class FailCommand {
    + FailCommand(test:Test, resultState:ResultState, message:string)
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
}
TestCommand <|-- FailCommand
IEnumerableTestMethodCommand <|-- FailCommand
interface IEnumerableTestMethodCommand {
    ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
}
class PlaymodeWorkItemFactory {
}
WorkItemFactory <|-- PlaymodeWorkItemFactory
class RestoreTestContextAfterDomainReload {
}
class TestCommandBuilder <<static>> {
    + {static} BuildTestCommand(test:TestMethod, filter:ITestFilter) : TestCommand
}
class UnityLogCheckDelegatingCommand {
    + UnityLogCheckDelegatingCommand(innerCommand:TestCommand)
    + <<override>> Execute(context:ITestExecutionContext) : TestResult
    + ExecuteEnumerable(context:ITestExecutionContext) : IEnumerable
    {static} CaptureException(result:TestResult, action:Action) : bool
    {static} ExecuteAndCheckLog(logScope:LogScope, result:TestResult, action:Action) : bool
    {static} PostTestValidation(logScope:LogScope, command:TestCommand, result:TestResult) : void
    {static} CheckLogs(result:TestResult, logScope:LogScope) : bool
    {static} CheckFailingLogs(logScope:LogScope, result:TestResult) : bool
    {static} CheckExpectedLogs(logScope:LogScope, result:TestResult) : bool
    {static} MustExpect(method:MemberInfo) : bool
}
class "Dictionary`2"<T1,T2> {
}
DelegatingTestCommand <|-- UnityLogCheckDelegatingCommand
IEnumerableTestMethodCommand <|-- UnityLogCheckDelegatingCommand
UnityLogCheckDelegatingCommand o-> "s_AttributeCache<object,bool?>" "Dictionary`2"
interface IUnityTestAssemblyRunner {
    IsTestLoaded : bool <<get>>
    IsTestRunning : bool <<get>>
    IsTestComplete : bool <<get>>
    GetCurrentContext() : UnityTestExecutionContext
    Load(assemblies:Assembly[], testPlatform:TestPlatform, settings:IDictionary<string, object>) : ITest
    Run(listener:ITestListener, filter:ITestFilter) : IEnumerable
    StopRun() : void
}
class UnityTestAssemblyRunner {
    + GetCurrentContext() : UnityTestExecutionContext
    + IsTestLoaded : bool <<get>>
    + IsTestRunning : bool <<get>>
    + IsTestComplete : bool <<get>>
    + UnityTestAssemblyRunner(builder:UnityTestAssemblyBuilder, factory:WorkItemFactory)
    + Load(assemblies:Assembly[], testPlatform:TestPlatform, settings:IDictionary<string, object>) : ITest
    + Run(listener:ITestListener, filter:ITestFilter) : IEnumerable
    + StopRun() : void
}
IUnityTestAssemblyRunner --> "LoadedTest" ITest
IUnityTestAssemblyRunner --> "Result" ITestResult
IUnityTestAssemblyRunner --> "TopLevelWorkItem" UnityWorkItem
IUnityTestAssemblyRunner <|-- UnityTestAssemblyRunner
UnityTestAssemblyRunner --> "LoadedTest" ITest
UnityTestAssemblyRunner --> "Result" ITestResult
UnityTestAssemblyRunner --> "TopLevelWorkItem" UnityWorkItem
class UnityTestExecutionContext {
    + StartTicks : long <<get>> <<set>>
    + TestObject : object <<get>> <<set>>
    + WorkDirectory : string <<get>> <<set>>
    + TestCaseTimeout : int <<get>> <<set>>
    + UnityTestExecutionContext()
    + UnityTestExecutionContext(other:UnityTestExecutionContext)
    + StopOnError : bool <<get>> <<set>>
    + WorkerId : string <<get>>
    + IsSingleThreaded : bool <<get>> <<set>>
    + EnumerableRepeatedTestState : int <<get>> <<set>>
    + EnumerableRetryTestState : int <<get>> <<set>>
    <<internal>> AssertCount : int <<get>>
    + IncrementAssertCount() : void
    + AddFormatter(formatterFactory:ValueFormatterFactory) : void
}
class "List`1"<T> {
}
ITestExecutionContext <|-- UnityTestExecutionContext
UnityTestExecutionContext --> "CurrentContext" UnityTestExecutionContext
UnityTestExecutionContext --> "Context" UnityTestExecutionContext
UnityTestExecutionContext --> "CurrentTest" Test
UnityTestExecutionContext --> "StartTime" DateTime
UnityTestExecutionContext --> "CurrentResult" TestResult
UnityTestExecutionContext --> "ExecutionStatus" TestExecutionStatus
UnityTestExecutionContext --> "UpstreamActions<ITestAction>" "List`1"
UnityTestExecutionContext --> "CurrentCulture" CultureInfo
UnityTestExecutionContext --> "CurrentUICulture" CultureInfo
UnityTestExecutionContext --> "Listener" ITestListener
UnityTestExecutionContext --> "OutWriter" TextWriter
UnityTestExecutionContext --> "Dispatcher" IWorkItemDispatcher
UnityTestExecutionContext --> "ParallelScope" ParallelScope
UnityTestExecutionContext --> "RandomGenerator" Randomizer
UnityTestExecutionContext --> "CurrentValueFormatter" ValueFormatter
UnityTestExecutionContext --> "SetUpTearDownState" BeforeAfterTestCommandState
UnityTestExecutionContext --> "OuterUnityTestActionState" BeforeAfterTestCommandState
abstract class UnityWorkItem {
    +  <<event>> Completed : EventHandler 
    + ResultedInDomainReload : bool <<get>> <<internal set>>
    + InitializeContext(context:UnityTestExecutionContext) : void
    + <<virtual>> Execute() : IEnumerable
    + <<virtual>> Cancel(force:bool) : void
}
class "List`1"<T> {
}
UnityWorkItem --> "Context" UnityTestExecutionContext
UnityWorkItem --> "Test" Test
UnityWorkItem --> "Result" TestResult
UnityWorkItem --> "State" WorkItemState
UnityWorkItem --> "Actions<ITestAction>" "List`1"
class UnityWorkItemDataHolder {
}
class "List`1"<T> {
}
UnityWorkItemDataHolder o-> "alreadyStartedTests<string>" "List`1"
UnityWorkItemDataHolder --> "alreadyExecutedTests<string>" "List`1"
abstract class WorkItemFactory {
    + Create(loadedTest:ITest, filter:ITestFilter) : UnityWorkItem
}
class PlayerQuitHandler {
    + Start() : void
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
}
MonoBehaviour <|-- PlayerQuitHandler
ITestRunnerListener <|-- PlayerQuitHandler
class PlayModeRunnerCallback {
    + RunFinished(testResults:ITestResult) : void
    + TestFinished(result:ITestResult) : void
    + OnGUI() : void
    + RunStarted(testsToRun:ITest) : void
    + TestStarted(test:ITest) : void
}
MonoBehaviour <|-- PlayModeRunnerCallback
ITestRunnerListener <|-- PlayModeRunnerCallback
class RemoteTestResultSender {
    + Start() : void
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
    + SendDataRoutine() : IEnumerator
}
class QueueData {
}
MonoBehaviour <|-- RemoteTestResultSender
ITestRunnerListener <|-- RemoteTestResultSender
RemoteTestResultSender +-- QueueData
QueueData --> "id" Guid
class TestResultRenderer {
    + TestResultRenderer(testResults:ITestResult)
    + ShowResults() : void
    + Draw() : void
}
class Styles <<static>> {
    {static} Styles()
}
TestResultRenderer +-- Styles
Styles --> "SucceedLabelStyle" GUIStyle
Styles --> "FailedLabelStyle" GUIStyle
Styles --> "FailedMessagesStyle" GUIStyle
class TestResultRendererCallback {
    + RunStarted(testsToRun:ITest) : void
    + RunFinished(testResults:ITestResult) : void
    + OnGUI() : void
    + TestStarted(test:ITest) : void
    + TestFinished(result:ITestResult) : void
}
MonoBehaviour <|-- TestResultRendererCallback
ITestRunnerListener <|-- TestResultRendererCallback
interface IEditModeTestYieldInstruction {
    ExpectDomainReload : bool <<get>>
    ExpectedPlaymodeState : bool <<get>>
    Perform() : IEnumerator
}
interface IRemoteTestResultDataFactory {
    CreateFromTestResult(result:ITestResult) : RemoteTestResultDataWithTestData
    CreateFromTest(test:ITest) : RemoteTestResultDataWithTestData
}
class PlayerConnectionMessageIds <<static>> {
}
PlayerConnectionMessageIds --> "runStartedMessageId" Guid
PlayerConnectionMessageIds --> "runFinishedMessageId" Guid
PlayerConnectionMessageIds --> "testStartedMessageId" Guid
PlayerConnectionMessageIds --> "testFinishedMessageId" Guid
PlayerConnectionMessageIds --> "quitPlayerMessageId" Guid
PlayerConnectionMessageIds --> "playerAliveHeartbeat" Guid
class RemoteTestData {
    + id : string
    + name : string
    + fullName : string
    + testCaseCount : int
    + ChildIndex : int
    + hasChildren : bool
    + isSuite : bool
    + testCaseTimeout : int
    + IsTestAssembly : bool
    + Description : string
    + SkipReason : string
    + ParentId : string
    + UniqueName : string
    + ParentUniqueName : string
    + ParentFullName : string
    <<internal>> RemoteTestData(test:ITest)
}
RemoteTestData --> "RunState" RunState
class RemoteTestResultData {
    + testId : string
    + name : string
    + fullName : string
    + resultState : string
    + duration : double
    + message : string
    + stackTrace : string
    + assertCount : int
    + failCount : int
    + passCount : int
    + skipCount : int
    + inconclusiveCount : int
    + hasChildren : bool
    + output : string
    + xml : string
    <<internal>> RemoteTestResultData(result:ITestResult)
}
RemoteTestResultData --> "testStatus" TestStatus
RemoteTestResultData --> "startTime" DateTime
RemoteTestResultData --> "endTime" DateTime
class RemoteTestResultDataFactory {
    + CreateFromTestResult(result:ITestResult) : RemoteTestResultDataWithTestData
    + CreateFromTest(test:ITest) : RemoteTestResultDataWithTestData
}
IRemoteTestResultDataFactory <|-- RemoteTestResultDataFactory
class RemoteTestResultDataWithTestData {
}
class AssemblyLoadProxy {
    + Load(assemblyString:string) : IAssemblyWrapper
}
IAssemblyLoadProxy <|-- AssemblyLoadProxy
class AssemblyWrapper {
    + AssemblyWrapper(assembly:Assembly)
    + <<virtual>> Location : string <<get>>
    + <<virtual>> GetReferencedAssemblies() : AssemblyName[]
}
IAssemblyWrapper <|-- AssemblyWrapper
AssemblyWrapper --> "Assembly" Assembly
interface IAssemblyLoadProxy {
    Load(assemblyString:string) : IAssemblyWrapper
}
interface IAssemblyWrapper {
    Location : string <<get>>
    GetReferencedAssemblies() : AssemblyName[]
}
IAssemblyWrapper --> "Assembly" Assembly
interface IScriptingRuntimeProxy {
    GetAllUserAssemblies() : string[]
}
interface ITestAssemblyProvider {
    GetTestsWithNUnit() : ITest
    GetUserAssemblies() : IAssemblyWrapper[]
}
class PlayerTestAssemblyProvider {
    <<internal>> PlayerTestAssemblyProvider(assemblyLoadProxy:IAssemblyLoadProxy, assembliesToLoad:List<string>)
    + GetTestsWithNUnit() : ITest
    + GetUserAssemblies() : List<IAssemblyWrapper>
}
class ScriptingRuntimeProxy {
    + GetAllUserAssemblies() : string[]
}
IScriptingRuntimeProxy <|-- ScriptingRuntimeProxy
interface IMonoBehaviourTest {
    IsTestFinished : bool <<get>>
}
class "MonoBehaviourTest`1"<T> {
    + component : T <<get>>
    + MonoBehaviourTest(dontDestroyOnLoad:bool)
    + <<override>> keepWaiting : bool <<get>>
}
CustomYieldInstruction <|-- "MonoBehaviourTest`1"
"MonoBehaviourTest`1" --> "gameObject" GameObject
enum MenuActionDisplayState {
    Visible,
    Disabled,
    Hidden,
}
class MenuActionItem <<struct>> {
    + category : string
    + entryName : string
    + shortCut : string
    + priority : int
    + isChecked : bool
    + isActiveInMode : bool
}
class MenuItemActionBase {
    + mousePosition : Vector2? <<get>> <<set>>
    + {static} GetActionsOfType(actionType:Type) : IEnumerable<Type>
    + {static} GetShortcutAttributeForAction(action:MenuItemActionBase) : ShortcutAttribute
    + {static} BuildMenu(menu:GenericMenu, items:List<MenuActionItem>) : void
    + {static} GetActiveInModeAttribute(action:MenuItemActionBase) : ActiveInModeAttribute
    + {static} IsActionActiveInMode(action:MenuItemActionBase, mode:TimelineModes) : bool
    + priority : int <<get>>
    + category : string <<get>>
    + menuName : string <<get>>
    + shortCut : string <<get>>
    + showInMenu : bool <<get>>
}
MenuActionItem --> "state" MenuActionDisplayState
class SequencerContextMenu <<static>> {
    + {static} ShowMarkerHeaderContextMenu(mousePosition:Vector2?, state:WindowState) : void
    + {static} ShowNewTracksContextMenu(tracks:ICollection<TrackAsset>, state:WindowState) : void
    + {static} ShowNewTracksContextMenu(tracks:ICollection<TrackAsset>, state:WindowState, rect:Rect) : void
    + {static} ShowTrackContextMenu(tracks:TrackAsset[], mousePosition:Vector2?) : void
    + {static} ShowItemContextMenu(mousePosition:Vector2, clips:TimelineClip[], markers:IMarker[]) : void
    <<internal>> {static} BuildItemContextMenu(items:List<MenuActionItem>, mousePosition:Vector2, clips:TimelineClip[], markers:IMarker[]) : void
    <<internal>> {static} BuildNewTracksContextMenu(menuItems:List<MenuActionItem>, parentTracks:ICollection<TrackAsset>, state:WindowState, format:string) : void
    <<internal>> {static} BuildMarkerHeaderContextMenu(menu:List<MenuActionItem>, mousePosition:Vector2?, state:WindowState) : void
    <<internal>> {static} BuildTrackContextMenu(items:List<MenuActionItem>, tracks:TrackAsset[], mousePosition:Vector2?) : void
    {static} AddLayeredTrackCommands(menuItems:List<MenuActionItem>, tracks:ICollection<TrackAsset>) : void
    {static} AddClipMenuCommands(menuItems:List<MenuActionItem>, tracks:ICollection<TrackAsset>, candidateTime:double) : void
    {static} AddMarkerMenuCommands(menu:List<MenuActionItem>, markerTypes:IEnumerable<Type>, addMarkerCommand:Action<Type, Object>, enabled:bool) : void
    {static} AddMarkerMenuCommands(menuItems:List<MenuActionItem>, tracks:ICollection<TrackAsset>, candidateTime:double) : void
    {static} AddMarkerMenuCommands(menuItems:List<MenuActionItem>, tracks:ICollection<TrackAsset>, command:Action<Type, Object>, enabled:bool) : void
    {static} AddMarkersCallback(targets:ICollection<TrackAsset>, markerType:Type, time:double, obj:Object) : void
    {static} AddSingleMarkerCallback(markerType:Type, time:double, timeline:TimelineAsset, director:PlayableDirector, assignableObject:Object) : void
}
class Styles <<static>> {
    + {static} <<readonly>> addItemFromAssetTemplate : string
    + {static} <<readonly>> addSingleItemFromAssetTemplate : string
    + {static} <<readonly>> addItemTemplate : string
    + {static} <<readonly>> typeSelectorTemplate : string
    + {static} <<readonly>> trackGroup : string
    + {static} <<readonly>> trackSubGroup : string
    + {static} <<readonly>> addTrackLayer : string
    + {static} <<readonly>> layerName : string
}
SequencerContextMenu +-- Styles
class ClipInspector {
    InitializeProperties() : void
    m_IsClipAssetInspectorExpanded : bool = true
    m_MultiselectionHeaderTitle : string
    <<const>> k_TimeScaleSensitivity : double = 0.003
    hasMultipleSelection : bool <<get>>
    currentFrameRate : float <<get>>
    selectionHasIncompatibleCapabilities : bool <<get>>
    + <<override>> RequiresConstantRepaint() : bool
    <<internal>> <<override>> OnHeaderTitleGUI(titleRect:Rect, header:string) : void
    <<internal>> <<override>> DrawHeaderHelpAndSettingsGUI(r:Rect) : Rect
    <<internal>> <<override>> OnHeaderIconGUI(iconRect:Rect) : void
    + OnEnable() : void
    DrawClipProperties() : void
    + <<override>> OnInspectorGUI() : void
    <<internal>> <<override>> IsEnabled() : bool
    DrawTimeScale() : void
    DrawStartTimeField() : void
    DrawEndTimeField() : void
    DrawClipAssetGui() : void
    DrawExtrapolationOptions() : void
    OnDestroy() : void
    + <<override>> GetPreviewTitle() : GUIContent
    + <<override>> HasPreviewGUI() : bool
    + <<override>> OnInteractivePreviewGUI(r:Rect, background:GUIStyle) : void
    SetCurveEditorTrackHead() : void
    UnselectCurves() : void
    OnMixCurveSelected(title:string, library:CurvePresetLibrary, curveSelected:SerializedProperty, easeIn:bool) : void
    MixInCurveUpdated(curve:AnimationCurve, binding:EditorCurveBinding) : void
    MixOutCurveUpdated(curve:AnimationCurve, binding:EditorCurveBinding) : void
    RefreshCurves() : void
    DrawBlendCurve(title:GUIContent, modeProperty:SerializedProperty, curveProperty:SerializedProperty, onCurveClick:Action<SerializedProperty>) : void
    ShowPlayableAssetInspector() : void
    ApplyModifiedProperties() : void
    MarkClipsDirty() : void
    PlayableAssetSectionTitle() : string
    IsTimelineAssetValidForEditorClip(editorClip:EditorClip) : bool
    CanShowPlayableAssetInspector() : bool
    DrawDurationProperty() : void
    DrawBlendingProperties() : void
    DrawClipInProperty() : void
    DrawBlendOptions() : void
    DrawGroupSelectionProperties() : void
    IsLocked() : bool
    {static} IsCurrentSequenceReadOnly() : bool
}
class Styles <<static>> {
}
class EditorClipSelection {
    + lastCurveVersion : int <<get>> <<set>>
    + lastEvalTime : double <<get>> <<set>>
    + EditorClipSelection(anEditorClip:EditorClip)
    + ToLocalTime(time:double) : double
}
class "List`1"<T> {
}
Editor <|-- ClipInspector
ClipInspector --> "m_DisplayNameProperty" SerializedProperty
ClipInspector --> "m_BlendInDurationProperty" SerializedProperty
ClipInspector --> "m_BlendOutDurationProperty" SerializedProperty
ClipInspector --> "m_EaseInDurationProperty" SerializedProperty
ClipInspector --> "m_EaseOutDurationProperty" SerializedProperty
ClipInspector --> "m_ClipInProperty" SerializedProperty
ClipInspector --> "m_TimeScaleProperty" SerializedProperty
ClipInspector --> "m_PostExtrapolationModeProperty" SerializedProperty
ClipInspector --> "m_PreExtrapolationModeProperty" SerializedProperty
ClipInspector --> "m_PostExtrapolationTimeProperty" SerializedProperty
ClipInspector --> "m_PreExtrapolationTimeProperty" SerializedProperty
ClipInspector --> "m_MixInCurveProperty" SerializedProperty
ClipInspector --> "m_MixOutCurveProperty" SerializedProperty
ClipInspector --> "m_BlendInCurveModeProperty" SerializedProperty
ClipInspector --> "m_BlendOutCurveModeProperty" SerializedProperty
ClipInspector --> "m_TimelineAsset" TimelineAsset
ClipInspector --> "m_SelectionCache<EditorClipSelection>" "List`1"
ClipInspector --> "m_SelectedPlayableAssetsInspector" Editor
ClipInspector --> "m_ClipCurveEditor" ClipInspectorCurveEditor
ClipInspector --> "m_CurvePresets" CurvePresetLibrary
ClipInspector o-> "m_ClipAssetTitle" GUIContent
ClipInspector --> "m_SelectionInfo" ClipInspectorSelectionInfo
ClipInspector +-- Styles
Styles o-> "StartName" GUIContent
Styles o-> "DurationName" GUIContent
Styles o-> "EndName" GUIContent
Styles o-> "EaseInDurationName" GUIContent
Styles o-> "EaseOutDurationName" GUIContent
Styles o-> "ClipInName" GUIContent
Styles o-> "TimeScaleName" GUIContent
Styles o-> "PreExtrapolateLabel" GUIContent
Styles o-> "PostExtrapolateLabel" GUIContent
Styles o-> "BlendInCurveName" GUIContent
Styles o-> "BlendOutCurveName" GUIContent
Styles o-> "PreviewTitle" GUIContent
Styles o-> "ClipTimingTitle" GUIContent
Styles o-> "AnimationExtrapolationTitle" GUIContent
Styles o-> "BlendCurvesTitle" GUIContent
Styles o-> "GroupTimingTitle" GUIContent
Styles o-> "MultipleClipsSelectedIncompatibleCapabilitiesWarning" GUIContent
Styles o-> "MultipleSelectionTitle" GUIContent
Styles o-> "MultipleClipStartName" GUIContent
Styles o-> "MultipleClipEndName" GUIContent
Styles o-> "TimelineClipFG" GUIContent
Styles o-> "TimelineClipBG" GUIContent
ClipInspector +-- EditorClipSelection
ICurvesOwnerInspectorWrapper <|-- EditorClipSelection
EditorClipSelection --> "editorClip" EditorClip
EditorClipSelection --> "clip" TimelineClip
EditorClipSelection --> "serializedPlayableAsset" SerializedObject
EditorClipSelection --> "curvesOwner" ICurvesOwner
class ClipInspectorCurveEditor {
    <<const>> k_HeaderHeight : float = 30
    <<const>> k_PresetHeight : float = 30
    + {static} <<readonly>> kDisableTrackTime : double
    m_trackTime : double
    + trackTime : double <<get>> <<set>>
    + headerString : string <<get>> <<set>>
    + ClipInspectorCurveEditor()
    <<internal>> InitStyles() : bool
    <<internal>> OnGUI(clientRect:Rect, presets:CurvePresetLibrary) : void
    {static} ConsumeMouseEvents(rect:Rect) : void
    DrawPresets(position:Rect, curveLibrary:PresetLibrary) : void
    DrawTrackHead(clientRect:Rect) : void
    DrawLegend(r:Rect) : void
    {static} LabelName(propertyName:string) : string
    + SetCurves(curves:AnimationCurve[], bindings:EditorCurveBinding[]) : void
    <<internal>> SetUpdateCurveCallback(callback:Action<AnimationCurve, EditorCurveBinding>) : void
    ProcessUpdates() : void
    + SetSelected(curve:AnimationCurve) : void
    UpdateSelectionColors() : void
    + {static} CurveField(title:GUIContent, property:SerializedProperty, onClick:Action<SerializedProperty>) : void
    {static} DrawCurve(controlRect:Rect, property:SerializedProperty, onClick:Action<SerializedProperty>, fgColor:Color, bgColor:Color) : Rect
}
class "Action`2"<T1,T2> {
}
ClipInspectorCurveEditor --> "m_CurveEditor" CurveEditor
ClipInspectorCurveEditor --> "m_CurveUpdatedCallback<AnimationCurve,EditorCurveBinding>" "Action`2"
ClipInspectorCurveEditor o-> "m_TextContent" GUIContent
ClipInspectorCurveEditor --> "m_LabelStyle" GUIStyle
ClipInspectorCurveEditor --> "m_LegendStyle" GUIStyle
class ClipInspectorSelectionInfo {
    + start : double
    + end : double
    + duration : double
    + multipleClipStart : double
    + multipleClipEnd : double
    + smallestDuration : double
    + hasMultipleStartValues : bool
    + hasMultipleEndValues : bool
    + hasMultipleDurationValues : bool
    + supportsExtrapolation : bool
    + supportsClipIn : bool
    + supportsSpeedMultiplier : bool
    + supportsBlending : bool
    + hasBlendIn : bool
    + hasBlendOut : bool
    + selectedAssetTypesAreHomogeneous : bool
    + containsAtLeastTwoClipsOnTheSameTrack : bool
    + ClipInspectorSelectionInfo(selectedClips:ICollection<TimelineClip>)
    Build() : void
    + Update() : void
    InitSelectionBounds(clip:TimelineClip) : void
    InitMultipleClipBounds(firstSelectedClip:TimelineClip) : void
    UpdateSmallestDuration(clip:TimelineClip) : void
    UpdateClipCaps(clip:TimelineClip) : void
    UpdateMultipleValues(clip:TimelineClip) : void
    UpdateBlends(clip:TimelineClip) : void
}
class "HashSet`1"<T> {
}
class "ICollection`1"<T> {
}
ClipInspectorSelectionInfo o-> "uniqueParentTracks<TrackAsset>" "HashSet`1"
ClipInspectorSelectionInfo --> "clips<TimelineClip>" "ICollection`1"
class CurvesOwnerInspectorHelper <<static>> {
    + {static} PreparePlayableAsset(wrapper:ICurvesOwnerInspectorWrapper) : void
    {static} SetAnimatedValue(clip:ICurvesOwner, property:SerializedProperty, path:string, localTime:double) : void
}
interface ICurvesOwnerInspectorWrapper {
    lastCurveVersion : int <<get>> <<set>>
    lastEvalTime : double <<get>> <<set>>
    ToLocalTime(time:double) : double
}
ICurvesOwnerInspectorWrapper --> "curvesOwner" ICurvesOwner
ICurvesOwnerInspectorWrapper --> "serializedPlayableAsset" SerializedObject
class AddDeleteItemModeMix {
    + InsertItemsAtTime(itemsGroups:IEnumerable<ItemsPerTrack>, requestedTime:double) : void
    + RemoveItems(itemsGroups:IEnumerable<ItemsPerTrack>) : void
}
IAddDeleteItemMode <|-- AddDeleteItemModeMix
class AddDeleteItemModeReplace {
    + InsertItemsAtTime(itemsGroups:IEnumerable<ItemsPerTrack>, requestedTime:double) : void
    + RemoveItems(itemsGroups:IEnumerable<ItemsPerTrack>) : void
}
IAddDeleteItemMode <|-- AddDeleteItemModeReplace
class AddDeleteItemModeRipple {
    + InsertItemsAtTime(itemsGroups:IEnumerable<ItemsPerTrack>, requestedTime:double) : void
    + RemoveItems(itemsGroups:IEnumerable<ItemsPerTrack>) : void
}
IAddDeleteItemMode <|-- AddDeleteItemModeRipple
interface IAddDeleteItemMode {
    InsertItemsAtTime(itemsGroups:IEnumerable<ItemsPerTrack>, requestedTime:double) : void
    RemoveItems(itemsGroups:IEnumerable<ItemsPerTrack>) : void
}
class TimelineCursors {
    <<const>> k_CursorAssetRoot : string = "Cursors/"
    <<const>> k_CursorAssetsNamespace : string = "Timeline."
    <<const>> k_CursorAssetExtension : string = ".png"
    <<const>> k_MixBothCursorAssetName : string
    <<const>> k_MixLeftCursorAssetName : string
    <<const>> k_MixRightCursorAssetName : string
    <<const>> k_ReplaceCursorAssetName : string
    <<const>> k_RippleCursorAssetName : string
    {static} <<readonly>> s_PlatformPath : string
    {static} <<readonly>> s_CursorAssetDirectory : string
    {static} s_CurrentCursor : CursorType?
    + {static} SetCursor(cursorType:CursorType) : void
    + {static} ClearCursor() : void
    {static} LoadCursorAsset(assetPath:string) : Texture2D
}
enum CursorType {
    MixBoth,
    MixLeft,
    MixRight,
    Replace,
    Ripple,
    Pan,
}
class CursorInfo {
    + <<readonly>> assetPath : string
    + CursorInfo(assetPath:string, hotSpot:Vector2, mouseCursorType:MouseCursor)
}
class "Dictionary`2"<T1,T2> {
}
TimelineCursors o-> "s_CursorInfoLookup<CursorType,CursorInfo>" "Dictionary`2"
TimelineCursors o-> "s_CursorAssetCache<string,Texture2D>" "Dictionary`2"
TimelineCursors +-- CursorType
TimelineCursors +-- CursorInfo
CursorInfo --> "hotSpot" Vector2
CursorInfo --> "mouseCursorType" MouseCursor
interface IMoveItemMode {
    OnTrackDetach(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    HandleTrackSwitch(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    AllowTrackSwitch() : bool
    AdjustStartTime(state:WindowState, itemsGroup:ItemsPerTrack, time:double) : double
    OnModeClutchEnter(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    OnModeClutchExit(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    BeginMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    UpdateMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    FinishMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    ValidateMove(itemsGroup:ItemsPerTrack) : bool
}
interface IMoveItemDrawer {
    DrawGUI(state:WindowState, movingItems:IEnumerable<MovingItems>, color:Color) : void
}
class MoveItemHandler {
    m_Grabbing : bool
    + allowTrackSwitch : bool <<get>>
    m_GrabbedModalUndoGroup : int
    + MoveItemHandler(state:WindowState)
    + Grab(items:IEnumerable<ITimelineItem>, referenceTrack:TrackAsset) : void
    + Grab(items:IEnumerable<ITimelineItem>, referenceTrack:TrackAsset, mousePosition:Vector2) : void
    + Drop() : void
    IsValidDrop() : bool
    Cancel() : void
    Done() : void
    + start : double <<get>>
    + end : double <<get>>
    + ShouldSnapTo(snappable:ISnappable) : bool
    + UpdateTrackTarget(track:TrackAsset) : void
    + OnGUI(evt:Event) : void
    + OnAttractedEdge(attractable:IAttractable, manipulateEdges:ManipulateEdges, edge:AttractedEdge, time:double) : void
    + RefreshPreviewItems() : void
    {static} ValidateItemDrag(itemsGroup:ItemsPerTrack) : bool
    + OnTrackDetach() : void
}
class "HashSet`1"<T> {
}
IAttractable <|-- MoveItemHandler
IAttractionHandler <|-- MoveItemHandler
MoveItemHandler --> "m_LeftMostMovingItems" MovingItems
MoveItemHandler --> "m_RightMostMovingItems" MovingItems
MoveItemHandler --> "m_ItemGUIs<TimelineItemGUI>" "HashSet`1"
MoveItemHandler --> "m_ItemsGroup" ItemsGroup
MoveItemHandler --> "targetTrack" TrackAsset
MoveItemHandler --> "m_State" WindowState
class MoveItemModeMix {
    + OnTrackDetach(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + HandleTrackSwitch(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + AllowTrackSwitch() : bool
    + AdjustStartTime(state:WindowState, itemsGroup:ItemsPerTrack, time:double) : double
    + OnModeClutchEnter(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + OnModeClutchExit(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + BeginMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + UpdateMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + FinishMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + ValidateMove(itemsGroup:ItemsPerTrack) : bool
    + DrawGUI(state:WindowState, movingItems:IEnumerable<MovingItems>, color:Color) : void
}
IMoveItemMode <|-- MoveItemModeMix
IMoveItemDrawer <|-- MoveItemModeMix
class MoveItemModeReplace {
    + OnTrackDetach(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + HandleTrackSwitch(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + AllowTrackSwitch() : bool
    + AdjustStartTime(state:WindowState, itemsGroup:ItemsPerTrack, time:double) : double
    + OnModeClutchEnter(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + OnModeClutchExit(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + BeginMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + UpdateMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + FinishMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + ValidateMove(itemsGroup:ItemsPerTrack) : bool
    + DrawGUI(state:WindowState, movingItems:IEnumerable<MovingItems>, color:Color) : void
}
IMoveItemMode <|-- MoveItemModeReplace
IMoveItemDrawer <|-- MoveItemModeReplace
class MoveItemModeRipple {
    <<const>> k_SnapToEdgeDistance : float = 30.0f
    m_PreviousEnd : double
    m_TrackLocked : bool
    m_Detached : bool
    + OnTrackDetach(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + HandleTrackSwitch(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + AllowTrackSwitch() : bool
    + AdjustStartTime(state:WindowState, itemsGroup:ItemsPerTrack, time:double) : double
    StartDetachMode(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + OnModeClutchEnter(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + OnModeClutchExit(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + BeginMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + UpdateMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    {static} CalculatePrevItemInfo(orderedSelection:List<ITimelineItem>, orderedSiblings:List<ITimelineItem>, itemTypes:IEnumerable<Type>) : PrevItemInfo
    + ValidateMove(itemsGroup:ItemsPerTrack) : bool
    + FinishMove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + DrawGUI(state:WindowState, movingItems:IEnumerable<MovingItems>, color:Color) : void
}
class PrevItemInfo {
    + blending : bool
    + PrevItemInfo(item:ITimelineItem, firstSelectedItem:ITimelineItem)
}
class "Dictionary`2"<T1,T2> {
}
IMoveItemMode <|-- MoveItemModeRipple
IMoveItemDrawer <|-- MoveItemModeRipple
MoveItemModeRipple o-> "m_NextItems<Object,List<ITimelineItem>>" "Dictionary`2"
MoveItemModeRipple o-> "m_PreviousItem<Object,PrevItemInfo>" "Dictionary`2"
MoveItemModeRipple +-- PrevItemInfo
PrevItemInfo --> "item" ITimelineItem
PrevItemInfo --> "firstSelectedItem" ITimelineItem
class MovingItems {
    <<readonly>> m_AllowTrackSwitch : bool
    + canDrop : bool
    + start : double <<get>> <<set>>
    + end : double <<get>>
    + MovingItems(state:WindowState, parentTrack:TrackAsset, items:ITimelineItem[], referenceTrack:TrackAsset, mousePosition:Vector2, allowTrackSwitch:bool)
    + SetReferenceTrack(track:TrackAsset) : void
    + HasAnyDetachedParents() : bool
    + RefreshBounds(state:WindowState, mousePosition:Vector2) : void
    + Draw(isValid:bool) : void
    {static} DrawItemInternal(item:ITimelineItem, rect:Rect, isValid:bool) : void
}
ItemsPerTrack <|-- MovingItems
MovingItems --> "m_ReferenceTrack" TrackAsset
MovingItems o-> "s_InvisibleBounds" Rect
MovingItems --> "originalTrack" TrackAsset
MovingItems --> "targetTrack" TrackAsset
class EaseClip {
    m_IsCaptured : bool
    m_UndoSaved : bool
    m_OriginalValue : double
    + {static} <<readonly>> EaseInClipText : string
    + {static} <<readonly>> EaseOutClipText : string
    + {static} <<readonly>> EaseInText : string
    + {static} <<readonly>> EaseOutText : string
    + {static} <<readonly>> DurationFrameText : string
    + {static} <<readonly>> DurationSecText : string
    + {static} <<readonly>> DeltaFrameText : string
    + {static} <<readonly>> DeltaSecText : string
    + <<override>> Overlay(evt:Event, state:WindowState) : void
    RefreshOverlayStrings(handle:TimelineClipHandle, state:WindowState) : void
}
Manipulator <|-- EaseClip
EaseClip --> "m_EaseClipHandler" TimelineClipHandle
EaseClip --> "m_Edges" ManipulateEdges
EaseClip --> "m_Clip" TimelineClip
EaseClip o-> "m_OverlayText" StringBuilder
class Jog {
    {static} JogShortcut(args:ShortcutArguments) : void
}
Manipulator <|-- Jog
Jog o-> "m_MouseDownOrigin" Vector2
class TimelineMarkerHeaderContextMenu {
}
Manipulator <|-- TimelineMarkerHeaderContextMenu
class RectangleSelect {
}
RectangleTool <|-- RectangleSelect
abstract class RectangleTool {
    m_Id : int
    + OnGUI(state:WindowState, rawType:EventType, mousePosition:Vector2) : void
    {static} IsValidRect(rect:Rect) : bool
    CurrentRectangle() : Rect
}
class TimelinePoint <<struct>> {
    <<readonly>> m_Time : double
    <<readonly>> m_YPos : float
    <<readonly>> m_YScrollPos : float
    + TimelinePoint(state:WindowState, mousePosition:Vector2)
    + ToPixel() : Vector2
}
RectangleTool --> "m_TimeAreaAutoPanner" TimeAreaAutoPanner
RectangleTool --> "m_StartPoint" TimelinePoint
RectangleTool o-> "m_EndPixel" Vector2
RectangleTool --> "m_ActiveRect" Rect
RectangleTool +-- TimelinePoint
TimelinePoint --> "m_State" WindowState
TimelinePoint --> "m_TreeViewGUI" TimelineTreeViewGUI
class RectangleZoom {
}
RectangleTool <|-- RectangleZoom
class ClearSelection {
}
class ItemSelection <<static>> {
    + {static} CanClearSelection(evt:Event) : bool
    + {static} RangeSelectItems(lastItemToSelect:ITimelineItem) : void
    + {static} HandleSingleSelection(evt:Event) : ISelectable
    + {static} HandleItemSelection(evt:Event, item:ISelectable) : void
}
class SelectAndMoveItem {
    m_Dragged : bool
    m_HorizontalMovementDone : bool
    m_VerticalMovementDone : bool
    m_CycleMarkersPending : bool
    + <<override>> Overlay(evt:Event, state:WindowState) : void
    HandleMarkerCycle() : bool
    HandleSingleSelection(evt:Event) : bool
    DropItems() : void
    {static} GetTrackDropTargetAt(state:WindowState, point:Vector2) : TrackAsset
}
Manipulator <|-- ClearSelection
Manipulator <|-- SelectAndMoveItem
SelectAndMoveItem --> "m_SnapEngine" SnapEngine
SelectAndMoveItem --> "m_TimeAreaAutoPanner" TimeAreaAutoPanner
SelectAndMoveItem --> "m_MouseDownPosition" Vector2
SelectAndMoveItem --> "m_MoveItemHandler" MoveItemHandler
class TrackZoom {
}
Manipulator <|-- TrackZoom
class TrimClip {
    m_IsCaptured : bool
    m_OriginalDuration : double
    m_OriginalTimeScale : double
    m_UndoSaved : bool
    {static} <<readonly>> kEpsilon : double = 0.0000001
    + <<override>> Overlay(evt:Event, state:WindowState) : void
    RefreshOverlayStrings(handle:TimelineClipHandle, state:WindowState) : void
}
class TrimClipAttractionHandler {
    + OnAttractedEdge(attractable:IAttractable, manipulateEdges:ManipulateEdges, edge:AttractedEdge, time:double) : void
}
class "List`1"<T> {
}
Manipulator <|-- TrimClip
TrimClip --> "m_TrimClipHandler" TimelineClipHandle
TrimClip --> "m_SnapEngine" SnapEngine
TrimClip o-> "m_OverlayText" StringBuilder
TrimClip o-> "m_OverlayStrings<string>" "List`1"
TrimClip +-- TrimClipAttractionHandler
IAttractionHandler <|-- TrimClipAttractionHandler
enum TrimEdge {
    Start,
    End,
}
interface ITrimItemMode {
    OnBeforeTrim(item:ITrimmable, trimDirection:TrimEdge) : void
    TrimStart(item:ITrimmable, time:double) : void
    TrimEnd(item:ITrimmable, time:double, affectTimeScale:bool) : void
}
interface ITrimItemDrawer {
    DrawGUI(state:WindowState, bounds:Rect, color:Color, edge:TrimEdge) : void
}
class TrimItemModeMix {
    m_Min : double
    m_Max : double
    + OnBeforeTrim(item:ITrimmable, trimDirection:TrimEdge) : void
    + TrimStart(item:ITrimmable, time:double) : void
    + TrimEnd(item:ITrimmable, time:double, affectTimeScale:bool) : void
    + DrawGUI(state:WindowState, bounds:Rect, color:Color, edge:TrimEdge) : void
}
ITrimItemMode <|-- TrimItemModeMix
ITrimItemDrawer <|-- TrimItemModeMix
TrimItemModeMix --> "m_Item" ITrimmable
class TrimItemModeReplace {
    m_ClipOriginalEdgeValue : double
    m_TrimReplace : bool
    m_Min : double
    m_Max : double
    + OnBeforeTrim(item:ITrimmable, trimDirection:TrimEdge) : void
    + TrimStart(item:ITrimmable, time:double) : void
    + TrimEnd(item:ITrimmable, time:double, affectTimeScale:bool) : void
    + DrawGUI(state:WindowState, bounds:Rect, color:Color, edge:TrimEdge) : void
}
ITrimItemMode <|-- TrimItemModeReplace
ITrimItemDrawer <|-- TrimItemModeReplace
TrimItemModeReplace --> "m_Item" ITrimmable
TrimItemModeReplace --> "m_ItemToBeReplaced" ITrimmable
class TrimItemModeRipple {
    m_OriginalClipStart : double
    m_OriginalClipEnd : double
    m_BlendDuration : double
    m_TrimStartShift : double
    + OnBeforeTrim(item:ITrimmable, trimDirection:TrimEdge) : void
    + TrimStart(item:ITrimmable, time:double) : void
    + TrimEnd(item:ITrimmable, time:double, affectTimeScale:bool) : void
    + DrawGUI(state:WindowState, bounds:Rect, color:Color, edge:TrimEdge) : void
}
ITrimItemMode <|-- TrimItemModeRipple
ITrimItemDrawer <|-- TrimItemModeRipple
class EditModeGUIUtils <<static>> {
    + {static} DrawBoundsEdge(bounds:Rect, color:Color, edge:TrimEdge, width:float) : void
    + {static} DrawOverlayRect(bounds:Rect, overlayColor:Color) : void
}
class EditModeMixUtils <<static>> {
    + {static} CanInsert(itemsGroups:IEnumerable<ItemsPerTrack>) : bool
    + {static} PrepareItemsForInsertion(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + {static} GetPlacementValidity(item:ITimelineItem, otherItems:IEnumerable<ITimelineItem>) : PlacementValidity
}
class "List`1"<T> {
}
EditModeMixUtils o-> "k_UnrecoverablePlacements<PlacementValidity>" "List`1"
class EditModeReplaceUtils <<static>> {
    + {static} Insert(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    {static} Insert(track:TrackAsset, items:IEnumerable<ITimelineItem>) : void
}
class EditModeRippleUtils <<static>> {
    + {static} Insert(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    + {static} Remove(itemsGroups:IEnumerable<ItemsPerTrack>) : void
    {static} Remove(track:TrackAsset, items:IEnumerable<ITimelineItem>) : void
}
class EditModeUtils <<static>> {
    + {static} Delete(items:IEnumerable<ITimelineItem>) : void
    + {static} SetStart(items:IEnumerable<ITimelineItem>, time:double) : void
    + {static} SetParentTrack(items:IEnumerable<ITimelineItem>, parentTrack:TrackAsset) : void
    + {static} GetFirstIntersectedItem(items:IEnumerable<ITimelineItem>, time:double) : ITimelineItem
    {static} Intersects(time:double, start:double, end:double) : bool
    + {static} Overlaps(item:ITimelineItem, from:double, to:double) : bool
    + {static} IsItemWithinRange(item:ITimelineItem, from:double, to:double) : bool
    + {static} IsRangeWithinItem(from:double, to:double, item:ITimelineItem) : bool
    + {static} Contains(from:double, to:double, item:ITimelineItem) : bool
    + {static} HasBlends(item:ITimelineItem, edge:TrimEdge) : bool
    + {static} BlendDuration(item:ITimelineItem, edge:TrimEdge) : double
    + {static} IsInfiniteTrack(track:TrackAsset) : bool
    + {static} GetInfiniteClipBoundaries(track:TrackAsset, start:double, end:double) : void
}
class ManipulatorsUtils <<static>> {
}
ManipulatorsUtils --> "actionModifier" EventModifiers
enum PlacementValidity {
    Valid,
    InvalidContains,
    InvalidIsWithin,
    InvalidStartsInBlend,
    InvalidEndsInBlend,
    InvalidContainsBlend,
    InvalidOverlapWithNonBlendableClip,
}
class SignalListFactory <<static>> {
    + {static} CreateSignalInspectorList(state:TreeViewState, header:SignalReceiverHeader, target:SignalReceiver, so:SerializedObject) : SignalReceiverTreeView
    + {static} CreateHeader(state:MultiColumnHeaderState, columnHeight:int) : SignalReceiverHeader
    + {static} CreateHeaderState() : MultiColumnHeaderState
    + {static} CreateViewState() : TreeViewState
}
class SignalReceiverItem {
    m_CurrentRowIdx : int
    <<internal>> <<readonly>> enabled : bool
    <<internal>> <<readonly>> readonlySignal : bool
    <<internal>> <<const>> SignalName : string = "SignalName"
    <<internal>> <<const>> SignalNameReadOnly : string = "SignalNameReadOnly"
    <<internal>> <<const>> SignalOptions : string = "SignalOptions"
    + SignalReceiverItem(signalAsset:SerializedProperty, eventListEntry:SerializedProperty, id:int, readonlySignal:bool, enabled:bool, treeView:SignalReceiverTreeView)
    + GetHeight() : float
    + Draw(rect:Rect, colIdx:int, rowIdx:int, padding:float, target:SignalReceiver) : void
    DrawSignalNameColumn(rect:Rect, padding:float, target:SignalReceiver, rowIdx:int) : void
    DrawReactionColumn(rect:Rect, rowIdx:int) : void
    {static} GetOptionButtonSize() : Vector2
    DrawOptionsButton(rect:Rect, rowIdx:int, target:SignalReceiver) : void
    AvailableSignalAssets() : IEnumerable<SignalAsset>
    CreateNewSignalAsset(path:string) : void
}
class UnityEventCloner {
}
TreeViewItem <|-- SignalReceiverItem
ISignalAssetProvider <|-- SignalReceiverItem
SignalReceiverItem o-> "k_EvtDrawer" SignalEventDrawer
SignalReceiverItem --> "m_Asset" SerializedProperty
SignalReceiverItem --> "m_Evt" SerializedProperty
SignalReceiverItem --> "m_TreeView" SignalReceiverTreeView
SignalReceiverItem --> "m_CurrentReceiver" SignalReceiver
SignalReceiverItem --> "signalAsset" SignalAsset
SignalReceiverItem +-- UnityEventCloner
ScriptableObject <|-- UnityEventCloner
UnityEventCloner --> "evt" UnityEvent
class SignalReceiverTreeView {
    + dirty : bool <<set>>
    <<const>> k_VerticalPadding : float = 5
    <<const>> k_HorizontalPadding : float = 5
    + SignalReceiverTreeView(state:TreeViewState, multiColumnHeader:MultiColumnHeader, receiver:SignalReceiver, serializedObject:SerializedObject)
    + readonlySignals : bool <<get>> <<set>>
    + SetSignalContext(assetContext:SignalAsset) : void
    SetSerializedProperties(serializedObject:SerializedObject) : void
    + Draw() : void
    + RefreshIfDirty() : void
    + {static} GetColumns() : MultiColumnHeaderState.Column[]
    AddItem(root:TreeViewItem, id:int, enabled:bool) : void
    GetTotalHeight() : float
    {static} FindIdForSignal(signals:SerializedProperty, signalToFind:SignalAsset) : int
}
TreeView <|-- SignalReceiverTreeView
SignalReceiverTreeView --> "signals" SerializedProperty
SignalReceiverTreeView --> "events" SerializedProperty
SignalReceiverTreeView --> "m_Target" SignalReceiver
SignalReceiverTreeView --> "signalAssetContext" SignalAsset
class AnimationTrackDrawer {
    + <<override>> DrawTrackHeaderButton(rect:Rect, track:TrackAsset, state:WindowState) : bool
    + <<override>> DrawRecordingBackground(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : void
    {static} DrawBorderOfAddedRecordingClip(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : void
}
class Styles <<static>> {
}
TrackDrawer <|-- AnimationTrackDrawer
AnimationTrackDrawer +-- Styles
Styles o-> "AnimationButtonOnTooltip" GUIContent
Styles o-> "AnimationButtonOffTooltip" GUIContent
enum BlendKind {
    None,
    Ease,
    Mix,
}
enum BlendAngle {
    Descending,
    Ascending,
}
class IconData <<struct>> {
    + width : float <<get>>
    + height : float <<get>>
    + IconData(icon:Texture2D)
}
class ClipBorder {
    + <<readonly>> thickness : float
    ClipBorder(color:Color, thickness:float)
    <<const>> k_ClipSelectionBorder : float = 1.0f
    <<const>> k_ClipRecordingBorder : float = 2.0f
    + {static} Recording() : ClipBorder
    + {static} Selection() : ClipBorder
    + {static} Default() : ClipBorder
}
class ClipBlends <<struct>> {
    + ClipBlends(inKind:BlendKind, inRect:Rect, outKind:BlendKind, outRect:Rect)
}
class ClipDrawData <<struct>> {
    + title : string
    + selected : bool
    + inlineCurvesSelected : bool
    + localVisibleStartTime : double
    + localVisibleEndTime : double
    + previousClipSelected : bool
    + supportsLooping : bool
    + minLoopIndex : int
}
class ClipDrawer <<static>> {
    <<const>> k_ClipSwatchLineThickness : float = 4.0f
    <<const>> k_MinClipWidth : float = 7.0f
    <<const>> k_ClipInOutMinWidth : float = 15.0f
    <<const>> k_ClipLoopsMinWidth : float = 20.0f
    <<const>> k_ClipLabelPadding : float = 6.0f
    <<const>> k_ClipLabelMinWidth : float = 10.0f
    <<const>> k_IconsPadding : float = 1.0f
    <<const>> k_ClipInlineWidth : float = 1.0f
    {static} GetLoopString(loopIndex:int) : string
    {static} DrawLoops(drawData:ClipDrawData) : void
    {static} DrawClipBorder(drawData:ClipDrawData) : void
    + {static} DrawClipSelectionBorder(clipRect:Rect, border:ClipBorder, blends:ClipBlends) : void
    {static} DrawBlendLine(rect:Rect, blendAngle:BlendAngle, width:float, color:Color) : void
    {static} DrawClipBlendSelectionBorder(clipRect:Rect, border:ClipBorder, blends:ClipBlends) : void
    {static} DrawClipDefaultBorder(clipRect:Rect, border:ClipBorder, blends:ClipBlends) : void
    {static} DrawClipTimescale(targetRect:Rect, clippedRect:Rect, timeScale:double) : void
    {static} DrawClipInOut(targetRect:Rect, clip:TimelineClip) : void
    {static} DrawClipLabel(data:ClipDrawData, availableRect:Rect, color:Color) : void
    {static} DrawClipLabel(title:string, availableRect:Rect, color:Color, errorText:string) : void
    {static} DrawClipLabel(title:string, availableRect:Rect, textColor:Color, leftIcons:IconData[], rightIcons:IconData[], tooltipMessage:string) : void
    {static} DrawClipIcons(icons:IconData[], side:IconData.Side, labelWidth:float, availableRect:Rect) : void
    {static} DrawClipName(rect:Rect, content:GUIContent, textColor:Color) : void
    {static} DrawIcon(imageRect:Rect, color:Color, icon:Texture2D) : void
    {static} DrawClipBackground(clipCenterSection:Rect, selected:bool) : void
    {static} DrawClipBlends(blends:ClipBlends, inColor:Color, outColor:Color, backgroundColor:Color) : void
    {static} DrawClipSwatch(targetRect:Rect, swatchColor:Color) : void
    + {static} DrawSimpleClip(clip:TimelineClip, targetRect:Rect, border:ClipBorder, overlay:Color, drawOptions:ClipDrawOptions) : void
    + {static} DrawDefaultClip(drawData:ClipDrawData) : void
    {static} DrawClipEditorBackground(drawData:ClipDrawData) : void
    + {static} DrawAnimationRecordBorder(drawData:ClipDrawData) : void
    + {static} DrawRecordProhibited(drawData:ClipDrawData) : void
    + {static} DrawRecordOnBlend(drawData:ClipDrawData) : void
    + {static} DrawRecordInvalidClip(drawData:ClipDrawData) : void
    + {static} DrawInvalidRecordIcon(rect:Rect, helpText:GUIContent) : void
}
enum Side {
    Left= -1,
    Right= 1,
}
class "List`1"<T> {
}
class Styles <<static>> {
    + {static} <<readonly>> HoldText : string
}
class "Dictionary`2"<T1,T2> {
}
IconData --> "icon" Texture2D
IconData --> "tint" Color
ClipBorder --> "color" Color
ClipBlends --> "inKind" BlendKind
ClipBlends --> "inRect" Rect
ClipBlends --> "outKind" BlendKind
ClipBlends --> "outRect" Rect
ClipBlends o-> "kNone" ClipBlends
ClipDrawData --> "clip" TimelineClip
ClipDrawData --> "targetRect" Rect
ClipDrawData --> "unclippedRect" Rect
ClipDrawData --> "clippedRect" Rect
ClipDrawData --> "clipCenterSection" Rect
ClipDrawData --> "previousClip" TimelineClip
ClipDrawData --> "loopRects<Rect>" "List`1"
ClipDrawData --> "clipBlends" ClipBlends
ClipDrawData --> "ClipDrawOptions" ClipDrawOptions
ClipDrawData --> "clipEditor" ClipEditor
ClipDrawer o-> "s_TitleContent" GUIContent
ClipDrawer o-> "s_LoopStringCache<int,string>" "Dictionary`2"
IconData +-- Side
ClipDrawer +-- Styles
Styles o-> "iconWarn" Texture2D
Styles o-> "s_IconNoRecord" Texture2D
Styles o-> "s_ClipNotRecorable" GUIContent
Styles o-> "s_ClipNoRecordInBlend" GUIContent
class InfiniteTrackDrawer {
    + InfiniteTrackDrawer(dataSource:IPropertyKeyDataSource)
    + CanDraw(track:TrackAsset, state:WindowState) : bool
    {static} DrawRecordBackground(trackRect:Rect) : void
    + <<override>> DrawTrack(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : bool
    DrawKeyFrame(key:float, state:WindowState) : void
}
TrackDrawer <|-- InfiniteTrackDrawer
InfiniteTrackDrawer --> "m_DataSource" IPropertyKeyDataSource
InfiniteTrackDrawer --> "m_TrackRect" Rect
class TrackDrawer {
    + {static} CreateInstance(trackAsset:TrackAsset) : TrackDrawer
    + <<virtual>> DrawTrackHeaderButton(rect:Rect, track:TrackAsset, state:WindowState) : bool
    + <<virtual>> DrawTrack(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : bool
    + <<virtual>> DrawRecordingBackground(trackRect:Rect, trackAsset:TrackAsset, visibleTime:Vector2, state:WindowState) : void
}
GUIDrawer <|-- TrackDrawer
TrackDrawer --> "sequencerState" WindowState
class TrackItemsDrawer <<struct>> {
    + TrackItemsDrawer(parent:IRowGUI)
    BuildGUICache(parent:IRowGUI) : void
    + Draw(rect:Rect, state:WindowState) : void
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
TrackItemsDrawer --> "m_Layers<ItemsLayer>" "List`1"
TrackItemsDrawer --> "m_ClipsLayer" ClipsLayer
TrackItemsDrawer --> "clips<TimelineClipGUI>" "IEnumerable`1"
interface ISelectable {
    Select() : void
    IsSelected() : bool
    Deselect() : void
}
ILayerable <|-- ISelectable
class TimelineClipGUI {
    m_MinLoopIndex : int = 1
    m_LastDirtyIndex : int
    m_ClipViewDirty : bool = true
    supportResize : bool <<get>>
    {static} <<readonly>> k_MinMixWidth : float = 2
    {static} <<readonly>> k_MaxHandleWidth : float = 10f
    {static} <<readonly>> k_MinHandleWidth : float = 1f
    m_ShowDrillIcon : bool?
    name : string <<get>>
    + inlineCurvesSelected : bool <<get>> <<set>>
    + GetClipBlends() : ClipBlends
    + <<override>> start : double <<get>>
    + <<override>> end : double <<get>>
    + supportsLooping : bool <<get>>
    showLoops : bool <<get>>
    + supportsSubTimelines : bool <<get>>
    + minLoopIndex : int <<get>>
    + <<override>> Select() : void
    + <<override>> IsSelected() : bool
    + <<override>> Deselect() : void
    + TimelineClipGUI(clip:TimelineClip, parent:IRowGUI, provider:IZOrderProvider)
    CreateInlineCurveEditor(state:WindowState) : void
    UpdateDrawData(state:WindowState, drawRect:Rect, title:string, selected:bool, previousClipSelected:bool, rectXOffset:float) : void
    UpdateClipIcons(state:WindowState) : void
    {static} UpdateClipDrawOptions(clipEditor:ClipEditor, clip:TimelineClip) : ClipDrawOptions
    {static} DrawClip(drawData:ClipDrawData) : void
    + DrawGhostClip(targetRect:Rect) : void
    + DrawInvalidClip(targetRect:Rect) : void
    DrawSimpleClip(targetRect:Rect, border:ClipBorder, overlay:Color) : void
    DrawInto(drawRect:Rect, state:WindowState) : void
    CalculateClipRectangle(trackRect:Rect, state:WindowState) : void
    AddToSpacePartitioner(state:WindowState) : void
    CalculateBlendRect() : void
    + <<override>> Draw(trackRect:Rect, trackRectChanged:bool, state:WindowState) : void
    DetectClipChanged(trackRectChanged:bool) : void
    ResetClipChanged() : void
    GetExtrapolationIcon(mode:TimelineClip.ClipExtrapolation) : GUIStyle
    GetPreExtrapolationBounds(trackRect:Rect, clipRect:Rect, icon:GUIStyle) : Rect
    GetPostExtrapolationBounds(trackRect:Rect, clipRect:Rect, icon:GUIStyle) : Rect
    {static} DrawExtrapolationIcon(rect:Rect, icon:GUIStyle) : void
    DrawExtrapolation(trackRect:Rect, clipRect:Rect) : void
    {static} ProjectRectOnTimeline(rect:Rect, trackRect:Rect, state:WindowState) : Rect
    CalculateLoopRects(trackRect:Rect, state:WindowState) : void
    + <<override>> RectToTimeline(trackRect:Rect, state:WindowState) : Rect
    + SnappableEdgesFor(attractable:IAttractable, manipulateEdges:ManipulateEdges) : IEnumerable<Edge>
    + ShouldSnapTo(snappable:ISnappable) : bool
    ShowDrillIcon(resolver:PlayableDirector) : bool
    {static} AddEdge(edges:List<Edge>, time:double, showEdgeHint:bool) : void
}
class "List`1"<T> {
}
TimelineItemGUI <|-- TimelineClipGUI
IClipCurveEditorOwner <|-- TimelineClipGUI
ISnappable <|-- TimelineClipGUI
IAttractable <|-- TimelineClipGUI
TimelineClipGUI --> "m_EditorItem" EditorClip
TimelineClipGUI --> "m_ClipCenterSection" Rect
TimelineClipGUI o-> "m_LoopRects<Rect>" "List`1"
TimelineClipGUI --> "m_ClipDrawData" ClipDrawData
TimelineClipGUI o-> "m_MixOutRect" Rect
TimelineClipGUI o-> "m_MixInRect" Rect
TimelineClipGUI --> "clipCurveEditor" ClipCurveEditor
TimelineClipGUI --> "previousClip" TimelineClipGUI
TimelineClipGUI --> "nextClip" TimelineClipGUI
TimelineClipGUI --> "m_ClipEditor" ClipEditor
TimelineClipGUI o-> "s_TempSubDirectors<PlayableDirector>" "List`1"
TimelineClipGUI o-> "k_DiggableClipIcon" IconData
TimelineClipGUI --> "mixOutRect" Rect
TimelineClipGUI --> "mixInRect" Rect
TimelineClipGUI --> "owner" TrackAsset
TimelineClipGUI --> "drawer" TrackDrawer
TimelineClipGUI --> "clippedRect" Rect
TimelineClipGUI --> "item" ITimelineItem
TimelineClipGUI --> "zOrderProvider" IZOrderProvider
TimelineClipGUI --> "leftHandle" TimelineClipHandle
TimelineClipGUI --> "rightHandle" TimelineClipHandle
TimelineClipGUI --> "clip" TimelineClip
class ItemToItemGui <<static>> {
    + {static} Add(clip:TimelineClip, gui:TimelineItemGUI) : void
    + {static} Add(marker:IMarker, gui:TimelineItemGUI) : void
    + {static} GetGuiForClip(clip:TimelineClip) : TimelineClipGUI
    + {static} GetGuiForMarker(marker:IMarker) : TimelineMarkerGUI
    {static} GetGuiForItem(item:object) : TimelineItemGUI
}
abstract class TimelineItemGUI {
    + {abstract} start : double <<get>>
    + {abstract} end : double <<get>>
    + {abstract} Draw(rect:Rect, rectChanged:bool, state:WindowState) : void
    + {abstract} RectToTimeline(trackRect:Rect, state:WindowState) : Rect
    + <<virtual>> Select() : void
    + <<virtual>> IsSelected() : bool
    + <<virtual>> Deselect() : void
    + <<virtual>> StartDrag() : void
    + <<virtual>> StopDrag() : void
    + visible : bool <<get>> <<set>>
    + isInvalid : bool <<get>> <<set>>
}
class "Dictionary`2"<T1,T2> {
}
ItemToItemGui o-> "s_ItemToItemGUI<object,TimelineItemGUI>" "Dictionary`2"
ISelectable <|-- TimelineItemGUI
TimelineItemGUI --> "item" ITimelineItem
TimelineItemGUI --> "zOrder" LayerZOrder
TimelineItemGUI --> "parent" IRowGUI
TimelineItemGUI --> "rect" Rect
TimelineItemGUI --> "treeViewRect" Rect
TimelineItemGUI --> "m_TreeViewRect" Rect
class TimelineMarkerClusterGUI {
    + TimelineMarkerClusterGUI(guis:List<TimelineMarkerGUI>, parent:IRowGUI, zOrderProvider:IZOrderProvider, layerZOrder:LayerZOrder)
    + <<override>> start : double <<get>>
    + <<override>> end : double <<get>>
    + <<override>> Select() : void
    + <<override>> Deselect() : void
    + <<override>> Draw(trackRect:Rect, trackRectChanged:bool, state:WindowState) : void
    + <<override>> RectToTimeline(trackRect:Rect, state:WindowState) : Rect
    + CycleTop() : void
    OnDragTopMarker() : void
    SortMarkers() : void
    RegisterRect(state:WindowState) : void
    + {static} CanCycleMarkers() : bool
    + {static} CycleMarkers() : void
}
class "List`1"<T> {
}
TimelineItemGUI <|-- TimelineMarkerClusterGUI
TimelineMarkerClusterGUI --> "m_MarkerGUIs<TimelineMarkerGUI>" "List`1"
TimelineMarkerClusterGUI --> "m_ZOrderProvider" IZOrderProvider
TimelineMarkerClusterGUI --> "topMarker" TimelineMarkerGUI
TimelineMarkerClusterGUI --> "m_ManipulatedMarker" TimelineMarkerGUI
TimelineMarkerClusterGUI --> "item" ITimelineItem
class TimelineMarkerGUI {
    +  <<event>> onStartDrag : Action 
    m_ProjectedClipHash : int
    m_MarkerHash : int
    m_Selectable : bool
    selectable : bool <<get>>
    + time : double <<get>>
    + <<override>> start : double <<get>>
    + <<override>> end : double <<get>>
    + <<override>> Select() : void
    + <<override>> IsSelected() : bool
    + <<override>> Deselect() : void
    + TimelineMarkerGUI(theMarker:IMarker, parent:IRowGUI, provider:IZOrderProvider)
    ComputeDirtyHash() : int
    {static} DrawMarker(drawRect:Rect, type:Type, isSelected:bool, isCollapsed:bool, options:MarkerDrawOptions) : void
    UpdateDrawData() : void
    + <<override>> Draw(trackRect:Rect, trackRectChanged:bool, state:WindowState) : void
    + QueueOverlay(rect:Rect, isSelected:bool, isCollapsed:bool) : void
    + <<override>> StartDrag() : void
    CalculateClipRectangle(trackRect:Rect, state:WindowState, projectedClipHash:int, trackRectChanged:bool) : void
    + <<override>> RectToTimeline(trackRect:Rect, state:WindowState) : Rect
    + SnappableEdgesFor(attractable:IAttractable, manipulateEdges:ManipulateEdges) : IEnumerable<Edge>
    + ShouldSnapTo(snappable:ISnappable) : bool
}
TimelineItemGUI <|-- TimelineMarkerGUI
ISnappable <|-- TimelineMarkerGUI
IAttractable <|-- TimelineMarkerGUI
TimelineMarkerGUI --> "m_MarkerDrawOptions" MarkerDrawOptions
TimelineMarkerGUI --> "m_Editor" MarkerEditor
TimelineMarkerGUI --> "marker" IMarker
TimelineMarkerGUI --> "item" ITimelineItem
TimelineMarkerGUI --> "zOrderProvider" IZOrderProvider
enum AttractedEdge {
    None,
    Left,
    Right,
}
interface IAttractable {
    ShouldSnapTo(snappable:ISnappable) : bool
    start : double <<get>>
    end : double <<get>>
}
interface IAttractionHandler {
    OnAttractedEdge(attractable:IAttractable, manipulateEdges:ManipulateEdges, edge:AttractedEdge, time:double) : void
}
class Edge <<struct>> {
    + time : double <<get>> <<set>>
    + showSnapHint : bool <<get>> <<set>>
    + Edge(edgeTime:double, snapHint:bool)
}
interface ISnappable {
    SnappableEdgesFor(attractable:IAttractable, manipulateEdges:ManipulateEdges) : IEnumerable<Edge>
}
enum ManipulateEdges {
    Left,
    Right,
    Both,
}
class SnapEngine {
    {static} <<readonly>> k_MagnetInfluenceInPixels : float = 10.0f
    + {static} displayDebugLayout : bool
    m_GrabbedTime : double
    m_SnapEnabled : bool
    + SnapEngine(attractable:IAttractable, attractionHandler:IAttractionHandler, manipulateEdges:ManipulateEdges, state:WindowState, mousePosition:Vector2, snappables:IEnumerable<ISnappable>)
    + {static} GetVisibleSnappables(state:WindowState) : IEnumerable<ISnappable>
    AddMagnet(magnetTime:double, showSnapHint:bool, state:WindowState) : void
    {static} IsMagnetInShownArea(time:double, state:WindowState) : bool
    GetMagnetAt(time:double) : SnapInfo
    ClosestMagnet(time:double) : SnapInfo
    + Snap(currentMousePosition:Vector2, modifiers:EventModifiers) : void
    + OnGUI(showLeft:bool, showRight:bool) : void
    DrawMagnetLineAt(time:double) : void
}
class SnapInfo {
    + time : double <<get>> <<set>>
    + showSnapHint : bool <<get>> <<set>>
    + IsInInfluenceZone(currentTime:double, state:WindowState) : bool
}
class TimeBoundaries <<struct>> {
    + TimeBoundaries(l:double, r:double)
    + <<readonly>> left : double
    + <<readonly>> right : double
    + Translate(d:double) : TimeBoundaries
}
class "List`1"<T> {
}
SnapEngine --> "m_Attractable" IAttractable
SnapEngine --> "m_AttractionHandler" IAttractionHandler
SnapEngine --> "m_ManipulateEdges" ManipulateEdges
SnapEngine --> "m_State" WindowState
SnapEngine --> "m_GrabbedTimes" TimeBoundaries
SnapEngine --> "m_CurrentTimes" TimeBoundaries
SnapEngine o-> "m_Magnets<SnapInfo>" "List`1"
SnapEngine +-- SnapInfo
SnapEngine +-- TimeBoundaries
class TimelineActiveMode {
    + TimelineActiveMode()
    + <<override>> ShouldShowTimeCursor(state:WindowState) : bool
    + <<override>> ShouldShowPlayRange(state:WindowState) : bool
    + <<override>> ToolbarState(state:WindowState) : TimelineModeGUIState
    + <<override>> TrackState(state:WindowState) : TimelineModeGUIState
}
TimelineMode <|-- TimelineActiveMode
class TimelineAssetEditionMode {
    + <<override>> TrackState(state:WindowState) : TimelineModeGUIState
    + TimelineAssetEditionMode()
}
TimelineInactiveMode <|-- TimelineAssetEditionMode
class TimelineDisabledMode {
    + TimelineDisabledMode()
    + <<override>> ShouldShowPlayRange(state:WindowState) : bool
    + <<override>> ShouldShowTimeCursor(state:WindowState) : bool
    + <<override>> ToolbarState(state:WindowState) : TimelineModeGUIState
    + <<override>> TrackState(state:WindowState) : TimelineModeGUIState
}
TimelineMode <|-- TimelineDisabledMode
class TimelineInactiveMode {
    + TimelineInactiveMode()
    + <<override>> ShouldShowPlayRange(state:WindowState) : bool
    + <<override>> ShouldShowTimeCursor(state:WindowState) : bool
    + <<override>> ToolbarState(state:WindowState) : TimelineModeGUIState
    + <<override>> TrackState(state:WindowState) : TimelineModeGUIState
    + <<override>> PreviewState(state:WindowState) : TimelineModeGUIState
}
TimelineMode <|-- TimelineInactiveMode
enum TimelineModeGUIState {
    Disabled,
    Hidden,
    Enabled,
}
abstract class TimelineMode {
    + {abstract} ShouldShowPlayRange(state:WindowState) : bool
    + {abstract} ShouldShowTimeCursor(state:WindowState) : bool
    + <<virtual>> ShouldShowTrackBindings(state:WindowState) : bool
    + <<virtual>> ShouldShowTimeArea(state:WindowState) : bool
    + {abstract} TrackState(state:WindowState) : TimelineModeGUIState
    + {abstract} ToolbarState(state:WindowState) : TimelineModeGUIState
    + <<virtual>> PreviewState(state:WindowState) : TimelineModeGUIState
    + <<virtual>> EditModeButtonsState(state:WindowState) : TimelineModeGUIState
}
enum TimelineModes {
    None= 0,
    Active= 1,
    ReadOnly= 2,
    Inactive= 4,
    Disabled= 8,
    AssetEdition= 16,
    All= Active | ReadOnly | Inactive | Disabled,
    Default= Active | AssetEdition,
}
class HeaderState <<struct>> {
}
class TrackOptionsState <<struct>> {
}
TimelineMode --> "headerState" HeaderState
TimelineMode --> "trackOptionsState" TrackOptionsState
TimelineMode --> "mode" TimelineModes
TimelineMode +-- HeaderState
HeaderState --> "breadCrumb" TimelineModeGUIState
HeaderState --> "sequenceSelector" TimelineModeGUIState
HeaderState --> "options" TimelineModeGUIState
TimelineMode +-- TrackOptionsState
TrackOptionsState --> "newButton" TimelineModeGUIState
TrackOptionsState --> "editAsAssetButton" TimelineModeGUIState
class TimelineReadOnlyMode {
    + TimelineReadOnlyMode()
    + <<override>> ShouldShowPlayRange(state:WindowState) : bool
    + <<override>> ShouldShowTimeCursor(state:WindowState) : bool
    + <<override>> TrackState(state:WindowState) : TimelineModeGUIState
    + <<override>> ToolbarState(state:WindowState) : TimelineModeGUIState
    + <<override>> PreviewState(state:WindowState) : TimelineModeGUIState
    + <<override>> EditModeButtonsState(state:WindowState) : TimelineModeGUIState
}
TimelineMode <|-- TimelineReadOnlyMode
enum TimeReferenceMode {
    Local= 0,
    Global= 1,
}
class "ScriptableObjectViewPrefs`1"<TViewModel> {
    <<const>> k_DefaultFilePath : string = "Library/"
    <<const>> k_Extension : string = ".pref"
    <<readonly>> m_RelativePath : string
    <<readonly>> m_AbsolutePath : string
    <<readonly>> m_FileName : string
    m_ViewModel : TViewModel
    isSavable : bool <<get>>
    + ScriptableObjectViewPrefs(asset:ScriptableObject, relativeSavePath:string)
    + viewModel : TViewModel <<get>>
    + Save() : void
    + DeleteFile() : void
    + Dispose() : void
    + {static} CreateViewModel() : TViewModel
    LoadViewModel() : TViewModel
    {static} GetAssetKey(asset:UnityObject) : string
}
IDisposable <|-- "ScriptableObjectViewPrefs`1"
"ScriptableObjectViewPrefs`1" --> "m_Asset" ScriptableObject
class TrackViewModelData {
    + {static} <<readonly>> DefaultinlineAnimationCurveHeight : float = 100.0f
    + collapsed : bool = true
    + showMarkers : bool = true
    + showInlineCurves : bool = false
    + inlineAnimationCurveHeight : float
    + lastInlineCurveDataID : int
    + OnBeforeSerialize() : void
    + OnAfterDeserialize() : void
}
class TimelineAssetViewModel {
    + <<const>> DefaultTrackScale : float = 1.0f
    + <<const>> DefaultVerticalScroll : float = 0
    + timeInFrames : bool = true
    + showAudioWaveform : bool = true
    + trackScale : float
    + playRangeEnabled : bool
    + windowTime : double
    + verticalScroll : float
    + showMarkerHeader : bool
    + OnBeforeSerialize() : void
    + OnAfterDeserialize() : void
    + OnEnable() : void
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
ISerializationCallbackReceiver <|-- TrackViewModelData
TrackViewModelData o-> "inlineCurvesState" TreeViewState
TrackViewModelData o-> "inlineCurvesShownAreaInsideMargins" Rect
TrackViewModelData o-> "markerTimeStamps<int,long>" "Dictionary`2"
TrackViewModelData --> "m_MarkerTimeStampsKeys<int>" "List`1"
TrackViewModelData --> "m_MarkerTimeStampsValues<long>" "List`1"
ScriptableObject <|-- TimelineAssetViewModel
ISerializationCallbackReceiver <|-- TimelineAssetViewModel
TimelineAssetViewModel o-> "TimeAreaDefaultRange" Vector2
TimelineAssetViewModel o-> "NoPlayRangeSet" Vector2
TimelineAssetViewModel o-> "timeAreaShownRange" Vector2
TimelineAssetViewModel o-> "timeAreaPlayRange" Vector2
TimelineAssetViewModel o-> "tracksViewModelData<TrackAsset,TrackViewModelData>" "Dictionary`2"
TimelineAssetViewModel o-> "m_Keys<TrackAsset>" "List`1"
TimelineAssetViewModel o-> "m_Vals<TrackViewModelData>" "List`1"
class TimelineWindowViewPrefs <<static>> {
    + <<const>> FilePath : string = "Library/Timeline"
    + {static} viewModelCount : int <<get>>
    + {static} GetOrCreateViewModel(asset:TimelineAsset) : TimelineAssetViewModel
    + {static} CreateUnassociatedViewModel() : TimelineAssetViewModel
    {static} CreateViewModel(asset:TimelineAsset) : ScriptableObjectViewPrefs<TimelineAssetViewModel>
    + {static} SaveViewModel(asset:TimelineAsset) : void
    + {static} SaveAll() : void
    + {static} UnloadViewModel(asset:TimelineAsset) : void
    + {static} UnloadAllViewModels() : void
    + {static} GetTrackViewModelData(track:TrackAsset) : TrackViewModelData
    + {static} IsTrackCollapsed(track:TrackAsset) : bool
    + {static} SetTrackCollapsed(track:TrackAsset, collapsed:bool) : void
    + {static} IsShowMarkers(track:TrackAsset) : bool
    + {static} SetTrackShowMarkers(track:TrackAsset, collapsed:bool) : void
    + {static} GetShowInlineCurves(track:TrackAsset) : bool
    + {static} SetShowInlineCurves(track:TrackAsset, inlineOn:bool) : void
    + {static} GetInlineCurveHeight(asset:TrackAsset) : float
    + {static} SetInlineCurveHeight(asset:TrackAsset, height:float) : void
}
class "Dictionary`2"<T1,T2> {
}
class "List`1"<T> {
}
TimelineWindowViewPrefs o-> "k_ViewModelsMap" ViewModelsMap
TimelineWindowViewPrefs o-> "k_UnassociatedViewModels" ViewModelsList
class CustomSignalEventDrawer {
}
PropertyAttribute <|-- CustomSignalEventDrawer
class SignalAsset {
    <<internal>> {static}  <<event>> OnEnableCallback : Action<SignalAsset> 
    OnEnable() : void
}
ScriptableObject <|-- SignalAsset
class SignalEmitter {
    m_Retroactive : bool
    m_EmitOnce : bool
    + retroactive : bool <<get>> <<set>>
    + emitOnce : bool <<get>> <<set>>
}
Marker <|-- SignalEmitter
INotification <|-- SignalEmitter
INotificationOptionProvider <|-- SignalEmitter
SignalEmitter --> "m_Asset" SignalAsset
SignalEmitter --> "asset" SignalAsset
SignalEmitter --> "id" PropertyName
SignalEmitter --> "flags" NotificationFlags
class SignalReceiver {
    + OnNotify(origin:Playable, notification:INotification, context:object) : void
    + AddReaction(asset:SignalAsset, reaction:UnityEvent) : void
    + AddEmptyReaction(reaction:UnityEvent) : int
    + Remove(asset:SignalAsset) : void
    + GetRegisteredSignals() : IEnumerable<SignalAsset>
    + GetReaction(key:SignalAsset) : UnityEvent
    + Count() : int
    + ChangeSignalAtIndex(idx:int, newKey:SignalAsset) : void
    + RemoveAtIndex(idx:int) : void
    + ChangeReactionAtIndex(idx:int, reaction:UnityEvent) : void
    + GetReactionAtIndex(idx:int) : UnityEvent
    + GetSignalAssetAtIndex(idx:int) : SignalAsset
}
class EventKeyValue {
    + TryGetValue(key:SignalAsset, value:UnityEvent) : bool
    + Append(key:SignalAsset, value:UnityEvent) : void
    + Remove(idx:int) : void
    + Remove(key:SignalAsset) : void
}
class "List`1"<T> {
}
MonoBehaviour <|-- SignalReceiver
INotificationReceiver <|-- SignalReceiver
SignalReceiver o-> "m_Events" EventKeyValue
SignalReceiver +-- EventKeyValue
EventKeyValue o-> "m_Signals<SignalAsset>" "List`1"
EventKeyValue o-> "m_Events<UnityEvent>" "List`1"
EventKeyValue --> "signals<SignalAsset>" "List`1"
EventKeyValue --> "events<UnityEvent>" "List`1"
class Dwyer {
    + UseDwyer : bool = true
    + Triangulate(points:IList<Vertex>, config:Configuration) : IMesh
    MergeHulls(farleft:Otri, innerleft:Otri, innerright:Otri, farright:Otri, axis:int) : void
    DivconqRecurse(left:int, right:int, axis:int, farleft:Otri, farright:Otri) : void
    RemoveGhosts(startghost:Otri) : int
}
ITriangulator <|-- Dwyer
Dwyer --> "predicates" IPredicates
Dwyer --> "mesh" Mesh
class Incremental {
    + Triangulate(points:IList<Vertex>, config:Configuration) : IMesh
    GetBoundingBox() : void
    RemoveBox() : int
}
ITriangulator <|-- Incremental
Incremental --> "mesh" Mesh
class SweepLine {
    {static} randomseed : int = 1
    {static} SAMPLERATE : int = 10
    {static} randomnation(choices:int) : int
    xminextreme : double
    + Triangulate(points:IList<Vertex>, config:Configuration) : IMesh
    HeapInsert(heap:SweepEvent[], heapsize:int, newevent:SweepEvent) : void
    Heapify(heap:SweepEvent[], heapsize:int, eventnum:int) : void
    HeapDelete(heap:SweepEvent[], heapsize:int, eventnum:int) : void
    CreateHeap(eventheap:SweepEvent[], size:int) : void
    Splay(splaytree:SplayNode, searchpoint:Point, searchtri:Otri) : SplayNode
    SplayInsert(splayroot:SplayNode, newkey:Otri, searchpoint:Point) : SplayNode
    FrontLocate(splayroot:SplayNode, bottommost:Otri, searchvertex:Vertex, searchtri:Otri, farright:bool) : SplayNode
    CircleTopInsert(splayroot:SplayNode, newkey:Otri, pa:Vertex, pb:Vertex, pc:Vertex, topy:double) : SplayNode
    RightOfHyperbola(fronttri:Otri, newsite:Point) : bool
    CircleTop(pa:Vertex, pb:Vertex, pc:Vertex, ccwabc:double) : double
    Check4DeadEvent(checktri:Otri, eventheap:SweepEvent[], heapsize:int) : void
    RemoveGhosts(startghost:Otri) : int
}
class "List`1"<T> {
}
class SweepEvent {
    + xkey : double
    + ykey : double
    + heapposition : int
}
class SweepEventVertex {
    + SweepEventVertex(e:SweepEvent)
}
class SplayNode {
}
ITriangulator <|-- SweepLine
SweepLine --> "predicates" IPredicates
SweepLine --> "mesh" Mesh
SweepLine --> "splaynodes<SplayNode>" "List`1"
SweepLine +-- SweepEvent
SweepEvent --> "vertexEvent" Vertex
SweepEvent --> "otriEvent" Otri
SweepLine +-- SweepEventVertex
Vertex <|-- SweepEventVertex
SweepEventVertex --> "evt" SweepEvent
SweepLine +-- SplayNode
SplayNode --> "keyedge" Otri
SplayNode --> "keydest" Vertex
SplayNode --> "lchild" SplayNode
SplayNode --> "rchild" SplayNode
class BadSubseg {
    + <<override>> GetHashCode() : int
    + <<override>> ToString() : string
}
BadSubseg --> "subseg" Osub
BadSubseg --> "org" Vertex
BadSubseg --> "dest" Vertex
class BadTriangle {
    + key : double
    + <<override>> ToString() : string
}
BadTriangle --> "poortri" Otri
BadTriangle --> "org" Vertex
BadTriangle --> "dest" Vertex
BadTriangle --> "apex" Vertex
BadTriangle --> "next" BadTriangle
class BadTriQueue {
    <<const>> SQRT2 : double = 1.4142135623730950488016887242096980785696718753769480732
    + Count : int <<get>>
    firstnonemptyq : int
    count : int
    + BadTriQueue()
    + Enqueue(badtri:BadTriangle) : void
    + Enqueue(enqtri:Otri, minedge:double, apex:Vertex, org:Vertex, dest:Vertex) : void
    + Dequeue() : BadTriangle
}
class EdgeIterator {
    + EdgeIterator(mesh:Mesh)
    + Dispose() : void
    Current : object <<get>>
    + MoveNext() : bool
    + Reset() : void
}
class "IEnumerator`1"<T> {
}
"IEnumerator`1" "<Edge>" <|-- EdgeIterator
EdgeIterator --> "triangles<Triangle>" "IEnumerator`1"
EdgeIterator o-> "tri" Otri
EdgeIterator o-> "neighbor" Otri
EdgeIterator o-> "sub" Osub
EdgeIterator --> "current" Edge
EdgeIterator --> "p1" Vertex
EdgeIterator --> "p2" Vertex
EdgeIterator --> "Current" Edge
class RegionIterator {
    + RegionIterator(mesh:Mesh)
    + Process(triangle:Triangle, boundary:int) : void
    + Process(triangle:Triangle, action:Action<Triangle>, boundary:int) : void
    ProcessRegion(action:Action<Triangle>, protector:Func<SubSegment, bool>) : void
}
class "List`1"<T> {
}
RegionIterator --> "region<Triangle>" "List`1"
class DcelMesh {
    + DcelMesh()
    + <<virtual>> IsConsistent(closed:bool, depth:int) : bool
    + ResolveBoundaryEdges() : void
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
DcelMesh --> "Vertices<Vertex>" "List`1"
DcelMesh --> "HalfEdges<HalfEdge>" "List`1"
DcelMesh --> "Faces<Face>" "List`1"
DcelMesh --> "Edges<IEdge>" "IEnumerable`1"
class Face {
    {static} Face()
    <<internal>> id : int
    <<internal>> mark : int = 0
    <<internal>> bounded : bool
    + ID : int <<get>> <<set>>
    + Bounded : bool <<get>> <<set>>
    + Face(generator:Point)
    + Face(generator:Point, edge:HalfEdge)
    + EnumerateEdges() : IEnumerable<HalfEdge>
    + <<override>> ToString() : string
}
Face --> "Empty" Face
Face --> "generator" Point
Face --> "edge" HalfEdge
Face --> "Edge" HalfEdge
class HalfEdge {
    <<internal>> id : int
    <<internal>> mark : int
    + ID : int <<get>> <<set>>
    + Boundary : int <<get>> <<set>>
    + HalfEdge(origin:Vertex)
    + HalfEdge(origin:Vertex, face:Face)
    + <<override>> ToString() : string
}
HalfEdge --> "origin" Vertex
HalfEdge --> "face" Face
HalfEdge --> "twin" HalfEdge
HalfEdge --> "next" HalfEdge
HalfEdge --> "Origin" Vertex
HalfEdge --> "Face" Face
HalfEdge --> "Twin" HalfEdge
HalfEdge --> "Next" HalfEdge
class Vertex {
    + Vertex(x:double, y:double)
    + Vertex(x:double, y:double, leaving:HalfEdge)
    + EnumerateEdges() : IEnumerable<HalfEdge>
    + <<override>> ToString() : string
}
Vertex --> "leaving" HalfEdge
Vertex --> "Leaving" HalfEdge
class BoundedVoronoiLegacy {
    segIndex : int
    includeBoundary : bool = true
    + BoundedVoronoiLegacy(mesh:Mesh)
    + BoundedVoronoiLegacy(mesh:Mesh, includeBoundary:bool)
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
class "ICollection`1"<T> {
}
class "IEnumerable`1"<T> {
}
IVoronoi <|-- BoundedVoronoiLegacy
BoundedVoronoiLegacy o-> "predicates" IPredicates
BoundedVoronoiLegacy --> "mesh" Mesh
BoundedVoronoiLegacy --> "regions<VoronoiRegion>" "List`1"
BoundedVoronoiLegacy --> "segPoints<Point>" "List`1"
BoundedVoronoiLegacy --> "subsegMap<int,SubSegment>" "Dictionary`2"
BoundedVoronoiLegacy --> "Regions<VoronoiRegion>" "ICollection`1"
BoundedVoronoiLegacy --> "Edges<IEdge>" "IEnumerable`1"
interface IVoronoi {
}
class "ICollection`1"<T> {
}
class "IEnumerable`1"<T> {
}
IVoronoi --> "Regions<VoronoiRegion>" "ICollection`1"
IVoronoi --> "Edges<IEdge>" "IEnumerable`1"
class SimpleVoronoi {
    rayIndex : int
    + SimpleVoronoi(mesh:Mesh)
}
class "Dictionary`2"<T1,T2> {
}
class "ICollection`1"<T> {
}
class "IEnumerable`1"<T> {
}
IVoronoi <|-- SimpleVoronoi
SimpleVoronoi o-> "predicates" IPredicates
SimpleVoronoi --> "mesh" Mesh
SimpleVoronoi --> "regions<int,VoronoiRegion>" "Dictionary`2"
SimpleVoronoi --> "rayPoints<int,Point>" "Dictionary`2"
SimpleVoronoi --> "bounds" Rectangle
SimpleVoronoi --> "Regions<VoronoiRegion>" "ICollection`1"
SimpleVoronoi --> "Edges<IEdge>" "IEnumerable`1"
class VoronoiRegion {
    id : int
    bounded : bool
    + ID : int <<get>>
    + Bounded : bool <<get>> <<set>>
    + VoronoiRegion(generator:Vertex)
    + Add(point:Point) : void
    + Add(points:List<Point>) : void
    + GetNeighbor(p:Point) : VoronoiRegion
    <<internal>> AddNeighbor(id:int, neighbor:VoronoiRegion) : void
    + <<override>> ToString() : string
}
class "List`1"<T> {
}
class "Dictionary`2"<T1,T2> {
}
class "ICollection`1"<T> {
}
VoronoiRegion --> "generator" Point
VoronoiRegion --> "vertices<Point>" "List`1"
VoronoiRegion --> "neighbors<int,VoronoiRegion>" "Dictionary`2"
VoronoiRegion --> "Generator" Point
VoronoiRegion --> "Vertices<Point>" "ICollection`1"
class BasicCameraFollow {
    + moveSpeed : float
    Update() : void
}
MonoBehaviour <|-- BasicCameraFollow
BasicCameraFollow --> "followTarget" GameObject
class CameraManager {
    Awake() : void
    + TogglePixelPerfect(value:bool) : void
    + ValidateCameras(value:bool) : void
}
MonoBehaviour <|-- CameraManager
CameraManager --> "ordinaryCamera" Camera
CameraManager --> "pixelPerfectCamera" PixelPerfectCamera
class HeroMover {
    + Amplitude : float = 1.0f
    + Frequency : float = 1.0f
    Start() : void
    Update() : void
}
MonoBehaviour <|-- HeroMover
class EndianReverser {
    + EndianReverser(imageData:ImageData)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- EndianReverser
abstract class ImageData {
    + BitDepth : int <<get>>
    + BytesPerRow : int <<get>>
    + <<virtual>> Read() : byte[]
    <<internal>> {abstract} Read(buffer:byte[]) : void
    + {abstract} ReadCompressed() : byte[]
}
ImageData --> "Size" Size
class ImageDataFactory <<static>> {
    + {static} Create(channel:Channel, data:byte[]) : ImageData
}
class RawImage {
    + RawImage(data:byte[], size:Size, bitDepth:int)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- RawImage
class RleImage {
    + RleImage(rleData:byte[], rleRowLengths:RleRowLengths, size:Size, bitDepth:int)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- RleImage
class ZipImage {
    + ZipImage(data:byte[], size:Size, bitDepth:int)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- ZipImage
class ZipPredict16Image {
    + ZipPredict16Image(zipData:byte[], size:Size)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- ZipPredict16Image
class ZipPredict32Image {
    + ZipPredict32Image(zipData:byte[], size:Size)
    <<internal>> <<override>> Read(buffer:byte[]) : void
    + <<override>> ReadCompressed() : byte[]
}
ImageData <|-- ZipPredict32Image
class AlphaChannelNames {
    + AlphaChannelNames()
    + AlphaChannelNames(reader:PsdBinaryReader, name:string, resourceDataLength:int)
}
class "List`1"<T> {
}
ImageResource <|-- AlphaChannelNames
AlphaChannelNames --> "ID" ResourceID
AlphaChannelNames --> "ChannelNames<string>" "List`1"
class RawImageResource {
    + RawImageResource(resourceId:ResourceID, name:string)
    + RawImageResource(reader:PsdBinaryReader, signature:string, resourceId:ResourceID, name:string, numBytes:int)
}
ImageResource <|-- RawImageResource
RawImageResource --> "ID" ResourceID
class ResolutionInfo {
    + ResolutionInfo()
    + ResolutionInfo(reader:PsdBinaryReader, name:string)
}
enum ResUnit {
    PxPerInch= 1,
    PxPerCm= 2,
}
enum Unit {
    Inches= 1,
    Centimeters= 2,
    Points= 3,
    Picas= 4,
    Columns= 5,
}
ImageResource <|-- ResolutionInfo
ResolutionInfo --> "ID" ResourceID
ResolutionInfo --> "HDpi" UFixed16_16
ResolutionInfo --> "VDpi" UFixed16_16
ResolutionInfo --> "HResDisplayUnit" ResUnit
ResolutionInfo --> "VResDisplayUnit" ResUnit
ResolutionInfo --> "WidthDisplayUnit" Unit
ResolutionInfo --> "HeightDisplayUnit" Unit
ResolutionInfo +-- ResUnit
ResolutionInfo +-- Unit
class Thumbnail {
    + Thumbnail(id:ResourceID, name:string)
    + Thumbnail(psdReader:PsdBinaryReader, id:ResourceID, name:string, numBytes:int)
}
RawImageResource <|-- Thumbnail
class UnicodeAlphaNames {
    + UnicodeAlphaNames()
    + UnicodeAlphaNames(reader:PsdBinaryReader, name:string, resourceDataLength:int)
}
class "List`1"<T> {
}
ImageResource <|-- UnicodeAlphaNames
UnicodeAlphaNames --> "ID" ResourceID
UnicodeAlphaNames --> "ChannelNames<string>" "List`1"
class VersionInfo {
    + HasRealMergedData : bool <<get>> <<set>>
    + ReaderName : string <<get>> <<set>>
    + WriterName : string <<get>> <<set>>
    + VersionInfo()
    + VersionInfo(reader:PsdBinaryReader, name:string)
}
ImageResource <|-- VersionInfo
VersionInfo --> "ID" ResourceID
VersionInfo --> "Version" UInt32
VersionInfo --> "FileVersion" UInt32
class BlendingRanges {
    + BlendingRanges(layer:Layer)
    + BlendingRanges(reader:PsdBinaryReader, layer:Layer)
}
BlendingRanges --> "Layer" Layer
class ChannelList {
    + ToIdArray() : Channel[]
    + ChannelList()
    + GetId(id:int) : Channel
    + ContainsId(id:int) : bool
}
class Channel {
    + ID : short <<get>> <<set>>
    + Length : long <<get>> <<set>>
    <<internal>> Channel(id:short, layer:Layer)
    <<internal>> Channel(reader:PsdBinaryReader, layer:Layer)
    <<internal>> Cleanup() : void
    <<internal>> LoadPixelData(reader:PsdBinaryReader) : void
    + DecodeImageData() : void
}
class "List`1"<T> {
}
class "NativeArray`1"<T> {
}
"List`1" "<Channel>" <|-- ChannelList
Channel --> "Layer" Layer
Channel --> "Rect" Rectangle
Channel --> "ImageData<byte>" "NativeArray`1"
Channel --> "ImageCompression" ImageCompression
Channel --> "RleRowLengths" RleRowLengths
class Layer {
    + IsGroup : bool <<get>> <<set>>
    + IsEndGroupMarker : bool <<get>> <<set>>
    + LayerID : int <<get>> <<set>>
    + BlendModeKey : string <<get>> <<set>>
    + Opacity : byte <<get>> <<set>>
    + Clipping : bool <<get>> <<set>>
    + Visible : bool <<get>> <<set>>
    + ProtectTrans : bool <<get>> <<set>>
    + Name : string <<get>> <<set>>
    + Layer(psdFile:PsdFile)
    + Layer(reader:PsdBinaryReader, psdFile:PsdFile)
    + CreateMissingChannels() : void
}
class "List`1"<T> {
}
Layer --> "PsdFile" PsdFile
Layer --> "Rect" Rectangle
Layer --> "ParentLayer" Layer
Layer --> "Channels" ChannelList
Layer --> "AlphaChannel" Channel
Layer o-> "flags" BitVector32
Layer --> "BlendingRangesData" BlendingRanges
Layer --> "Masks" MaskInfo
Layer --> "AdditionalInfo<LayerInfo>" "List`1"
class LayerInfoFactory <<static>> {
    + {static} Load(reader:PsdBinaryReader, psdFile:PsdFile, globalLayerInfo:bool, fileEndPos:long) : LayerInfo
}
class LayerInfoUtil <<static>> {
    <<internal>> {static} HasLongLength(key:string, isLargeDocument:bool) : bool
}
abstract class LayerInfo {
    + {abstract} Signature : string <<get>>
    + {abstract} Key : string <<get>>
}
class Mask {
    + BackgroundColor : byte <<get>> <<set>>
    + PositionVsLayer : bool <<get>> <<set>>
    + Disabled : bool <<get>> <<set>>
    + InvertOnBlend : bool <<get>> <<set>>
    + Mask(layer:Layer)
    + Mask(layer:Layer, rect:Rectangle, color:byte, flags:BitVector32)
}
class MaskInfo {
    + MaskInfo()
    + MaskInfo(reader:PsdBinaryReader, layer:Layer)
}
class "NativeArray`1"<T> {
}
Mask --> "Layer" Layer
Mask --> "Rect" Rectangle
Mask --> "Flags" BitVector32
Mask --> "ImageData<byte>" "NativeArray`1"
MaskInfo --> "LayerMask" Mask
MaskInfo --> "UserMask" Mask
class ClipsLayer {
    + ClipsLayer(layerOrder:Layer, parent:IRowGUI)
    + <<override>> Draw(rect:Rect, state:WindowState) : void
    {static} DrawConnector(clips:IEnumerable<TimelineClipGUI>) : void
}
ItemsLayer <|-- ClipsLayer
ClipsLayer o-> "k_ConnectorIcon" GUIStyle
enum Layer {
    Clips,
    ClipHandles,
    Markers,
    MarkerHeaderTrack,
    MarkersOnHeader,
}
class LayerZOrder <<struct>> {
    m_ZOrder : int
    + LayerZOrder(layer:Layer, zOrder:int)
    + CompareTo(other:LayerZOrder) : int
    + ChangeLayer(layer:Layer) : LayerZOrder
}
interface ILayerable {
}
interface IZOrderProvider {
    Next() : LayerZOrder
}
abstract class ItemsLayer {
    m_PreviousLayerStateHash : int
    + Next() : LayerZOrder
    m_NeedSort : bool = true
    + <<virtual>> Draw(rect:Rect, state:WindowState) : void
    Sort() : void
    GetLayerViewStateChanged(rect:Rect, state:WindowState) : bool
}
class "IComparable`1"<T> {
}
class "List`1"<T> {
}
class "IEnumerable`1"<T> {
}
"IComparable`1" "<LayerZOrder>" <|-- LayerZOrder
LayerZOrder --> "m_Layer" Layer
ILayerable --> "zOrder" LayerZOrder
IZOrderProvider <|-- ItemsLayer
ItemsLayer --> "m_LastZOrder" LayerZOrder
ItemsLayer o-> "m_Items<TimelineItemGUI>" "List`1"
ItemsLayer --> "items<TimelineItemGUI>" "IEnumerable`1"
class MarkersLayer {
    + MarkersLayer(layerOrder:Layer, parent:IRowGUI)
    CreateLists(parent:IRowGUI) : void
    ProcessAccumulator(accumulator:List<IMarker>, parent:IRowGUI) : void
}
ItemsLayer <|-- MarkersLayer
class BuildAssetBundle <<static>> {
    {static} BuildAssetBundle()
}
class LoadSwapDLC {
    <<const>> k_AssetBundleName : string = "2DAnimationSampleAssetBundles"
    + LoadAssetBundle() : void
}
MonoBehaviour <|-- LoadSwapDLC
class SwapFullSkin {
    Start() : void
    OnDropDownValueChanged(value:int) : void
    <<internal>> UpdateSelectionChoice() : void
}
MonoBehaviour <|-- SwapFullSkin
SwapFullSkin --> "spriteLibraryTarget" SpriteLibrary
SwapFullSkin --> "dropDownSelection" Dropdown
class SwapOptionData <<struct>> {
    + category : string
}
class SwapPart {
    Start() : void
}
SwapOptionData --> "dropdown" Dropdown
SwapOptionData --> "spriteResolver" SpriteResolver
MonoBehaviour <|-- SwapPart
SwapPart --> "spriteLibraryAsset" SpriteLibraryAsset
class Hero {
    + m_MoveSpeed : float
    dashCooldown : float = 0f
    + dead : bool = false
    Start() : void
    Update() : void
    + LevelComplete() : void
}
enum PlayerState {
    Alive,
    Dead,
}
MonoBehaviour <|-- Hero
Hero --> "animator" Animator
Hero --> "rb" Rigidbody2D
Hero o-> "playerState" PlayerState
Hero --> "lookFacing" Vector2
Hero --> "respawnPoint" Vector2
Hero --> "audioSource" AudioSource
Hero +-- PlayerState
class RuleTile {
    + <<override>> GetTileData(position:Vector3Int, tileMap:ITilemap, tileData:TileData) : void
    + <<override>> GetTileAnimationData(position:Vector3Int, tilemap:ITilemap, tileAnimationData:TileAnimationData) : bool
    + <<override>> RefreshTile(location:Vector3Int, tileMap:ITilemap) : void
    + RuleMatches(rule:TilingRule, position:Vector3Int, tilemap:ITilemap, transform:Matrix4x4) : bool
    + RuleMatches(rule:TilingRule, position:Vector3Int, tilemap:ITilemap, angle:int) : bool
    + RuleMatches(rule:TilingRule, position:Vector3Int, tilemap:ITilemap, mirrorX:bool, mirrorY:bool) : bool
    + GetRotatedPos(original:Vector3Int, rotation:int) : Vector3Int
    + GetMirroredPos(original:Vector3Int, mirrorX:bool, mirrorY:bool) : Vector3Int
}
class TilingRule {
    + m_AnimationSpeed : float
    + m_PerlinScale : float
    + TilingRule()
}
class "List`1"<T> {
}
enum Transform {
    Fixed,
    Rotated,
    MirrorX,
    MirrorY,
}
enum Neighbor {
    DontCare,
    This,
    NotThis,
}
enum OutputSprite {
    Single,
    Random,
    Animation,
}
TileBase <|-- RuleTile
RuleTile --> "m_DefaultSprite" Sprite
RuleTile --> "m_TilingRules<TilingRule>" "List`1"
RuleTile +-- TilingRule
TilingRule --> "m_RuleTransform" Transform
TilingRule --> "m_Output" OutputSprite
TilingRule --> "m_RandomTransform" Transform
TilingRule +-- Transform
TilingRule +-- Neighbor
TilingRule +-- OutputSprite
class InfoLayers {
    + <<override>> Signature : string <<get>>
    + <<override>> Key : string <<get>>
    + InfoLayers(psdFile:PsdFile, key:string)
    + InfoLayers(reader:PsdBinaryReader, psdFile:PsdFile, key:string, dataLength:long)
}
LayerInfo <|-- InfoLayers
InfoLayers --> "PsdFile" PsdFile
class LayerId {
    + <<override>> Signature : string <<get>>
    + <<override>> Key : string <<get>>
    + ID : int <<get>>
    + LayerId(key:string)
    + LayerId(reader:PsdBinaryReader, key:string, dataLength:long)
}
LayerInfo <|-- LayerId
enum LayerSectionType {
    Layer= 0,
    OpenFolder= 1,
    ClosedFolder= 2,
    SectionDivider= 3,
}
enum LayerSectionSubtype {
    Normal= 0,
    SceneGroup= 1,
}
class LayerSectionInfo {
    + <<override>> Signature : string <<get>>
    + <<override>> Key : string <<get>>
    + BlendModeKey : string <<get>> <<set>>
    + LayerSectionInfo(reader:PsdBinaryReader, key:string, dataLength:int)
}
LayerInfo <|-- LayerSectionInfo
LayerSectionInfo --> "SectionType" LayerSectionType
LayerSectionInfo --> "Subtype" LayerSectionSubtype
class LayerUnicodeName {
    + <<override>> Signature : string <<get>>
    + <<override>> Key : string <<get>>
    + Name : string <<get>> <<set>>
    + LayerUnicodeName(name:string)
    + LayerUnicodeName(reader:PsdBinaryReader)
}
LayerInfo <|-- LayerUnicodeName
class RawLayerInfo {
    + <<override>> Signature : string <<get>>
    + <<override>> Key : string <<get>>
    + RawLayerInfo(key:string, signature:string)
    + RawLayerInfo(reader:PsdBinaryReader, signature:string, key:string, dataLength:long)
}
LayerInfo <|-- RawLayerInfo
class RuleTileEditor {
    <<const>> k_DefaultElementHeight : float = 48f
    <<const>> k_PaddingBetweenRules : float = 13f
    <<const>> k_SingleLineHeight : float = 16f
    <<const>> k_LabelWidth : float = 53f
    + OnEnable() : void
    + <<override>> OnInspectorGUI() : void
    + <<override>> RenderStaticPreview(assetPath:string, subAssets:Object[], width:int, height:int) : Texture2D
}
class MenuItemData {
    + MenuItemData(mRule:RuleTile.TilingRule, mNewValue:RuleTile.TilingRule.Transform)
}
Editor <|-- RuleTileEditor
RuleTileEditor --> "tile" RuleTile
RuleTileEditor +-- MenuItemData
@enduml
